{"id": "task_c_missing_decreases_75c75f5ef6d8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "75c75f5ef6d8", "function_name": "find_first_occurrence", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_d29ad2b3aa22", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_732_iter_3_current.rs", "verified": true, "metadata": {"original_id": "d29ad2b3aa22", "function_name": "replace_with_colon", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_47ee998accef", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_bind_none<T, U>(outputs: Set<Option<T>>, f: spec_fn(T) -> Set<Option<U>>)\n    \n    ensures gen_option_bind(outputs, f).contains(Option::None)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_bind_none<T, U>(outputs: Set<Option<T>>, f: spec_fn(T) -> Set<Option<U>>)\n    requires outputs.contains(Option::None)\n    ensures gen_option_bind(outputs, f).contains(Option::None)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_bind_none<T, U>(outputs: Set<Option<T>>, f: spec_fn(T) -> Set<Option<U>>)\n    requires outputs.contains(Option::None)\n    ensures gen_option_bind(outputs, f).contains(Option::None)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_option.rs", "verified": true, "metadata": {"original_id": "47ee998accef", "function_name": "gen_option_bind_none", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_d637c54f03b0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_nonempty(lo: nat, hi: nat)\n    requires lo < hi\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_nonempty(lo: nat, hi: nat)\n    requires lo < hi\n    ensures choose_outputs(lo, hi).contains(lo)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_nonempty(lo: nat, hi: nat)\n    requires lo < hi\n    ensures choose_outputs(lo, hi).contains(lo)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_nat.rs", "verified": true, "metadata": {"original_id": "d637c54f03b0", "function_name": "choose_nonempty", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b7a077e84932", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bool_value_has_bool_type(t: Tm)\n    requires bvalue(t)\n    \n{\n    match t {\n        Tm::Tru => {}\n        Tm::Fls => {}\n        _ => {}\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bool_value_has_bool_type(t: Tm)\n    requires bvalue(t)\n    ensures has_type(t, Ty::TBool)\n{\n    match t {\n        Tm::Tru => {}\n        Tm::Fls => {}\n        _ => {}\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bool_value_has_bool_type(t: Tm)\n    requires bvalue(t)\n    ensures has_type(t, Ty::TBool)\n{\n    match t {\n        Tm::Tru => {}\n        Tm::Fls => {}\n        _ => {}\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "types_verus.rs", "verified": true, "metadata": {"original_id": "b7a077e84932", "function_name": "bool_value_has_bool_type", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_733f0ff599ae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)  ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "733f0ff599ae", "function_name": "remove_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_d6570104686d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/intersperse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d6570104686d", "function_name": "intersperse", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_7bd15a9f2d14", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_43/verina_advanced_43_impl.rs", "verified": true, "metadata": {"original_id": "7bd15a9f2d14", "function_name": "max_strength", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_849aa2fc577e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "849aa2fc577e", "function_name": "contains", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_26842855e1dd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn contains(k: nat, t: Tree) -> bool\n    {\n    match t {\n        Tree::E => false,\n        Tree::T { left, key, value: _, right } =>\n            if k < key {\n                contains(k, *left)\n            } else if k > key {\n                contains(k, *right)\n            } else {\n                true\n            }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn contains(k: nat, t: Tree) -> bool\n    decreases t\n{\n    match t {\n        Tree::E => false,\n        Tree::T { left, key, value: _, right } =>\n            if k < key {\n                contains(k, *left)\n            } else if k > key {\n                contains(k, *right)\n            } else {\n                true\n            }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn contains(k: nat, t: Tree) -> bool\n    decreases t\n{\n    match t {\n        Tree::E => false,\n        Tree::T { left, key, value: _, right } =>\n            if k < key {\n                contains(k, *left)\n            } else if k > key {\n                contains(k, *right)\n            } else {\n                true\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_search.rs", "verified": true, "metadata": {"original_id": "26842855e1dd", "function_name": "contains", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_a64d84288315", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "a64d84288315", "function_name": "prime_num", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_ca65ef766ffb", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/findmax_impl.rs", "verified": true, "metadata": {"original_id": "ca65ef766ffb", "function_name": "find_max", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_56f3ede37371", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn foldr_empty<A, B>(init: B, f: spec_fn(A, B) -> B)\n    \n{\n    assert(Seq::<A>::empty().len() == 0);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn foldr_empty<A, B>(init: B, f: spec_fn(A, B) -> B)\n    ensures foldr(Seq::<A>::empty(), init, f) == init\n{\n    assert(Seq::<A>::empty().len() == 0);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn foldr_empty<A, B>(init: B, f: spec_fn(A, B) -> B)\n    ensures foldr(Seq::<A>::empty(), init, f) == init\n{\n    assert(Seq::<A>::empty().len() == 0);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "56f3ede37371", "function_name": "foldr_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_0c07da4154e1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_sum_bounded_correct(bound: nat, p: (nat, nat))\n    requires gen_pair_sum_bounded_outputs(bound).contains(p)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_sum_bounded_correct(bound: nat, p: (nat, nat))\n    requires gen_pair_sum_bounded_outputs(bound).contains(p)\n    ensures p.0 + p.1 <= bound\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_sum_bounded_correct(bound: nat, p: (nat, nat))\n    requires gen_pair_sum_bounded_outputs(bound).contains(p)\n    ensures p.0 + p.1 <= bound\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_pair.rs", "verified": true, "metadata": {"original_id": "0c07da4154e1", "function_name": "gen_pair_sum_bounded_correct", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_c55b8b249333", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "c55b8b249333", "function_name": "contains_z", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_b0dc6fc2f573", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    requires dm_valid(dm), i < dm.n, dm_get(dm, i, i) == Some(0nat)\n    \n{}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    requires dm_valid(dm), i < dm.n, dm_get(dm, i, i) == Some(0nat)\n    ensures fw_relax(dm, i, i, i) == Some(0nat)\n{}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    requires dm_valid(dm), i < dm.n, dm_get(dm, i, i) == Some(0nat)\n    ensures fw_relax(dm, i, i, i) == Some(0nat)\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_floyd_warshall.rs", "verified": true, "metadata": {"original_id": "b0dc6fc2f573", "function_name": "diagonal_zero", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_d065fab5e527", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len ()  { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "d065fab5e527", "function_name": "is_smaller", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_39c13a2bda84", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "39c13a2bda84", "function_name": "separate", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_a7107533123a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_rhs_unfold(e: RtStep1)\n     {\n        RtStep1::Refl { x } => x,\n        RtStep1::Snoc { prev: _, y } => y,\n    }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_rhs_unfold(e: RtStep1)\n    ensures rt_rhs(e) == match e {\n        RtStep1::Refl { x } => x,\n        RtStep1::Snoc { prev: _, y } => y,\n    }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_rhs_unfold(e: RtStep1)\n    ensures rt_rhs(e) == match e {\n        RtStep1::Refl { x } => x,\n        RtStep1::Snoc { prev: _, y } => y,\n    }\n\n} // verus!", "source": "coq_translation", "source_file": "rel_verus.rs", "verified": true, "metadata": {"original_id": "a7107533123a", "function_name": "lemma_rt_rhs_unfold", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_080372a5dbc2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_gt_complement(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_gt_complement(a: nat, b: nat)\n    ensures dec_to_bool(dec_le_nat(a, b)) == !dec_to_bool(dec_gt_nat(a, b))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_gt_complement(a: nat, b: nat)\n    ensures dec_to_bool(dec_le_nat(a, b)) == !dec_to_bool(dec_gt_nat(a, b))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_ord.rs", "verified": true, "metadata": {"original_id": "080372a5dbc2", "function_name": "dec_le_gt_complement", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_e2a5bbc51457", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32)  ensures true { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_20/verina_basic_20_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e2a5bbc51457", "function_name": "unique_product", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_55cfdc94cc4a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX ,  { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "55cfdc94cc4a", "function_name": "update_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_326dcb4a9e07", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)  ensures k_out >= 0 , { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "326dcb4a9e07", "function_name": "main_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_adts_7172b41de434", "task": "task_c", "input_text": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/adts.rs", "verified": true, "metadata": {"original_id": "verus_adts_7172b41de434", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_e374f40eae7f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn find_witness_helper(n: nat, p: spec_fn(nat) -> bool, i: nat) -> Option<nat>\n    {\n    if i >= n {\n        Option::None\n    } else if p(i) {\n        Option::Some(i)\n    } else {\n        find_witness_helper(n, p, i + 1)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn find_witness_helper(n: nat, p: spec_fn(nat) -> bool, i: nat) -> Option<nat>\n    decreases n - i when i <= n\n{\n    if i >= n {\n        Option::None\n    } else if p(i) {\n        Option::Some(i)\n    } else {\n        find_witness_helper(n, p, i + 1)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn find_witness_helper(n: nat, p: spec_fn(nat) -> bool, i: nat) -> Option<nat>\n    decreases n - i when i <= n\n{\n    if i >= n {\n        Option::None\n    } else if p(i) {\n        Option::Some(i)\n    } else {\n        find_witness_helper(n, p, i + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_exists.rs", "verified": true, "metadata": {"original_id": "e374f40eae7f", "function_name": "find_witness_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_64537322c29f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool)  ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_match/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "64537322c29f", "function_name": "match_strings", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_const_4a3b8978107b", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n\n{\n    1\n}\n\nexec const E: u64\n\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/const.rs", "verified": true, "metadata": {"original_id": "verus_const_4a3b8978107b", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1f053d22680c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "1f053d22680c", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_c7e6da5e5ec9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "c7e6da5e5ec9", "function_name": "largest_prime_factor", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_d2a64f515fe1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    {\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Eq { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Lt { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Eq { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Lt { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Eq { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Lt { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_mutation.rs", "verified": true, "metadata": {"original_id": "d2a64f515fe1", "function_name": "expr_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_7e11715b30a0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { let mut idx = 0 ; while idx < l . len () invariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t , { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { let mut idx = 0 ; while idx < l . len () invariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t , decreases l . len () - idx { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { let mut idx = 0 ; while idx < l . len () invariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t , decreases l . len () - idx { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/052-below-threshold_impl.rs", "verified": true, "metadata": {"original_id": "7e11715b30a0", "function_name": "below_threshold", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_fc734197f4a1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_unwrap_some<T>(outputs: Set<Option<T>>, default: T, x: T)\n    \n    ensures gen_option_unwrap_or(outputs, default).contains(x)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_unwrap_some<T>(outputs: Set<Option<T>>, default: T, x: T)\n    requires outputs.contains(Option::Some(x))\n    ensures gen_option_unwrap_or(outputs, default).contains(x)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_option_unwrap_some<T>(outputs: Set<Option<T>>, default: T, x: T)\n    requires outputs.contains(Option::Some(x))\n    ensures gen_option_unwrap_or(outputs, default).contains(x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_option.rs", "verified": true, "metadata": {"original_id": "fc734197f4a1", "function_name": "gen_option_unwrap_some", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_504950a7e62a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "504950a7e62a", "function_name": "find_even_numbers", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_ec1f5ab02dc8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_option_some_some<A, B>(a: A, b: B, f: spec_fn(A) -> Option<B>)\n    requires f(a) == Option::Some(b)\n    \n{\n    // Trivially true\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_option_some_some<A, B>(a: A, b: B, f: spec_fn(A) -> Option<B>)\n    requires f(a) == Option::Some(b)\n    ensures traverse_option(Option::Some(a), f) == Option::Some(Option::Some(b))\n{\n    // Trivially true\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_option_some_some<A, B>(a: A, b: B, f: spec_fn(A) -> Option<B>)\n    requires f(a) == Option::Some(b)\n    ensures traverse_option(Option::Some(a), f) == Option::Some(Option::Some(b))\n{\n    // Trivially true\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_traversable.rs", "verified": true, "metadata": {"original_id": "ec1f5ab02dc8", "function_name": "traverse_option_some_some", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_3e011cee461c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn no_red_red(t: RBTree) -> bool\n    {\n    match t {\n        RBTree::E => true,\n        RBTree::T { color, left, key: _, value: _, right } => {\n            let left_ok = no_red_red(*left);\n            let right_ok = no_red_red(*right);\n            let this_ok = if color == Color::Red {\n                get_color(*left) == Color::Black && get_color(*right) == Color::Black\n            } else {\n                true\n            };\n            this_ok && left_ok && right_ok\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn no_red_red(t: RBTree) -> bool\n    decreases t\n{\n    match t {\n        RBTree::E => true,\n        RBTree::T { color, left, key: _, value: _, right } => {\n            let left_ok = no_red_red(*left);\n            let right_ok = no_red_red(*right);\n            let this_ok = if color == Color::Red {\n                get_color(*left) == Color::Black && get_color(*right) == Color::Black\n            } else {\n                true\n            };\n            this_ok && left_ok && right_ok\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn no_red_red(t: RBTree) -> bool\n    decreases t\n{\n    match t {\n        RBTree::E => true,\n        RBTree::T { color, left, key: _, value: _, right } => {\n            let left_ok = no_red_red(*left);\n            let right_ok = no_red_red(*right);\n            let this_ok = if color == Color::Red {\n                get_color(*left) == Color::Black && get_color(*right) == Color::Black\n            } else {\n                true\n            };\n            this_ok && left_ok && right_ok\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_redblack_def.rs", "verified": true, "metadata": {"original_id": "3e011cee461c", "function_name": "no_red_red", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_ebba0bb8ea12", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_fmap_length<A, B>(f: spec_fn(A) -> B, s: Seq<A>)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_fmap_length<A, B>(f: spec_fn(A) -> B, s: Seq<A>)\n    ensures seq_fmap(f, s).len() == s.len()\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_fmap_length<A, B>(f: spec_fn(A) -> B, s: Seq<A>)\n    ensures seq_fmap(f, s).len() == s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_functor.rs", "verified": true, "metadata": {"original_id": "ebba0bb8ea12", "function_name": "seq_fmap_length", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8f95f3ae8106", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f95f3ae8106", "function_name": "is_space_comma_dot", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_2ead9a18c535", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs5_impl.rs", "verified": true, "metadata": {"original_id": "2ead9a18c535", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_d4e8ebf49cb4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut result : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } result . push (row) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut result : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == a [k] . len () , forall | k : int | # ! [trigger result [k] , a [k] , b [k]] 0 <= k < i ==> forall | j : int | 0 <= j < result [k] . len () ==> result [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } result . push (row) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut result : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == a [k] . len () , forall | k : int | # ! [trigger result [k] , a [k] , b [k]] 0 <= k < i ==> forall | j : int | 0 <= j < result [k] . len () ==> result [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } result . push (row) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "d4e8ebf49cb4", "function_name": "index_wise_addition", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_1e85f9564809", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_is_even/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1e85f9564809", "function_name": "compute_is_even", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_fea20d875003", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "fea20d875003", "function_name": "linear_search", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_dc955fe25f39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn pow (base : int , exp : nat) -> int decreases exp { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool) requires is_power_of_two_precond (n as int) ,  { proof { admit () ; } if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn pow (base : int , exp : nat) -> int decreases exp { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool) requires is_power_of_two_precond (n as int) , ensures is_power_of_two_postcond (n as int , result) , { proof { admit () ; } if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn pow (base : int , exp : nat) -> int decreases exp { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool) requires is_power_of_two_precond (n as int) , ensures is_power_of_two_postcond (n as int , result) , { proof { admit () ; } if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_23/verina_advanced_23_iter_3_current.rs", "verified": true, "metadata": {"original_id": "dc955fe25f39", "function_name": "is_power_of_two", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_0937588b64e4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_never_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_never_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    ensures try_shrink(state, candidate, still_fails).current <= state.current\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_never_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    ensures try_shrink(state, candidate, still_fails).current <= state.current\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_runner_shrink.rs", "verified": true, "metadata": {"original_id": "0937588b64e4", "function_name": "shrink_never_increases", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_fc13cae53e1e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fc13cae53e1e", "function_name": "minArray", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_553a4b7e9bf1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/replace_iter_2_current.rs", "verified": true, "metadata": {"original_id": "553a4b7e9bf1", "function_name": "replace", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_5cbadc11b08a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn maybe_swap_ordered(s: Seq<nat>, i: nat, j: nat)\n    requires i < s.len(), j < s.len()\n    \n{\n    if s[i as int] > s[j as int] {\n        assert(swap_at(s, i, j)[i as int] == s[j as int]);\n        assert(swap_at(s, i, j)[j as int] == s[i as int]);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn maybe_swap_ordered(s: Seq<nat>, i: nat, j: nat)\n    requires i < s.len(), j < s.len()\n    ensures maybe_swap(s, i, j)[i as int] <= maybe_swap(s, i, j)[j as int]\n{\n    if s[i as int] > s[j as int] {\n        assert(swap_at(s, i, j)[i as int] == s[j as int]);\n        assert(swap_at(s, i, j)[j as int] == s[i as int]);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn maybe_swap_ordered(s: Seq<nat>, i: nat, j: nat)\n    requires i < s.len(), j < s.len()\n    ensures maybe_swap(s, i, j)[i as int] <= maybe_swap(s, i, j)[j as int]\n{\n    if s[i as int] > s[j as int] {\n        assert(swap_at(s, i, j)[i as int] == s[j as int]);\n        assert(swap_at(s, i, j)[j as int] == s[i as int]);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_perm_swap.rs", "verified": true, "metadata": {"original_id": "5cbadc11b08a", "function_name": "maybe_swap_ordered", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7dbadc23d5c5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    \n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "lists_verus.rs", "verified": true, "metadata": {"original_id": "7dbadc23d5c5", "function_name": "lemma_reverse_index", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_31b43faaebe3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_holds(p: bool)\n    \n    ensures prop_when(true, p)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_holds(p: bool)\n    requires p\n    ensures prop_when(true, p)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_holds(p: bool)\n    requires p\n    ensures prop_when(true, p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_bool.rs", "verified": true, "metadata": {"original_id": "31b43faaebe3", "function_name": "prop_when_holds", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_27efb7251eee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "27efb7251eee", "function_name": "contains_z", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_481feda38498", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 ,  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "481feda38498", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8f343f78db7d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    requires xs.len() > 1,\n             0 <= i < xs.len() as int\n    \n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    requires xs.len() > 1,\n             0 <= i < xs.len() as int\n    ensures shrink_seq_nat(xs)[i].len() < xs.len()\n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    requires xs.len() > 1,\n             0 <= i < xs.len() as int\n    ensures shrink_seq_nat(xs)[i].len() < xs.len()\n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_arbitrary.rs", "verified": true, "metadata": {"original_id": "8f343f78db7d", "function_name": "shrink_seq_shorter", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_fef94c2f1dde", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { let mut i : usize = 0 ; while i < list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , { let mut j : usize = 0 ; while j < list2 . len () invariant i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { let mut i : usize = 0 ; while i < list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , decreases list1 . len () - i { let mut j : usize = 0 ; while j < list2 . len () invariant i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , decreases list2 . len () - j { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { let mut i : usize = 0 ; while i < list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , decreases list1 . len () - i { let mut j : usize = 0 ; while j < list2 . len () invariant i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , decreases list2 . len () - j { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "fef94c2f1dde", "function_name": "has_common_element", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_384695c57c63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "384695c57c63", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_lib_examples_85b5449808d7", "task": "task_c", "input_text": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n\n    v.set(2, 21);\n\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/lib_examples.rs", "verified": true, "metadata": {"original_id": "verus_lib_examples_85b5449808d7", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_78e542bc9dd1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX ,  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "78e542bc9dd1", "function_name": "interleave", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_34c53725a9bc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_is_bst()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_is_bst()\n    ensures dec_to_bool(dec_is_bst(Tree::<nat>::Leaf))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_is_bst()\n    ensures dec_to_bool(dec_is_bst(Tree::<nat>::Leaf))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_tree.rs", "verified": true, "metadata": {"original_id": "34c53725a9bc", "function_name": "leaf_is_bst", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_7501af37a05e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)  ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "7501af37a05e", "function_name": "find_min_loop", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_23d1dc2a0a62", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "23d1dc2a0a62", "function_name": "F", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_5bad090f8fd5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32)  ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_62/verina_advanced_62_iter_0_original.rs", "verified": true, "metadata": {"original_id": "5bad090f8fd5", "function_name": "rain", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_a30a136e4ced", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "a30a136e4ced", "function_name": "binary_search_recursive", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4c35cb082aec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_complete(lo: int, hi: int, n: int)\n    requires lo <= n && n < hi\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_complete(lo: int, hi: int, n: int)\n    requires lo <= n && n < hi\n    ensures choose_int_outputs(lo, hi).contains(n)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_complete(lo: int, hi: int, n: int)\n    requires lo <= n && n < hi\n    ensures choose_int_outputs(lo, hi).contains(n)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "4c35cb082aec", "function_name": "choose_int_complete", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_95f3adf14501", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)  ensures sum [0] == 4 * N , { sum . set (0 , 4 * N as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s32if_impl.rs", "verified": true, "metadata": {"original_id": "95f3adf14501", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_51851ecb2982", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_807_iter_4_current.rs", "verified": true, "metadata": {"original_id": "51851ecb2982", "function_name": "find_first_odd", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a439577991c0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "a439577991c0", "function_name": "element_wise_divide", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_94fc95a22d1f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "94fc95a22d1f", "function_name": "max", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_assert_8c81c80d49c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ;  } } else { proof {  } } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c81c80d49c3", "function_name": "is_divisible_by_11", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_0cca59d8cea0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "0cca59d8cea0", "function_name": "element_wise_divide", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_bbc941e4aa4d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "bbc941e4aa4d", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_af24ef4d27ab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "af24ef4d27ab", "function_name": "reverse_to_k", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_a5aaacac93d5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_annihil(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_annihil(p: bool)\n    ensures conj_annihil(p)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_annihil(p: bool)\n    ensures conj_annihil(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "a5aaacac93d5", "function_name": "verify_conj_annihil", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_aa2c3f910a04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_contains(x: nat, s: Set<nat>)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_contains(x: nat, s: Set<nat>)\n    ensures set_contains(x, set_insert(x, s))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_contains(x: nat, s: Set<nat>)\n    ensures set_contains(x, set_insert(x, s))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_adt_set.rs", "verified": true, "metadata": {"original_id": "aa2c3f910a04", "function_name": "insert_contains", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_1f06fb34afe9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "1f06fb34afe9", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_06ae2221d67c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)  ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "06ae2221d67c", "function_name": "find_min_loop", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c5475d6423de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "c5475d6423de", "function_name": "is_greater", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_86fb88eba4f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , found <==> (exists | k : int | 0 <= k < j && result [k] == a [i as int]) , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , found <==> (exists | k : int | 0 <= k < j && result [k] == a [i as int]) , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , found <==> (exists | k : int | 0 <= k < j && result [k] == a [i as int]) , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "86fb88eba4f6", "function_name": "remove_duplicates", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_553a4b7e9bf1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/replace_iter_2_current.rs", "verified": true, "metadata": {"original_id": "553a4b7e9bf1", "function_name": "replace", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_b43b0fe6a5bc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)  ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/unique_better_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b43b0fe6a5bc", "function_name": "unique_better", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_e5f3508fc988", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs4_impl.rs", "verified": true, "metadata": {"original_id": "e5f3508fc988", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_2eace5cd4634", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >)  ensures find_first_odd_postcond (a , result) { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { proof { assert (is_odd (a [i as int] as int)) ; } return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { proof { assert (is_odd (a [i as int] as int)) ; } return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { proof { assert (is_odd (a [i as int] as int)) ; } return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_49/verina_basic_49_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2eace5cd4634", "function_name": "find_first_odd", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_e6f3cda068fa", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_any<T>(t: Tree<T>, p: spec_fn(T) -> bool) -> bool\n    {\n    match t {\n        Tree::Leaf => false,\n        Tree::Node { left, value, right } =>\n            p(value) ||\n            tree_any(*left, p) ||\n            tree_any(*right, p),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_any<T>(t: Tree<T>, p: spec_fn(T) -> bool) -> bool\n    decreases t\n{\n    match t {\n        Tree::Leaf => false,\n        Tree::Node { left, value, right } =>\n            p(value) ||\n            tree_any(*left, p) ||\n            tree_any(*right, p),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_any<T>(t: Tree<T>, p: spec_fn(T) -> bool) -> bool\n    decreases t\n{\n    match t {\n        Tree::Leaf => false,\n        Tree::Node { left, value, right } =>\n            p(value) ||\n            tree_any(*left, p) ||\n            tree_any(*right, p),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_tree.rs", "verified": true, "metadata": {"original_id": "e6f3cda068fa", "function_name": "tree_any", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_a1901dce877e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn for_all_nat_soundness_single(\n    prop: spec_fn(nat) -> bool,\n    seed: nat,\n    size: nat,\n    num_tests: nat\n)\n    \n    ensures prop(arbitrary_nat(seed, size))\n{\n    // When for_all_nat returns true with num_tests > 0,\n    // it means prop(arbitrary_nat(seed, size)) is true\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn for_all_nat_soundness_single(\n    prop: spec_fn(nat) -> bool,\n    seed: nat,\n    size: nat,\n    num_tests: nat\n)\n    requires for_all_nat(prop, seed, size, num_tests),\n             num_tests > 0\n    ensures prop(arbitrary_nat(seed, size))\n{\n    // When for_all_nat returns true with num_tests > 0,\n    // it means prop(arbitrary_nat(seed, size)) is true\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn for_all_nat_soundness_single(\n    prop: spec_fn(nat) -> bool,\n    seed: nat,\n    size: nat,\n    num_tests: nat\n)\n    requires for_all_nat(prop, seed, size, num_tests),\n             num_tests > 0\n    ensures prop(arbitrary_nat(seed, size))\n{\n    // When for_all_nat returns true with num_tests > 0,\n    // it means prop(arbitrary_nat(seed, size)) is true\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_arbitrary.rs", "verified": true, "metadata": {"original_id": "a1901dce877e", "function_name": "for_all_nat_soundness_single", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_f36d321f2a42", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)  ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f36d321f2a42", "function_name": "binary_search_recursive", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_interior_mutability_bb35c8760b0b", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "target_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "full_verified_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/interior_mutability.rs", "verified": true, "metadata": {"original_id": "verus_interior_mutability_bb35c8760b0b", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_813646cb02a1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n  { if (n % i) == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if (n % i) == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if (n % i) == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/code_from_spec_on_17-07_17h24/task_id_605_impl_impl.rs", "verified": true, "metadata": {"original_id": "813646cb02a1", "function_name": "prime_num", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_2d2df738f15b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "2d2df738f15b", "function_name": "iter_copy", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_5e8defeb6441", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)  ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "5e8defeb6441", "function_name": "compare_int", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_85c81ee22263", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)  ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_2_current.rs", "verified": true, "metadata": {"original_id": "85c81ee22263", "function_name": "max_strength", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_a33d41e9a24e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () ,  { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a33d41e9a24e", "function_name": "barrier", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_2b6913fa918f", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len ()  { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "2b6913fa918f", "function_name": "clone_option_vec_u8", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_f1b935345b11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_elim_left(p: bool, q: bool)\n    \n    ensures p\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_elim_left(p: bool, q: bool)\n    requires p && q\n    ensures p\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_elim_left(p: bool, q: bool)\n    requires p && q\n    ensures p\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "f1b935345b11", "function_name": "and_elim_left", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_99ac91a8e131", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "99ac91a8e131", "function_name": "intersection", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_606681853ccd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)  ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)  ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "606681853ccd", "function_name": "search_insert", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_d6d6c78c13e8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn rb_empty_is_empty(cap: nat) requires cap > 0  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn rb_empty_is_empty(cap: nat) requires cap > 0 ensures rb_is_empty(rb_empty(cap)) {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn rb_empty_is_empty(cap: nat) requires cap > 0 ensures rb_is_empty(rb_empty(cap)) {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_ring_buffer.rs", "verified": true, "metadata": {"original_id": "d6d6c78c13e8", "function_name": "rb_empty_is_empty", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_d286deebe977", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn forall_empty_range(p: spec_fn(nat) -> bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn forall_empty_range(p: spec_fn(nat) -> bool)\n    ensures dec_to_bool(dec_forall_nat_lt(0, p))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn forall_empty_range(p: spec_fn(nat) -> bool)\n    ensures dec_to_bool(dec_forall_nat_lt(0, p))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_forall.rs", "verified": true, "metadata": {"original_id": "d286deebe977", "function_name": "forall_empty_range", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_8f052db50046", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f052db50046", "function_name": "binary_search_recursive", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_3f5c1f805fb1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn elements_complete<T>(elems: Seq<T>, i: int)\n    requires 0 <= i < elems.len()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn elements_complete<T>(elems: Seq<T>, i: int)\n    requires 0 <= i < elems.len()\n    ensures elements_outputs(elems).contains(elems[i])\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn elements_complete<T>(elems: Seq<T>, i: int)\n    requires 0 <= i < elems.len()\n    ensures elements_outputs(elems).contains(elems[i])\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_oneof.rs", "verified": true, "metadata": {"original_id": "3f5c1f805fb1", "function_name": "elements_complete", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_dc79c0fb0aec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "dc79c0fb0aec", "function_name": "max_of_list", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_090adcd5be63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex1_even_sound(e: EvenEv)\n    \n    decreases e\n{\n    match e {\n        EvenEv::Ev0 => {\n            assert(is_even(0));\n        }\n        EvenEv::EvSS(e1) => {\n            ex1_even_sound(*e1);\n            assert(is_even(e.n()) == is_even((e1.n()) as nat));\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex1_even_sound(e: EvenEv)\n    ensures is_even(e.n())\n    decreases e\n{\n    match e {\n        EvenEv::Ev0 => {\n            assert(is_even(0));\n        }\n        EvenEv::EvSS(e1) => {\n            ex1_even_sound(*e1);\n            assert(is_even(e.n()) == is_even((e1.n()) as nat));\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex1_even_sound(e: EvenEv)\n    ensures is_even(e.n())\n    decreases e\n{\n    match e {\n        EvenEv::Ev0 => {\n            assert(is_even(0));\n        }\n        EvenEv::EvSS(e1) => {\n            ex1_even_sound(*e1);\n            assert(is_even(e.n()) == is_even((e1.n()) as nat));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "090adcd5be63", "function_name": "ex1_even_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_1f681c77b4c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "1f681c77b4c7", "function_name": "extract_rear_chars", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_a9f193cf911c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)  ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result @ == a @ . subrange (0 , i as int) decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result @ == a @ . subrange (0 , i as int) decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result @ == a @ . subrange (0 , i as int) decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_array_append/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a9f193cf911c", "function_name": "append", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_cbfdc10a023e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/intersperse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cbfdc10a023e", "function_name": "intersperse", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_06d9796e8a51", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)  ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)  ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "06d9796e8a51", "function_name": "largest_prime_factor", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_fa9fe227ebaf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn same_seed_same_replay(info: ReplayInfo)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn same_seed_same_replay(info: ReplayInfo)\n    ensures replay_produces_same_test(info, info)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn same_seed_same_replay(info: ReplayInfo)\n    ensures replay_produces_same_test(info, info)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_replay_test.rs", "verified": true, "metadata": {"original_id": "fa9fe227ebaf", "function_name": "same_seed_same_replay", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8620ff43a009", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 ,  { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "8620ff43a009", "function_name": "triple_if", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a69f60f76982", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int ,  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a69f60f76982", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_0c10f306fe6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >)  ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_aae9270037a8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_nat_sound(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_nat_sound(a: nat, b: nat)\n    ensures dec_to_bool(dec_le_nat(a, b)) <==> (a <= b)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_nat_sound(a: nat, b: nat)\n    ensures dec_to_bool(dec_le_nat(a, b)) <==> (a <= b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_ord.rs", "verified": true, "metadata": {"original_id": "aae9270037a8", "function_name": "dec_le_nat_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7551c5191921", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7551c5191921", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a44c330cf656", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 ,  { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a44c330cf656", "function_name": "is_sorted", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a7d07e85cdf7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize)  ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a7d07e85cdf7", "function_name": "longest_increasing_streak_aux", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_47e7ebd516ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof {    } max_val - min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_145_iter_2_current.rs", "verified": true, "metadata": {"original_id": "47e7ebd516ec", "function_name": "max_difference", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_379762ca5f16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)  ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "379762ca5f16", "function_name": "element_wise_module", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_fc12360a6125", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms4_impl.rs", "verified": true, "metadata": {"original_id": "fc12360a6125", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_ffd714a2cd2f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_trans(ty1: Ty, ty2: Ty, ty3: Ty)\n    \n    ensures ty_eq(ty1, ty3)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_trans(ty1: Ty, ty2: Ty, ty3: Ty)\n    requires\n        ty_eq(ty1, ty2),\n        ty_eq(ty2, ty3),\n    ensures ty_eq(ty1, ty3)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_trans(ty1: Ty, ty2: Ty, ty3: Ty)\n    requires\n        ty_eq(ty1, ty2),\n        ty_eq(ty2, ty3),\n    ensures ty_eq(ty1, ty3)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_type.rs", "verified": true, "metadata": {"original_id": "ffd714a2cd2f", "function_name": "ty_eq_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_b375d0077dd0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "b375d0077dd0", "function_name": "replace_blanks_with_chars", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_84f1fcf3e5ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)  ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "84f1fcf3e5ee", "function_name": "find_even_numbers", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_25b4a97f7bf0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "25b4a97f7bf0", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_c6508c551eb5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_2/verina_basic_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c6508c551eb5", "function_name": "find_smallest", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_7dfba95d31d0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn div_self(a: nat)\n    \n    ensures a / a == 1\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn div_self(a: nat)\n    requires a > 0\n    ensures a / a == 1\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn div_self(a: nat)\n    requires a > 0\n    ensures a / a == 1\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "7dfba95d31d0", "function_name": "div_self", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6c4e2454c325", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) ,  { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6c4e2454c325", "function_name": "single_digit_prime_factor", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a23c449ffa34", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_allows_1000_discards()\n    \n{\n    assert(100 * 10 == 1000);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_allows_1000_discards()\n    ensures max_discards(default_config()) == 1000\n{\n    assert(100 * 10 == 1000);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_allows_1000_discards()\n    ensures max_discards(default_config()) == 1000\n{\n    assert(100 * 10 == 1000);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_quickcheck_config.rs", "verified": true, "metadata": {"original_id": "a23c449ffa34", "function_name": "default_allows_1000_discards", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_766002711d69", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_max_iter_2_current.rs", "verified": true, "metadata": {"original_id": "766002711d69", "function_name": "max", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_385ba17c20ec", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "385ba17c20ec", "function_name": "seq_to_vec", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_2c47fe33ac66", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex_seq_append_nil_right(xs: ListN)\n    \n{\n    assert_seqs_equal!(xs.add(seq![]), xs);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex_seq_append_nil_right(xs: ListN)\n    ensures xs.add(seq![]) =~= xs\n{\n    assert_seqs_equal!(xs.add(seq![]), xs);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex_seq_append_nil_right(xs: ListN)\n    ensures xs.add(seq![]) =~= xs\n{\n    assert_seqs_equal!(xs.add(seq![]), xs);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "auto_verus.rs", "verified": true, "metadata": {"original_id": "2c47fe33ac66", "function_name": "ex_seq_append_nil_right", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_52e2f9691e2a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "52e2f9691e2a", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_chapter-1-22_fa6ac1200b1d", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n     {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-1-22.rs", "verified": true, "metadata": {"original_id": "verus_chapter-1-22_fa6ac1200b1d", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_verus_top_sort_dfs_ea18631d9b04", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::slice::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n#[verifier::reject_recursive_types(V)]\npub struct DirectedGraph<V> {\n    pub edges: Set<(V, V)>,\n}\n\nimpl<V> DirectedGraph<V> {\n    pub open spec fn dest_set(&self, v: V) -> Set<V> {\n        Set::new(|w: V| self.edges.contains((v, w)))\n    }\n\n    pub open spec fn is_sorted(&self, s: Seq<V>) -> bool {\n        forall|i, j: int| 0 <= i <= j < s.len() ==> !self.edges.contains((s.index(i), s.index(j)))\n    }\n\n    pub open spec fn is_cycle_i(&self, s: Seq<V>, i: int) -> bool {\n        self.edges.contains((s[i], s[i + 1]))\n    }\n\n    pub open spec fn is_cycle(&self, s: Seq<V>) -> bool {\n        s.len() > 0 && (forall|i: int| 0 <= i < s.len() - 1 ==> self.is_cycle_i(s, i))\n            && self.edges.contains((s.last(), s[0]))\n    }\n}\n\ntokenized_state_machine!{\n    #[verifier::reject_recursive_types(V)]\n    TopSort<V> {\n        fields {\n            #[sharding(constant)]\n            pub graph: DirectedGraph<V>,\n\n            #[sharding(set)]\n            pub unvisited: Set<V>,\n\n            #[sharding(persistent_set)]\n            pub visited: Set<V>,\n\n            #[sharding(variable)]\n            pub top_sort: Seq<V>,\n        }\n\n        init!{\n            initialize(graph: DirectedGraph<V>) {\n                init graph = graph;\n                init unvisited = Set::full();\n                init visited = Set::empty();\n                init top_sort = Seq::empty();\n            }\n        }\n\n        transition!{\n            push_into_top_sort(v: V) {\n                have visited >= (pre.graph.dest_set(v));\n\n                remove unvisited -= set { v };\n                add visited (union)= set { v };\n\n                update top_sort = pre.top_sort.push(v);\n            }\n        }\n\n        property!{\n            done(s: Set<V>) {\n                have visited >= (s);\n                assert(forall |i| s.contains(i) ==> pre.top_sort.contains(i));\n                assert(pre.graph.is_sorted(pre.top_sort));\n            }\n        }\n\n        #[invariant]\n        pub fn un_vis(&self) -> bool {\n            self.unvisited === self.visited.complement()\n        }\n\n        #[invariant]\n        pub fn top_sort_is_sort(&self) -> bool {\n            self.graph.is_sorted(self.top_sort)\n        }\n\n        #[invariant]\n        pub fn visited_closed_under_dep(&self) -> bool {\n            forall |v, w| #[trigger] self.graph.edges.contains((v, w)) ==>\n                self.visited.contains(v) ==>\n                self.visited.contains(w)\n        }\n\n        #[invariant]\n        pub fn top_sort_matches_visited(&self) -> bool {\n            forall |v| #[trigger] self.visited.contains(v) <==>\n                self.top_sort.contains(v)\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, graph: DirectedGraph<V>) { }\n\n        #[inductive(push_into_top_sort)]\n        fn push_into_top_sort_inductive(pre: Self, post: Self, v: V) {\n            assert_sets_equal!(post.unvisited, post.visited.complement());\n\n            assert forall |a| #[trigger] post.visited.contains(a) implies\n                post.top_sort.contains(a)\n            by {\n                if a === v {\n                    assert(post.top_sort.last() === a);\n                    assert(post.top_sort.contains(a));\n                } else {\n                    assert(pre.visited.contains(a));\n                    assert(pre.top_sort.contains(a));\n                    let i = choose |i| 0 <= i < pre.top_sort.len() && pre.top_sort.index(i) === a;\n                    assert(post.top_sort.index(i) === a);\n                    assert(post.top_sort.contains(a));\n                }\n            }\n\n            assert forall |v| #[trigger] post.top_sort.contains(v) implies\n                post.visited.contains(v)\n            by {\n            }\n        }\n\n    }\n}\n\nstruct ConcreteDirectedGraph {\n    edges: Vec<Vec<usize>>,\n}\n\nimpl ConcreteDirectedGraph {\n    spec fn well_formed(&self) -> bool {\n        forall|i, j|\n            0 <= i < self.edges@.len() && 0 <= j < self.edges@.index(i)@.len() ==> 0 <= (\n            #[trigger] self.edges@.index(i)@.index(j)) < self.edges@.len()\n    }\n\n    spec fn view(&self) -> DirectedGraph<usize> {\n        DirectedGraph {\n            edges: Set::<(usize, usize)>::new(\n                |p: (usize, usize)|\n                    0 <= (p.0 as int) < (self.edges@.len() as int) && self.edges@.index(\n                        p.0 as int,\n                    )@.contains(p.1),\n            ),\n        }\n    }\n}\n\nenum NodeToken {\n    Unvisited(TopSort::unvisited<usize>),\n    InProgress,\n    Visited(TopSort::visited<usize>),\n}\n\nstruct NodeState {\n    visited: bool,\n    in_stack: bool,\n    token: Tracked<NodeToken>,\n}\n\nimpl NodeState {\n    spec fn well_formed(&self, i: int, inst: TopSort::Instance<usize>) -> bool {\n        match self.token@ {\n            NodeToken::Unvisited(token) => {\n                &&& !self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n            NodeToken::InProgress => {\n                &&& self.visited\n                &&& self.in_stack\n            },\n            NodeToken::Visited(token) => {\n                &&& self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n        }\n    }\n}\n\nstruct DfsState {\n    top_sort: Vec<usize>,\n    cur_stack: Vec<usize>,\n    cycle: Vec<usize>,\n    node_states: Vec<NodeState>,\n    top_sort_token: Tracked<TopSort::top_sort<usize>>,\n    instance: Tracked<TopSort::Instance<usize>>,\n}\n\nspec fn valid_stack_i(cur_stack: Seq<usize>, graph: DirectedGraph<usize>, i: int) -> bool {\n    graph.edges.contains((cur_stack[i], cur_stack[i + 1]))\n}\n\nspec fn valid_stack(cur_stack: Seq<usize>, graph: DirectedGraph<usize>) -> bool {\n    forall|i: int| 0 <= i < cur_stack.len() as int - 1 ==> valid_stack_i(cur_stack, graph, i)\n}\n\nimpl DfsState {\n    spec fn well_formed(&self, graph: &ConcreteDirectedGraph) -> bool {\n        &&& graph.well_formed()\n        &&& self.node_states@.len() == graph.edges@.len()\n        &&& forall|i|\n            0 <= i < self.node_states@.len() ==> self.node_states@[i].well_formed(i, self.instance@)\n        &&& self.top_sort_token@.instance_id() === self.instance@.id()\n        &&& self.top_sort_token@.value() === self.top_sort@\n        &&& self.instance@.graph() === graph@\n        &&& valid_stack(self.cur_stack@, graph@)\n        &&& forall|i: usize|\n            0 <= i < self.node_states@.len() ==> (self.node_states@[i as int].in_stack\n                <==> self.cur_stack@.contains(i))\n    }\n}\n\nspec fn is_complete_top_sort(top_sort: &Vec<usize>, graph: &ConcreteDirectedGraph) -> bool {\n    graph@.is_sorted(top_sort@) && forall|i: usize|\n        0 <= i < graph.edges@.len() ==> top_sort@.contains(i)\n}\n\nfn vec_find(v: &Vec<usize>, needle: usize) -> (idx: usize)\n    requires\n        v@.contains(needle),\n\n{\n    let mut idx = 0;\n    loop\n        invariant\n            v@.contains(needle),\n            0 <= idx < v@.len(),\n            forall|j| 0 <= j < idx ==> v@[j] != needle,\n    {\n        if v[idx] == needle {\n            return idx;\n        }\n        assert(idx + 1 < v.len());\n        idx = idx + 1;\n    }\n}\n\nfn find_cycle(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize)\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n        old(dfs_state).node_states@.index(v as int).in_stack,\n\n{\n    let j = vec_find(&dfs_state.cur_stack, v);\n    let len = dfs_state.cur_stack.len();\n    let tmp1 = dfs_state.cur_stack.as_slice();\n    let tmp2 = slice_subrange(tmp1, j, len);\n    let cycle = slice_to_vec(tmp2);\n    dfs_state.cycle = cycle;\n    assert(tmp1@.len() == dfs_state.cur_stack.len());\n    assert(tmp2@.len() + j == len);\n    assert(tmp2@ == cycle@);\n    assert(cycle.len() + j == len);\n    assert(j + dfs_state.cycle@.len() == len);\n    assert(graph@.is_cycle(dfs_state.cycle@)) by {\n        assert forall|i: int| 0 <= i < dfs_state.cycle@.len() - 1 implies graph@.is_cycle_i(\n            dfs_state.cycle@,\n            i,\n        ) by {\n            assert(valid_stack_i(dfs_state.cur_stack@, graph@, i + j));  // trigger\n        }\n    };\n}\n\nfn visit(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize) -> (res: (\n    bool,\n    Tracked<Option<TopSort::visited<usize>>>,\n))\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n\n{\n    let node_state = &dfs_state.node_states[v as usize];\n    if node_state.in_stack {\n        find_cycle(graph, dfs_state, v);\n        return (false, Tracked(None));\n    }\n    if node_state.visited {\n        let tracked tok = match node_state.token.borrow() {\n            NodeToken::Visited(tok) => tok.clone(),\n            _ => proof_from_false(),\n        };\n        return (true, Tracked(Some(tok)));\n    }\n    let mut node_state_tmp = NodeState {\n        in_stack: true,\n        visited: true,\n        token: Tracked(NodeToken::InProgress),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    let tracked unvisited = match node_state_tmp.token.get() {\n        NodeToken::Unvisited(unvisited) => unvisited,\n        _ => proof_from_false(),\n    };\n    dfs_state.cur_stack.push(v);\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: int|\n            0 <= i && i < dfs_state.cur_stack@.len() as int - 2 ==> valid_stack_i(\n                old(dfs_state).cur_stack@,\n                graph@,\n                i,\n            ) ==> #[trigger] valid_stack_i(dfs_state.cur_stack@, graph@, i));\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assert forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() implies dfs_state.node_states@.index(\n            i as int,\n        ).in_stack == dfs_state.cur_stack@.contains(i) by {\n            if i == v {\n                assert(dfs_state.cur_stack@.last() == i);\n                assert(dfs_state.cur_stack@.contains(i));\n            } else {\n                if old(dfs_state).cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(dfs_state.cur_stack@.index(j) == i);\n                }\n                if dfs_state.cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(old(dfs_state).cur_stack@.index(j) == i);\n                }\n                assert(dfs_state.cur_stack@.contains(i) == old(dfs_state).cur_stack@.contains(i));\n            }\n        }\n    }\n    let ghost extended_cur_stack = dfs_state.cur_stack;\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> =\n        TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    let mut idx: usize = 0;\n    while idx < graph.edges[v as usize].len()\n        invariant\n            equal(dfs_state.instance, old(dfs_state).instance),\n            dfs_state.cur_stack@.len() > 0,\n            dfs_state.cur_stack@.last() == v,\n            0 <= v && v < graph.edges@.len(),\n            0 <= idx && idx <= graph.edges@.index(v as int)@.len(),\n            dfs_state.well_formed(graph),\n            equal(dfs_state.cur_stack@, extended_cur_stack@),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|idx0: int|\n                0 <= idx0 && idx0 < idx ==> {\n                    let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n                    map_visited_deps.contains(w)\n                },\n    {\n        let w = graph.edges[v as usize][idx];\n        assert((v as usize) as int == v as int);\n        assert(graph.edges@.index(v as int)@.index(idx as int) == w);\n        assert(graph.edges@.index(v as int)@.contains(w));\n        assert(graph@.edges.contains((v, w)));\n        let (b, Tracked(opt_visited)) = visit(graph, dfs_state, w);\n        if !b {\n            return (false, Tracked(None));\n        }\n        let ghost old_map_visited_deps = map_visited_deps;\n        let ghost old_idx = idx;\n        proof {\n            let tracked visited = opt_visited.tracked_unwrap();\n            map_visited_deps.insert(visited);\n        }\n        idx = idx + 1;\n        assert forall|idx0: int| 0 <= idx0 && idx0 < idx implies ({\n            let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n            map_visited_deps.contains(w)\n        }) by {\n            assume(false);\n        }\n    }\n    dfs_state.cur_stack.pop();\n    assert(equal(unvisited.instance_id(), dfs_state.instance@.id()));\n    let tracked visited = dfs_state.instance.borrow().push_into_top_sort(\n        v,\n        unvisited,\n        &map_visited_deps,\n        dfs_state.top_sort_token.borrow_mut(),\n    );\n    dfs_state.top_sort.push(v);\n    let mut node_state_tmp = NodeState {\n        in_stack: false,  // TODO don't need to write this field again\n        visited: true,\n        token: Tracked(NodeToken::Visited(visited.clone())),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    proof {\n        assert_seqs_equal!(\n            dfs_state.cur_stack@,\n            old(dfs_state).cur_stack@);\n    }\n    assert(dfs_state.well_formed(graph)) by {\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assume(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==> (dfs_state.node_states@.index(\n                i as int,\n            ).in_stack == dfs_state.cur_stack@.contains(i)));\n    };\n    (true, Tracked(Some(visited)))\n}\n\nfn init_node_states(\n    n: usize,\n    Tracked(instance): Tracked<TopSort::Instance<usize>>,\n    Tracked(unv): Tracked<TopSort::unvisited_set<usize>>,\n) -> (node_states: Vec<NodeState>)\n    requires\n        forall|j: usize| 0 <= j && j < n ==> unv.contains(j),\n        unv.instance_id() == instance.id(),\n\n{\n    let mut node_states = Vec::<NodeState>::new();\n    let mut i: usize = 0;\n    let tracked mut unv = unv;\n    while i < n\n        invariant\n            0 <= i && i <= n,\n            node_states@.len() == i as int,\n            forall|j: int| 0 <= j && j < i ==> node_states@.index(j).well_formed(j, instance),\n            forall|j: int| 0 <= j && j < i ==> !node_states@.index(j).in_stack,\n            forall|j: usize| i <= j && j < n ==> #[trigger] unv.contains(j),\n            unv.instance_id() == instance.id(),\n    {\n        assert(unv.contains(i));\n        let tracked unv1 = unv.remove(i);\n        node_states.push(\n            NodeState {\n                visited: false,\n                in_stack: false,\n                token: Tracked(NodeToken::Unvisited(unv1)),\n            },\n        );\n        i = i + 1;\n        /*let ghost i_spec = i;\n        assert_forall_by(|j: int| {\n            requires(0 <= j && j < i);\n            ensures(node_states@.index(j).well_formed(j, instance));\n\n            if j + 1 < i_spec {\n                assert(old_node_states@.index(j).well_formed(j, instance));\n            } else {\n                assert(node_states@.index(j).well_formed(j, instance));\n            }\n        });*/\n    }\n    node_states\n}\n\nenum TopSortResult {\n    TopSort(Vec<usize>),\n    Cycle(Vec<usize>),\n}\n\nfn compute_top_sort(graph: &ConcreteDirectedGraph) -> (tsr: TopSortResult)\n    requires\n        graph.well_formed(),\n     {\n            TopSortResult::TopSort(top_sort) => is_complete_top_sort(&top_sort, graph),\n            TopSortResult::Cycle(cycle) => graph@.is_cycle(cycle@),\n        }),\n{\n    let tracked (Tracked(instance), Tracked(unv), _, Tracked(top_sort_token)) =\n        TopSort::Instance::<usize>::initialize(graph@);\n    let mut dfs_state = DfsState {\n        top_sort: Vec::new(),\n        cur_stack: Vec::new(),\n        cycle: Vec::new(),\n        node_states: init_node_states(\n            graph.edges.len() as usize,\n            Tracked(instance.clone()),\n            Tracked(unv),\n        ),\n        top_sort_token: Tracked(top_sort_token),\n        instance: Tracked(instance),\n    };\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> = TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==>\n                (dfs_state.node_states@.index(i as int).in_stack == dfs_state.cur_stack@.contains(i)));\n    }\n    let mut v: usize = 0;\n    while v < graph.edges.len() as usize\n        invariant\n            graph.well_formed(),\n            dfs_state.well_formed(graph),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|w| 0 <= w && (w as int) < (v as int) ==> map_visited_deps.contains(w),\n            dfs_state.cur_stack@.len() == 0,\n    {\n        let (b, Tracked(opt_visited)) = visit(graph, &mut dfs_state, v);\n        if !b {\n            return TopSortResult::Cycle(dfs_state.cycle);\n        }\n        proof {\n            map_visited_deps.insert(opt_visited.tracked_unwrap());\n        }\n        v = v + 1;\n    }\n    let DfsState { top_sort, top_sort_token: Tracked(top_sort_token), .. } = dfs_state;\n    proof {\n        let ghost s = Set::new(|i: usize| 0 <= i && i < graph.edges@.len());\n        dfs_state.instance.borrow().done(s, &map_visited_deps, &top_sort_token);\n        assert forall|i: usize| 0 <= i && i < graph.edges@.len() implies top_sort@.contains(i) by {\n            assert(s.contains(i));\n        }\n        assert(is_complete_top_sort(&top_sort, graph));\n    }\n    TopSortResult::TopSort(top_sort)\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::slice::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n#[verifier::reject_recursive_types(V)]\npub struct DirectedGraph<V> {\n    pub edges: Set<(V, V)>,\n}\n\nimpl<V> DirectedGraph<V> {\n    pub open spec fn dest_set(&self, v: V) -> Set<V> {\n        Set::new(|w: V| self.edges.contains((v, w)))\n    }\n\n    pub open spec fn is_sorted(&self, s: Seq<V>) -> bool {\n        forall|i, j: int| 0 <= i <= j < s.len() ==> !self.edges.contains((s.index(i), s.index(j)))\n    }\n\n    pub open spec fn is_cycle_i(&self, s: Seq<V>, i: int) -> bool {\n        self.edges.contains((s[i], s[i + 1]))\n    }\n\n    pub open spec fn is_cycle(&self, s: Seq<V>) -> bool {\n        s.len() > 0 && (forall|i: int| 0 <= i < s.len() - 1 ==> self.is_cycle_i(s, i))\n            && self.edges.contains((s.last(), s[0]))\n    }\n}\n\ntokenized_state_machine!{\n    #[verifier::reject_recursive_types(V)]\n    TopSort<V> {\n        fields {\n            #[sharding(constant)]\n            pub graph: DirectedGraph<V>,\n\n            #[sharding(set)]\n            pub unvisited: Set<V>,\n\n            #[sharding(persistent_set)]\n            pub visited: Set<V>,\n\n            #[sharding(variable)]\n            pub top_sort: Seq<V>,\n        }\n\n        init!{\n            initialize(graph: DirectedGraph<V>) {\n                init graph = graph;\n                init unvisited = Set::full();\n                init visited = Set::empty();\n                init top_sort = Seq::empty();\n            }\n        }\n\n        transition!{\n            push_into_top_sort(v: V) {\n                have visited >= (pre.graph.dest_set(v));\n\n                remove unvisited -= set { v };\n                add visited (union)= set { v };\n\n                update top_sort = pre.top_sort.push(v);\n            }\n        }\n\n        property!{\n            done(s: Set<V>) {\n                have visited >= (s);\n                assert(forall |i| s.contains(i) ==> pre.top_sort.contains(i));\n                assert(pre.graph.is_sorted(pre.top_sort));\n            }\n        }\n\n        #[invariant]\n        pub fn un_vis(&self) -> bool {\n            self.unvisited === self.visited.complement()\n        }\n\n        #[invariant]\n        pub fn top_sort_is_sort(&self) -> bool {\n            self.graph.is_sorted(self.top_sort)\n        }\n\n        #[invariant]\n        pub fn visited_closed_under_dep(&self) -> bool {\n            forall |v, w| #[trigger] self.graph.edges.contains((v, w)) ==>\n                self.visited.contains(v) ==>\n                self.visited.contains(w)\n        }\n\n        #[invariant]\n        pub fn top_sort_matches_visited(&self) -> bool {\n            forall |v| #[trigger] self.visited.contains(v) <==>\n                self.top_sort.contains(v)\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, graph: DirectedGraph<V>) { }\n\n        #[inductive(push_into_top_sort)]\n        fn push_into_top_sort_inductive(pre: Self, post: Self, v: V) {\n            assert_sets_equal!(post.unvisited, post.visited.complement());\n\n            assert forall |a| #[trigger] post.visited.contains(a) implies\n                post.top_sort.contains(a)\n            by {\n                if a === v {\n                    assert(post.top_sort.last() === a);\n                    assert(post.top_sort.contains(a));\n                } else {\n                    assert(pre.visited.contains(a));\n                    assert(pre.top_sort.contains(a));\n                    let i = choose |i| 0 <= i < pre.top_sort.len() && pre.top_sort.index(i) === a;\n                    assert(post.top_sort.index(i) === a);\n                    assert(post.top_sort.contains(a));\n                }\n            }\n\n            assert forall |v| #[trigger] post.top_sort.contains(v) implies\n                post.visited.contains(v)\n            by {\n            }\n        }\n\n    }\n}\n\nstruct ConcreteDirectedGraph {\n    edges: Vec<Vec<usize>>,\n}\n\nimpl ConcreteDirectedGraph {\n    spec fn well_formed(&self) -> bool {\n        forall|i, j|\n            0 <= i < self.edges@.len() && 0 <= j < self.edges@.index(i)@.len() ==> 0 <= (\n            #[trigger] self.edges@.index(i)@.index(j)) < self.edges@.len()\n    }\n\n    spec fn view(&self) -> DirectedGraph<usize> {\n        DirectedGraph {\n            edges: Set::<(usize, usize)>::new(\n                |p: (usize, usize)|\n                    0 <= (p.0 as int) < (self.edges@.len() as int) && self.edges@.index(\n                        p.0 as int,\n                    )@.contains(p.1),\n            ),\n        }\n    }\n}\n\nenum NodeToken {\n    Unvisited(TopSort::unvisited<usize>),\n    InProgress,\n    Visited(TopSort::visited<usize>),\n}\n\nstruct NodeState {\n    visited: bool,\n    in_stack: bool,\n    token: Tracked<NodeToken>,\n}\n\nimpl NodeState {\n    spec fn well_formed(&self, i: int, inst: TopSort::Instance<usize>) -> bool {\n        match self.token@ {\n            NodeToken::Unvisited(token) => {\n                &&& !self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n            NodeToken::InProgress => {\n                &&& self.visited\n                &&& self.in_stack\n            },\n            NodeToken::Visited(token) => {\n                &&& self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n        }\n    }\n}\n\nstruct DfsState {\n    top_sort: Vec<usize>,\n    cur_stack: Vec<usize>,\n    cycle: Vec<usize>,\n    node_states: Vec<NodeState>,\n    top_sort_token: Tracked<TopSort::top_sort<usize>>,\n    instance: Tracked<TopSort::Instance<usize>>,\n}\n\nspec fn valid_stack_i(cur_stack: Seq<usize>, graph: DirectedGraph<usize>, i: int) -> bool {\n    graph.edges.contains((cur_stack[i], cur_stack[i + 1]))\n}\n\nspec fn valid_stack(cur_stack: Seq<usize>, graph: DirectedGraph<usize>) -> bool {\n    forall|i: int| 0 <= i < cur_stack.len() as int - 1 ==> valid_stack_i(cur_stack, graph, i)\n}\n\nimpl DfsState {\n    spec fn well_formed(&self, graph: &ConcreteDirectedGraph) -> bool {\n        &&& graph.well_formed()\n        &&& self.node_states@.len() == graph.edges@.len()\n        &&& forall|i|\n            0 <= i < self.node_states@.len() ==> self.node_states@[i].well_formed(i, self.instance@)\n        &&& self.top_sort_token@.instance_id() === self.instance@.id()\n        &&& self.top_sort_token@.value() === self.top_sort@\n        &&& self.instance@.graph() === graph@\n        &&& valid_stack(self.cur_stack@, graph@)\n        &&& forall|i: usize|\n            0 <= i < self.node_states@.len() ==> (self.node_states@[i as int].in_stack\n                <==> self.cur_stack@.contains(i))\n    }\n}\n\nspec fn is_complete_top_sort(top_sort: &Vec<usize>, graph: &ConcreteDirectedGraph) -> bool {\n    graph@.is_sorted(top_sort@) && forall|i: usize|\n        0 <= i < graph.edges@.len() ==> top_sort@.contains(i)\n}\n\nfn vec_find(v: &Vec<usize>, needle: usize) -> (idx: usize)\n    requires\n        v@.contains(needle),\n    ensures\n        0 <= idx < v@.len() && v@[idx as int] == needle,\n{\n    let mut idx = 0;\n    loop\n        invariant\n            v@.contains(needle),\n            0 <= idx < v@.len(),\n            forall|j| 0 <= j < idx ==> v@[j] != needle,\n    {\n        if v[idx] == needle {\n            return idx;\n        }\n        assert(idx + 1 < v.len());\n        idx = idx + 1;\n    }\n}\n\nfn find_cycle(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize)\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n        old(dfs_state).node_states@.index(v as int).in_stack,\n    ensures\n        graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let j = vec_find(&dfs_state.cur_stack, v);\n    let len = dfs_state.cur_stack.len();\n    let tmp1 = dfs_state.cur_stack.as_slice();\n    let tmp2 = slice_subrange(tmp1, j, len);\n    let cycle = slice_to_vec(tmp2);\n    dfs_state.cycle = cycle;\n    assert(tmp1@.len() == dfs_state.cur_stack.len());\n    assert(tmp2@.len() + j == len);\n    assert(tmp2@ == cycle@);\n    assert(cycle.len() + j == len);\n    assert(j + dfs_state.cycle@.len() == len);\n    assert(graph@.is_cycle(dfs_state.cycle@)) by {\n        assert forall|i: int| 0 <= i < dfs_state.cycle@.len() - 1 implies graph@.is_cycle_i(\n            dfs_state.cycle@,\n            i,\n        ) by {\n            assert(valid_stack_i(dfs_state.cur_stack@, graph@, i + j));  // trigger\n        }\n    };\n}\n\nfn visit(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize) -> (res: (\n    bool,\n    Tracked<Option<TopSort::visited<usize>>>,\n))\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n    ensures\n        res.0 ==> dfs_state.well_formed(graph),\n        res.0 ==> equal(dfs_state.cur_stack@, old(dfs_state).cur_stack@),\n        res.0 ==> res.1@ is Some && res.1@->0.instance_id() == dfs_state.instance@.id()\n            && res.1@->0.element() == v,\n        !res.0 ==> graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let node_state = &dfs_state.node_states[v as usize];\n    if node_state.in_stack {\n        find_cycle(graph, dfs_state, v);\n        return (false, Tracked(None));\n    }\n    if node_state.visited {\n        let tracked tok = match node_state.token.borrow() {\n            NodeToken::Visited(tok) => tok.clone(),\n            _ => proof_from_false(),\n        };\n        return (true, Tracked(Some(tok)));\n    }\n    let mut node_state_tmp = NodeState {\n        in_stack: true,\n        visited: true,\n        token: Tracked(NodeToken::InProgress),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    let tracked unvisited = match node_state_tmp.token.get() {\n        NodeToken::Unvisited(unvisited) => unvisited,\n        _ => proof_from_false(),\n    };\n    dfs_state.cur_stack.push(v);\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: int|\n            0 <= i && i < dfs_state.cur_stack@.len() as int - 2 ==> valid_stack_i(\n                old(dfs_state).cur_stack@,\n                graph@,\n                i,\n            ) ==> #[trigger] valid_stack_i(dfs_state.cur_stack@, graph@, i));\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assert forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() implies dfs_state.node_states@.index(\n            i as int,\n        ).in_stack == dfs_state.cur_stack@.contains(i) by {\n            if i == v {\n                assert(dfs_state.cur_stack@.last() == i);\n                assert(dfs_state.cur_stack@.contains(i));\n            } else {\n                if old(dfs_state).cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(dfs_state.cur_stack@.index(j) == i);\n                }\n                if dfs_state.cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(old(dfs_state).cur_stack@.index(j) == i);\n                }\n                assert(dfs_state.cur_stack@.contains(i) == old(dfs_state).cur_stack@.contains(i));\n            }\n        }\n    }\n    let ghost extended_cur_stack = dfs_state.cur_stack;\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> =\n        TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    let mut idx: usize = 0;\n    while idx < graph.edges[v as usize].len()\n        invariant\n            equal(dfs_state.instance, old(dfs_state).instance),\n            dfs_state.cur_stack@.len() > 0,\n            dfs_state.cur_stack@.last() == v,\n            0 <= v && v < graph.edges@.len(),\n            0 <= idx && idx <= graph.edges@.index(v as int)@.len(),\n            dfs_state.well_formed(graph),\n            equal(dfs_state.cur_stack@, extended_cur_stack@),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|idx0: int|\n                0 <= idx0 && idx0 < idx ==> {\n                    let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n                    map_visited_deps.contains(w)\n                },\n    {\n        let w = graph.edges[v as usize][idx];\n        assert((v as usize) as int == v as int);\n        assert(graph.edges@.index(v as int)@.index(idx as int) == w);\n        assert(graph.edges@.index(v as int)@.contains(w));\n        assert(graph@.edges.contains((v, w)));\n        let (b, Tracked(opt_visited)) = visit(graph, dfs_state, w);\n        if !b {\n            return (false, Tracked(None));\n        }\n        let ghost old_map_visited_deps = map_visited_deps;\n        let ghost old_idx = idx;\n        proof {\n            let tracked visited = opt_visited.tracked_unwrap();\n            map_visited_deps.insert(visited);\n        }\n        idx = idx + 1;\n        assert forall|idx0: int| 0 <= idx0 && idx0 < idx implies ({\n            let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n            map_visited_deps.contains(w)\n        }) by {\n            assume(false);\n        }\n    }\n    dfs_state.cur_stack.pop();\n    assert(equal(unvisited.instance_id(), dfs_state.instance@.id()));\n    let tracked visited = dfs_state.instance.borrow().push_into_top_sort(\n        v,\n        unvisited,\n        &map_visited_deps,\n        dfs_state.top_sort_token.borrow_mut(),\n    );\n    dfs_state.top_sort.push(v);\n    let mut node_state_tmp = NodeState {\n        in_stack: false,  // TODO don't need to write this field again\n        visited: true,\n        token: Tracked(NodeToken::Visited(visited.clone())),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    proof {\n        assert_seqs_equal!(\n            dfs_state.cur_stack@,\n            old(dfs_state).cur_stack@);\n    }\n    assert(dfs_state.well_formed(graph)) by {\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assume(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==> (dfs_state.node_states@.index(\n                i as int,\n            ).in_stack == dfs_state.cur_stack@.contains(i)));\n    };\n    (true, Tracked(Some(visited)))\n}\n\nfn init_node_states(\n    n: usize,\n    Tracked(instance): Tracked<TopSort::Instance<usize>>,\n    Tracked(unv): Tracked<TopSort::unvisited_set<usize>>,\n) -> (node_states: Vec<NodeState>)\n    requires\n        forall|j: usize| 0 <= j && j < n ==> unv.contains(j),\n        unv.instance_id() == instance.id(),\n    ensures\n        node_states@.len() == n as int,\n        forall|j: int|\n            0 <= j && j < node_states@.len() ==> node_states@.index(j).well_formed(j, instance),\n        forall|j: int| 0 <= j && j < node_states@.len() ==> !node_states@.index(j).in_stack,\n{\n    let mut node_states = Vec::<NodeState>::new();\n    let mut i: usize = 0;\n    let tracked mut unv = unv;\n    while i < n\n        invariant\n            0 <= i && i <= n,\n            node_states@.len() == i as int,\n            forall|j: int| 0 <= j && j < i ==> node_states@.index(j).well_formed(j, instance),\n            forall|j: int| 0 <= j && j < i ==> !node_states@.index(j).in_stack,\n            forall|j: usize| i <= j && j < n ==> #[trigger] unv.contains(j),\n            unv.instance_id() == instance.id(),\n    {\n        assert(unv.contains(i));\n        let tracked unv1 = unv.remove(i);\n        node_states.push(\n            NodeState {\n                visited: false,\n                in_stack: false,\n                token: Tracked(NodeToken::Unvisited(unv1)),\n            },\n        );\n        i = i + 1;\n        /*let ghost i_spec = i;\n        assert_forall_by(|j: int| {\n            requires(0 <= j && j < i);\n            ensures(node_states@.index(j).well_formed(j, instance));\n\n            if j + 1 < i_spec {\n                assert(old_node_states@.index(j).well_formed(j, instance));\n            } else {\n                assert(node_states@.index(j).well_formed(j, instance));\n            }\n        });*/\n    }\n    node_states\n}\n\nenum TopSortResult {\n    TopSort(Vec<usize>),\n    Cycle(Vec<usize>),\n}\n\nfn compute_top_sort(graph: &ConcreteDirectedGraph) -> (tsr: TopSortResult)\n    requires\n        graph.well_formed(),\n    ensures\n        (match tsr {\n            TopSortResult::TopSort(top_sort) => is_complete_top_sort(&top_sort, graph),\n            TopSortResult::Cycle(cycle) => graph@.is_cycle(cycle@),\n        }),\n{\n    let tracked (Tracked(instance), Tracked(unv), _, Tracked(top_sort_token)) =\n        TopSort::Instance::<usize>::initialize(graph@);\n    let mut dfs_state = DfsState {\n        top_sort: Vec::new(),\n        cur_stack: Vec::new(),\n        cycle: Vec::new(),\n        node_states: init_node_states(\n            graph.edges.len() as usize,\n            Tracked(instance.clone()),\n            Tracked(unv),\n        ),\n        top_sort_token: Tracked(top_sort_token),\n        instance: Tracked(instance),\n    };\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> = TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==>\n                (dfs_state.node_states@.index(i as int).in_stack == dfs_state.cur_stack@.contains(i)));\n    }\n    let mut v: usize = 0;\n    while v < graph.edges.len() as usize\n        invariant\n            graph.well_formed(),\n            dfs_state.well_formed(graph),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|w| 0 <= w && (w as int) < (v as int) ==> map_visited_deps.contains(w),\n            dfs_state.cur_stack@.len() == 0,\n    {\n        let (b, Tracked(opt_visited)) = visit(graph, &mut dfs_state, v);\n        if !b {\n            return TopSortResult::Cycle(dfs_state.cycle);\n        }\n        proof {\n            map_visited_deps.insert(opt_visited.tracked_unwrap());\n        }\n        v = v + 1;\n    }\n    let DfsState { top_sort, top_sort_token: Tracked(top_sort_token), .. } = dfs_state;\n    proof {\n        let ghost s = Set::new(|i: usize| 0 <= i && i < graph.edges@.len());\n        dfs_state.instance.borrow().done(s, &map_visited_deps, &top_sort_token);\n        assert forall|i: usize| 0 <= i && i < graph.edges@.len() implies top_sort@.contains(i) by {\n            assert(s.contains(i));\n        }\n        assert(is_complete_top_sort(&top_sort, graph));\n    }\n    TopSortResult::TopSort(top_sort)\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::slice::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n#[verifier::reject_recursive_types(V)]\npub struct DirectedGraph<V> {\n    pub edges: Set<(V, V)>,\n}\n\nimpl<V> DirectedGraph<V> {\n    pub open spec fn dest_set(&self, v: V) -> Set<V> {\n        Set::new(|w: V| self.edges.contains((v, w)))\n    }\n\n    pub open spec fn is_sorted(&self, s: Seq<V>) -> bool {\n        forall|i, j: int| 0 <= i <= j < s.len() ==> !self.edges.contains((s.index(i), s.index(j)))\n    }\n\n    pub open spec fn is_cycle_i(&self, s: Seq<V>, i: int) -> bool {\n        self.edges.contains((s[i], s[i + 1]))\n    }\n\n    pub open spec fn is_cycle(&self, s: Seq<V>) -> bool {\n        s.len() > 0 && (forall|i: int| 0 <= i < s.len() - 1 ==> self.is_cycle_i(s, i))\n            && self.edges.contains((s.last(), s[0]))\n    }\n}\n\ntokenized_state_machine!{\n    #[verifier::reject_recursive_types(V)]\n    TopSort<V> {\n        fields {\n            #[sharding(constant)]\n            pub graph: DirectedGraph<V>,\n\n            #[sharding(set)]\n            pub unvisited: Set<V>,\n\n            #[sharding(persistent_set)]\n            pub visited: Set<V>,\n\n            #[sharding(variable)]\n            pub top_sort: Seq<V>,\n        }\n\n        init!{\n            initialize(graph: DirectedGraph<V>) {\n                init graph = graph;\n                init unvisited = Set::full();\n                init visited = Set::empty();\n                init top_sort = Seq::empty();\n            }\n        }\n\n        transition!{\n            push_into_top_sort(v: V) {\n                have visited >= (pre.graph.dest_set(v));\n\n                remove unvisited -= set { v };\n                add visited (union)= set { v };\n\n                update top_sort = pre.top_sort.push(v);\n            }\n        }\n\n        property!{\n            done(s: Set<V>) {\n                have visited >= (s);\n                assert(forall |i| s.contains(i) ==> pre.top_sort.contains(i));\n                assert(pre.graph.is_sorted(pre.top_sort));\n            }\n        }\n\n        #[invariant]\n        pub fn un_vis(&self) -> bool {\n            self.unvisited === self.visited.complement()\n        }\n\n        #[invariant]\n        pub fn top_sort_is_sort(&self) -> bool {\n            self.graph.is_sorted(self.top_sort)\n        }\n\n        #[invariant]\n        pub fn visited_closed_under_dep(&self) -> bool {\n            forall |v, w| #[trigger] self.graph.edges.contains((v, w)) ==>\n                self.visited.contains(v) ==>\n                self.visited.contains(w)\n        }\n\n        #[invariant]\n        pub fn top_sort_matches_visited(&self) -> bool {\n            forall |v| #[trigger] self.visited.contains(v) <==>\n                self.top_sort.contains(v)\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, graph: DirectedGraph<V>) { }\n\n        #[inductive(push_into_top_sort)]\n        fn push_into_top_sort_inductive(pre: Self, post: Self, v: V) {\n            assert_sets_equal!(post.unvisited, post.visited.complement());\n\n            assert forall |a| #[trigger] post.visited.contains(a) implies\n                post.top_sort.contains(a)\n            by {\n                if a === v {\n                    assert(post.top_sort.last() === a);\n                    assert(post.top_sort.contains(a));\n                } else {\n                    assert(pre.visited.contains(a));\n                    assert(pre.top_sort.contains(a));\n                    let i = choose |i| 0 <= i < pre.top_sort.len() && pre.top_sort.index(i) === a;\n                    assert(post.top_sort.index(i) === a);\n                    assert(post.top_sort.contains(a));\n                }\n            }\n\n            assert forall |v| #[trigger] post.top_sort.contains(v) implies\n                post.visited.contains(v)\n            by {\n            }\n        }\n\n    }\n}\n\nstruct ConcreteDirectedGraph {\n    edges: Vec<Vec<usize>>,\n}\n\nimpl ConcreteDirectedGraph {\n    spec fn well_formed(&self) -> bool {\n        forall|i, j|\n            0 <= i < self.edges@.len() && 0 <= j < self.edges@.index(i)@.len() ==> 0 <= (\n            #[trigger] self.edges@.index(i)@.index(j)) < self.edges@.len()\n    }\n\n    spec fn view(&self) -> DirectedGraph<usize> {\n        DirectedGraph {\n            edges: Set::<(usize, usize)>::new(\n                |p: (usize, usize)|\n                    0 <= (p.0 as int) < (self.edges@.len() as int) && self.edges@.index(\n                        p.0 as int,\n                    )@.contains(p.1),\n            ),\n        }\n    }\n}\n\nenum NodeToken {\n    Unvisited(TopSort::unvisited<usize>),\n    InProgress,\n    Visited(TopSort::visited<usize>),\n}\n\nstruct NodeState {\n    visited: bool,\n    in_stack: bool,\n    token: Tracked<NodeToken>,\n}\n\nimpl NodeState {\n    spec fn well_formed(&self, i: int, inst: TopSort::Instance<usize>) -> bool {\n        match self.token@ {\n            NodeToken::Unvisited(token) => {\n                &&& !self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n            NodeToken::InProgress => {\n                &&& self.visited\n                &&& self.in_stack\n            },\n            NodeToken::Visited(token) => {\n                &&& self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n        }\n    }\n}\n\nstruct DfsState {\n    top_sort: Vec<usize>,\n    cur_stack: Vec<usize>,\n    cycle: Vec<usize>,\n    node_states: Vec<NodeState>,\n    top_sort_token: Tracked<TopSort::top_sort<usize>>,\n    instance: Tracked<TopSort::Instance<usize>>,\n}\n\nspec fn valid_stack_i(cur_stack: Seq<usize>, graph: DirectedGraph<usize>, i: int) -> bool {\n    graph.edges.contains((cur_stack[i], cur_stack[i + 1]))\n}\n\nspec fn valid_stack(cur_stack: Seq<usize>, graph: DirectedGraph<usize>) -> bool {\n    forall|i: int| 0 <= i < cur_stack.len() as int - 1 ==> valid_stack_i(cur_stack, graph, i)\n}\n\nimpl DfsState {\n    spec fn well_formed(&self, graph: &ConcreteDirectedGraph) -> bool {\n        &&& graph.well_formed()\n        &&& self.node_states@.len() == graph.edges@.len()\n        &&& forall|i|\n            0 <= i < self.node_states@.len() ==> self.node_states@[i].well_formed(i, self.instance@)\n        &&& self.top_sort_token@.instance_id() === self.instance@.id()\n        &&& self.top_sort_token@.value() === self.top_sort@\n        &&& self.instance@.graph() === graph@\n        &&& valid_stack(self.cur_stack@, graph@)\n        &&& forall|i: usize|\n            0 <= i < self.node_states@.len() ==> (self.node_states@[i as int].in_stack\n                <==> self.cur_stack@.contains(i))\n    }\n}\n\nspec fn is_complete_top_sort(top_sort: &Vec<usize>, graph: &ConcreteDirectedGraph) -> bool {\n    graph@.is_sorted(top_sort@) && forall|i: usize|\n        0 <= i < graph.edges@.len() ==> top_sort@.contains(i)\n}\n\nfn vec_find(v: &Vec<usize>, needle: usize) -> (idx: usize)\n    requires\n        v@.contains(needle),\n    ensures\n        0 <= idx < v@.len() && v@[idx as int] == needle,\n{\n    let mut idx = 0;\n    loop\n        invariant\n            v@.contains(needle),\n            0 <= idx < v@.len(),\n            forall|j| 0 <= j < idx ==> v@[j] != needle,\n    {\n        if v[idx] == needle {\n            return idx;\n        }\n        assert(idx + 1 < v.len());\n        idx = idx + 1;\n    }\n}\n\nfn find_cycle(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize)\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n        old(dfs_state).node_states@.index(v as int).in_stack,\n    ensures\n        graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let j = vec_find(&dfs_state.cur_stack, v);\n    let len = dfs_state.cur_stack.len();\n    let tmp1 = dfs_state.cur_stack.as_slice();\n    let tmp2 = slice_subrange(tmp1, j, len);\n    let cycle = slice_to_vec(tmp2);\n    dfs_state.cycle = cycle;\n    assert(tmp1@.len() == dfs_state.cur_stack.len());\n    assert(tmp2@.len() + j == len);\n    assert(tmp2@ == cycle@);\n    assert(cycle.len() + j == len);\n    assert(j + dfs_state.cycle@.len() == len);\n    assert(graph@.is_cycle(dfs_state.cycle@)) by {\n        assert forall|i: int| 0 <= i < dfs_state.cycle@.len() - 1 implies graph@.is_cycle_i(\n            dfs_state.cycle@,\n            i,\n        ) by {\n            assert(valid_stack_i(dfs_state.cur_stack@, graph@, i + j));  // trigger\n        }\n    };\n}\n\nfn visit(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize) -> (res: (\n    bool,\n    Tracked<Option<TopSort::visited<usize>>>,\n))\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n    ensures\n        res.0 ==> dfs_state.well_formed(graph),\n        res.0 ==> equal(dfs_state.cur_stack@, old(dfs_state).cur_stack@),\n        res.0 ==> res.1@ is Some && res.1@->0.instance_id() == dfs_state.instance@.id()\n            && res.1@->0.element() == v,\n        !res.0 ==> graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let node_state = &dfs_state.node_states[v as usize];\n    if node_state.in_stack {\n        find_cycle(graph, dfs_state, v);\n        return (false, Tracked(None));\n    }\n    if node_state.visited {\n        let tracked tok = match node_state.token.borrow() {\n            NodeToken::Visited(tok) => tok.clone(),\n            _ => proof_from_false(),\n        };\n        return (true, Tracked(Some(tok)));\n    }\n    let mut node_state_tmp = NodeState {\n        in_stack: true,\n        visited: true,\n        token: Tracked(NodeToken::InProgress),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    let tracked unvisited = match node_state_tmp.token.get() {\n        NodeToken::Unvisited(unvisited) => unvisited,\n        _ => proof_from_false(),\n    };\n    dfs_state.cur_stack.push(v);\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: int|\n            0 <= i && i < dfs_state.cur_stack@.len() as int - 2 ==> valid_stack_i(\n                old(dfs_state).cur_stack@,\n                graph@,\n                i,\n            ) ==> #[trigger] valid_stack_i(dfs_state.cur_stack@, graph@, i));\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assert forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() implies dfs_state.node_states@.index(\n            i as int,\n        ).in_stack == dfs_state.cur_stack@.contains(i) by {\n            if i == v {\n                assert(dfs_state.cur_stack@.last() == i);\n                assert(dfs_state.cur_stack@.contains(i));\n            } else {\n                if old(dfs_state).cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(dfs_state.cur_stack@.index(j) == i);\n                }\n                if dfs_state.cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(old(dfs_state).cur_stack@.index(j) == i);\n                }\n                assert(dfs_state.cur_stack@.contains(i) == old(dfs_state).cur_stack@.contains(i));\n            }\n        }\n    }\n    let ghost extended_cur_stack = dfs_state.cur_stack;\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> =\n        TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    let mut idx: usize = 0;\n    while idx < graph.edges[v as usize].len()\n        invariant\n            equal(dfs_state.instance, old(dfs_state).instance),\n            dfs_state.cur_stack@.len() > 0,\n            dfs_state.cur_stack@.last() == v,\n            0 <= v && v < graph.edges@.len(),\n            0 <= idx && idx <= graph.edges@.index(v as int)@.len(),\n            dfs_state.well_formed(graph),\n            equal(dfs_state.cur_stack@, extended_cur_stack@),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|idx0: int|\n                0 <= idx0 && idx0 < idx ==> {\n                    let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n                    map_visited_deps.contains(w)\n                },\n    {\n        let w = graph.edges[v as usize][idx];\n        assert((v as usize) as int == v as int);\n        assert(graph.edges@.index(v as int)@.index(idx as int) == w);\n        assert(graph.edges@.index(v as int)@.contains(w));\n        assert(graph@.edges.contains((v, w)));\n        let (b, Tracked(opt_visited)) = visit(graph, dfs_state, w);\n        if !b {\n            return (false, Tracked(None));\n        }\n        let ghost old_map_visited_deps = map_visited_deps;\n        let ghost old_idx = idx;\n        proof {\n            let tracked visited = opt_visited.tracked_unwrap();\n            map_visited_deps.insert(visited);\n        }\n        idx = idx + 1;\n        assert forall|idx0: int| 0 <= idx0 && idx0 < idx implies ({\n            let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n            map_visited_deps.contains(w)\n        }) by {\n            assume(false);\n        }\n    }\n    dfs_state.cur_stack.pop();\n    assert(equal(unvisited.instance_id(), dfs_state.instance@.id()));\n    let tracked visited = dfs_state.instance.borrow().push_into_top_sort(\n        v,\n        unvisited,\n        &map_visited_deps,\n        dfs_state.top_sort_token.borrow_mut(),\n    );\n    dfs_state.top_sort.push(v);\n    let mut node_state_tmp = NodeState {\n        in_stack: false,  // TODO don't need to write this field again\n        visited: true,\n        token: Tracked(NodeToken::Visited(visited.clone())),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    proof {\n        assert_seqs_equal!(\n            dfs_state.cur_stack@,\n            old(dfs_state).cur_stack@);\n    }\n    assert(dfs_state.well_formed(graph)) by {\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assume(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==> (dfs_state.node_states@.index(\n                i as int,\n            ).in_stack == dfs_state.cur_stack@.contains(i)));\n    };\n    (true, Tracked(Some(visited)))\n}\n\nfn init_node_states(\n    n: usize,\n    Tracked(instance): Tracked<TopSort::Instance<usize>>,\n    Tracked(unv): Tracked<TopSort::unvisited_set<usize>>,\n) -> (node_states: Vec<NodeState>)\n    requires\n        forall|j: usize| 0 <= j && j < n ==> unv.contains(j),\n        unv.instance_id() == instance.id(),\n    ensures\n        node_states@.len() == n as int,\n        forall|j: int|\n            0 <= j && j < node_states@.len() ==> node_states@.index(j).well_formed(j, instance),\n        forall|j: int| 0 <= j && j < node_states@.len() ==> !node_states@.index(j).in_stack,\n{\n    let mut node_states = Vec::<NodeState>::new();\n    let mut i: usize = 0;\n    let tracked mut unv = unv;\n    while i < n\n        invariant\n            0 <= i && i <= n,\n            node_states@.len() == i as int,\n            forall|j: int| 0 <= j && j < i ==> node_states@.index(j).well_formed(j, instance),\n            forall|j: int| 0 <= j && j < i ==> !node_states@.index(j).in_stack,\n            forall|j: usize| i <= j && j < n ==> #[trigger] unv.contains(j),\n            unv.instance_id() == instance.id(),\n    {\n        assert(unv.contains(i));\n        let tracked unv1 = unv.remove(i);\n        node_states.push(\n            NodeState {\n                visited: false,\n                in_stack: false,\n                token: Tracked(NodeToken::Unvisited(unv1)),\n            },\n        );\n        i = i + 1;\n        /*let ghost i_spec = i;\n        assert_forall_by(|j: int| {\n            requires(0 <= j && j < i);\n            ensures(node_states@.index(j).well_formed(j, instance));\n\n            if j + 1 < i_spec {\n                assert(old_node_states@.index(j).well_formed(j, instance));\n            } else {\n                assert(node_states@.index(j).well_formed(j, instance));\n            }\n        });*/\n    }\n    node_states\n}\n\nenum TopSortResult {\n    TopSort(Vec<usize>),\n    Cycle(Vec<usize>),\n}\n\nfn compute_top_sort(graph: &ConcreteDirectedGraph) -> (tsr: TopSortResult)\n    requires\n        graph.well_formed(),\n    ensures\n        (match tsr {\n            TopSortResult::TopSort(top_sort) => is_complete_top_sort(&top_sort, graph),\n            TopSortResult::Cycle(cycle) => graph@.is_cycle(cycle@),\n        }),\n{\n    let tracked (Tracked(instance), Tracked(unv), _, Tracked(top_sort_token)) =\n        TopSort::Instance::<usize>::initialize(graph@);\n    let mut dfs_state = DfsState {\n        top_sort: Vec::new(),\n        cur_stack: Vec::new(),\n        cycle: Vec::new(),\n        node_states: init_node_states(\n            graph.edges.len() as usize,\n            Tracked(instance.clone()),\n            Tracked(unv),\n        ),\n        top_sort_token: Tracked(top_sort_token),\n        instance: Tracked(instance),\n    };\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> = TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==>\n                (dfs_state.node_states@.index(i as int).in_stack == dfs_state.cur_stack@.contains(i)));\n    }\n    let mut v: usize = 0;\n    while v < graph.edges.len() as usize\n        invariant\n            graph.well_formed(),\n            dfs_state.well_formed(graph),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|w| 0 <= w && (w as int) < (v as int) ==> map_visited_deps.contains(w),\n            dfs_state.cur_stack@.len() == 0,\n    {\n        let (b, Tracked(opt_visited)) = visit(graph, &mut dfs_state, v);\n        if !b {\n            return TopSortResult::Cycle(dfs_state.cycle);\n        }\n        proof {\n            map_visited_deps.insert(opt_visited.tracked_unwrap());\n        }\n        v = v + 1;\n    }\n    let DfsState { top_sort, top_sort_token: Tracked(top_sort_token), .. } = dfs_state;\n    proof {\n        let ghost s = Set::new(|i: usize| 0 <= i && i < graph.edges@.len());\n        dfs_state.instance.borrow().done(s, &map_visited_deps, &top_sort_token);\n        assert forall|i: usize| 0 <= i && i < graph.edges@.len() implies top_sort@.contains(i) by {\n            assert(s.contains(i));\n        }\n        assert(is_complete_top_sort(&top_sort, graph));\n    }\n    TopSortResult::TopSort(top_sort)\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/top_sort_dfs.rs", "verified": true, "metadata": {"original_id": "verus_top_sort_dfs_ea18631d9b04", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_ab1f796fda73", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_bounded(lo: int, hi: int, n: int)\n    requires choose_int_outputs(lo, hi).contains(n)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_bounded(lo: int, hi: int, n: int)\n    requires choose_int_outputs(lo, hi).contains(n)\n    ensures lo <= n && n < hi\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn choose_int_bounded(lo: int, hi: int, n: int)\n    requires choose_int_outputs(lo, hi).contains(n)\n    ensures lo <= n && n < hi\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "ab1f796fda73", "function_name": "choose_int_bounded", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b9cc7f1e51fc", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 ,  { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 , ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 , ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "multilog_inlined.rs", "verified": true, "metadata": {"original_id": "b9cc7f1e51fc", "function_name": "padding_needed", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8f1df1d685c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f1df1d685c7", "function_name": "arithmetic", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_99075a360b25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "99075a360b25", "function_name": "intersection", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_ed70253ccf77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)  ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_product_impl.rs", "verified": true, "metadata": {"original_id": "ed70253ccf77", "function_name": "array_product", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_07a415573335", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "07a415573335", "function_name": "abs_diff", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_b4ae1e7fa402", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b4ae1e7fa402", "function_name": "aux", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_2f8692a729d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 ,  { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2f8692a729d3", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a1ca01cbe16a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a1ca01cbe16a", "function_name": "swap", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_660b19e85469", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn perfect_size<T>(t: Tree<T>)\n    \n    ensures tree_size(t) == pow2(tree_height(t)) - 1\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    reveal_with_fuel(is_perfect, 2);\n    reveal_with_fuel(pow2, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            perfect_size(*left);\n            perfect_size(*right);\n            let h = tree_height(*left);\n            // size = 1 + (2^h - 1) + (2^h - 1) = 2^(h+1) - 1\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn perfect_size<T>(t: Tree<T>)\n    requires is_perfect(t)\n    ensures tree_size(t) == pow2(tree_height(t)) - 1\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    reveal_with_fuel(is_perfect, 2);\n    reveal_with_fuel(pow2, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            perfect_size(*left);\n            perfect_size(*right);\n            let h = tree_height(*left);\n            // size = 1 + (2^h - 1) + (2^h - 1) = 2^(h+1) - 1\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn perfect_size<T>(t: Tree<T>)\n    requires is_perfect(t)\n    ensures tree_size(t) == pow2(tree_height(t)) - 1\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    reveal_with_fuel(is_perfect, 2);\n    reveal_with_fuel(pow2, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            perfect_size(*left);\n            perfect_size(*right);\n            let h = tree_height(*left);\n            // size = 1 + (2^h - 1) + (2^h - 1) = 2^(h+1) - 1\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_size.rs", "verified": true, "metadata": {"original_id": "660b19e85469", "function_name": "perfect_size", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_aef9dfb8e0b7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem ,  { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "aef9dfb8e0b7", "function_name": "last_position", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_6b1cd51a307c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_depth_zero(ty: Ty)\n    \n    ensures ty_depth(ty) == 0\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_depth_zero(ty: Ty)\n    requires is_base_type(ty)\n    ensures ty_depth(ty) == 0\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_depth_zero(ty: Ty)\n    requires is_base_type(ty)\n    ensures ty_depth(ty) == 0\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_type.rs", "verified": true, "metadata": {"original_id": "6b1cd51a307c", "function_name": "base_type_depth_zero", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_32d92380bdf5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof_flatten_contains<T>(nested: Seq<Seq<Set<T>>>, i: int, j: int, x: T)\n    \n    ensures oneof_flatten(nested).contains(x)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof_flatten_contains<T>(nested: Seq<Seq<Set<T>>>, i: int, j: int, x: T)\n    requires\n        0 <= i < nested.len(),\n        0 <= j < nested[i].len(),\n        nested[i][j].contains(x),\n    ensures oneof_flatten(nested).contains(x)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof_flatten_contains<T>(nested: Seq<Seq<Set<T>>>, i: int, j: int, x: T)\n    requires\n        0 <= i < nested.len(),\n        0 <= j < nested[i].len(),\n        nested[i][j].contains(x),\n    ensures oneof_flatten(nested).contains(x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_oneof.rs", "verified": true, "metadata": {"original_id": "32d92380bdf5", "function_name": "oneof_flatten_contains", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_a4f6f843d086", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_removes_key(k: nat, t: Tree)\n    requires is_bst(t)\n    ensures !contains(k, delete(k, t))\n    {\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                delete_removes_key(k, *left);\n            } else if k > key {\n                delete_removes_key(k, *right);\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(!contains(k, delete(k, t)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_removes_key(k: nat, t: Tree)\n    requires is_bst(t)\n    ensures !contains(k, delete(k, t))\n    decreases t\n{\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                delete_removes_key(k, *left);\n            } else if k > key {\n                delete_removes_key(k, *right);\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(!contains(k, delete(k, t)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_removes_key(k: nat, t: Tree)\n    requires is_bst(t)\n    ensures !contains(k, delete(k, t))\n    decreases t\n{\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                delete_removes_key(k, *left);\n            } else if k > key {\n                delete_removes_key(k, *right);\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(!contains(k, delete(k, t)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_delete.rs", "verified": true, "metadata": {"original_id": "a4f6f843d086", "function_name": "delete_removes_key", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_9eafcf90cf77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9eafcf90cf77", "function_name": "loop_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_87521840ad4f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_associative(d1: Dec, d2: Dec, d3: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_associative(d1: Dec, d2: Dec, d3: Dec)\n    ensures dec_or(dec_or(d1, d2), d3) == dec_or(d1, dec_or(d2, d3))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_associative(d1: Dec, d2: Dec, d3: Dec)\n    ensures dec_or(dec_or(d1, d2), d3) == dec_or(d1, dec_or(d2, d3))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "87521840ad4f", "function_name": "dec_or_associative", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_dae8ee4d4fc0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn option_map_preserves_is_none<T, U>(opt: Option<T>, f: spec_fn(T) -> U)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn option_map_preserves_is_none<T, U>(opt: Option<T>, f: spec_fn(T) -> U)\n    ensures dec_to_bool(dec_is_none(opt)) == dec_to_bool(dec_is_none(option_map(opt, f)))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn option_map_preserves_is_none<T, U>(opt: Option<T>, f: spec_fn(T) -> U)\n    ensures dec_to_bool(dec_is_none(opt)) == dec_to_bool(dec_is_none(option_map(opt, f)))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_option.rs", "verified": true, "metadata": {"original_id": "dae8ee4d4fc0", "function_name": "option_map_preserves_is_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7a561411b753", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms3_impl.rs", "verified": true, "metadata": {"original_id": "7a561411b753", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_78aa65f17712", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == N * (N + 2) , { let result = N * (N + 2) ; sum . set (0 , result) ; assert (sum [0] == result) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= 46340 , N * (N + 2) <= MAX , ensures sum [0] == N * (N + 2) , { let result = N * (N + 2) ; sum . set (0 , result) ; assert (sum [0] == result) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= 46340 , N * (N + 2) <= MAX , ensures sum [0] == N * (N + 2) , { let result = N * (N + 2) ; sum . set (0 , result) ; assert (sum [0] == result) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ss1_impl.rs", "verified": true, "metadata": {"original_id": "78aa65f17712", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_0105236fb665", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn beval(st: State, b: BExp) -> bool\n    {\n    match b {\n        BExp::BTrue => true,\n        BExp::BFalse => false,\n        BExp::BEq { a1, a2 } => aeval(st, a1) == aeval(st, a2),\n        BExp::BLe { a1, a2 } => aeval(st, a1) <= aeval(st, a2),\n        BExp::BNot { b } => !beval(st, *b),\n        BExp::BAnd { b1, b2 } => beval(st, *b1) && beval(st, *b2),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn beval(st: State, b: BExp) -> bool\n    decreases b\n{\n    match b {\n        BExp::BTrue => true,\n        BExp::BFalse => false,\n        BExp::BEq { a1, a2 } => aeval(st, a1) == aeval(st, a2),\n        BExp::BLe { a1, a2 } => aeval(st, a1) <= aeval(st, a2),\n        BExp::BNot { b } => !beval(st, *b),\n        BExp::BAnd { b1, b2 } => beval(st, *b1) && beval(st, *b2),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn beval(st: State, b: BExp) -> bool\n    decreases b\n{\n    match b {\n        BExp::BTrue => true,\n        BExp::BFalse => false,\n        BExp::BEq { a1, a2 } => aeval(st, a1) == aeval(st, a2),\n        BExp::BLe { a1, a2 } => aeval(st, a1) <= aeval(st, a2),\n        BExp::BNot { b } => !beval(st, *b),\n        BExp::BAnd { b1, b2 } => beval(st, *b1) && beval(st, *b2),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "hoare2_verus.rs", "verified": true, "metadata": {"original_id": "0105236fb665", "function_name": "beval", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_27dfc3c0e722", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge(s1: Seq<nat>, s2: Seq<nat>) -> Seq<nat>\n    {\n    if s1.len() == 0 {\n        s2\n    } else if s2.len() == 0 {\n        s1\n    } else if s1[0] <= s2[0] {\n        seq![s1[0]].add(merge(s1.skip(1), s2))\n    } else {\n        seq![s2[0]].add(merge(s1, s2.skip(1)))\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge(s1: Seq<nat>, s2: Seq<nat>) -> Seq<nat>\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 {\n        s2\n    } else if s2.len() == 0 {\n        s1\n    } else if s1[0] <= s2[0] {\n        seq![s1[0]].add(merge(s1.skip(1), s2))\n    } else {\n        seq![s2[0]].add(merge(s1, s2.skip(1)))\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge(s1: Seq<nat>, s2: Seq<nat>) -> Seq<nat>\n    decreases s1.len() + s2.len()\n{\n    if s1.len() == 0 {\n        s2\n    } else if s2.len() == 0 {\n        s1\n    } else if s1[0] <= s2[0] {\n        seq![s1[0]].add(merge(s1.skip(1), s2))\n    } else {\n        seq![s2[0]].add(merge(s1, s2.skip(1)))\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_merge.rs", "verified": true, "metadata": {"original_id": "27dfc3c0e722", "function_name": "merge", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_6d7eea4062f0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)  ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_11/verina_basic_11_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6d7eea4062f0", "function_name": "last_digit", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_4e0f7b3ed23b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)  ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "4e0f7b3ed23b", "function_name": "abs", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_bc087dc63d11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn dot_product(v1: Seq<nat>, v2: Seq<nat>) -> nat\n    recommends v1.len() == v2.len()\n    {\n    if v1.len() == 0 { 0 }\n    else { v1[0] * v2[0] + dot_product(v1.skip(1), v2.skip(1)) }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn dot_product(v1: Seq<nat>, v2: Seq<nat>) -> nat\n    recommends v1.len() == v2.len()\n    decreases v1.len()\n{\n    if v1.len() == 0 { 0 }\n    else { v1[0] * v2[0] + dot_product(v1.skip(1), v2.skip(1)) }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn dot_product(v1: Seq<nat>, v2: Seq<nat>) -> nat\n    recommends v1.len() == v2.len()\n    decreases v1.len()\n{\n    if v1.len() == 0 { 0 }\n    else { v1[0] * v2[0] + dot_product(v1.skip(1), v2.skip(1)) }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_vec_def.rs", "verified": true, "metadata": {"original_id": "bc087dc63d11", "function_name": "dot_product", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_ab74a643825c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eval(t: Tm, fuel: nat) -> Tm\n    {\n    if fuel == 0 {\n        t\n    } else {\n        match step_once(t) {\n            Option::Some(t_prime) => eval(t_prime, (fuel - 1) as nat),\n            Option::None => t,\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eval(t: Tm, fuel: nat) -> Tm\n    decreases fuel\n{\n    if fuel == 0 {\n        t\n    } else {\n        match step_once(t) {\n            Option::Some(t_prime) => eval(t_prime, (fuel - 1) as nat),\n            Option::None => t,\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eval(t: Tm, fuel: nat) -> Tm\n    decreases fuel\n{\n    if fuel == 0 {\n        t\n    } else {\n        match step_once(t) {\n            Option::Some(t_prime) => eval(t_prime, (fuel - 1) as nat),\n            Option::None => t,\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "norm_verus.rs", "verified": true, "metadata": {"original_id": "ab74a643825c", "function_name": "eval", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_58fb96ec49ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)  ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)  ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58fb96ec49ca", "function_name": "largest_prime_factor", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_4244d29e83ab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4244d29e83ab", "function_name": "binary_search_loop", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_e6b58a67275b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , {    if arr1 [idx] <= arr2 [idx] {   return false ; } idx += 1 ; }  true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e6b58a67275b", "function_name": "is_smaller", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_e6e7ef5c8f6f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e6e7ef5c8f6f", "function_name": "is_even_at_even_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_733272a0f358", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "733272a0f358", "function_name": "any_value_exists", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_7fcaead1c7e4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7fcaead1c7e4", "function_name": "count_sum_divisible_by", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_2085e64bc1d5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/WIP/WIP__mcontained.rs", "verified": true, "metadata": {"original_id": "2085e64bc1d5", "function_name": "mcontained", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_bb0489574c48", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_49/verina_basic_49_impl.rs", "verified": true, "metadata": {"original_id": "bb0489574c48", "function_name": "find_first_odd", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_6edf0fc34933", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "6edf0fc34933", "function_name": "replace_last_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_652fca66e6aa", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)  ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_72/verina_advanced_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "652fca66e6aa", "function_name": "single_digit_prime_factor", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_58a39e51f107", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sized_monotonic(size1: nat, size2: nat, n: nat)\n    requires size1 <= size2, arbitrary_nat_sized(size1).contains(n)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sized_monotonic(size1: nat, size2: nat, n: nat)\n    requires size1 <= size2, arbitrary_nat_sized(size1).contains(n)\n    ensures arbitrary_nat_sized(size2).contains(n)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sized_monotonic(size1: nat, size2: nat, n: nat)\n    requires size1 <= size2, arbitrary_nat_sized(size1).contains(n)\n    ensures arbitrary_nat_sized(size2).contains(n)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_arbitrary_nat.rs", "verified": true, "metadata": {"original_id": "58a39e51f107", "function_name": "sized_monotonic", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_164190bd6377", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "164190bd6377", "function_name": "is_integer", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_ac78bb1d581e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_lazy_equiv(d1: Dec, d2: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_lazy_equiv(d1: Dec, d2: Dec)\n    ensures dec_or_lazy(d1, || d2) == dec_or(d1, d2)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_lazy_equiv(d1: Dec, d2: Dec)\n    ensures dec_or_lazy(d1, || d2) == dec_or(d1, d2)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "ac78bb1d581e", "function_name": "dec_or_lazy_equiv", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_2aa2e5d87f40", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_add_assoc(a: nat, b: nat, c: nat)\n    ensures add(add(a, b), c) == add(a, add(b, c))\n    {\n    if a == 0 {\n        assert(add(add(0, b), c) == add(b, c));\n        assert(add(0, add(b, c)) == add(b, c));\n    } else {\n        let a1 = (a - 1) as nat;\n        ex4_add_assoc(a1, b, c);\n\n        assert(add(a, b) == add(a1, b) + 1);\n        assert(add(add(a, b), c) == add(add(a1, b) + 1, c));\n        assert(add(a, add(b, c)) == add(a1, add(b, c)) + 1);\n\n        // A tiny rewrite: add(x+1, c) unfolds to add(x,c)+1\n        assert(add(add(a1, b) + 1, c) == add(add(a1, b), c) + 1);\n\n        // Close with IH\n        assert(add(add(a1, b), c) == add(a1, add(b, c)));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_add_assoc(a: nat, b: nat, c: nat)\n    ensures add(add(a, b), c) == add(a, add(b, c))\n    decreases a\n{\n    if a == 0 {\n        assert(add(add(0, b), c) == add(b, c));\n        assert(add(0, add(b, c)) == add(b, c));\n    } else {\n        let a1 = (a - 1) as nat;\n        ex4_add_assoc(a1, b, c);\n\n        assert(add(a, b) == add(a1, b) + 1);\n        assert(add(add(a, b), c) == add(add(a1, b) + 1, c));\n        assert(add(a, add(b, c)) == add(a1, add(b, c)) + 1);\n\n        // A tiny rewrite: add(x+1, c) unfolds to add(x,c)+1\n        assert(add(add(a1, b) + 1, c) == add(add(a1, b), c) + 1);\n\n        // Close with IH\n        assert(add(add(a1, b), c) == add(a1, add(b, c)));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_add_assoc(a: nat, b: nat, c: nat)\n    ensures add(add(a, b), c) == add(a, add(b, c))\n    decreases a\n{\n    if a == 0 {\n        assert(add(add(0, b), c) == add(b, c));\n        assert(add(0, add(b, c)) == add(b, c));\n    } else {\n        let a1 = (a - 1) as nat;\n        ex4_add_assoc(a1, b, c);\n\n        assert(add(a, b) == add(a1, b) + 1);\n        assert(add(add(a, b), c) == add(add(a1, b) + 1, c));\n        assert(add(a, add(b, c)) == add(a1, add(b, c)) + 1);\n\n        // A tiny rewrite: add(x+1, c) unfolds to add(x,c)+1\n        assert(add(add(a1, b) + 1, c) == add(add(a1, b), c) + 1);\n\n        // Close with IH\n        assert(add(add(a1, b), c) == add(a1, add(b, c)));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "tactics_verus.rs", "verified": true, "metadata": {"original_id": "2aa2e5d87f40", "function_name": "ex4_add_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_3dfde2018b4b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)  ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_9/verina_basic_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3dfde2018b4b", "function_name": "has_common_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f23dbe71eeb0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn or_idemp(a: bool)  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn or_idemp(a: bool) ensures bool_or(a, a) == a {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn or_idemp(a: bool) ensures bool_or(a, a) == a {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_bool.rs", "verified": true, "metadata": {"original_id": "f23dbe71eeb0", "function_name": "or_idemp", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_377c0479642d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 ,  { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "377c0479642d", "function_name": "conditional_average", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_ca87cb45cbfd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x {  lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ca87cb45cbfd", "function_name": "triple", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_9b9b793d3774", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right  { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9b9b793d3774", "function_name": "separate", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_a9338b565e15", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32)  ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset/verus_code_iter_4_current.rs", "verified": true, "metadata": {"original_id": "a9338b565e15", "function_name": "min_of_vec", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_896a3b8e6bc9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right  { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "896a3b8e6bc9", "function_name": "binary_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_f9fd013b136f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "f9fd013b136f", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_c2cae5d7ae88", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)  ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "c2cae5d7ae88", "function_name": "smallest_list_length", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6b228108a01b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 ,  { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6b228108a01b", "function_name": "append", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_e958818aa085", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn any_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    ensures any_foldr(xs, p) <==> exists|i: int| 0 <= i < xs.len() as int && p(xs[i])\n    {\n    if xs.len() == 0 {\n        assert(!any_foldr(xs, p));\n    } else {\n        any_foldr_correct(xs.skip(1), p);\n        assert(any_foldr(xs, p) == (p(xs[0]) || any_foldr(xs.skip(1), p)));\n\n        if p(xs[0]) {\n            assert(p(xs[0]));\n        }\n\n        assert forall|i: int| 0 <= i < xs.len() as int && p(xs[i])\n            implies any_foldr(xs, p) by {\n            if i == 0 {\n                assert(p(xs[0]));\n            } else {\n                assert(0 <= i - 1 < xs.skip(1).len() as int);\n                assert(xs.skip(1)[i - 1] == xs[i]);\n                assert(p(xs.skip(1)[i - 1]));\n            }\n        };\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn any_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    ensures any_foldr(xs, p) <==> exists|i: int| 0 <= i < xs.len() as int && p(xs[i])\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(!any_foldr(xs, p));\n    } else {\n        any_foldr_correct(xs.skip(1), p);\n        assert(any_foldr(xs, p) == (p(xs[0]) || any_foldr(xs.skip(1), p)));\n\n        if p(xs[0]) {\n            assert(p(xs[0]));\n        }\n\n        assert forall|i: int| 0 <= i < xs.len() as int && p(xs[i])\n            implies any_foldr(xs, p) by {\n            if i == 0 {\n                assert(p(xs[0]));\n            } else {\n                assert(0 <= i - 1 < xs.skip(1).len() as int);\n                assert(xs.skip(1)[i - 1] == xs[i]);\n                assert(p(xs.skip(1)[i - 1]));\n            }\n        };\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn any_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    ensures any_foldr(xs, p) <==> exists|i: int| 0 <= i < xs.len() as int && p(xs[i])\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(!any_foldr(xs, p));\n    } else {\n        any_foldr_correct(xs.skip(1), p);\n        assert(any_foldr(xs, p) == (p(xs[0]) || any_foldr(xs.skip(1), p)));\n\n        if p(xs[0]) {\n            assert(p(xs[0]));\n        }\n\n        assert forall|i: int| 0 <= i < xs.len() as int && p(xs[i])\n            implies any_foldr(xs, p) by {\n            if i == 0 {\n                assert(p(xs[0]));\n            } else {\n                assert(0 <= i - 1 < xs.skip(1).len() as int);\n                assert(xs.skip(1)[i - 1] == xs[i]);\n                assert(p(xs.skip(1)[i - 1]));\n            }\n        };\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "e958818aa085", "function_name": "any_foldr_correct", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_b5dcdc870050", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_30/verina_advanced_30.rs", "verified": true, "metadata": {"original_id": "b5dcdc870050", "function_name": "longest_increasing_streak_aux", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_a71ab9dcb389", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)  ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_binary_search/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a71ab9dcb389", "function_name": "binary_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_edaffa22605f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)  ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_43/verina_basic_43_iter_1_current.rs", "verified": true, "metadata": {"original_id": "edaffa22605f", "function_name": "sum_of_fourth_power_of_odd_numbers", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1faaccb99904", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1faaccb99904", "function_name": "shared_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1911c106f11b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1911c106f11b", "function_name": "minMethod", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_2eef64f99a14", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn height_bounds_size<T>(t: Tree<T>)\n    \n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    match t {\n        Tree::Leaf => {\n            assert(tree_size(t) == 0);\n            assert(tree_height(t) == 0);\n            pow2_pos(0);\n        }\n        Tree::Node { left, value: _, right } => {\n            height_bounds_size(*left);\n            height_bounds_size(*right);\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            let h = if lh > rh { lh } else { rh };\n            pow2_monotonic(lh, h);\n            pow2_monotonic(rh, h);\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn height_bounds_size<T>(t: Tree<T>)\n    ensures tree_size(t) < pow2(tree_height(t))\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    match t {\n        Tree::Leaf => {\n            assert(tree_size(t) == 0);\n            assert(tree_height(t) == 0);\n            pow2_pos(0);\n        }\n        Tree::Node { left, value: _, right } => {\n            height_bounds_size(*left);\n            height_bounds_size(*right);\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            let h = if lh > rh { lh } else { rh };\n            pow2_monotonic(lh, h);\n            pow2_monotonic(rh, h);\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn height_bounds_size<T>(t: Tree<T>)\n    ensures tree_size(t) < pow2(tree_height(t))\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_height, 2);\n    match t {\n        Tree::Leaf => {\n            assert(tree_size(t) == 0);\n            assert(tree_height(t) == 0);\n            pow2_pos(0);\n        }\n        Tree::Node { left, value: _, right } => {\n            height_bounds_size(*left);\n            height_bounds_size(*right);\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            let h = if lh > rh { lh } else { rh };\n            pow2_monotonic(lh, h);\n            pow2_monotonic(rh, h);\n            pow2_double(h);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_size.rs", "verified": true, "metadata": {"original_id": "2eef64f99a14", "function_name": "height_bounds_size", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_420bab83e5fd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)  ensures k_out >= 0 , { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "420bab83e5fd", "function_name": "main_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_9592b43c84dc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_multiset_cons(x: nat, s: Seq<nat>)\n    \n{\n    reveal_with_fuel(seq_to_multiset, 2);\n    assume(meq(seq_to_multiset(seq![x].add(s)), madd(seq_to_multiset(s), x)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_multiset_cons(x: nat, s: Seq<nat>)\n    ensures meq(seq_to_multiset(seq![x].add(s)), madd(seq_to_multiset(s), x))\n{\n    reveal_with_fuel(seq_to_multiset, 2);\n    assume(meq(seq_to_multiset(seq![x].add(s)), madd(seq_to_multiset(s), x)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn seq_multiset_cons(x: nat, s: Seq<nat>)\n    ensures meq(seq_to_multiset(seq![x].add(s)), madd(seq_to_multiset(s), x))\n{\n    reveal_with_fuel(seq_to_multiset, 2);\n    assume(meq(seq_to_multiset(seq![x].add(s)), madd(seq_to_multiset(s), x)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_multiset_def.rs", "verified": true, "metadata": {"original_id": "9592b43c84dc", "function_name": "seq_multiset_cons", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_0996f8d1e791", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_even_complete(n: nat) -> (e: EvenEv)\n    \n    ensures e.n() == n,\n    decreases n\n{\n    if n == 0 {\n        EvenEv::Ev0\n    } else {\n        // For nat, if is_even(n) and n != 0, then n >= 2.\n        assert(n != 1);\n        assert(n >= 2);\n        let n2 = (n - 2) as nat;\n        let e2 = ex2_even_complete(n2);\n        EvenEv::EvSS(Box::new(e2))\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_even_complete(n: nat) -> (e: EvenEv)\n    requires is_even(n),\n    ensures e.n() == n,\n    decreases n\n{\n    if n == 0 {\n        EvenEv::Ev0\n    } else {\n        // For nat, if is_even(n) and n != 0, then n >= 2.\n        assert(n != 1);\n        assert(n >= 2);\n        let n2 = (n - 2) as nat;\n        let e2 = ex2_even_complete(n2);\n        EvenEv::EvSS(Box::new(e2))\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_even_complete(n: nat) -> (e: EvenEv)\n    requires is_even(n),\n    ensures e.n() == n,\n    decreases n\n{\n    if n == 0 {\n        EvenEv::Ev0\n    } else {\n        // For nat, if is_even(n) and n != 0, then n >= 2.\n        assert(n != 1);\n        assert(n >= 2);\n        let n2 = (n - 2) as nat;\n        let e2 = ex2_even_complete(n2);\n        EvenEv::EvSS(Box::new(e2))\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "0996f8d1e791", "function_name": "ex2_even_complete", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_0505c64c32d7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_greater(n: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_greater(n: nat)\n    ensures witness_greater(n) > n\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_greater(n: nat)\n    ensures witness_greater(n) > n\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "0505c64c32d7", "function_name": "verify_witness_greater", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_a7bc3cc60e7a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element , { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element , decreases arr . len () - i { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element , decreases arr . len () - i { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_284_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a7bc3cc60e7a", "function_name": "all_elements_equals", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_c405f9ffc80a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_lt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_lt(t, bound), k < bound\n    \n    decreases t\n{\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_lt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_lt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_lt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_lt(t, bound), k < bound\n    ensures all_lt(insert(k, v, t), bound)\n    decreases t\n{\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_lt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_lt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_lt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_lt(t, bound), k < bound\n    ensures all_lt(insert(k, v, t), bound)\n    decreases t\n{\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_lt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_lt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_invariant.rs", "verified": true, "metadata": {"original_id": "c405f9ffc80a", "function_name": "insert_all_lt", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_0437d714c0c6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "0437d714c0c6", "function_name": "intersection", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a73f2758dd9f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    requires 0 <= k < xs.len() as int,\n             xs[k] == Option::<nat>::None\n    \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    requires 0 <= k < xs.len() as int,\n             xs[k] == Option::<nat>::None\n    ensures sequence_option(xs) == Option::<Seq<nat>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    requires 0 <= k < xs.len() as int,\n             xs[k] == Option::<nat>::None\n    ensures sequence_option(xs) == Option::<Seq<nat>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_applicative.rs", "verified": true, "metadata": {"original_id": "a73f2758dd9f", "function_name": "sequence_option_any_none", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_verus_doubly_linked_xor_034d7a0db0a4", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::*;\n\n// \"XOR Linked List\". This is a sorta-cute (if not usually practical) folk data structure:\n// A doubly-linked list which saves memory by having each node store the XOR of the two\n// pointers to its two neighbors.\n//\n// This example uses the XOR Linked List to build a deque.\n//\n// TODO should really use usize, but bit-vector operations on usize aren't supported right now,\n// so we use u64 and assume it's equivalent to usize.\n\nverus! {\n\n#[verifier::external_body]\nproof fn lemma_usize_u64(x: u64)\n    ensures\n        x as usize as u64 == x,\n{\n    unimplemented!();\n}\n\n// Single node in the list\nstruct Node<V> {\n    xored: u64,\n    v: V,\n}\n\n// Doubly-linked list\n// Contains head pointer, tail pointer\n// and in ghost code, tracks all the pointers and all the permissions to access the nodes\ntype MemPerms<V> = PointsTo<Node<V>>;\n\n// The xor-doubly-linked list  {\n    ptrs: Ghost<Seq<PPtr<Node<V>>>>,\n    perms: Tracked<Map<nat, MemPerms<V>>>,\n    head: u64,\n    tail: u64,\n}\n\nimpl<V> DListXor<V> {\n    spec fn wf_perms(&self) -> bool {\n        forall|i: nat| 0 <= i < self.ptrs@.len() ==> self.wf_perm(i)\n    }\n\n    spec fn prev_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i == 0 {\n            0\n        } else {\n            self.ptrs@[i - 1].addr() as u64\n        }\n    }\n\n    spec fn next_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i + 1 == self.ptrs@.len() {\n            0\n        } else {\n            self.ptrs@[i + 1int].addr() as u64\n        }\n    }\n\n    spec fn wf_perm(&self, i: nat) -> bool\n        recommends\n            i < self.ptrs@.len(),\n    {\n        &&& self.perms@.dom().contains(i)\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& 0 < self.ptrs@[i as int].addr()\n        &&& self.ptrs@[i as int].addr() < 0x10000000000000000\n        &&& self.perms@[i].is_init()\n        &&& self.perms@[i].value().xored == (self.prev_of(i) ^ self.next_of(i))\n    }\n\n    spec fn wf_head(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.head == 0\n        } else {\n            self.head == self.ptrs@[0].addr()\n        }\n    }\n\n    spec fn wf_tail(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.tail == 0\n        } else {\n            self.tail == self.ptrs@[self.ptrs@.len() - 1].addr()\n        }\n    }\n\n    spec fn wf(&self) -> bool {\n        self.wf_perms() && self.wf_head() && self.wf_tail()\n    }\n\n    spec fn view(&self) -> Seq<V>\n        recommends\n            self.wf(),\n    {\n        Seq::<V>::new(self.ptrs@.len(), |i: int| { self.perms@[i as nat].value().v })\n    }\n\n    fn new() -> (s: Self)\n        ensures\n            s.wf(),\n            s@.len() == 0,\n    {\n        DListXor {\n            ptrs: Ghost(Seq::empty()),\n            perms: Tracked(Map::tracked_empty()),\n            head: 0,\n            tail: 0,\n        }\n    }\n\n    fn push_empty_case(&mut self, v: V)\n\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        let (ptr, Tracked(perm)) = PPtr::new(Node::<V> { xored: 0, v });\n        proof {\n            self.ptrs@ = self.ptrs@.push(ptr);\n            (&perm).is_nonnull();\n            self.perms.borrow_mut().tracked_insert((self.ptrs@.len() - 1) as nat, perm);\n        }\n        self.tail = ptr.addr() as u64;\n        self.head = self.tail;\n        assert(0u64 ^ 0u64 == 0u64) by (bit_vector);\n        assert(self@ =~= old(self)@.push(v));\n    }\n\n    fn push_back(&mut self, v: V)\n\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            let tail_ptr_u64 = self.tail;\n            proof {\n                lemma_usize_u64(tail_ptr_u64);\n            }\n            let tail_ptr = PPtr::<Node<V>>::from_usize(tail_ptr_u64 as usize);\n            let tracked mut tail_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 1) as nat,\n            );\n            let mut tail_node = tail_ptr.take(Tracked(&mut tail_perm));\n            let second_to_last_ptr = tail_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: tail_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            tail_node.xored = second_to_last_ptr ^ new_ptr_u64;\n            tail_ptr.put(Tracked(&mut tail_perm), tail_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 1) as nat,\n                    tail_perm,\n                );\n                self.perms.borrow_mut().tracked_insert(self.ptrs@.len(), perm);\n                self.ptrs@ = self.ptrs@.push(ptr);\n            }\n            self.tail = new_ptr_u64;\n            proof {\n                assert(tail_ptr_u64 ^ 0 == tail_ptr_u64) by (bit_vector);\n                let i = (self.ptrs@.len() - 2) as nat;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let prev_of_i = self.prev_of(i);\n                assert(prev_of_i ^ 0 == prev_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.wf_perm((self.ptrs@.len() - 2) as nat));\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                assert(forall|i: nat|\n                    i < self.ptrs@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[self.ptrs@.len() - 1] == v);\n                assert forall|i: int| 0 <= i < self.ptrs@.len() - 1 implies old(self)@[i]\n                    == self@[i] by {\n                    assert(old(self).wf_perm(i as nat));  // trigger\n                };\n                assert(self@ =~= old(self)@.push(v));\n            }\n        }\n    }\n\n    fn pop_back(&mut self) -> (v: V)\n\n        ensures\n            self.wf(),\n            self@ == old(self)@.drop_last(),\n            v == old(self)@[old(self)@.len() - 1],\n    {\n        assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n        let last_u64 = self.tail;\n        proof {\n            lemma_usize_u64(last_u64);\n        }\n        let last_ptr = PPtr::<Node<V>>::from_usize(last_u64 as usize);\n        let tracked last_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n            (self.ptrs@.len() - 1) as nat,\n        );\n        let last_node = last_ptr.into_inner(Tracked(last_perm));\n        let penult_u64 = last_node.xored;\n        let v = last_node.v;\n        proof {\n            let self_head = self.head;\n            assert(self_head ^ 0 == self_head) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if penult_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n                    #[verifier::spec] let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                    assert(actual_penult_u64 ^ 0 == actual_penult_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.tail = penult_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n            proof {\n                let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                assert(actual_penult_u64 ^ 0 == actual_penult_u64) by (bit_vector);\n                lemma_usize_u64(penult_u64);\n            }\n            let penult_ptr = PPtr::<Node<V>>::from_usize(penult_u64 as usize);\n            let tracked mut penult_perm = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 2) as nat,\n            );\n            let mut penult_node = penult_ptr.take(Tracked(&mut penult_perm));\n            let t: Ghost<u64> = Ghost(self.prev_of((self.ptrs@.len() - 2) as nat));\n            assert((t@ ^ last_u64) ^ last_u64 == t@ ^ 0) by (bit_vector);\n            penult_node.xored = penult_node.xored ^ last_u64;\n            assert(penult_node.xored == t@ ^ 0);\n            penult_ptr.put(Tracked(&mut penult_perm), penult_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 2) as nat,\n                    penult_perm,\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.drop_last();\n        }\n        proof {\n            assert(self.wf_head());\n            assert(self.wf_tail());\n            if self.ptrs@.len() > 0 {\n                /*#[verifier::spec] let i = self.ptrs@.len() - 1;\n                assert(self.ptrs@.len() == old(self).ptrs@.len() - 1);\n                assert(self.perms@.dom().contains(i));\n                assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                assert(0 < self.ptrs@[i]@);\n                assert(self.ptrs@[i]@ < 0x10000000000000000);\n                assert(self.perms@[i].value.is_Some());\n                assert(self.perms@[i].value.get_Some_0().xored == (\n                    self.prev_of(i) ^ self.next_of(i)\n                ));*/\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.drop_last()[i] by {\n                assert(old(self).wf_perm(i as nat));  // trigger\n            }\n            assert(self@ =~= old(self)@.drop_last());\n        }\n        v\n    }\n\n    fn pop_front(&mut self) -> (v: V)\n\n        ensures\n            self.wf(),\n            self@ == old(self)@.subrange(1, old(self)@.len() as int),\n            v == old(self)@[0],\n    {\n        assert(self.wf_perm(0));\n        let first_u64 = self.head;\n        proof {\n            lemma_usize_u64(first_u64);\n        }\n        let first_ptr = PPtr::<Node<V>>::from_usize(first_u64 as usize);\n        let tracked first_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(0);\n        let first_node = first_ptr.into_inner(Tracked(first_perm));\n        let second_u64 = first_node.xored;\n        let v = first_node.v;\n        proof {\n            let self_tail = self.tail;\n            assert(self_tail ^ 0 == self_tail) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if second_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm(1));\n                    #[verifier::spec] let actual_second_u64 = self.next_of(0);\n                    assert(0 ^ actual_second_u64 == actual_second_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.head = second_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm(1));\n            proof {\n                let actual_second_u64 = self.next_of(0);\n                assert(0 ^ actual_second_u64 == actual_second_u64) by (bit_vector);\n                lemma_usize_u64(second_u64);\n            }\n            let second_ptr = PPtr::<Node<V>>::from_usize(second_u64 as usize);\n            let tracked mut second_perm = (self.perms.borrow_mut()).tracked_remove(1);\n            let mut second_node = second_ptr.take(Tracked(&mut second_perm));\n            let t: Ghost<u64> = Ghost(self.next_of(1));\n            assert((first_u64 ^ t@) ^ first_u64 == 0 ^ t@) by (bit_vector);\n            second_node.xored = second_node.xored ^ first_u64;\n            assert(second_node.xored == 0 ^ t@);\n            second_ptr.put(Tracked(&mut second_perm), second_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(1, second_perm);\n                assert forall|j: nat| 1 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                (self.perms.borrow_mut()).tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 0 <= j < old(self)@.len() - 1,\n                        |j: nat| (j + 1) as nat,\n                    ),\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.subrange(1, self.ptrs@.len() as int);\n        }\n        proof {\n            assert(self.wf_tail());\n            assert(self.wf_head());\n            if self.ptrs@.len() > 0 {\n                assert(self.wf_perm(0));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i + 1) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.subrange(1, old(self)@.len() as int)[i] by {\n                assert(old(self).wf_perm(i as nat + 1));  // trigger\n            }\n            assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n        }\n        v\n    }\n\n    fn push_front(&mut self, v: V)\n\n        ensures\n            self.wf(),\n            self@ == seq![v].add(old(self)@),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n            assert(self@ =~= seq![v].add(old(self)@));\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm(0));\n            let head_ptr_u64 = self.head;\n            proof {\n                lemma_usize_u64(head_ptr_u64);\n            }\n            let head_ptr = PPtr::<Node<V>>::from_usize(head_ptr_u64 as usize);\n            let tracked mut head_perm: MemPerms<V> = (self.perms.borrow_mut()).tracked_remove(\n                0,\n            );\n            let mut head_node = head_ptr.take(Tracked(&mut head_perm));\n            let second_ptr = head_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: head_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            head_node.xored = new_ptr_u64 ^ second_ptr;\n            head_ptr.put(Tracked(&mut head_perm), head_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(0, head_perm);\n                assert forall|j: nat| 0 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                self.perms.borrow_mut().tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 1 <= j <= old(self)@.len(),\n                        |j: nat| (j - 1) as nat,\n                    ),\n                );\n                self.perms.borrow_mut().tracked_insert(0, perm);\n                self.ptrs@ = seq![ptr].add(self.ptrs@);\n            }\n            self.head = new_ptr_u64;\n            proof {\n                assert(0 ^ head_ptr_u64 == head_ptr_u64) by (bit_vector);\n                let i = 1;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let next_of_i = self.next_of(i);\n                assert(0 ^ next_of_i == next_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.perms@.index(1).value().xored == new_ptr_u64\n                    ^ second_ptr);\n                assert(self.perms@.index(0).value().xored == head_ptr_u64);\n                assert(self.perms@.index(1).pptr().addr() == head_ptr_u64);\n                assert(self.wf_perm(1));\n                assert(self.wf_perm(0));\n                assert(forall|i: nat|\n                    1 <= i <= old(self).ptrs@.len() ==> old(self).wf_perm((i - 1) as nat)\n                        ==> #[trigger] self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[0] == v);\n                assert forall|i: int| 1 <= i <= self.ptrs@.len() - 1 implies old(self)@[i - 1]\n                    == self@[i] by {\n                    assert(old(self).wf_perm((i - 1) as nat));  // trigger\n                };\n                assert(self@ =~= seq![v].add(old(self)@));\n            }\n        }\n    }\n}\n\n#[verifier::external_body]\nfn print_result(msg: &'static str, value: u32) {\n    println!(\"{}: {value}\", msg);\n}\n\nfn main() {\n    let mut t = DListXor::<u32>::new();\n    t.push_back(2);\n    t.push_back(3);\n    t.push_front(1);  // 1, 2, 3\n    print_result(\"pushed\", 2);\n    print_result(\"pushed\", 3);\n    print_result(\"pushed\", 1);\n    let x = t.pop_back();  // 3\n    let y = t.pop_front();  // 1\n    let z = t.pop_front();  // 2\n    assert(x == 3);\n    assert(y == 1);\n    assert(z == 2);\n    print_result(\"popped\", x);\n    print_result(\"popped\", y);\n    print_result(\"popped\", z);\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::*;\n\n// \"XOR Linked List\". This is a sorta-cute (if not usually practical) folk data structure:\n// A doubly-linked list which saves memory by having each node store the XOR of the two\n// pointers to its two neighbors.\n//\n// This example uses the XOR Linked List to build a deque.\n//\n// TODO should really use usize, but bit-vector operations on usize aren't supported right now,\n// so we use u64 and assume it's equivalent to usize.\n\nverus! {\n\n#[verifier::external_body]\nproof fn lemma_usize_u64(x: u64)\n    ensures\n        x as usize as u64 == x,\n{\n    unimplemented!();\n}\n\n// Single node in the list\nstruct Node<V> {\n    xored: u64,\n    v: V,\n}\n\n// Doubly-linked list\n// Contains head pointer, tail pointer\n// and in ghost code, tracks all the pointers and all the permissions to access the nodes\ntype MemPerms<V> = PointsTo<Node<V>>;\n\n// The xor-doubly-linked list requires us to treat pointers as integer addresses.\n// This is somewhat tricky because it forces us to think a bit about pointer provenance.\n// The simple_pptr library abstracts this away (and verifies it) and thus lets us treat pointers\n// as isomoprhic to usize values.\n\nstruct DListXor<V> {\n    ptrs: Ghost<Seq<PPtr<Node<V>>>>,\n    perms: Tracked<Map<nat, MemPerms<V>>>,\n    head: u64,\n    tail: u64,\n}\n\nimpl<V> DListXor<V> {\n    spec fn wf_perms(&self) -> bool {\n        forall|i: nat| 0 <= i < self.ptrs@.len() ==> self.wf_perm(i)\n    }\n\n    spec fn prev_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i == 0 {\n            0\n        } else {\n            self.ptrs@[i - 1].addr() as u64\n        }\n    }\n\n    spec fn next_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i + 1 == self.ptrs@.len() {\n            0\n        } else {\n            self.ptrs@[i + 1int].addr() as u64\n        }\n    }\n\n    spec fn wf_perm(&self, i: nat) -> bool\n        recommends\n            i < self.ptrs@.len(),\n    {\n        &&& self.perms@.dom().contains(i)\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& 0 < self.ptrs@[i as int].addr()\n        &&& self.ptrs@[i as int].addr() < 0x10000000000000000\n        &&& self.perms@[i].is_init()\n        &&& self.perms@[i].value().xored == (self.prev_of(i) ^ self.next_of(i))\n    }\n\n    spec fn wf_head(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.head == 0\n        } else {\n            self.head == self.ptrs@[0].addr()\n        }\n    }\n\n    spec fn wf_tail(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.tail == 0\n        } else {\n            self.tail == self.ptrs@[self.ptrs@.len() - 1].addr()\n        }\n    }\n\n    spec fn wf(&self) -> bool {\n        self.wf_perms() && self.wf_head() && self.wf_tail()\n    }\n\n    spec fn view(&self) -> Seq<V>\n        recommends\n            self.wf(),\n    {\n        Seq::<V>::new(self.ptrs@.len(), |i: int| { self.perms@[i as nat].value().v })\n    }\n\n    fn new() -> (s: Self)\n        ensures\n            s.wf(),\n            s@.len() == 0,\n    {\n        DListXor {\n            ptrs: Ghost(Seq::empty()),\n            perms: Tracked(Map::tracked_empty()),\n            head: 0,\n            tail: 0,\n        }\n    }\n\n    fn push_empty_case(&mut self, v: V)\n        requires\n            old(self).wf(),\n            old(self).ptrs@.len() == 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        let (ptr, Tracked(perm)) = PPtr::new(Node::<V> { xored: 0, v });\n        proof {\n            self.ptrs@ = self.ptrs@.push(ptr);\n            (&perm).is_nonnull();\n            self.perms.borrow_mut().tracked_insert((self.ptrs@.len() - 1) as nat, perm);\n        }\n        self.tail = ptr.addr() as u64;\n        self.head = self.tail;\n        assert(0u64 ^ 0u64 == 0u64) by (bit_vector);\n        assert(self@ =~= old(self)@.push(v));\n    }\n\n    fn push_back(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            let tail_ptr_u64 = self.tail;\n            proof {\n                lemma_usize_u64(tail_ptr_u64);\n            }\n            let tail_ptr = PPtr::<Node<V>>::from_usize(tail_ptr_u64 as usize);\n            let tracked mut tail_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 1) as nat,\n            );\n            let mut tail_node = tail_ptr.take(Tracked(&mut tail_perm));\n            let second_to_last_ptr = tail_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: tail_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            tail_node.xored = second_to_last_ptr ^ new_ptr_u64;\n            tail_ptr.put(Tracked(&mut tail_perm), tail_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 1) as nat,\n                    tail_perm,\n                );\n                self.perms.borrow_mut().tracked_insert(self.ptrs@.len(), perm);\n                self.ptrs@ = self.ptrs@.push(ptr);\n            }\n            self.tail = new_ptr_u64;\n            proof {\n                assert(tail_ptr_u64 ^ 0 == tail_ptr_u64) by (bit_vector);\n                let i = (self.ptrs@.len() - 2) as nat;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let prev_of_i = self.prev_of(i);\n                assert(prev_of_i ^ 0 == prev_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.wf_perm((self.ptrs@.len() - 2) as nat));\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                assert(forall|i: nat|\n                    i < self.ptrs@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[self.ptrs@.len() - 1] == v);\n                assert forall|i: int| 0 <= i < self.ptrs@.len() - 1 implies old(self)@[i]\n                    == self@[i] by {\n                    assert(old(self).wf_perm(i as nat));  // trigger\n                };\n                assert(self@ =~= old(self)@.push(v));\n            }\n        }\n    }\n\n    fn pop_back(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.drop_last(),\n            v == old(self)@[old(self)@.len() - 1],\n    {\n        assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n        let last_u64 = self.tail;\n        proof {\n            lemma_usize_u64(last_u64);\n        }\n        let last_ptr = PPtr::<Node<V>>::from_usize(last_u64 as usize);\n        let tracked last_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n            (self.ptrs@.len() - 1) as nat,\n        );\n        let last_node = last_ptr.into_inner(Tracked(last_perm));\n        let penult_u64 = last_node.xored;\n        let v = last_node.v;\n        proof {\n            let self_head = self.head;\n            assert(self_head ^ 0 == self_head) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if penult_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n                    #[verifier::spec] let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                    assert(actual_penult_u64 ^ 0 == actual_penult_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.tail = penult_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n            proof {\n                let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                assert(actual_penult_u64 ^ 0 == actual_penult_u64) by (bit_vector);\n                lemma_usize_u64(penult_u64);\n            }\n            let penult_ptr = PPtr::<Node<V>>::from_usize(penult_u64 as usize);\n            let tracked mut penult_perm = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 2) as nat,\n            );\n            let mut penult_node = penult_ptr.take(Tracked(&mut penult_perm));\n            let t: Ghost<u64> = Ghost(self.prev_of((self.ptrs@.len() - 2) as nat));\n            assert((t@ ^ last_u64) ^ last_u64 == t@ ^ 0) by (bit_vector);\n            penult_node.xored = penult_node.xored ^ last_u64;\n            assert(penult_node.xored == t@ ^ 0);\n            penult_ptr.put(Tracked(&mut penult_perm), penult_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 2) as nat,\n                    penult_perm,\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.drop_last();\n        }\n        proof {\n            assert(self.wf_head());\n            assert(self.wf_tail());\n            if self.ptrs@.len() > 0 {\n                /*#[verifier::spec] let i = self.ptrs@.len() - 1;\n                assert(self.ptrs@.len() == old(self).ptrs@.len() - 1);\n                assert(self.perms@.dom().contains(i));\n                assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                assert(0 < self.ptrs@[i]@);\n                assert(self.ptrs@[i]@ < 0x10000000000000000);\n                assert(self.perms@[i].value.is_Some());\n                assert(self.perms@[i].value.get_Some_0().xored == (\n                    self.prev_of(i) ^ self.next_of(i)\n                ));*/\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.drop_last()[i] by {\n                assert(old(self).wf_perm(i as nat));  // trigger\n            }\n            assert(self@ =~= old(self)@.drop_last());\n        }\n        v\n    }\n\n    fn pop_front(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.subrange(1, old(self)@.len() as int),\n            v == old(self)@[0],\n    {\n        assert(self.wf_perm(0));\n        let first_u64 = self.head;\n        proof {\n            lemma_usize_u64(first_u64);\n        }\n        let first_ptr = PPtr::<Node<V>>::from_usize(first_u64 as usize);\n        let tracked first_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(0);\n        let first_node = first_ptr.into_inner(Tracked(first_perm));\n        let second_u64 = first_node.xored;\n        let v = first_node.v;\n        proof {\n            let self_tail = self.tail;\n            assert(self_tail ^ 0 == self_tail) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if second_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm(1));\n                    #[verifier::spec] let actual_second_u64 = self.next_of(0);\n                    assert(0 ^ actual_second_u64 == actual_second_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.head = second_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm(1));\n            proof {\n                let actual_second_u64 = self.next_of(0);\n                assert(0 ^ actual_second_u64 == actual_second_u64) by (bit_vector);\n                lemma_usize_u64(second_u64);\n            }\n            let second_ptr = PPtr::<Node<V>>::from_usize(second_u64 as usize);\n            let tracked mut second_perm = (self.perms.borrow_mut()).tracked_remove(1);\n            let mut second_node = second_ptr.take(Tracked(&mut second_perm));\n            let t: Ghost<u64> = Ghost(self.next_of(1));\n            assert((first_u64 ^ t@) ^ first_u64 == 0 ^ t@) by (bit_vector);\n            second_node.xored = second_node.xored ^ first_u64;\n            assert(second_node.xored == 0 ^ t@);\n            second_ptr.put(Tracked(&mut second_perm), second_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(1, second_perm);\n                assert forall|j: nat| 1 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                (self.perms.borrow_mut()).tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 0 <= j < old(self)@.len() - 1,\n                        |j: nat| (j + 1) as nat,\n                    ),\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.subrange(1, self.ptrs@.len() as int);\n        }\n        proof {\n            assert(self.wf_tail());\n            assert(self.wf_head());\n            if self.ptrs@.len() > 0 {\n                assert(self.wf_perm(0));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i + 1) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.subrange(1, old(self)@.len() as int)[i] by {\n                assert(old(self).wf_perm(i as nat + 1));  // trigger\n            }\n            assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n        }\n        v\n    }\n\n    fn push_front(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == seq![v].add(old(self)@),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n            assert(self@ =~= seq![v].add(old(self)@));\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm(0));\n            let head_ptr_u64 = self.head;\n            proof {\n                lemma_usize_u64(head_ptr_u64);\n            }\n            let head_ptr = PPtr::<Node<V>>::from_usize(head_ptr_u64 as usize);\n            let tracked mut head_perm: MemPerms<V> = (self.perms.borrow_mut()).tracked_remove(\n                0,\n            );\n            let mut head_node = head_ptr.take(Tracked(&mut head_perm));\n            let second_ptr = head_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: head_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            head_node.xored = new_ptr_u64 ^ second_ptr;\n            head_ptr.put(Tracked(&mut head_perm), head_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(0, head_perm);\n                assert forall|j: nat| 0 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                self.perms.borrow_mut().tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 1 <= j <= old(self)@.len(),\n                        |j: nat| (j - 1) as nat,\n                    ),\n                );\n                self.perms.borrow_mut().tracked_insert(0, perm);\n                self.ptrs@ = seq![ptr].add(self.ptrs@);\n            }\n            self.head = new_ptr_u64;\n            proof {\n                assert(0 ^ head_ptr_u64 == head_ptr_u64) by (bit_vector);\n                let i = 1;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let next_of_i = self.next_of(i);\n                assert(0 ^ next_of_i == next_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.perms@.index(1).value().xored == new_ptr_u64\n                    ^ second_ptr);\n                assert(self.perms@.index(0).value().xored == head_ptr_u64);\n                assert(self.perms@.index(1).pptr().addr() == head_ptr_u64);\n                assert(self.wf_perm(1));\n                assert(self.wf_perm(0));\n                assert(forall|i: nat|\n                    1 <= i <= old(self).ptrs@.len() ==> old(self).wf_perm((i - 1) as nat)\n                        ==> #[trigger] self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[0] == v);\n                assert forall|i: int| 1 <= i <= self.ptrs@.len() - 1 implies old(self)@[i - 1]\n                    == self@[i] by {\n                    assert(old(self).wf_perm((i - 1) as nat));  // trigger\n                };\n                assert(self@ =~= seq![v].add(old(self)@));\n            }\n        }\n    }\n}\n\n#[verifier::external_body]\nfn print_result(msg: &'static str, value: u32) {\n    println!(\"{}: {value}\", msg);\n}\n\nfn main() {\n    let mut t = DListXor::<u32>::new();\n    t.push_back(2);\n    t.push_back(3);\n    t.push_front(1);  // 1, 2, 3\n    print_result(\"pushed\", 2);\n    print_result(\"pushed\", 3);\n    print_result(\"pushed\", 1);\n    let x = t.pop_back();  // 3\n    let y = t.pop_front();  // 1\n    let z = t.pop_front();  // 2\n    assert(x == 3);\n    assert(y == 1);\n    assert(z == 2);\n    print_result(\"popped\", x);\n    print_result(\"popped\", y);\n    print_result(\"popped\", z);\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::*;\n\n// \"XOR Linked List\". This is a sorta-cute (if not usually practical) folk data structure:\n// A doubly-linked list which saves memory by having each node store the XOR of the two\n// pointers to its two neighbors.\n//\n// This example uses the XOR Linked List to build a deque.\n//\n// TODO should really use usize, but bit-vector operations on usize aren't supported right now,\n// so we use u64 and assume it's equivalent to usize.\n\nverus! {\n\n#[verifier::external_body]\nproof fn lemma_usize_u64(x: u64)\n    ensures\n        x as usize as u64 == x,\n{\n    unimplemented!();\n}\n\n// Single node in the list\nstruct Node<V> {\n    xored: u64,\n    v: V,\n}\n\n// Doubly-linked list\n// Contains head pointer, tail pointer\n// and in ghost code, tracks all the pointers and all the permissions to access the nodes\ntype MemPerms<V> = PointsTo<Node<V>>;\n\n// The xor-doubly-linked list requires us to treat pointers as integer addresses.\n// This is somewhat tricky because it forces us to think a bit about pointer provenance.\n// The simple_pptr library abstracts this away (and verifies it) and thus lets us treat pointers\n// as isomoprhic to usize values.\n\nstruct DListXor<V> {\n    ptrs: Ghost<Seq<PPtr<Node<V>>>>,\n    perms: Tracked<Map<nat, MemPerms<V>>>,\n    head: u64,\n    tail: u64,\n}\n\nimpl<V> DListXor<V> {\n    spec fn wf_perms(&self) -> bool {\n        forall|i: nat| 0 <= i < self.ptrs@.len() ==> self.wf_perm(i)\n    }\n\n    spec fn prev_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i == 0 {\n            0\n        } else {\n            self.ptrs@[i - 1].addr() as u64\n        }\n    }\n\n    spec fn next_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i + 1 == self.ptrs@.len() {\n            0\n        } else {\n            self.ptrs@[i + 1int].addr() as u64\n        }\n    }\n\n    spec fn wf_perm(&self, i: nat) -> bool\n        recommends\n            i < self.ptrs@.len(),\n    {\n        &&& self.perms@.dom().contains(i)\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& 0 < self.ptrs@[i as int].addr()\n        &&& self.ptrs@[i as int].addr() < 0x10000000000000000\n        &&& self.perms@[i].is_init()\n        &&& self.perms@[i].value().xored == (self.prev_of(i) ^ self.next_of(i))\n    }\n\n    spec fn wf_head(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.head == 0\n        } else {\n            self.head == self.ptrs@[0].addr()\n        }\n    }\n\n    spec fn wf_tail(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.tail == 0\n        } else {\n            self.tail == self.ptrs@[self.ptrs@.len() - 1].addr()\n        }\n    }\n\n    spec fn wf(&self) -> bool {\n        self.wf_perms() && self.wf_head() && self.wf_tail()\n    }\n\n    spec fn view(&self) -> Seq<V>\n        recommends\n            self.wf(),\n    {\n        Seq::<V>::new(self.ptrs@.len(), |i: int| { self.perms@[i as nat].value().v })\n    }\n\n    fn new() -> (s: Self)\n        ensures\n            s.wf(),\n            s@.len() == 0,\n    {\n        DListXor {\n            ptrs: Ghost(Seq::empty()),\n            perms: Tracked(Map::tracked_empty()),\n            head: 0,\n            tail: 0,\n        }\n    }\n\n    fn push_empty_case(&mut self, v: V)\n        requires\n            old(self).wf(),\n            old(self).ptrs@.len() == 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        let (ptr, Tracked(perm)) = PPtr::new(Node::<V> { xored: 0, v });\n        proof {\n            self.ptrs@ = self.ptrs@.push(ptr);\n            (&perm).is_nonnull();\n            self.perms.borrow_mut().tracked_insert((self.ptrs@.len() - 1) as nat, perm);\n        }\n        self.tail = ptr.addr() as u64;\n        self.head = self.tail;\n        assert(0u64 ^ 0u64 == 0u64) by (bit_vector);\n        assert(self@ =~= old(self)@.push(v));\n    }\n\n    fn push_back(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            let tail_ptr_u64 = self.tail;\n            proof {\n                lemma_usize_u64(tail_ptr_u64);\n            }\n            let tail_ptr = PPtr::<Node<V>>::from_usize(tail_ptr_u64 as usize);\n            let tracked mut tail_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 1) as nat,\n            );\n            let mut tail_node = tail_ptr.take(Tracked(&mut tail_perm));\n            let second_to_last_ptr = tail_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: tail_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            tail_node.xored = second_to_last_ptr ^ new_ptr_u64;\n            tail_ptr.put(Tracked(&mut tail_perm), tail_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 1) as nat,\n                    tail_perm,\n                );\n                self.perms.borrow_mut().tracked_insert(self.ptrs@.len(), perm);\n                self.ptrs@ = self.ptrs@.push(ptr);\n            }\n            self.tail = new_ptr_u64;\n            proof {\n                assert(tail_ptr_u64 ^ 0 == tail_ptr_u64) by (bit_vector);\n                let i = (self.ptrs@.len() - 2) as nat;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let prev_of_i = self.prev_of(i);\n                assert(prev_of_i ^ 0 == prev_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.wf_perm((self.ptrs@.len() - 2) as nat));\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                assert(forall|i: nat|\n                    i < self.ptrs@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[self.ptrs@.len() - 1] == v);\n                assert forall|i: int| 0 <= i < self.ptrs@.len() - 1 implies old(self)@[i]\n                    == self@[i] by {\n                    assert(old(self).wf_perm(i as nat));  // trigger\n                };\n                assert(self@ =~= old(self)@.push(v));\n            }\n        }\n    }\n\n    fn pop_back(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.drop_last(),\n            v == old(self)@[old(self)@.len() - 1],\n    {\n        assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n        let last_u64 = self.tail;\n        proof {\n            lemma_usize_u64(last_u64);\n        }\n        let last_ptr = PPtr::<Node<V>>::from_usize(last_u64 as usize);\n        let tracked last_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n            (self.ptrs@.len() - 1) as nat,\n        );\n        let last_node = last_ptr.into_inner(Tracked(last_perm));\n        let penult_u64 = last_node.xored;\n        let v = last_node.v;\n        proof {\n            let self_head = self.head;\n            assert(self_head ^ 0 == self_head) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if penult_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n                    #[verifier::spec] let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                    assert(actual_penult_u64 ^ 0 == actual_penult_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.tail = penult_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n            proof {\n                let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                assert(actual_penult_u64 ^ 0 == actual_penult_u64) by (bit_vector);\n                lemma_usize_u64(penult_u64);\n            }\n            let penult_ptr = PPtr::<Node<V>>::from_usize(penult_u64 as usize);\n            let tracked mut penult_perm = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 2) as nat,\n            );\n            let mut penult_node = penult_ptr.take(Tracked(&mut penult_perm));\n            let t: Ghost<u64> = Ghost(self.prev_of((self.ptrs@.len() - 2) as nat));\n            assert((t@ ^ last_u64) ^ last_u64 == t@ ^ 0) by (bit_vector);\n            penult_node.xored = penult_node.xored ^ last_u64;\n            assert(penult_node.xored == t@ ^ 0);\n            penult_ptr.put(Tracked(&mut penult_perm), penult_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 2) as nat,\n                    penult_perm,\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.drop_last();\n        }\n        proof {\n            assert(self.wf_head());\n            assert(self.wf_tail());\n            if self.ptrs@.len() > 0 {\n                /*#[verifier::spec] let i = self.ptrs@.len() - 1;\n                assert(self.ptrs@.len() == old(self).ptrs@.len() - 1);\n                assert(self.perms@.dom().contains(i));\n                assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                assert(0 < self.ptrs@[i]@);\n                assert(self.ptrs@[i]@ < 0x10000000000000000);\n                assert(self.perms@[i].value.is_Some());\n                assert(self.perms@[i].value.get_Some_0().xored == (\n                    self.prev_of(i) ^ self.next_of(i)\n                ));*/\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.drop_last()[i] by {\n                assert(old(self).wf_perm(i as nat));  // trigger\n            }\n            assert(self@ =~= old(self)@.drop_last());\n        }\n        v\n    }\n\n    fn pop_front(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.subrange(1, old(self)@.len() as int),\n            v == old(self)@[0],\n    {\n        assert(self.wf_perm(0));\n        let first_u64 = self.head;\n        proof {\n            lemma_usize_u64(first_u64);\n        }\n        let first_ptr = PPtr::<Node<V>>::from_usize(first_u64 as usize);\n        let tracked first_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(0);\n        let first_node = first_ptr.into_inner(Tracked(first_perm));\n        let second_u64 = first_node.xored;\n        let v = first_node.v;\n        proof {\n            let self_tail = self.tail;\n            assert(self_tail ^ 0 == self_tail) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if second_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm(1));\n                    #[verifier::spec] let actual_second_u64 = self.next_of(0);\n                    assert(0 ^ actual_second_u64 == actual_second_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.head = second_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm(1));\n            proof {\n                let actual_second_u64 = self.next_of(0);\n                assert(0 ^ actual_second_u64 == actual_second_u64) by (bit_vector);\n                lemma_usize_u64(second_u64);\n            }\n            let second_ptr = PPtr::<Node<V>>::from_usize(second_u64 as usize);\n            let tracked mut second_perm = (self.perms.borrow_mut()).tracked_remove(1);\n            let mut second_node = second_ptr.take(Tracked(&mut second_perm));\n            let t: Ghost<u64> = Ghost(self.next_of(1));\n            assert((first_u64 ^ t@) ^ first_u64 == 0 ^ t@) by (bit_vector);\n            second_node.xored = second_node.xored ^ first_u64;\n            assert(second_node.xored == 0 ^ t@);\n            second_ptr.put(Tracked(&mut second_perm), second_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(1, second_perm);\n                assert forall|j: nat| 1 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                (self.perms.borrow_mut()).tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 0 <= j < old(self)@.len() - 1,\n                        |j: nat| (j + 1) as nat,\n                    ),\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.subrange(1, self.ptrs@.len() as int);\n        }\n        proof {\n            assert(self.wf_tail());\n            assert(self.wf_head());\n            if self.ptrs@.len() > 0 {\n                assert(self.wf_perm(0));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i + 1) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.subrange(1, old(self)@.len() as int)[i] by {\n                assert(old(self).wf_perm(i as nat + 1));  // trigger\n            }\n            assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n        }\n        v\n    }\n\n    fn push_front(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == seq![v].add(old(self)@),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n            assert(self@ =~= seq![v].add(old(self)@));\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm(0));\n            let head_ptr_u64 = self.head;\n            proof {\n                lemma_usize_u64(head_ptr_u64);\n            }\n            let head_ptr = PPtr::<Node<V>>::from_usize(head_ptr_u64 as usize);\n            let tracked mut head_perm: MemPerms<V> = (self.perms.borrow_mut()).tracked_remove(\n                0,\n            );\n            let mut head_node = head_ptr.take(Tracked(&mut head_perm));\n            let second_ptr = head_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: head_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            head_node.xored = new_ptr_u64 ^ second_ptr;\n            head_ptr.put(Tracked(&mut head_perm), head_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(0, head_perm);\n                assert forall|j: nat| 0 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                self.perms.borrow_mut().tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 1 <= j <= old(self)@.len(),\n                        |j: nat| (j - 1) as nat,\n                    ),\n                );\n                self.perms.borrow_mut().tracked_insert(0, perm);\n                self.ptrs@ = seq![ptr].add(self.ptrs@);\n            }\n            self.head = new_ptr_u64;\n            proof {\n                assert(0 ^ head_ptr_u64 == head_ptr_u64) by (bit_vector);\n                let i = 1;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let next_of_i = self.next_of(i);\n                assert(0 ^ next_of_i == next_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.perms@.index(1).value().xored == new_ptr_u64\n                    ^ second_ptr);\n                assert(self.perms@.index(0).value().xored == head_ptr_u64);\n                assert(self.perms@.index(1).pptr().addr() == head_ptr_u64);\n                assert(self.wf_perm(1));\n                assert(self.wf_perm(0));\n                assert(forall|i: nat|\n                    1 <= i <= old(self).ptrs@.len() ==> old(self).wf_perm((i - 1) as nat)\n                        ==> #[trigger] self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[0] == v);\n                assert forall|i: int| 1 <= i <= self.ptrs@.len() - 1 implies old(self)@[i - 1]\n                    == self@[i] by {\n                    assert(old(self).wf_perm((i - 1) as nat));  // trigger\n                };\n                assert(self@ =~= seq![v].add(old(self)@));\n            }\n        }\n    }\n}\n\n#[verifier::external_body]\nfn print_result(msg: &'static str, value: u32) {\n    println!(\"{}: {value}\", msg);\n}\n\nfn main() {\n    let mut t = DListXor::<u32>::new();\n    t.push_back(2);\n    t.push_back(3);\n    t.push_front(1);  // 1, 2, 3\n    print_result(\"pushed\", 2);\n    print_result(\"pushed\", 3);\n    print_result(\"pushed\", 1);\n    let x = t.pop_back();  // 3\n    let y = t.pop_front();  // 1\n    let z = t.pop_front();  // 2\n    assert(x == 3);\n    assert(y == 1);\n    assert(z == 2);\n    print_result(\"popped\", x);\n    print_result(\"popped\", y);\n    print_result(\"popped\", z);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/doubly_linked_xor.rs", "verified": true, "metadata": {"original_id": "verus_doubly_linked_xor_034d7a0db0a4", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_18d0b3583f5d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s12if_impl.rs", "verified": true, "metadata": {"original_id": "18d0b3583f5d", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_ad595921fb84", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "ad595921fb84", "function_name": "in_array_exec", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_9d9a40f30e90", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaves_nodes_relation<T>(t: Tree<T>)\n    \n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_leaves, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            leaves_nodes_relation(*left);\n            leaves_nodes_relation(*right);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaves_nodes_relation<T>(t: Tree<T>)\n    ensures tree_leaves(t) == tree_size(t) + 1\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_leaves, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            leaves_nodes_relation(*left);\n            leaves_nodes_relation(*right);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaves_nodes_relation<T>(t: Tree<T>)\n    ensures tree_leaves(t) == tree_size(t) + 1\n    decreases t\n{\n    reveal_with_fuel(tree_size, 2);\n    reveal_with_fuel(tree_leaves, 2);\n    match t {\n        Tree::Leaf => {}\n        Tree::Node { left, value: _, right } => {\n            leaves_nodes_relation(*left);\n            leaves_nodes_relation(*right);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_size.rs", "verified": true, "metadata": {"original_id": "9d9a40f30e90", "function_name": "leaves_nodes_relation", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_7a3bec4446fa", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "7a3bec4446fa", "function_name": "sel_sort", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_verus_strings_a9ecfdea6bcc", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "target_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "full_verified_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/strings.rs", "verified": true, "metadata": {"original_id": "verus_strings_a9ecfdea6bcc", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_e5e53c32a53f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)  ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e5e53c32a53f", "function_name": "swap", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_43ab2c0e8435", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_not(b: bool, p: bool)\n    requires reflect(b, p)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_not(b: bool, p: bool)\n    requires reflect(b, p)\n    ensures reflect(!b, !p)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_not(b: bool, p: bool)\n    requires reflect(b, p)\n    ensures reflect(!b, !p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_bool.rs", "verified": true, "metadata": {"original_id": "43ab2c0e8435", "function_name": "reflect_not", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1e6ddf5088b6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 ,  { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/sina1_impl.rs", "verified": true, "metadata": {"original_id": "1e6ddf5088b6", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_1ef6da17a6e6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)  ensures sum [0] == 6 * N , { sum . set (0 , (6 * N) as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , (6 * N) as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , (6 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "1ef6da17a6e6", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_verus_bitmap_d13ecbc0afdf", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "target_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "full_verified_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/bitmap.rs", "verified": true, "metadata": {"original_id": "verus_bitmap_d13ecbc0afdf", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_28f246cc2622", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 ,  { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 , ensures sum [0] == 2 * N , { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 , ensures sum [0] == 2 * N , { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "28f246cc2622", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_fee542870c4e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condn_impl.rs", "verified": true, "metadata": {"original_id": "fee542870c4e", "function_name": "myfun", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4ebba314eff1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "4ebba314eff1", "function_name": "has_common_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_ca844d5abd72", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "ca844d5abd72", "function_name": "interleave", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_assert_verus_chapter-2-2_fd1678b12990", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-2-2.rs", "verified": true, "metadata": {"original_id": "verus_chapter-2-2_fd1678b12990", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_b0dc6fc2f573", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    \n    ensures fw_relax(dm, i, i, i) == Some(0nat)\n{}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    requires dm_valid(dm), i < dm.n, dm_get(dm, i, i) == Some(0nat)\n    ensures fw_relax(dm, i, i, i) == Some(0nat)\n{}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn diagonal_zero(dm: DistMatrix, i: nat)\n    requires dm_valid(dm), i < dm.n, dm_get(dm, i, i) == Some(0nat)\n    ensures fw_relax(dm, i, i, i) == Some(0nat)\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_floyd_warshall.rs", "verified": true, "metadata": {"original_id": "b0dc6fc2f573", "function_name": "diagonal_zero", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_57e27db4e05a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "57e27db4e05a", "function_name": "has_only_one_distinct_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_146b12691683", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "146b12691683", "function_name": "intersection", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_e5011044af14", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 , decreases arr . len () - i , { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 , decreases arr . len () - i , { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 , decreases arr . len () - i , { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "e5011044af14", "function_name": "find_first_odd", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_5a742015d7ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_lookup(label: Label, ty: Ty) -> Option<Ty>\n    {\n    match ty {\n        Ty::TRNil => Option::None,\n        Ty::TRCons { label: l, ty: t, rest } =>\n            if l == label {\n                Option::Some(*t)\n            } else {\n                ty_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_lookup(label: Label, ty: Ty) -> Option<Ty>\n    decreases ty\n{\n    match ty {\n        Ty::TRNil => Option::None,\n        Ty::TRCons { label: l, ty: t, rest } =>\n            if l == label {\n                Option::Some(*t)\n            } else {\n                ty_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_lookup(label: Label, ty: Ty) -> Option<Ty>\n    decreases ty\n{\n    match ty {\n        Ty::TRNil => Option::None,\n        Ty::TRCons { label: l, ty: t, rest } =>\n            if l == label {\n                Option::Some(*t)\n            } else {\n                ty_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "records_verus.rs", "verified": true, "metadata": {"original_id": "5a742015d7ee", "function_name": "ty_lookup", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4749b06bd7ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 ,  { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "4749b06bd7ea", "function_name": "copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_35af8b038295", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn remove_not_contains<V>(t: Trie<V>, key: Seq<bool>)\n    ensures !contains(remove(t, key), key)\n    {\n    reveal_with_fuel(lookup, 3);\n    reveal_with_fuel(remove, 3);\n    match t {\n        Trie::Leaf => {}\n        Trie::Node { value: _, left, right } => {\n            if key.len() > 0 {\n                if key[0] {\n                    remove_not_contains(*right, key.skip(1));\n                } else {\n                    remove_not_contains(*left, key.skip(1));\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn remove_not_contains<V>(t: Trie<V>, key: Seq<bool>)\n    ensures !contains(remove(t, key), key)\n    decreases key.len()\n{\n    reveal_with_fuel(lookup, 3);\n    reveal_with_fuel(remove, 3);\n    match t {\n        Trie::Leaf => {}\n        Trie::Node { value: _, left, right } => {\n            if key.len() > 0 {\n                if key[0] {\n                    remove_not_contains(*right, key.skip(1));\n                } else {\n                    remove_not_contains(*left, key.skip(1));\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn remove_not_contains<V>(t: Trie<V>, key: Seq<bool>)\n    ensures !contains(remove(t, key), key)\n    decreases key.len()\n{\n    reveal_with_fuel(lookup, 3);\n    reveal_with_fuel(remove, 3);\n    match t {\n        Trie::Leaf => {}\n        Trie::Node { value: _, left, right } => {\n            if key.len() > 0 {\n                if key[0] {\n                    remove_not_contains(*right, key.skip(1));\n                } else {\n                    remove_not_contains(*left, key.skip(1));\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_trie_ops.rs", "verified": true, "metadata": {"original_id": "35af8b038295", "function_name": "remove_not_contains", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_c2cae5d7ae88", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 ,  { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "c2cae5d7ae88", "function_name": "smallest_list_length", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_53783bc47f7a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_47/verina_advanced_47.rs", "verified": true, "metadata": {"original_id": "53783bc47f7a", "function_name": "merge_intervals", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f086a67575eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 ,  { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f086a67575eb", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_6bb69aafc424", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs2_impl.rs", "verified": true, "metadata": {"original_id": "6bb69aafc424", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_f853734a797b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f853734a797b", "function_name": "last_position", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_a7733bc6c36c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)  ensures true , { false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a7733bc6c36c", "function_name": "tangent", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_exec_attr_8a9f2ac676ab", "task": "task_c", "input_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum =>\n     requires\n         x < 100,\n         y < 100,\n     ensures\n         sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n\n   }\n   test_for_loop(10);\n   proof!{\n\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32>\n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n\n    }\n    {\n        proof!{}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "target_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "full_verified_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/exec_attr.rs", "verified": true, "metadata": {"original_id": "verus_exec_attr_8a9f2ac676ab", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_8b51381fc709", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8b51381fc709", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_5b700e08b023", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,)  ensures used . len () == old (used) . len () , { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/interprocedural/AlgorithmsRust/permutations.rs", "verified": true, "metadata": {"original_id": "5b700e08b023", "function_name": "backtrack", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_b1d23e5299d9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b1d23e5299d9", "function_name": "longest_prefix", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_0f6e1bbdfe8c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len ()  { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique_impl.rs", "verified": true, "metadata": {"original_id": "0f6e1bbdfe8c", "function_name": "unique", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_5a32ea0f8529", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "5a32ea0f8529", "function_name": "bubble_outer", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c7e6da5e5ec9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 ,  { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "c7e6da5e5ec9", "function_name": "largest_prime_factor", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_152ad66b0916", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn arbitrary_bool_complete()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn arbitrary_bool_complete()\n    ensures\n        arbitrary_bool().contains(true),\n        arbitrary_bool().contains(false)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn arbitrary_bool_complete()\n    ensures\n        arbitrary_bool().contains(true),\n        arbitrary_bool().contains(false)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_arbitrary_bool.rs", "verified": true, "metadata": {"original_id": "152ad66b0916", "function_name": "arbitrary_bool_complete", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_7a07e78bbb25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)  ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8)  ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)  ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "7a07e78bbb25", "function_name": "decode_shift", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_86698098f817", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i ,  { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) ,  { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "86698098f817", "function_name": "secondSmallest", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_6a1924bcbe6f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "6a1924bcbe6f", "function_name": "binary_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_58a0eaec350f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1  { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_19/verina_basic_19_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58a0eaec350f", "function_name": "is_sorted", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_1b398a370819", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_hd_cons(d: nat, x: nat, xs: NatList)\n    \n{\n    assert(seq![x].add(xs).len() > 0);\n    assert(hd(d, seq![x].add(xs)) == (seq![x].add(xs))[0]);\n    assert((seq![x].add(xs))[0] == x);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_hd_cons(d: nat, x: nat, xs: NatList)\n    ensures hd(d, seq![x].add(xs)) == x\n{\n    assert(seq![x].add(xs).len() > 0);\n    assert(hd(d, seq![x].add(xs)) == (seq![x].add(xs))[0]);\n    assert((seq![x].add(xs))[0] == x);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_hd_cons(d: nat, x: nat, xs: NatList)\n    ensures hd(d, seq![x].add(xs)) == x\n{\n    assert(seq![x].add(xs).len() > 0);\n    assert(hd(d, seq![x].add(xs)) == (seq![x].add(xs))[0]);\n    assert((seq![x].add(xs))[0] == x);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "lists_verus.rs", "verified": true, "metadata": {"original_id": "1b398a370819", "function_name": "ex10_hd_cons", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_2b478bfb2995", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_linear_search2/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2b478bfb2995", "function_name": "linear_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_b97506b2ab46", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b97506b2ab46", "function_name": "is_odd_at_odd_index", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_6a85dea21f16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn split_first_smaller(s: Seq<nat>)\n    \n    ensures split_first(s).len() < s.len()\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn split_first_smaller(s: Seq<nat>)\n    requires s.len() > 1\n    ensures split_first(s).len() < s.len()\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn split_first_smaller(s: Seq<nat>)\n    requires s.len() > 1\n    ensures split_first(s).len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_merge.rs", "verified": true, "metadata": {"original_id": "6a85dea21f16", "function_name": "split_first_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_d81b487e6c95", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn not_ltb_geb(a: nat, b: nat)\n    requires !ltb(a, b)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn not_ltb_geb(a: nat, b: nat)\n    requires !ltb(a, b)\n    ensures geb(a, b)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn not_ltb_geb(a: nat, b: nat)\n    requires !ltb(a, b)\n    ensures geb(a, b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_comparison.rs", "verified": true, "metadata": {"original_id": "d81b487e6c95", "function_name": "not_ltb_geb", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_12e79e5822de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () ,  { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "12e79e5822de", "function_name": "barrier", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_02a512f3bc2f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lookup(d: nat, k: nat, t: Tree) -> nat\n    {\n    match t {\n        Tree::E => d,\n        Tree::T { left, key, value, right } =>\n            if k < key {\n                lookup(d, k, *left)\n            } else if k > key {\n                lookup(d, k, *right)\n            } else {\n                value\n            }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lookup(d: nat, k: nat, t: Tree) -> nat\n    decreases t\n{\n    match t {\n        Tree::E => d,\n        Tree::T { left, key, value, right } =>\n            if k < key {\n                lookup(d, k, *left)\n            } else if k > key {\n                lookup(d, k, *right)\n            } else {\n                value\n            }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lookup(d: nat, k: nat, t: Tree) -> nat\n    decreases t\n{\n    match t {\n        Tree::E => d,\n        Tree::T { left, key, value, right } =>\n            if k < key {\n                lookup(d, k, *left)\n            } else if k > key {\n                lookup(d, k, *right)\n            } else {\n                value\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_search.rs", "verified": true, "metadata": {"original_id": "02a512f3bc2f", "function_name": "lookup", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_dc7f79589a5a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut j = 1 ; while j < lists . len ()  { if lists [j] . len () < min_length { min_length = lists [j] . len () ; } j += 1 ; } min_length }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut j = 1 ; while j < lists . len () invariant 0 < j <= lists . len () , exists | i : int | # ! [auto] 0 <= i < j && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < j ==> min_length <= lists [i] . len () , decreases lists . len () - j { if lists [j] . len () < min_length { min_length = lists [j] . len () ; } j += 1 ; } min_length }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut j = 1 ; while j < lists . len () invariant 0 < j <= lists . len () , exists | i : int | # ! [auto] 0 <= i < j && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < j ==> min_length <= lists [i] . len () , decreases lists . len () - j { if lists [j] . len () < min_length { min_length = lists [j] . len () ; } j += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "dc7f79589a5a", "function_name": "smallest_list_length", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_4586f8902d83", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)  ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "4586f8902d83", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_7b9f156a5f39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fold_fusion<A, B, C>(\n    xs: Seq<A>,\n    init: B,\n    f: spec_fn(A, B) -> B,\n    g: spec_fn(A, C) -> C,\n    h: spec_fn(B) -> C\n)\n    requires forall|a: A, b: B| #[trigger] h(f(a, b)) == g(a, h(b))\n    \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(foldr(xs, init, f) == init);\n        assert(foldr(xs, h(init), g) == h(init));\n    } else {\n        fold_fusion(xs.skip(1), init, f, g, h);\n        assert(h(foldr(xs.skip(1), init, f)) == foldr(xs.skip(1), h(init), g));\n\n        assert(foldr(xs, init, f) == f(xs[0], foldr(xs.skip(1), init, f)));\n        assert(h(foldr(xs, init, f)) == h(f(xs[0], foldr(xs.skip(1), init, f))));\n        assert(h(f(xs[0], foldr(xs.skip(1), init, f))) == g(xs[0], h(foldr(xs.skip(1), init, f))));\n        assert(g(xs[0], h(foldr(xs.skip(1), init, f))) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n        assert(foldr(xs, h(init), g) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fold_fusion<A, B, C>(\n    xs: Seq<A>,\n    init: B,\n    f: spec_fn(A, B) -> B,\n    g: spec_fn(A, C) -> C,\n    h: spec_fn(B) -> C\n)\n    requires forall|a: A, b: B| #[trigger] h(f(a, b)) == g(a, h(b))\n    ensures h(foldr(xs, init, f)) == foldr(xs, h(init), g)\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(foldr(xs, init, f) == init);\n        assert(foldr(xs, h(init), g) == h(init));\n    } else {\n        fold_fusion(xs.skip(1), init, f, g, h);\n        assert(h(foldr(xs.skip(1), init, f)) == foldr(xs.skip(1), h(init), g));\n\n        assert(foldr(xs, init, f) == f(xs[0], foldr(xs.skip(1), init, f)));\n        assert(h(foldr(xs, init, f)) == h(f(xs[0], foldr(xs.skip(1), init, f))));\n        assert(h(f(xs[0], foldr(xs.skip(1), init, f))) == g(xs[0], h(foldr(xs.skip(1), init, f))));\n        assert(g(xs[0], h(foldr(xs.skip(1), init, f))) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n        assert(foldr(xs, h(init), g) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fold_fusion<A, B, C>(\n    xs: Seq<A>,\n    init: B,\n    f: spec_fn(A, B) -> B,\n    g: spec_fn(A, C) -> C,\n    h: spec_fn(B) -> C\n)\n    requires forall|a: A, b: B| #[trigger] h(f(a, b)) == g(a, h(b))\n    ensures h(foldr(xs, init, f)) == foldr(xs, h(init), g)\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(foldr(xs, init, f) == init);\n        assert(foldr(xs, h(init), g) == h(init));\n    } else {\n        fold_fusion(xs.skip(1), init, f, g, h);\n        assert(h(foldr(xs.skip(1), init, f)) == foldr(xs.skip(1), h(init), g));\n\n        assert(foldr(xs, init, f) == f(xs[0], foldr(xs.skip(1), init, f)));\n        assert(h(foldr(xs, init, f)) == h(f(xs[0], foldr(xs.skip(1), init, f))));\n        assert(h(f(xs[0], foldr(xs.skip(1), init, f))) == g(xs[0], h(foldr(xs.skip(1), init, f))));\n        assert(g(xs[0], h(foldr(xs.skip(1), init, f))) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n        assert(foldr(xs, h(init), g) == g(xs[0], foldr(xs.skip(1), h(init), g)));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "7b9f156a5f39", "function_name": "fold_fusion", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_37a4db675187", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_iter_2_current.rs", "verified": true, "metadata": {"original_id": "37a4db675187", "function_name": "all_digits", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_3c8f489ffced", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex5_update_comm(m: TotalMap, default: int, k1: Key, v1: int, k2: Key, v2: int)\n    \n    ensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n{\n    assert forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n    by {\n        if x == k1 {\n            // Left: update at k2 doesn't affect k1\n            ex2_update_neq(t_update(m, k1, v1), default, k2, k1, v2);\n            ex1_update_eq(t_update(m, k2, v2), default, k1, v1);\n        } else if x == k2 {\n            ex1_update_eq(t_update(m, k1, v1), default, k2, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, k2, v1);\n        } else {\n            ex2_update_neq(t_update(m, k1, v1), default, k2, x, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, x, v1);\n        }\n    };\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex5_update_comm(m: TotalMap, default: int, k1: Key, v1: int, k2: Key, v2: int)\n    requires k1 != k2,\n    ensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n{\n    assert forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n    by {\n        if x == k1 {\n            // Left: update at k2 doesn't affect k1\n            ex2_update_neq(t_update(m, k1, v1), default, k2, k1, v2);\n            ex1_update_eq(t_update(m, k2, v2), default, k1, v1);\n        } else if x == k2 {\n            ex1_update_eq(t_update(m, k1, v1), default, k2, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, k2, v1);\n        } else {\n            ex2_update_neq(t_update(m, k1, v1), default, k2, x, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, x, v1);\n        }\n    };\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex5_update_comm(m: TotalMap, default: int, k1: Key, v1: int, k2: Key, v2: int)\n    requires k1 != k2,\n    ensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n{\n    assert forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n    by {\n        if x == k1 {\n            // Left: update at k2 doesn't affect k1\n            ex2_update_neq(t_update(m, k1, v1), default, k2, k1, v2);\n            ex1_update_eq(t_update(m, k2, v2), default, k1, v1);\n        } else if x == k2 {\n            ex1_update_eq(t_update(m, k1, v1), default, k2, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, k2, v1);\n        } else {\n            ex2_update_neq(t_update(m, k1, v1), default, k2, x, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, x, v1);\n        }\n    };\n}\n\n} // verus!", "source": "coq_translation", "source_file": "maps_verus.rs", "verified": true, "metadata": {"original_id": "3c8f489ffced", "function_name": "ex5_update_comm", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_442259409fce", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "442259409fce", "function_name": "find_max", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_59d56b1e193a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)  ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 1 <= idx <= list . len () , min >= 0 , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx , { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 1 <= idx <= list . len () , min >= 0 , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx , { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 1 <= idx <= list . len () , min >= 0 , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx , { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "59d56b1e193a", "function_name": "smallest_list_length", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_3dbb5ee1f5b2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32)  ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_75/verina_advanced_75.rs", "verified": true, "metadata": {"original_id": "3dbb5ee1f5b2", "function_name": "task_code", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_ec8090f2b64a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)  ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "ec8090f2b64a", "function_name": "is_sorted", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_3e18ee679b08", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "3e18ee679b08", "function_name": "list_deep_clone", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_280df798a05c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)  ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "280df798a05c", "function_name": "is_prime", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6016fedb34c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn union_assoc(s1: Set<nat>, s2: Set<nat>, s3: Set<nat>)\n    \n{\n    assert(set_union(set_union(s1, s2), s3) =~= set_union(s1, set_union(s2, s3)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn union_assoc(s1: Set<nat>, s2: Set<nat>, s3: Set<nat>)\n    ensures set_union(set_union(s1, s2), s3) == set_union(s1, set_union(s2, s3))\n{\n    assert(set_union(set_union(s1, s2), s3) =~= set_union(s1, set_union(s2, s3)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn union_assoc(s1: Set<nat>, s2: Set<nat>, s3: Set<nat>)\n    ensures set_union(set_union(s1, s2), s3) == set_union(s1, set_union(s2, s3))\n{\n    assert(set_union(set_union(s1, s2), s3) =~= set_union(s1, set_union(s2, s3)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_adt_set.rs", "verified": true, "metadata": {"original_id": "6016fedb34c3", "function_name": "union_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7513c9d2b94d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "7513c9d2b94d", "function_name": "list_deep_clone", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_ce9024c8f45e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex9_exists_nat()\n    \n{\n    assert(exists|k: nat| #[trigger] add(k, 0) == k) by {\n        let w: nat = 0;\n        ex3_add_n_0(w);\n        assert(add(w, 0) == w);\n    };\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex9_exists_nat()\n    ensures exists|k: nat| #[trigger] add(k, 0) == k\n{\n    assert(exists|k: nat| #[trigger] add(k, 0) == k) by {\n        let w: nat = 0;\n        ex3_add_n_0(w);\n        assert(add(w, 0) == w);\n    };\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex9_exists_nat()\n    ensures exists|k: nat| #[trigger] add(k, 0) == k\n{\n    assert(exists|k: nat| #[trigger] add(k, 0) == k) by {\n        let w: nat = 0;\n        ex3_add_n_0(w);\n        assert(add(w, 0) == w);\n    };\n}\n\n} // verus!", "source": "coq_translation", "source_file": "tactics_verus.rs", "verified": true, "metadata": {"original_id": "ce9024c8f45e", "function_name": "ex9_exists_nat", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_2c18f8f4e000", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "2c18f8f4e000", "function_name": "max_of_list", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_b986bdb21d26", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len ()  { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_38/verina_basic_38_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b986bdb21d26", "function_name": "all_characters_same", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_56ade0e9e02d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "56ade0e9e02d", "function_name": "max_coverage_after_removing_one", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_e7c2be2a4e20", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i : usize = 0 ; while i < nums . len ()  { if nums [i] == target { assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i = i + 1 ; } assert (i == nums @ . len ()) ; assert (forall | j : int | 0 <= j < nums @ . len () as int ==> # [trigger] nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i : usize = 0 ; while i < nums . len () invariant i <= nums @ . len () , forall | j : int | 0 <= j < i as int ==> # [trigger] nums @ [j] != target , nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i = i + 1 ; } assert (i == nums @ . len ()) ; assert (forall | j : int | 0 <= j < nums @ . len () as int ==> # [trigger] nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i : usize = 0 ; while i < nums . len () invariant i <= nums @ . len () , forall | j : int | 0 <= j < i as int ==> # [trigger] nums @ [j] != target , nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i = i + 1 ; } assert (i == nums @ . len ()) ; assert (forall | j : int | 0 <= j < nums @ . len () as int ==> # [trigger] nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/linearsearch_impl.rs", "verified": true, "metadata": {"original_id": "e7c2be2a4e20", "function_name": "linear_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_d5eae418e192", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "d5eae418e192", "function_name": "digit_to_letters_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_9954dce0f34e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/replace_impl.rs", "verified": true, "metadata": {"original_id": "9954dce0f34e", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_40b51ce988ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] ,  { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "40b51ce988ca", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a903dcc95b1a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn full_coverage_means_100_percent(data: CoverageData)\n    \n    ensures branch_coverage(data) == 100, path_coverage(data) == 100\n{\n    assert((data.total_branches * 100) / data.total_branches == 100) by(nonlinear_arith)\n        requires data.total_branches > 0;\n    assert((data.total_paths * 100) / data.total_paths == 100) by(nonlinear_arith)\n        requires data.total_paths > 0;\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn full_coverage_means_100_percent(data: CoverageData)\n    requires full_coverage(data), data.total_branches > 0, data.total_paths > 0\n    ensures branch_coverage(data) == 100, path_coverage(data) == 100\n{\n    assert((data.total_branches * 100) / data.total_branches == 100) by(nonlinear_arith)\n        requires data.total_branches > 0;\n    assert((data.total_paths * 100) / data.total_paths == 100) by(nonlinear_arith)\n        requires data.total_paths > 0;\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn full_coverage_means_100_percent(data: CoverageData)\n    requires full_coverage(data), data.total_branches > 0, data.total_paths > 0\n    ensures branch_coverage(data) == 100, path_coverage(data) == 100\n{\n    assert((data.total_branches * 100) / data.total_branches == 100) by(nonlinear_arith)\n        requires data.total_branches > 0;\n    assert((data.total_paths * 100) / data.total_paths == 100) by(nonlinear_arith)\n        requires data.total_paths > 0;\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_coverage_analysis.rs", "verified": true, "metadata": {"original_id": "a903dcc95b1a", "function_name": "full_coverage_means_100_percent", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_30f6aa5835fd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "30f6aa5835fd", "function_name": "F", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_260ee288b5cf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)  ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)  ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left , { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left , { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left , { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "260ee288b5cf", "function_name": "two_way_sort", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_vostd_cast_ptr_314976b92d91", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr::MemContents;\nuse vstd::set;\nuse vstd::set_lib;\nuse vstd::simple_pptr::{self, PPtr};\n\nuse core::marker::PhantomData;\n\nverus! {\n\npub trait Repr<R: Sized>: Sized {\n    spec fn wf(r: R) -> bool;\n\n    spec fn to_repr_spec(self) -> R;\n\n    #[verifier::when_used_as_spec(to_repr_spec)]\n    fn to_repr(self) -> (res: R)\n        ensures\n            res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>> {\n    pub addr: usize,\n    pub ptr: PPtr<R>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> Clone for ReprPtr<R, T> {\n    fn clone(&self) -> Self {\n        Self { addr: self.addr, ptr: self.ptr, _T: PhantomData }\n    }\n}\n\nimpl<R, T: Repr<R>> Copy for ReprPtr<R, T> {\n\n}\n\nimpl<R, T: Repr<R>> ReprPtr<R, T> {\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n\n    {\n        self.addr\n    }\n\n    pub exec fn take(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>) -> (v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(),\n\n    {\n        proof {\n            T::from_to_repr(perm.value());\n        }\n        T::from_repr(self.ptr.take(Tracked(perm.points_to.borrow_mut())))\n    }\n\n    pub exec fn put(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>, v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>,\n\n    {\n        proof {\n            v.from_to_repr();\n            v.to_repr_wf();\n        }\n        self.ptr.put(Tracked(perm.points_to.borrow_mut()), v.to_repr())\n    }\n\n    pub exec fn borrow<'a>(self, Tracked(perm): Tracked<&'a PointsTo<R, T>>) -> (v: &'a T)\n        requires\n            perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(),\n\n    {\n        T::from_borrowed(self.ptr.borrow(Tracked(perm.points_to.borrow())))\n    }\n}\n\n#[verifier::accept_recursive_types(T)]\npub tracked struct PointsTo<R, T: Repr<R>> {\n    pub addr: usize,\n    pub points_to: Tracked<simple_pptr::PointsTo<R>>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> PointsTo<R, T> {\n    pub fn new(addr: usize, points_to: Tracked<simple_pptr::PointsTo<R>>) -> Tracked<Self> {\n        Tracked(Self { addr: addr, points_to: points_to, _T: PhantomData })\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        &&& T::wf(self.points_to@.value())\n    }\n\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n\n    {\n        self.addr\n    }\n\n    pub closed spec fn mem_contents(self) -> MemContents<T> {\n        match self.points_to@.mem_contents() {\n            MemContents::<R>::Uninit => MemContents::<T>::Uninit,\n            MemContents::<R>::Init(r) => MemContents::<T>::Init(T::from_repr(r)),\n        }\n    }\n\n    pub open spec fn is_init(self) -> bool {\n        self.mem_contents().is_init()\n    }\n\n    pub open spec fn is_uninit(self) -> bool {\n        self.mem_contents().is_uninit()\n    }\n\n    pub open spec fn value(self) -> T\n        recommends\n            self.is_init(),\n    {\n        self.mem_contents().value()\n    }\n\n    pub open spec fn pptr(self) -> ReprPtr<R, T> {\n        ReprPtr { addr: self.addr, ptr: self.points_to@.pptr(), _T: PhantomData }\n    }\n\n    pub broadcast proof fn pptr_implies_addr(&self)\n\n    {\n    }\n}\n\n/*#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub open spec fn mem_contents_unwrap<V, const N: usize>(arr: [raw_ptr::MemContents<V>; N]) -> (res:\n    raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub open spec fn mem_contents_wrap<V, const N: usize>(data: raw_ptr::MemContents<[V; N]>) -> (res:\n    [raw_ptr::MemContents<V>; N]);\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n\n{\n    unimplemented!();\n}\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(&self) -> *mut [V; N] {\n        self.view().ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.view().value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\n#[verusfmt::skip]\nbroadcast use\n    raw_ptr::group_raw_ptr_axioms,\n//    set_lib::group_set_lib_axioms,\n    set::group_set_axioms;\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Spec: cast the pointer to an integer\n    #[verifier::inline]\n    pub open spec fn addr_spec(&self) -> usize {\n        self.addr\n    }\n\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub exec fn addr(&self) -> (res: usize)\n\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n\n    {\n        Self { addr, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(&self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn pptr(&self) -> ArrayPtr<V, N> {\n        ArrayPtr { addr: self.addr(), _type: PhantomData }\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(&self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(&self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V, const N: usize>()\n\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm.view().value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit_all(),\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.pptr() == p);\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(\n                points_to.view().value,\n                perm_ptr.opt_value(),\n            );\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N,\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize) -> (res:\n        V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(),\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n*/\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr::MemContents;\nuse vstd::set;\nuse vstd::set_lib;\nuse vstd::simple_pptr::{self, PPtr};\n\nuse core::marker::PhantomData;\n\nverus! {\n\npub trait Repr<R: Sized>: Sized {\n    spec fn wf(r: R) -> bool;\n\n    spec fn to_repr_spec(self) -> R;\n\n    #[verifier::when_used_as_spec(to_repr_spec)]\n    fn to_repr(self) -> (res: R)\n        ensures\n            res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>> {\n    pub addr: usize,\n    pub ptr: PPtr<R>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> Clone for ReprPtr<R, T> {\n    fn clone(&self) -> Self {\n        Self { addr: self.addr, ptr: self.ptr, _T: PhantomData }\n    }\n}\n\nimpl<R, T: Repr<R>> Copy for ReprPtr<R, T> {\n\n}\n\nimpl<R, T: Repr<R>> ReprPtr<R, T> {\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr,\n    {\n        self.addr\n    }\n\n    pub exec fn take(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>) -> (v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(),\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Uninit::<T>,\n            v == old(perm).value(),\n    {\n        proof {\n            T::from_to_repr(perm.value());\n        }\n        T::from_repr(self.ptr.take(Tracked(perm.points_to.borrow_mut())))\n    }\n\n    pub exec fn put(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>, v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Init(v),\n            perm.wf(),\n    {\n        proof {\n            v.from_to_repr();\n            v.to_repr_wf();\n        }\n        self.ptr.put(Tracked(perm.points_to.borrow_mut()), v.to_repr())\n    }\n\n    pub exec fn borrow<'a>(self, Tracked(perm): Tracked<&'a PointsTo<R, T>>) -> (v: &'a T)\n        requires\n            perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(),\n        ensures\n            *v === perm.value(),\n    {\n        T::from_borrowed(self.ptr.borrow(Tracked(perm.points_to.borrow())))\n    }\n}\n\n#[verifier::accept_recursive_types(T)]\npub tracked struct PointsTo<R, T: Repr<R>> {\n    pub addr: usize,\n    pub points_to: Tracked<simple_pptr::PointsTo<R>>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> PointsTo<R, T> {\n    pub fn new(addr: usize, points_to: Tracked<simple_pptr::PointsTo<R>>) -> Tracked<Self> {\n        Tracked(Self { addr: addr, points_to: points_to, _T: PhantomData })\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        &&& T::wf(self.points_to@.value())\n    }\n\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr_spec(),\n    {\n        self.addr\n    }\n\n    pub closed spec fn mem_contents(self) -> MemContents<T> {\n        match self.points_to@.mem_contents() {\n            MemContents::<R>::Uninit => MemContents::<T>::Uninit,\n            MemContents::<R>::Init(r) => MemContents::<T>::Init(T::from_repr(r)),\n        }\n    }\n\n    pub open spec fn is_init(self) -> bool {\n        self.mem_contents().is_init()\n    }\n\n    pub open spec fn is_uninit(self) -> bool {\n        self.mem_contents().is_uninit()\n    }\n\n    pub open spec fn value(self) -> T\n        recommends\n            self.is_init(),\n    {\n        self.mem_contents().value()\n    }\n\n    pub open spec fn pptr(self) -> ReprPtr<R, T> {\n        ReprPtr { addr: self.addr, ptr: self.points_to@.pptr(), _T: PhantomData }\n    }\n\n    pub broadcast proof fn pptr_implies_addr(&self)\n        ensures\n            self.addr() == self.pptr().addr(),\n    {\n    }\n}\n\n/*#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub open spec fn mem_contents_unwrap<V, const N: usize>(arr: [raw_ptr::MemContents<V>; N]) -> (res:\n    raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub open spec fn mem_contents_wrap<V, const N: usize>(data: raw_ptr::MemContents<[V; N]>) -> (res:\n    [raw_ptr::MemContents<V>; N]);\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n{\n    unimplemented!();\n}\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(&self) -> *mut [V; N] {\n        self.view().ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.view().value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\n#[verusfmt::skip]\nbroadcast use\n    raw_ptr::group_raw_ptr_axioms,\n//    set_lib::group_set_lib_axioms,\n    set::group_set_axioms;\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Spec: cast the pointer to an integer\n    #[verifier::inline]\n    pub open spec fn addr_spec(&self) -> usize {\n        self.addr\n    }\n\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub exec fn addr(&self) -> (res: usize)\n        ensures\n            res == self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n    {\n        Self { addr, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(&self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn pptr(&self) -> ArrayPtr<V, N> {\n        ArrayPtr { addr: self.addr(), _type: PhantomData }\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(&self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(&self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res.view().ptr == pt.view().ptr,\n            res.view().value == mem_contents_wrap(pt.view().opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res.view().ptr == self.view().ptr,\n            res.view().opt_value == mem_contents_unwrap(self.view().value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::is_sized::<[V; N]>(),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm.view().value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.pptr() == p);\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(\n                points_to.view().value,\n                perm_ptr.opt_value(),\n            );\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize) -> (res:\n        V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n*/\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr::MemContents;\nuse vstd::set;\nuse vstd::set_lib;\nuse vstd::simple_pptr::{self, PPtr};\n\nuse core::marker::PhantomData;\n\nverus! {\n\npub trait Repr<R: Sized>: Sized {\n    spec fn wf(r: R) -> bool;\n\n    spec fn to_repr_spec(self) -> R;\n\n    #[verifier::when_used_as_spec(to_repr_spec)]\n    fn to_repr(self) -> (res: R)\n        ensures\n            res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>> {\n    pub addr: usize,\n    pub ptr: PPtr<R>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> Clone for ReprPtr<R, T> {\n    fn clone(&self) -> Self {\n        Self { addr: self.addr, ptr: self.ptr, _T: PhantomData }\n    }\n}\n\nimpl<R, T: Repr<R>> Copy for ReprPtr<R, T> {\n\n}\n\nimpl<R, T: Repr<R>> ReprPtr<R, T> {\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr,\n    {\n        self.addr\n    }\n\n    pub exec fn take(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>) -> (v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(),\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Uninit::<T>,\n            v == old(perm).value(),\n    {\n        proof {\n            T::from_to_repr(perm.value());\n        }\n        T::from_repr(self.ptr.take(Tracked(perm.points_to.borrow_mut())))\n    }\n\n    pub exec fn put(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>, v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Init(v),\n            perm.wf(),\n    {\n        proof {\n            v.from_to_repr();\n            v.to_repr_wf();\n        }\n        self.ptr.put(Tracked(perm.points_to.borrow_mut()), v.to_repr())\n    }\n\n    pub exec fn borrow<'a>(self, Tracked(perm): Tracked<&'a PointsTo<R, T>>) -> (v: &'a T)\n        requires\n            perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(),\n        ensures\n            *v === perm.value(),\n    {\n        T::from_borrowed(self.ptr.borrow(Tracked(perm.points_to.borrow())))\n    }\n}\n\n#[verifier::accept_recursive_types(T)]\npub tracked struct PointsTo<R, T: Repr<R>> {\n    pub addr: usize,\n    pub points_to: Tracked<simple_pptr::PointsTo<R>>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> PointsTo<R, T> {\n    pub fn new(addr: usize, points_to: Tracked<simple_pptr::PointsTo<R>>) -> Tracked<Self> {\n        Tracked(Self { addr: addr, points_to: points_to, _T: PhantomData })\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        &&& T::wf(self.points_to@.value())\n    }\n\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr_spec(),\n    {\n        self.addr\n    }\n\n    pub closed spec fn mem_contents(self) -> MemContents<T> {\n        match self.points_to@.mem_contents() {\n            MemContents::<R>::Uninit => MemContents::<T>::Uninit,\n            MemContents::<R>::Init(r) => MemContents::<T>::Init(T::from_repr(r)),\n        }\n    }\n\n    pub open spec fn is_init(self) -> bool {\n        self.mem_contents().is_init()\n    }\n\n    pub open spec fn is_uninit(self) -> bool {\n        self.mem_contents().is_uninit()\n    }\n\n    pub open spec fn value(self) -> T\n        recommends\n            self.is_init(),\n    {\n        self.mem_contents().value()\n    }\n\n    pub open spec fn pptr(self) -> ReprPtr<R, T> {\n        ReprPtr { addr: self.addr, ptr: self.points_to@.pptr(), _T: PhantomData }\n    }\n\n    pub broadcast proof fn pptr_implies_addr(&self)\n        ensures\n            self.addr() == self.pptr().addr(),\n    {\n    }\n}\n\n/*#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub open spec fn mem_contents_unwrap<V, const N: usize>(arr: [raw_ptr::MemContents<V>; N]) -> (res:\n    raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub open spec fn mem_contents_wrap<V, const N: usize>(data: raw_ptr::MemContents<[V; N]>) -> (res:\n    [raw_ptr::MemContents<V>; N]);\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n{\n    unimplemented!();\n}\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(&self) -> *mut [V; N] {\n        self.view().ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.view().value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\n#[verusfmt::skip]\nbroadcast use\n    raw_ptr::group_raw_ptr_axioms,\n//    set_lib::group_set_lib_axioms,\n    set::group_set_axioms;\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Spec: cast the pointer to an integer\n    #[verifier::inline]\n    pub open spec fn addr_spec(&self) -> usize {\n        self.addr\n    }\n\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub exec fn addr(&self) -> (res: usize)\n        ensures\n            res == self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n    {\n        Self { addr, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(&self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn pptr(&self) -> ArrayPtr<V, N> {\n        ArrayPtr { addr: self.addr(), _type: PhantomData }\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(&self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(&self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res.view().ptr == pt.view().ptr,\n            res.view().value == mem_contents_wrap(pt.view().opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res.view().ptr == self.view().ptr,\n            res.view().opt_value == mem_contents_unwrap(self.view().value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::is_sized::<[V; N]>(),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm.view().value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.pptr() == p);\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(\n                points_to.view().value,\n                perm_ptr.opt_value(),\n            );\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize) -> (res:\n        V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n*/\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/cast_ptr.rs", "verified": true, "metadata": {"original_id": "vostd_cast_ptr_314976b92d91", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_99052f311f73", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contraposition(p: bool, q: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contraposition(p: bool, q: bool)\n    ensures contraposition(p, q)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contraposition(p: bool, q: bool)\n    ensures contraposition(p, q)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_negation.rs", "verified": true, "metadata": {"original_id": "99052f311f73", "function_name": "verify_contraposition", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_c1eec920f16e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)  ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c1eec920f16e", "function_name": "double_array_elements_aux", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_861f8b0e0841", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem ,  { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i , { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i , { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i , { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i , { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i , { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i , { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/last_position_impl.rs", "verified": true, "metadata": {"original_id": "861f8b0e0841", "function_name": "last_position", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_0200e16b05a5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) decreases n , { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >)  { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 ,  { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >)  { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) decreases n , { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >) ensures string_seq @ == string_sequence (n as nat) , decreases n { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) decreases n , { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >) ensures string_seq @ == string_sequence (n as nat) , decreases n { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_impl.rs", "verified": true, "metadata": {"original_id": "0200e16b05a5", "function_name": "string_sequence_impl", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7321ac779b22", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn meet_idemp(a: nat)  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn meet_idemp(a: nat) ensures meet(a, a) == a {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn meet_idemp(a: nat) ensures meet(a, a) == a {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_lattice.rs", "verified": true, "metadata": {"original_id": "7321ac779b22", "function_name": "meet_idemp", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_vostd_pod_e02b9add994d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nuse core::mem::MaybeUninit;\n\nverus! {\n\npub trait Pod: Copy + Sized {\n    /// Creates a new instance of Pod type that is filled with zeroes.\n    #[verifier::external_body]\n    fn new_zeroed() -> Self {\n        // SAFETY. An all-zero value of `T: Pod` is always valid.\n        unsafe { core::mem::zeroed() }\n    }\n\n    /// Creates a new instance of Pod type with uninitialized content.\n    #[verifier::external_body]\n    fn new_uninit() -> Self {\n        // SAFETY. A value of `T: Pod` can have arbitrary bits.\n        #[allow(clippy::uninit_assumed_init)]\n        unsafe { MaybeUninit::uninit().assume_init() }\n    }\n\n    /// As a slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes(&self) -> (slice: &[u8])\n\n    {\n        let ptr = self as *const Self as *const u8;\n        let len = core::mem::size_of::<Self>();\n        unsafe { core::slice::from_raw_parts(ptr, len) }\n    }\n\n    /// As a mutable slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes_mut(&mut self) -> (*mut u8, usize) {\n        let ptr = self as *mut Self as *mut u8;\n        let len = core::mem::size_of::<Self>();\n        // unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n        (ptr, len)\n    }\n}\n\n#[verifier::external]\npub fn as_bytes_mut_ex<T: Pod>(val: &mut T) -> &mut [u8] {\n    let ptr = val as *mut T as *mut u8;\n    let len = core::mem::size_of::<T>();\n    unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n}\n\npub open spec fn pod_size_spec<T: Pod>() -> usize {\n    core::mem::size_of::<T>()\n}\n\npub open spec fn pod_pnt_is_aligned<T: Pod>(pnt: *const u8) -> bool {\n    (pnt as usize) % pod_size_spec::<T>() == 0\n}\n\npub open spec fn pod_mem_space_is_aligned<T: Pod>(avail: int) -> bool {\n    avail % pod_size_spec::<T>() as int == 0\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nuse core::mem::MaybeUninit;\n\nverus! {\n\npub trait Pod: Copy + Sized {\n    /// Creates a new instance of Pod type that is filled with zeroes.\n    #[verifier::external_body]\n    fn new_zeroed() -> Self {\n        // SAFETY. An all-zero value of `T: Pod` is always valid.\n        unsafe { core::mem::zeroed() }\n    }\n\n    /// Creates a new instance of Pod type with uninitialized content.\n    #[verifier::external_body]\n    fn new_uninit() -> Self {\n        // SAFETY. A value of `T: Pod` can have arbitrary bits.\n        #[allow(clippy::uninit_assumed_init)]\n        unsafe { MaybeUninit::uninit().assume_init() }\n    }\n\n    /// As a slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes(&self) -> (slice: &[u8])\n        ensures\n            slice.len() == core::mem::size_of::<Self>(),\n    {\n        let ptr = self as *const Self as *const u8;\n        let len = core::mem::size_of::<Self>();\n        unsafe { core::slice::from_raw_parts(ptr, len) }\n    }\n\n    /// As a mutable slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes_mut(&mut self) -> (*mut u8, usize) {\n        let ptr = self as *mut Self as *mut u8;\n        let len = core::mem::size_of::<Self>();\n        // unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n        (ptr, len)\n    }\n}\n\n#[verifier::external]\npub fn as_bytes_mut_ex<T: Pod>(val: &mut T) -> &mut [u8] {\n    let ptr = val as *mut T as *mut u8;\n    let len = core::mem::size_of::<T>();\n    unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n}\n\npub open spec fn pod_size_spec<T: Pod>() -> usize {\n    core::mem::size_of::<T>()\n}\n\npub open spec fn pod_pnt_is_aligned<T: Pod>(pnt: *const u8) -> bool {\n    (pnt as usize) % pod_size_spec::<T>() == 0\n}\n\npub open spec fn pod_mem_space_is_aligned<T: Pod>(avail: int) -> bool {\n    avail % pod_size_spec::<T>() as int == 0\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nuse core::mem::MaybeUninit;\n\nverus! {\n\npub trait Pod: Copy + Sized {\n    /// Creates a new instance of Pod type that is filled with zeroes.\n    #[verifier::external_body]\n    fn new_zeroed() -> Self {\n        // SAFETY. An all-zero value of `T: Pod` is always valid.\n        unsafe { core::mem::zeroed() }\n    }\n\n    /// Creates a new instance of Pod type with uninitialized content.\n    #[verifier::external_body]\n    fn new_uninit() -> Self {\n        // SAFETY. A value of `T: Pod` can have arbitrary bits.\n        #[allow(clippy::uninit_assumed_init)]\n        unsafe { MaybeUninit::uninit().assume_init() }\n    }\n\n    /// As a slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes(&self) -> (slice: &[u8])\n        ensures\n            slice.len() == core::mem::size_of::<Self>(),\n    {\n        let ptr = self as *const Self as *const u8;\n        let len = core::mem::size_of::<Self>();\n        unsafe { core::slice::from_raw_parts(ptr, len) }\n    }\n\n    /// As a mutable slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes_mut(&mut self) -> (*mut u8, usize) {\n        let ptr = self as *mut Self as *mut u8;\n        let len = core::mem::size_of::<Self>();\n        // unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n        (ptr, len)\n    }\n}\n\n#[verifier::external]\npub fn as_bytes_mut_ex<T: Pod>(val: &mut T) -> &mut [u8] {\n    let ptr = val as *mut T as *mut u8;\n    let len = core::mem::size_of::<T>();\n    unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n}\n\npub open spec fn pod_size_spec<T: Pod>() -> usize {\n    core::mem::size_of::<T>()\n}\n\npub open spec fn pod_pnt_is_aligned<T: Pod>(pnt: *const u8) -> bool {\n    (pnt as usize) % pod_size_spec::<T>() == 0\n}\n\npub open spec fn pod_mem_space_is_aligned<T: Pod>(avail: int) -> bool {\n    avail % pod_size_spec::<T>() as int == 0\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/fvt6-vmreader-and-vmwriter/src/pod.rs", "verified": true, "metadata": {"original_id": "vostd_pod_e02b9add994d", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_59468cd5d2ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "59468cd5d2ca", "function_name": "triple_if", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_f8c095391aa0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8c095391aa0", "function_name": "up_while_less", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_998dbba568b9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/choose_odd_iter_3_current.rs", "verified": true, "metadata": {"original_id": "998dbba568b9", "function_name": "choose_odd", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_3b317f7559d1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)  ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b317f7559d1", "function_name": "max_strength", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_8c81c80d49c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int)  { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c81c80d49c3", "function_name": "is_divisible_by_11", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_3536863dfc81", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n  { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n  { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/WIP/WIP__transpose_matrix_impl.rs", "verified": true, "metadata": {"original_id": "3536863dfc81", "function_name": "transpose", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_28cea2e5ca93", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "28cea2e5ca93", "function_name": "remove_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_2d5c23d76df7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/063-fibfib_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2d5c23d76df7", "function_name": "fibfib", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_ab94299eda92", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ab94299eda92", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_be8112c0bae7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)  ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "be8112c0bae7", "function_name": "split_and_append", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_verus_const_4a3b8978107b", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/const.rs", "verified": true, "metadata": {"original_id": "verus_const_4a3b8978107b", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_cabbb977ab37", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 ,  { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "cabbb977ab37", "function_name": "smallest_list_length", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_cde163aa1355", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_sized_empty(size: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_sized_empty(size: nat)\n    ensures gen_list_sized(size).contains(Seq::empty())\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_sized_empty(size: nat)\n    ensures gen_list_sized(size).contains(Seq::empty())\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_sized.rs", "verified": true, "metadata": {"original_id": "cde163aa1355", "function_name": "gen_list_sized_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a4636b413b3c", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64)  ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/trigger_impl.rs", "verified": true, "metadata": {"original_id": "a4636b413b3c", "function_name": "get_element_check_property", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_4c6f8983e6f3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_law_option_u8()\n    \n{\n    assert(option_nat_le(Option::None, Option::Some(255)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_law_option_u8()\n    ensures option_nat_le(min_bound_option_u8(), max_bound_option_u8())\n{\n    assert(option_nat_le(Option::None, Option::Some(255)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_law_option_u8()\n    ensures option_nat_le(min_bound_option_u8(), max_bound_option_u8())\n{\n    assert(option_nat_le(Option::None, Option::Some(255)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_bounded.rs", "verified": true, "metadata": {"original_id": "4c6f8983e6f3", "function_name": "bounded_law_option_u8", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_syntax_attr_05f355728c93", "task": "task_c", "input_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n          // reveal f1's definition just inside this block\n        }\n\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "target_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "full_verified_code": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/syntax_attr.rs", "verified": true, "metadata": {"original_id": "verus_syntax_attr_05f355728c93", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_08cd98324fd4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_triple_membership<A, B, C>(\n    out_a: Set<A>,\n    out_b: Set<B>,\n    out_c: Set<C>,\n    a: A,\n    b: B,\n    c: C\n)\n    requires out_a.contains(a), out_b.contains(b), out_c.contains(c)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_triple_membership<A, B, C>(\n    out_a: Set<A>,\n    out_b: Set<B>,\n    out_c: Set<C>,\n    a: A,\n    b: B,\n    c: C\n)\n    requires out_a.contains(a), out_b.contains(b), out_c.contains(c)\n    ensures gen_triple_outputs(out_a, out_b, out_c).contains((a, b, c))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_triple_membership<A, B, C>(\n    out_a: Set<A>,\n    out_b: Set<B>,\n    out_c: Set<C>,\n    a: A,\n    b: B,\n    c: C\n)\n    requires out_a.contains(a), out_b.contains(b), out_c.contains(c)\n    ensures gen_triple_outputs(out_a, out_b, out_c).contains((a, b, c))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_pair.rs", "verified": true, "metadata": {"original_id": "08cd98324fd4", "function_name": "gen_triple_membership", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_b2f748cf906b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)  ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b2f748cf906b", "function_name": "last_digit", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6bb69aafc424", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs2_impl.rs", "verified": true, "metadata": {"original_id": "6bb69aafc424", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a96317058f01", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_nat_range(n: nat, k: nat)\n    \n    ensures enum_all_nat_range(n).contains(k)\n    decreases n\n{\n    enum_count_eq_len_nat_range(n);\n    enum_all_nat_range_index(n, k);\n    assert(enum_all_nat_range(n)[k as int] == k);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_nat_range(n: nat, k: nat)\n    requires k < n\n    ensures enum_all_nat_range(n).contains(k)\n    decreases n\n{\n    enum_count_eq_len_nat_range(n);\n    enum_all_nat_range_index(n, k);\n    assert(enum_all_nat_range(n)[k as int] == k);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_nat_range(n: nat, k: nat)\n    requires k < n\n    ensures enum_all_nat_range(n).contains(k)\n    decreases n\n{\n    enum_count_eq_len_nat_range(n);\n    enum_all_nat_range_index(n, k);\n    assert(enum_all_nat_range(n)[k as int] == k);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_enum.rs", "verified": true, "metadata": {"original_id": "a96317058f01", "function_name": "enum_all_complete_nat_range", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_ae37f0326cf7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , decreases x . len () - i { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , decreases x . len () - i { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/filter_weak_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ae37f0326cf7", "function_name": "myfun4", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_057da121d61c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/reverse_impl.rs", "verified": true, "metadata": {"original_id": "057da121d61c", "function_name": "reverse", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_23bdb60d18e6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "23bdb60d18e6", "function_name": "element_wise_subtract", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_verus_bst_map_type_invariant_62d3bbe5efb1", "task": "task_c", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map_type_invariant.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_type_invariant_62d3bbe5efb1", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_structural_e297b8c0a3d9", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Thing {}\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Car<T> {\n    passengers: T,\n    four_doors: bool,\n}\n\nfn one() {\n    let c1 = Car { passengers: Thing {  }, four_doors: true };\n    let c2 = Car { passengers: Thing {  }, four_doors: true };\n\n}\n\nfn two(c1: Car<u64>, c2: Car<u64>) {\n  if c1 == c2 {\n\n  }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Thing {}\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Car<T> {\n    passengers: T,\n    four_doors: bool,\n}\n\nfn one() {\n    let c1 = Car { passengers: Thing {  }, four_doors: true };\n    let c2 = Car { passengers: Thing {  }, four_doors: true };\n    assert(c1 == c2);\n}\n\nfn two(c1: Car<u64>, c2: Car<u64>) {\n  if c1 == c2 {\n    assert(c1 == c2);\n  }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Thing {}\n\n#[derive(PartialEq, Eq, Structural)]\nstruct Car<T> {\n    passengers: T,\n    four_doors: bool,\n}\n\nfn one() {\n    let c1 = Car { passengers: Thing {  }, four_doors: true };\n    let c2 = Car { passengers: Thing {  }, four_doors: true };\n    assert(c1 == c2);\n}\n\nfn two(c1: Car<u64>, c2: Car<u64>) {\n  if c1 == c2 {\n    assert(c1 == c2);\n  }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/structural.rs", "verified": true, "metadata": {"original_id": "verus_structural_e297b8c0a3d9", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_9d319f499bb1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] ,  { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) ,  { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9d319f499bb1", "function_name": "double_array_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_10a228758399", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_iter_2_current.rs", "verified": true, "metadata": {"original_id": "10a228758399", "function_name": "monotonic", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_3af88082379a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_all_different(n: nat, x: nat, y: nat)\n    requires x < n, y < n, x != y\n    \n{\n    reveal_with_fuel(find_root_fuel, 2);\n    assume(!same_set(uf_init(n), x, y));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_all_different(n: nat, x: nat, y: nat)\n    requires x < n, y < n, x != y\n    ensures !same_set(uf_init(n), x, y)\n{\n    reveal_with_fuel(find_root_fuel, 2);\n    assume(!same_set(uf_init(n), x, y));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_all_different(n: nat, x: nat, y: nat)\n    requires x < n, y < n, x != y\n    ensures !same_set(uf_init(n), x, y)\n{\n    reveal_with_fuel(find_root_fuel, 2);\n    assume(!same_set(uf_init(n), x, y));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_union_find.rs", "verified": true, "metadata": {"original_id": "3af88082379a", "function_name": "init_all_different", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_229b0ecd15f0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn length_foldr_correct<A>(xs: Seq<A>)\n    ensures length_foldr(xs) == xs.len()\n    {\n    if xs.len() == 0 {\n        assert(length_foldr(xs) == 0);\n    } else {\n        length_foldr_correct(xs.skip(1));\n        assert(length_foldr(xs) == 1 + length_foldr(xs.skip(1)));\n        assert(xs.skip(1).len() == xs.len() - 1);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn length_foldr_correct<A>(xs: Seq<A>)\n    ensures length_foldr(xs) == xs.len()\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(length_foldr(xs) == 0);\n    } else {\n        length_foldr_correct(xs.skip(1));\n        assert(length_foldr(xs) == 1 + length_foldr(xs.skip(1)));\n        assert(xs.skip(1).len() == xs.len() - 1);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn length_foldr_correct<A>(xs: Seq<A>)\n    ensures length_foldr(xs) == xs.len()\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(length_foldr(xs) == 0);\n    } else {\n        length_foldr_correct(xs.skip(1));\n        assert(length_foldr(xs) == 1 + length_foldr(xs.skip(1)));\n        assert(xs.skip(1).len() == xs.len() - 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "229b0ecd15f0", "function_name": "length_foldr_correct", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_8c8aa235938a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn zero_score_when_none_killed(total: nat)\n    \n    ensures mutation_score(0, total) == 0\n{\n    assert((0 * 100) / total == 0);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn zero_score_when_none_killed(total: nat)\n    requires total > 0\n    ensures mutation_score(0, total) == 0\n{\n    assert((0 * 100) / total == 0);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn zero_score_when_none_killed(total: nat)\n    requires total > 0\n    ensures mutation_score(0, total) == 0\n{\n    assert((0 * 100) / total == 0);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_mutation.rs", "verified": true, "metadata": {"original_id": "8c8aa235938a", "function_name": "zero_score_when_none_killed", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_2cc966840512", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >)  ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "2cc966840512", "function_name": "replace_with_colon", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_689fefa6b937", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_some_ignores_default<A>(x: A, default: A)\n    \n{\n    // Trivially true\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_some_ignores_default<A>(x: A, default: A)\n    ensures unwrap_or(Option::Some(x), default) == x\n{\n    // Trivially true\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_some_ignores_default<A>(x: A, default: A)\n    ensures unwrap_or(Option::Some(x), default) == x\n{\n    // Trivially true\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_default.rs", "verified": true, "metadata": {"original_id": "689fefa6b937", "function_name": "unwrap_or_some_ignores_default", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_811f2eecaa4d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn skip_search_fuel(sl: SkipList, key: nat, level: nat, current: nat, fuel: nat) -> bool\n    {\n    if fuel == 0 {\n        false\n    } else if current >= sl.nodes.len() {\n        false\n    } else if sl.nodes[current as int].key == key {\n        true\n    } else if level > 0 {\n        // Try lower level\n        skip_search_fuel(sl, key, (level - 1) as nat, current, (fuel - 1) as nat)\n    } else if sl.nodes[current as int].forward.len() > 0 {\n        // Move forward at level 0\n        let next = sl.nodes[current as int].forward[0];\n        if next < sl.nodes.len() && next != current {\n            skip_search_fuel(sl, key, 0, next, (fuel - 1) as nat)\n        } else {\n            false\n        }\n    } else {\n        false\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn skip_search_fuel(sl: SkipList, key: nat, level: nat, current: nat, fuel: nat) -> bool\n    decreases fuel\n{\n    if fuel == 0 {\n        false\n    } else if current >= sl.nodes.len() {\n        false\n    } else if sl.nodes[current as int].key == key {\n        true\n    } else if level > 0 {\n        // Try lower level\n        skip_search_fuel(sl, key, (level - 1) as nat, current, (fuel - 1) as nat)\n    } else if sl.nodes[current as int].forward.len() > 0 {\n        // Move forward at level 0\n        let next = sl.nodes[current as int].forward[0];\n        if next < sl.nodes.len() && next != current {\n            skip_search_fuel(sl, key, 0, next, (fuel - 1) as nat)\n        } else {\n            false\n        }\n    } else {\n        false\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn skip_search_fuel(sl: SkipList, key: nat, level: nat, current: nat, fuel: nat) -> bool\n    decreases fuel\n{\n    if fuel == 0 {\n        false\n    } else if current >= sl.nodes.len() {\n        false\n    } else if sl.nodes[current as int].key == key {\n        true\n    } else if level > 0 {\n        // Try lower level\n        skip_search_fuel(sl, key, (level - 1) as nat, current, (fuel - 1) as nat)\n    } else if sl.nodes[current as int].forward.len() > 0 {\n        // Move forward at level 0\n        let next = sl.nodes[current as int].forward[0];\n        if next < sl.nodes.len() && next != current {\n            skip_search_fuel(sl, key, 0, next, (fuel - 1) as nat)\n        } else {\n            false\n        }\n    } else {\n        false\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_skip_list.rs", "verified": true, "metadata": {"original_id": "811f2eecaa4d", "function_name": "skip_search_fuel", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_55e969d48129", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first_element = a [0] ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first_element , decreases a . len () - i { if a [i] != first_element { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first_element = a [0] ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first_element , decreases a . len () - i { if a [i] != first_element { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first_element = a [0] ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first_element , decreases a . len () - i { if a [i] != first_element { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "55e969d48129", "function_name": "has_only_one_distinct_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_305fa8a021b2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () ,  { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "305fa8a021b2", "function_name": "canyon_search_aux", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_c93368c267b1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "c93368c267b1", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_e4f1bab20d97", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "e4f1bab20d97", "function_name": "bubble_inner", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_826b70672971", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN ,  { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "826b70672971", "function_name": "abs", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_f038eb73e65a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len ()  { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f038eb73e65a", "function_name": "mpositive4", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_dbfd245c5fae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dbfd245c5fae", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_863b44090447", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_ge(h: Heap, bound: nat) -> bool\n    {\n    match h {\n        Heap::E => true,\n        Heap::T { priority, left, right } =>\n            priority >= bound &&\n            all_ge(*left, bound) &&\n            all_ge(*right, bound),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_ge(h: Heap, bound: nat) -> bool\n    decreases h\n{\n    match h {\n        Heap::E => true,\n        Heap::T { priority, left, right } =>\n            priority >= bound &&\n            all_ge(*left, bound) &&\n            all_ge(*right, bound),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_ge(h: Heap, bound: nat) -> bool\n    decreases h\n{\n    match h {\n        Heap::E => true,\n        Heap::T { priority, left, right } =>\n            priority >= bound &&\n            all_ge(*left, bound) &&\n            all_ge(*right, bound),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_priqueue_heap.rs", "verified": true, "metadata": {"original_id": "863b44090447", "function_name": "all_ge", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_8d4192fb2564", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; }   result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "8d4192fb2564", "function_name": "array_product", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_f5db45215f15", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_14/verina_advanced_14.rs", "verified": true, "metadata": {"original_id": "f5db45215f15", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_565b6f8306ad", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_iter_4_current.rs", "verified": true, "metadata": {"original_id": "565b6f8306ad", "function_name": "pairs_sum_to_zero", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4d082ffd5263", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4d082ffd5263", "function_name": "extract_rear_chars", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_74247a728380", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn factorial_monotonic(n: nat)\n    requires n > 0\n    \n    decreases n\n{\n    reveal_with_fuel(factorial, 2);\n    // n * (n-1)! >= (n-1)! when n > 0\n    assume(factorial(n) >= factorial((n - 1) as nat));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn factorial_monotonic(n: nat)\n    requires n > 0\n    ensures factorial(n) >= factorial((n - 1) as nat)\n    decreases n\n{\n    reveal_with_fuel(factorial, 2);\n    // n * (n-1)! >= (n-1)! when n > 0\n    assume(factorial(n) >= factorial((n - 1) as nat));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn factorial_monotonic(n: nat)\n    requires n > 0\n    ensures factorial(n) >= factorial((n - 1) as nat)\n    decreases n\n{\n    reveal_with_fuel(factorial, 2);\n    // n * (n-1)! >= (n-1)! when n > 0\n    assume(factorial(n) >= factorial((n - 1) as nat));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_induction.rs", "verified": true, "metadata": {"original_id": "74247a728380", "function_name": "factorial_monotonic", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_bd19d45f01bb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "bd19d45f01bb", "function_name": "min_array", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_9f6bfb281468", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "9f6bfb281468", "function_name": "in_array_exec", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_e5e53c32a53f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) ,  { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e5e53c32a53f", "function_name": "swap", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_cc49ae963741", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_any_none<A, B>(xs: Seq<A>, f: spec_fn(A) -> Option<B>, k: int)\n    requires 0 <= k < xs.len() as int,\n             f(xs[k]) == Option::<B>::None\n    \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(f(xs[0]) == Option::<B>::None);\n    } else {\n        traverse_any_none(xs.skip(1), f, k - 1);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_any_none<A, B>(xs: Seq<A>, f: spec_fn(A) -> Option<B>, k: int)\n    requires 0 <= k < xs.len() as int,\n             f(xs[k]) == Option::<B>::None\n    ensures traverse_seq_option(xs, f) == Option::<Seq<B>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(f(xs[0]) == Option::<B>::None);\n    } else {\n        traverse_any_none(xs.skip(1), f, k - 1);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traverse_any_none<A, B>(xs: Seq<A>, f: spec_fn(A) -> Option<B>, k: int)\n    requires 0 <= k < xs.len() as int,\n             f(xs[k]) == Option::<B>::None\n    ensures traverse_seq_option(xs, f) == Option::<Seq<B>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(f(xs[0]) == Option::<B>::None);\n    } else {\n        traverse_any_none(xs.skip(1), f, k - 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_traversable.rs", "verified": true, "metadata": {"original_id": "cc49ae963741", "function_name": "traverse_any_none", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b812c4a3edf5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_impl.rs", "verified": true, "metadata": {"original_id": "b812c4a3edf5", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_03dece2f4741", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_list_arbitrary<A>(elements: Set<A>, max_len: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_list_arbitrary<A>(elements: Set<A>, max_len: nat)\n    ensures arbitrary_list(elements, max_len).contains(Seq::empty())\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_list_arbitrary<A>(elements: Set<A>, max_len: nat)\n    ensures arbitrary_list(elements, max_len).contains(Seq::empty())\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_arbitrary_list.rs", "verified": true, "metadata": {"original_id": "03dece2f4741", "function_name": "empty_list_arbitrary", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_9c67ef7b3580", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn filter_seq<A>(values: Seq<A>, predicate: spec_fn(A) -> bool) -> Seq<A>\n    {\n    if values.len() == 0 {\n        seq![]\n    } else {\n        let first = values[0];\n        let rest = filter_seq(values.drop_first(), predicate);\n        if predicate(first) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn filter_seq<A>(values: Seq<A>, predicate: spec_fn(A) -> bool) -> Seq<A>\n    decreases values.len()\n{\n    if values.len() == 0 {\n        seq![]\n    } else {\n        let first = values[0];\n        let rest = filter_seq(values.drop_first(), predicate);\n        if predicate(first) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn filter_seq<A>(values: Seq<A>, predicate: spec_fn(A) -> bool) -> Seq<A>\n    decreases values.len()\n{\n    if values.len() == 0 {\n        seq![]\n    } else {\n        let first = values[0];\n        let rest = filter_seq(values.drop_first(), predicate);\n        if predicate(first) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_filter_precondition.rs", "verified": true, "metadata": {"original_id": "9c67ef7b3580", "function_name": "filter_seq", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_52e2f9691e2a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "52e2f9691e2a", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_chapter-2-3_79eb1884c0da", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //\n\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n\n        // show there's no other multiset that'll work.\n\n        output\n        */\n        assume(false);\n\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-2-3.rs", "verified": true, "metadata": {"original_id": "verus_chapter-2-3_79eb1884c0da", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_assert_verus_equality_ddf69b2bb203", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: eq1\nfn equal1(x: u8, y: u8) {\n    let eq1 = x == y;  // means x.eq(y) in Rust\n    let eq2 = y == x;  // means y.eq(x) in Rust\n      // succeeds\n}\n// ANCHOR_END: eq1\n\n/*\n// ANCHOR: eq2\nfn equal2<A: Eq>(x: A, y: A) {\n    let eq1 = x == y; // means x.eq(y) in Rust\n    let eq2 = y == x; // means y.eq(x) in Rust\n     // won't work; we can't be sure that A is an equivalence relation\n}\n// ANCHOR_END: eq2\n*/\n\n// ANCHOR: eq3\nfn equal3(x: u8, y: u8) {\n    assert({\n        let eq1 = x == y;\n        let eq2 = y == x;\n        eq1 ==> eq2\n    });\n}\n// ANCHOR_END: eq3\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: eq1\nfn equal1(x: u8, y: u8) {\n    let eq1 = x == y;  // means x.eq(y) in Rust\n    let eq2 = y == x;  // means y.eq(x) in Rust\n    assert(eq1 ==> eq2);  // succeeds\n}\n// ANCHOR_END: eq1\n\n/*\n// ANCHOR: eq2\nfn equal2<A: Eq>(x: A, y: A) {\n    let eq1 = x == y; // means x.eq(y) in Rust\n    let eq2 = y == x; // means y.eq(x) in Rust\n    assert(eq1 ==> eq2); // won't work; we can't be sure that A is an equivalence relation\n}\n// ANCHOR_END: eq2\n*/\n\n// ANCHOR: eq3\nfn equal3(x: u8, y: u8) {\n    assert({\n        let eq1 = x == y;\n        let eq2 = y == x;\n        eq1 ==> eq2\n    });\n}\n// ANCHOR_END: eq3\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: eq1\nfn equal1(x: u8, y: u8) {\n    let eq1 = x == y;  // means x.eq(y) in Rust\n    let eq2 = y == x;  // means y.eq(x) in Rust\n    assert(eq1 ==> eq2);  // succeeds\n}\n// ANCHOR_END: eq1\n\n/*\n// ANCHOR: eq2\nfn equal2<A: Eq>(x: A, y: A) {\n    let eq1 = x == y; // means x.eq(y) in Rust\n    let eq2 = y == x; // means y.eq(x) in Rust\n    assert(eq1 ==> eq2); // won't work; we can't be sure that A is an equivalence relation\n}\n// ANCHOR_END: eq2\n*/\n\n// ANCHOR: eq3\nfn equal3(x: u8, y: u8) {\n    assert({\n        let eq1 = x == y;\n        let eq2 = y == x;\n        eq1 ==> eq2\n    });\n}\n// ANCHOR_END: eq3\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/equality.rs", "verified": true, "metadata": {"original_id": "verus_equality_ddf69b2bb203", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_ec0669710e30", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ec0669710e30", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_d19a2f294596", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char { new_char } else { str1 [k] }) , decreases str1 @ . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char { new_char } else { str1 [k] }) , decreases str1 @ . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char { new_char } else { str1 [k] }) , decreases str1 @ . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d19a2f294596", "function_name": "replace_chars", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_07ca229a1044", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn sum_to(n: nat) -> nat\n    {\n    if n == 0 { 0 } else { sum_to((n - 1) as nat) + ((n - 1) as nat) }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn sum_to(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { sum_to((n - 1) as nat) + ((n - 1) as nat) }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn sum_to(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 0 } else { sum_to((n - 1) as nat) + ((n - 1) as nat) }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprinciples_verus.rs", "verified": true, "metadata": {"original_id": "07ca229a1044", "function_name": "sum_to", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_b9ac506e9e48", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "b9ac506e9e48", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_fb494ff22b85", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)  ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "fb494ff22b85", "function_name": "minArray", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_787644ad7cc8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn disj_elim(p: bool, q: bool, r: bool)\n    \n    ensures r\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn disj_elim(p: bool, q: bool, r: bool)\n    requires p || q, p ==> r, q ==> r\n    ensures r\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn disj_elim(p: bool, q: bool, r: bool)\n    requires p || q, p ==> r, q ==> r\n    ensures r\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_disjunction.rs", "verified": true, "metadata": {"original_id": "787644ad7cc8", "function_name": "disj_elim", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_381dfa033c22", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key ,  { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "381dfa033c22", "function_name": "binary_search_loop", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_dfd9edf0ce2b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ,  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dfd9edf0ce2b", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_347c52913eba", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_elim_left(p: bool, q: bool)\n    requires p && q\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_elim_left(p: bool, q: bool)\n    requires p && q\n    ensures p\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_elim_left(p: bool, q: bool)\n    requires p && q\n    ensures p\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "347c52913eba", "function_name": "conj_elim_left", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_9d373b11dee8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)  ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9d373b11dee8", "function_name": "compute_avg", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_3661409307fb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool)  ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_impl.rs", "verified": true, "metadata": {"original_id": "3661409307fb", "function_name": "isEven", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2629690925c4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_add_comm_alt(n: nat, m: nat)\n    ensures add(n, m) == add(m, n)\n    {\n    if m == 0 {\n        lemma_add_0_r(n);\n    } else {\n        lemma_add_comm_alt(n, (m - 1) as nat);\n        lemma_add_succ_r(n, (m - 1) as nat);\n        // add(m,n) unfolds on m, so we also need succ on the other side\n        // via commutativity on smaller m:\n        lemma_add_comm((m - 1) as nat, n);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_add_comm_alt(n: nat, m: nat)\n    ensures add(n, m) == add(m, n)\n    decreases m\n{\n    if m == 0 {\n        lemma_add_0_r(n);\n    } else {\n        lemma_add_comm_alt(n, (m - 1) as nat);\n        lemma_add_succ_r(n, (m - 1) as nat);\n        // add(m,n) unfolds on m, so we also need succ on the other side\n        // via commutativity on smaller m:\n        lemma_add_comm((m - 1) as nat, n);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_add_comm_alt(n: nat, m: nat)\n    ensures add(n, m) == add(m, n)\n    decreases m\n{\n    if m == 0 {\n        lemma_add_0_r(n);\n    } else {\n        lemma_add_comm_alt(n, (m - 1) as nat);\n        lemma_add_succ_r(n, (m - 1) as nat);\n        // add(m,n) unfolds on m, so we also need succ on the other side\n        // via commutativity on smaller m:\n        lemma_add_comm((m - 1) as nat, n);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprinciples_verus.rs", "verified": true, "metadata": {"original_id": "2629690925c4", "function_name": "lemma_add_comm_alt", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_5881a4fc6b4b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_none_is_default<A>(default: A)\n    \n{\n    // Trivially true\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_none_is_default<A>(default: A)\n    ensures unwrap_or(Option::None, default) == default\n{\n    // Trivially true\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn unwrap_or_none_is_default<A>(default: A)\n    ensures unwrap_or(Option::None, default) == default\n{\n    // Trivially true\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_default.rs", "verified": true, "metadata": {"original_id": "5881a4fc6b4b", "function_name": "unwrap_or_none_is_default", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1a2824875b68", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1a2824875b68", "function_name": "Triple1", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_ac591ad72f9a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "ac591ad72f9a", "function_name": "is_integer", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_bda45de2df39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "bda45de2df39", "function_name": "element_wise_divide", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_8b7ef890f90f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "8b7ef890f90f", "function_name": "has_only_one_distinct_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_3ec4aa8d4a38", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN ,  { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/abs_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3ec4aa8d4a38", "function_name": "abs", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_c5833f44f944", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len ()  { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len () invariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - index , { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len () invariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - index , { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "c5833f44f944", "function_name": "bit_wise_xor", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_3aa4fc4de8e2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_43/verina_advanced_43.rs", "verified": true, "metadata": {"original_id": "3aa4fc4de8e2", "function_name": "max_strength", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_f134f43fe138", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)  ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "f134f43fe138", "function_name": "replace_last_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_7c6e3b769730", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_71/verina_advanced_71_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7c6e3b769730", "function_name": "shortest_beautiful_substring", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_55bb3c0dfb79", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "55bb3c0dfb79", "function_name": "replace_with_colon", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4f2d31fc8adb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "4f2d31fc8adb", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_04911af74c2c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool)  ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "04911af74c2c", "function_name": "isEven", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1cb00516fc41", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] ,  { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) ,  { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "1cb00516fc41", "function_name": "min_array", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_18e19141fc74", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "18e19141fc74", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_0459c1a200ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)  ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0459c1a200ec", "function_name": "replace_last_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_16311594898c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_non_prime_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16311594898c", "function_name": "is_non_prime", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_c15c8ee8bdd1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_label_helper(props: Seq<LabeledProp>, target: Label, idx: int) -> nat\n    {\n    if idx >= props.len() {\n        0\n    } else {\n        let count = if label_eq(props[idx].label, target) { 1 as nat } else { 0 as nat };\n        count + count_label_helper(props, target, idx + 1)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_label_helper(props: Seq<LabeledProp>, target: Label, idx: int) -> nat\n    decreases props.len() - idx\n{\n    if idx >= props.len() {\n        0\n    } else {\n        let count = if label_eq(props[idx].label, target) { 1 as nat } else { 0 as nat };\n        count + count_label_helper(props, target, idx + 1)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_label_helper(props: Seq<LabeledProp>, target: Label, idx: int) -> nat\n    decreases props.len() - idx\n{\n    if idx >= props.len() {\n        0\n    } else {\n        let count = if label_eq(props[idx].label, target) { 1 as nat } else { 0 as nat };\n        count + count_label_helper(props, target, idx + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_label.rs", "verified": true, "metadata": {"original_id": "c15c8ee8bdd1", "function_name": "count_label_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_3fa3f6e6b06f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 ,  { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "3fa3f6e6b06f", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_modules_7ab9b4d9aaf0", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nmod M1 {\n    use verus_builtin::*;\n\n    spec fn f1(i: int) -> int {\n        i + 1\n    }\n\n    pub closed spec fn f2(i: int) -> int {\n        f1(i) + 1\n    }\n\n}\n\nmod M2 {\n    use crate::M1::f2;\n    #[allow(unused_imports)]\n    use verus_builtin::*;\n\n    proof fn P() {\n        //  // FAILS, since f2 is closed (abstract)\n\n    }\n\n}\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nmod M1 {\n    use verus_builtin::*;\n\n    spec fn f1(i: int) -> int {\n        i + 1\n    }\n\n    pub closed spec fn f2(i: int) -> int {\n        f1(i) + 1\n    }\n\n}\n\nmod M2 {\n    use crate::M1::f2;\n    #[allow(unused_imports)]\n    use verus_builtin::*;\n\n    proof fn P() {\n        // assert(f2(10) == 12); // FAILS, since f2 is closed (abstract)\n        assert(f2(10) == f2(10));\n    }\n\n}\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nmod M1 {\n    use verus_builtin::*;\n\n    spec fn f1(i: int) -> int {\n        i + 1\n    }\n\n    pub closed spec fn f2(i: int) -> int {\n        f1(i) + 1\n    }\n\n}\n\nmod M2 {\n    use crate::M1::f2;\n    #[allow(unused_imports)]\n    use verus_builtin::*;\n\n    proof fn P() {\n        // assert(f2(10) == 12); // FAILS, since f2 is closed (abstract)\n        assert(f2(10) == f2(10));\n    }\n\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/modules.rs", "verified": true, "metadata": {"original_id": "verus_modules_7ab9b4d9aaf0", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_29d9c6a0ca2c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_15/verina_advanced_15.rs", "verified": true, "metadata": {"original_id": "29d9c6a0ca2c", "function_name": "loop_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_e7d4b3a9c731", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/035-max-element_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e7d4b3a9c731", "function_name": "max_element", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_5114314b0258", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | p : int , q : int | 0 <= p < q < c . len () ==> c [p] != c [q] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | p : int , q : int | 0 <= p < q < c . len () ==> c [p] != c [q] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | p : int , q : int | 0 <= p < q < c . len () ==> c [p] != c [q] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "5114314b0258", "function_name": "remove_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_91799f90b830", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    \n    ensures shrink_nat_dec(n) < n\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    requires n > 0\n    ensures shrink_nat_dec(n) < n\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    requires n > 0\n    ensures shrink_nat_dec(n) < n\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_shrinking.rs", "verified": true, "metadata": {"original_id": "91799f90b830", "function_name": "verify_shrink_nat_dec_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_91f1d089a6f4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_all_pass()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_all_pass()\n    ensures all_pass(seq![])\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_all_pass()\n    ensures all_pass(seq![])\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_checker_property.rs", "verified": true, "metadata": {"original_id": "91f1d089a6f4", "function_name": "empty_all_pass", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_3658fda3df08", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eq_seq_helper<T>(s1: Seq<T>, s2: Seq<T>, eq_t: spec_fn(T, T) -> bool, idx: int) -> bool\n    {\n    if idx >= s1.len() {\n        true\n    } else {\n        eq_t(s1[idx], s2[idx]) && eq_seq_helper(s1, s2, eq_t, idx + 1)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eq_seq_helper<T>(s1: Seq<T>, s2: Seq<T>, eq_t: spec_fn(T, T) -> bool, idx: int) -> bool\n    decreases s1.len() - idx\n{\n    if idx >= s1.len() {\n        true\n    } else {\n        eq_t(s1[idx], s2[idx]) && eq_seq_helper(s1, s2, eq_t, idx + 1)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn eq_seq_helper<T>(s1: Seq<T>, s2: Seq<T>, eq_t: spec_fn(T, T) -> bool, idx: int) -> bool\n    decreases s1.len() - idx\n{\n    if idx >= s1.len() {\n        true\n    } else {\n        eq_t(s1[idx], s2[idx]) && eq_seq_helper(s1, s2, eq_t, idx + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_eq.rs", "verified": true, "metadata": {"original_id": "3658fda3df08", "function_name": "eq_seq_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_e4f1bab20d97", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "e4f1bab20d97", "function_name": "bubble_inner", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_907a56a58ae6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len ()  { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t { if l [i] >= t { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/052-below-threshold_impl.rs", "verified": true, "metadata": {"original_id": "907a56a58ae6", "function_name": "below_threshold", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_3b59283454f1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] ,  { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) ,  { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3b59283454f1", "function_name": "append", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_798a03f8287d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "798a03f8287d", "function_name": "intersection", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_bc7ae17467e2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_9/verina_basic_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "bc7ae17467e2", "function_name": "has_common_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_ca87cb45cbfd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int)  ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32)  ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ca87cb45cbfd", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_08fa248ef5f5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "08fa248ef5f5", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1e49587ef937", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_weight()\n    \n{\n    assert(type_frequency(Ty::TBool) == 10);\n    assert(type_frequency(Ty::TNat) == 10);\n    assert(type_frequency(Ty::TUnit) == 5);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_weight()\n    ensures base_type_total_weight() == 25\n{\n    assert(type_frequency(Ty::TBool) == 10);\n    assert(type_frequency(Ty::TNat) == 10);\n    assert(type_frequency(Ty::TUnit) == 5);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_type_weight()\n    ensures base_type_total_weight() == 25\n{\n    assert(type_frequency(Ty::TBool) == 10);\n    assert(type_frequency(Ty::TNat) == 10);\n    assert(type_frequency(Ty::TUnit) == 5);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_gen_type.rs", "verified": true, "metadata": {"original_id": "1e49587ef937", "function_name": "base_type_weight", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_12e79e5822de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "12e79e5822de", "function_name": "barrier", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_ca25f043cf9a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ca25f043cf9a", "function_name": "up_while_less", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_31c37bb1c785", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn step(t1: Tm, t2: Tm) -> bool\n    {\n    match t1 {\n        // ST_AppAbs: (\\x:T.t) v --> [x:=v]t (beta reduction)\n        Tm::App { t1: func, t2: arg } => {\n            match *func {\n                Tm::Abs { x, ty: _, body } if value(*arg) =>\n                    t2 == subst(x, *arg, *body),\n                _ => {\n                    // ST_App1: t1 --> t1' => t1 t2 --> t1' t2\n                    if !value(*func) {\n                        exists|func_prime: Tm| step(*func, func_prime) &&\n                            t2 == Tm::App { t1: Box::new(func_prime), t2: arg }\n                    }\n                    // ST_App2: t2 --> t2' => v1 t2 --> v1 t2'\n                    else if value(*func) && !value(*arg) {\n                        exists|arg_prime: Tm| step(*arg, arg_prime) &&\n                            t2 == Tm::App { t1: func, t2: Box::new(arg_prime) }\n                    }\n                    else {\n                        false\n                    }\n                }\n            }\n        }\n        // ST_IfTrue\n        Tm::Ite { cond, then_br, else_br } => {\n            match *cond {\n                Tm::Tru => t2 == *then_br,\n                Tm::Fls => t2 == *else_br,\n                // ST_If: cond --> cond'\n                _ => exists|cond_prime: Tm| step(*cond, cond_prime) &&\n                    t2 == Tm::Ite { cond: Box::new(cond_prime), then_br, else_br }\n            }\n        }\n        _ => false,\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn step(t1: Tm, t2: Tm) -> bool\n    decreases t1\n{\n    match t1 {\n        // ST_AppAbs: (\\x:T.t) v --> [x:=v]t (beta reduction)\n        Tm::App { t1: func, t2: arg } => {\n            match *func {\n                Tm::Abs { x, ty: _, body } if value(*arg) =>\n                    t2 == subst(x, *arg, *body),\n                _ => {\n                    // ST_App1: t1 --> t1' => t1 t2 --> t1' t2\n                    if !value(*func) {\n                        exists|func_prime: Tm| step(*func, func_prime) &&\n                            t2 == Tm::App { t1: Box::new(func_prime), t2: arg }\n                    }\n                    // ST_App2: t2 --> t2' => v1 t2 --> v1 t2'\n                    else if value(*func) && !value(*arg) {\n                        exists|arg_prime: Tm| step(*arg, arg_prime) &&\n                            t2 == Tm::App { t1: func, t2: Box::new(arg_prime) }\n                    }\n                    else {\n                        false\n                    }\n                }\n            }\n        }\n        // ST_IfTrue\n        Tm::Ite { cond, then_br, else_br } => {\n            match *cond {\n                Tm::Tru => t2 == *then_br,\n                Tm::Fls => t2 == *else_br,\n                // ST_If: cond --> cond'\n                _ => exists|cond_prime: Tm| step(*cond, cond_prime) &&\n                    t2 == Tm::Ite { cond: Box::new(cond_prime), then_br, else_br }\n            }\n        }\n        _ => false,\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn step(t1: Tm, t2: Tm) -> bool\n    decreases t1\n{\n    match t1 {\n        // ST_AppAbs: (\\x:T.t) v --> [x:=v]t (beta reduction)\n        Tm::App { t1: func, t2: arg } => {\n            match *func {\n                Tm::Abs { x, ty: _, body } if value(*arg) =>\n                    t2 == subst(x, *arg, *body),\n                _ => {\n                    // ST_App1: t1 --> t1' => t1 t2 --> t1' t2\n                    if !value(*func) {\n                        exists|func_prime: Tm| step(*func, func_prime) &&\n                            t2 == Tm::App { t1: Box::new(func_prime), t2: arg }\n                    }\n                    // ST_App2: t2 --> t2' => v1 t2 --> v1 t2'\n                    else if value(*func) && !value(*arg) {\n                        exists|arg_prime: Tm| step(*arg, arg_prime) &&\n                            t2 == Tm::App { t1: func, t2: Box::new(arg_prime) }\n                    }\n                    else {\n                        false\n                    }\n                }\n            }\n        }\n        // ST_IfTrue\n        Tm::Ite { cond, then_br, else_br } => {\n            match *cond {\n                Tm::Tru => t2 == *then_br,\n                Tm::Fls => t2 == *else_br,\n                // ST_If: cond --> cond'\n                _ => exists|cond_prime: Tm| step(*cond, cond_prime) &&\n                    t2 == Tm::Ite { cond: Box::new(cond_prime), then_br, else_br }\n            }\n        }\n        _ => false,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "stlc_verus.rs", "verified": true, "metadata": {"original_id": "31c37bb1c785", "function_name": "step", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_b197612d2de2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b197612d2de2", "function_name": "contains_z", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_ef07e1ebdfb8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)  ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ef07e1ebdfb8", "function_name": "abs", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_295fb6b7020c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () ,  { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "295fb6b7020c", "function_name": "sel_sort", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_6b01cb537ca4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/barrier_impl.rs", "verified": true, "metadata": {"original_id": "6b01cb537ca4", "function_name": "barrier", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_c598d24e772a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_only_one_distinct_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c598d24e772a", "function_name": "has_only_one_distinct_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_add8d9e87bf3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "add8d9e87bf3", "function_name": "max_difference", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_80e5ef23e3da", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)  ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "80e5ef23e3da", "function_name": "append", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_249ab2dbe1ae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) ,  { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "249ab2dbe1ae", "function_name": "all_digits_spec_satisfied", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_f5eb73065f36", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f5eb73065f36", "function_name": "is_odd_at_odd_index", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_c7b4c4028e43", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n  { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "c7b4c4028e43", "function_name": "modp", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_e709ccd63ece", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn contrapositive(a: bool, b: bool)\n    \n{}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn contrapositive(a: bool, b: bool)\n    ensures bool_implies(a, b) == bool_implies(bool_not(b), bool_not(a))\n{}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn contrapositive(a: bool, b: bool)\n    ensures bool_implies(a, b) == bool_implies(bool_not(b), bool_not(a))\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_bool.rs", "verified": true, "metadata": {"original_id": "e709ccd63ece", "function_name": "contrapositive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_42a4c618e7cc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_gt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_gt(t, bound), k > bound\n    ensures all_gt(insert(k, v, t), bound)\n    {\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_gt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_gt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_gt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_gt(t, bound), k > bound\n    ensures all_gt(insert(k, v, t), bound)\n    decreases t\n{\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_gt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_gt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_all_gt(k: nat, v: nat, t: Tree, bound: nat)\n    requires all_gt(t, bound), k > bound\n    ensures all_gt(insert(k, v, t), bound)\n    decreases t\n{\n    reveal_with_fuel(forall_tree, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_all_gt(k, v, *left, bound);\n            } else if k > key {\n                insert_all_gt(k, v, *right, bound);\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_invariant.rs", "verified": true, "metadata": {"original_id": "42a4c618e7cc", "function_name": "insert_all_gt", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_671720bd3098", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_zero()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_zero()\n    ensures witness_zero() == 0\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_zero()\n    ensures witness_zero() == 0\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "671720bd3098", "function_name": "verify_witness_zero", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_132c2652b22c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_477_iter_2_current.rs", "verified": true, "metadata": {"original_id": "132c2652b22c", "function_name": "to_lowercase", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_verus_interner_63d8677f4199", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        {\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/interner.rs", "verified": true, "metadata": {"original_id": "verus_interner_63d8677f4199", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_7db8c481a5c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_beq_nat_sym(n: nat, m: nat)\n    ensures beq_nat(n, m) == beq_nat(m, n)\n    {\n    if n == 0 {\n        if m == 0 {\n            assert(beq_nat(0, 0));\n        } else {\n            assert(beq_nat(0, m) == false);\n            assert(beq_nat(m, 0) == false);\n        }\n    } else {\n        if m == 0 {\n            assert(beq_nat(n, 0) == false);\n            assert(beq_nat(0, n) == false);\n        } else {\n            let n1 = (n - 1) as nat;\n            let m1 = (m - 1) as nat;\n            ex7_beq_nat_sym(n1, m1);\n            assert(beq_nat(n, m) == beq_nat(n1, m1));\n            assert(beq_nat(m, n) == beq_nat(m1, n1));\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_beq_nat_sym(n: nat, m: nat)\n    ensures beq_nat(n, m) == beq_nat(m, n)\n    decreases n\n{\n    if n == 0 {\n        if m == 0 {\n            assert(beq_nat(0, 0));\n        } else {\n            assert(beq_nat(0, m) == false);\n            assert(beq_nat(m, 0) == false);\n        }\n    } else {\n        if m == 0 {\n            assert(beq_nat(n, 0) == false);\n            assert(beq_nat(0, n) == false);\n        } else {\n            let n1 = (n - 1) as nat;\n            let m1 = (m - 1) as nat;\n            ex7_beq_nat_sym(n1, m1);\n            assert(beq_nat(n, m) == beq_nat(n1, m1));\n            assert(beq_nat(m, n) == beq_nat(m1, n1));\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_beq_nat_sym(n: nat, m: nat)\n    ensures beq_nat(n, m) == beq_nat(m, n)\n    decreases n\n{\n    if n == 0 {\n        if m == 0 {\n            assert(beq_nat(0, 0));\n        } else {\n            assert(beq_nat(0, m) == false);\n            assert(beq_nat(m, 0) == false);\n        }\n    } else {\n        if m == 0 {\n            assert(beq_nat(n, 0) == false);\n            assert(beq_nat(0, n) == false);\n        } else {\n            let n1 = (n - 1) as nat;\n            let m1 = (m - 1) as nat;\n            ex7_beq_nat_sym(n1, m1);\n            assert(beq_nat(n, m) == beq_nat(n1, m1));\n            assert(beq_nat(m, n) == beq_nat(m1, n1));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "induction_verus.rs", "verified": true, "metadata": {"original_id": "7db8c481a5c3", "function_name": "ex7_beq_nat_sym", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_5876a4969db2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)  ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5876a4969db2", "function_name": "test_array_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_a20861a306ed", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "a20861a306ed", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_14011bb7b030", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "14011bb7b030", "function_name": "is_odd_at_odd_index", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_b843b3e80d44", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b843b3e80d44", "function_name": "to_uppercase", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_b11a90b961d4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize) requires length_of_lis_precond (nums) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize) requires length_of_lis_precond (nums) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_25/verina_advanced_25_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b11a90b961d4", "function_name": "length_of_lis", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f7d380262e19", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_sym(b1: Bag, b2: Bag)\n    requires bag_eq(b1, b2)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_sym(b1: Bag, b2: Bag)\n    requires bag_eq(b1, b2)\n    ensures bag_eq(b2, b1)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_sym(b1: Bag, b2: Bag)\n    requires bag_eq(b1, b2)\n    ensures bag_eq(b2, b1)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_multiset_perm.rs", "verified": true, "metadata": {"original_id": "f7d380262e19", "function_name": "bag_eq_sym", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_35193b4cfc3c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_bst(k: nat, v: nat, t: Tree)\n    requires is_bst(t)\n    ensures is_bst(insert(k, v, t))\n    {\n    reveal_with_fuel(is_bst, 2);\n    reveal_with_fuel(forall_tree, 2);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_bst(k, v, *left);\n                insert_all_lt(k, v, *left, key);\n            } else if k > key {\n                insert_bst(k, v, *right);\n                insert_all_gt(k, v, *right, key);\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_bst(k: nat, v: nat, t: Tree)\n    requires is_bst(t)\n    ensures is_bst(insert(k, v, t))\n    decreases t\n{\n    reveal_with_fuel(is_bst, 2);\n    reveal_with_fuel(forall_tree, 2);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_bst(k, v, *left);\n                insert_all_lt(k, v, *left, key);\n            } else if k > key {\n                insert_bst(k, v, *right);\n                insert_all_gt(k, v, *right, key);\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn insert_bst(k: nat, v: nat, t: Tree)\n    requires is_bst(t)\n    ensures is_bst(insert(k, v, t))\n    decreases t\n{\n    reveal_with_fuel(is_bst, 2);\n    reveal_with_fuel(forall_tree, 2);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k < key {\n                insert_bst(k, v, *left);\n                insert_all_lt(k, v, *left, key);\n            } else if k > key {\n                insert_bst(k, v, *right);\n                insert_all_gt(k, v, *right, key);\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_invariant.rs", "verified": true, "metadata": {"original_id": "35193b4cfc3c", "function_name": "insert_bst", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_16300e4e7930", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum [0] = 5 * N ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s5if_impl.rs", "verified": true, "metadata": {"original_id": "16300e4e7930", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_42262fbd4b9c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () ,  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/permutations_iter_0_original.rs", "verified": true, "metadata": {"original_id": "42262fbd4b9c", "function_name": "backtrack", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_402d55fb00aa", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_807_iter_4_current.rs", "verified": true, "metadata": {"original_id": "402d55fb00aa", "function_name": "find_first_odd", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_afa8ad47d9ce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "afa8ad47d9ce", "function_name": "barrier", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_ee0ef33b3821", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ee0ef33b3821", "function_name": "is_even_at_even_index", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_1d152138ffd0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_size(t: Ty) -> nat\n    {\n    match t {\n        Ty::TBool => 1,\n        Ty::TNat => 1,\n        Ty::TUnit => 1,\n        Ty::TProd { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TSum { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TArrow { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_size(t: Ty) -> nat\n    decreases t\n{\n    match t {\n        Ty::TBool => 1,\n        Ty::TNat => 1,\n        Ty::TUnit => 1,\n        Ty::TProd { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TSum { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TArrow { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_size(t: Ty) -> nat\n    decreases t\n{\n    match t {\n        Ty::TBool => 1,\n        Ty::TNat => 1,\n        Ty::TUnit => 1,\n        Ty::TProd { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TSum { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n        Ty::TArrow { t1, t2 } => 1 + ty_size(*t1) + ty_size(*t2),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_gen_type.rs", "verified": true, "metadata": {"original_id": "1d152138ffd0", "function_name": "ty_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_322003b623b8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_imp_trans(a: bool, b: bool, c: bool)\n    \n    ensures a ==> c\n{\n    // Proof object: a function from a proof of a to a proof of c.\n    assert(a ==> c) by {\n        if a {\n            assert(b);\n            assert(c);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_imp_trans(a: bool, b: bool, c: bool)\n    requires a ==> b,\n        b ==> c,\n    ensures a ==> c\n{\n    // Proof object: a function from a proof of a to a proof of c.\n    assert(a ==> c) by {\n        if a {\n            assert(b);\n            assert(c);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_imp_trans(a: bool, b: bool, c: bool)\n    requires a ==> b,\n        b ==> c,\n    ensures a ==> c\n{\n    // Proof object: a function from a proof of a to a proof of c.\n    assert(a ==> c) by {\n        if a {\n            assert(b);\n            assert(c);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "proofobjects_verus.rs", "verified": true, "metadata": {"original_id": "322003b623b8", "function_name": "lemma_imp_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_assert_by_compute_a4dde075646d", "task": "task_c", "input_text": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //  // Fails without more fuel\n\n          // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        //\n\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //\n    spec const v: int = 1;\n\n    fn crc_compute() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //\n    spec const v: int = 1;\n\n    fn crc_compute() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        //\n    }\n\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/assert_by_compute.rs", "verified": true, "metadata": {"original_id": "verus_assert_by_compute_a4dde075646d", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_9e3fe7c4a116", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_insert_different(m: M, k1: Key, k2: Key, v2: int)\n    \n    ensures m.insert(k2, v2)[k1] == m[k1]\n{\n    axiom_map_insert_different(m, k1, k2, v2);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_insert_different(m: M, k1: Key, k2: Key, v2: int)\n    requires k1 != k2\n    ensures m.insert(k2, v2)[k1] == m[k1]\n{\n    axiom_map_insert_different(m, k1, k2, v2);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_insert_different(m: M, k1: Key, k2: Key, v2: int)\n    requires k1 != k2\n    ensures m.insert(k2, v2)[k1] == m[k1]\n{\n    axiom_map_insert_different(m, k1, k2, v2);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "auto_verus.rs", "verified": true, "metadata": {"original_id": "9e3fe7c4a116", "function_name": "lemma_insert_different", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6aabc074f1ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_range_len(r: Range) requires range_empty(r)  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_range_len(r: Range) requires range_empty(r) ensures range_len(r) == 0 {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_range_len(r: Range) requires range_empty(r) ensures range_len(r) == 0 {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_range_def.rs", "verified": true, "metadata": {"original_id": "6aabc074f1ea", "function_name": "empty_range_len", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_6269b9f91ab1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6269b9f91ab1", "function_name": "contains_k", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_8d4192fb2564", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)  ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "8d4192fb2564", "function_name": "array_product", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_b11d94c23d98", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b11d94c23d98", "function_name": "to_toggle_case", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_4967f9d6b7bc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_plus_n_Sm(n: nat, m: nat)\n    ensures add(n, m + 1) == add(n, m) + 1\n    {\n    if n == 0 {\n        assert(add(0, m + 1) == m + 1);\n        assert(add(0, m) + 1 == m + 1);\n    } else {\n        let n1 = (n - 1) as nat;\n        ex2_plus_n_Sm(n1, m);\n        assert(add(n, m + 1) == add(n1, m + 1) + 1);\n        assert(add(n, m) == add(n1, m) + 1);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_plus_n_Sm(n: nat, m: nat)\n    ensures add(n, m + 1) == add(n, m) + 1\n    decreases n\n{\n    if n == 0 {\n        assert(add(0, m + 1) == m + 1);\n        assert(add(0, m) + 1 == m + 1);\n    } else {\n        let n1 = (n - 1) as nat;\n        ex2_plus_n_Sm(n1, m);\n        assert(add(n, m + 1) == add(n1, m + 1) + 1);\n        assert(add(n, m) == add(n1, m) + 1);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_plus_n_Sm(n: nat, m: nat)\n    ensures add(n, m + 1) == add(n, m) + 1\n    decreases n\n{\n    if n == 0 {\n        assert(add(0, m + 1) == m + 1);\n        assert(add(0, m) + 1 == m + 1);\n    } else {\n        let n1 = (n - 1) as nat;\n        ex2_plus_n_Sm(n1, m);\n        assert(add(n, m + 1) == add(n1, m + 1) + 1);\n        assert(add(n, m) == add(n1, m) + 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "induction_verus.rs", "verified": true, "metadata": {"original_id": "4967f9d6b7bc", "function_name": "ex2_plus_n_Sm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_34d3c66c04a9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn shrink_option<A>(o: Option<A>, shrunk_as: Seq<A>) -> Seq<Option<A>>\n    where A: std::marker::Copy\n    {\n    match o {\n        Option::None => seq![],\n        Option::Some(a) => {\n            seq![Option::None] + shrunk_as.map(|_i: int, x: A| Option::Some(x))\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn shrink_option<A>(o: Option<A>, shrunk_as: Seq<A>) -> Seq<Option<A>>\n    where A: std::marker::Copy\n    decreases shrunk_as.len()\n{\n    match o {\n        Option::None => seq![],\n        Option::Some(a) => {\n            seq![Option::None] + shrunk_as.map(|_i: int, x: A| Option::Some(x))\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn shrink_option<A>(o: Option<A>, shrunk_as: Seq<A>) -> Seq<Option<A>>\n    where A: std::marker::Copy\n    decreases shrunk_as.len()\n{\n    match o {\n        Option::None => seq![],\n        Option::Some(a) => {\n            seq![Option::None] + shrunk_as.map(|_i: int, x: A| Option::Some(x))\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_shrink_option.rs", "verified": true, "metadata": {"original_id": "34d3c66c04a9", "function_name": "shrink_option", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1d7d08671bf8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_option_is_none<A>()\n    \n{\n    // Trivially true by definition\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_option_is_none<A>()\n    ensures default_option::<A>() == Option::<A>::None\n{\n    // Trivially true by definition\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn default_option_is_none<A>()\n    ensures default_option::<A>() == Option::<A>::None\n{\n    // Trivially true by definition\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_default.rs", "verified": true, "metadata": {"original_id": "1d7d08671bf8", "function_name": "default_option_is_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_5e43ef69574e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)  ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "5e43ef69574e", "function_name": "max_array", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_61718e46195d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> 0 <= i < arr1 . len () && 0 <= i < arr2 . len () && result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , {   result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> 0 <= i < arr1 . len () && 0 <= i < arr2 . len () && result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> 0 <= i < arr1 . len () && 0 <= i < arr2 . len () && result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "61718e46195d", "function_name": "bit_wise_xor", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_92d9db1ecdcf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "92d9db1ecdcf", "function_name": "binary_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_ee0ef33b3821", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ee0ef33b3821", "function_name": "is_even_at_even_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_f7a6038f28f2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lam_eval_closure(env: Env, x: Id, ty: Ty, body: Expr, fuel: nat)\n    \n    ensures\n        is_ok(eval(env, lam_expr(x, ty, body), fuel)),\n        is_closure_val(get_value(eval(env, lam_expr(x, ty, body), fuel))),\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lam_eval_closure(env: Env, x: Id, ty: Ty, body: Expr, fuel: nat)\n    requires fuel >= 1\n    ensures\n        is_ok(eval(env, lam_expr(x, ty, body), fuel)),\n        is_closure_val(get_value(eval(env, lam_expr(x, ty, body), fuel))),\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lam_eval_closure(env: Env, x: Id, ty: Ty, body: Expr, fuel: nat)\n    requires fuel >= 1\n    ensures\n        is_ok(eval(env, lam_expr(x, ty, body), fuel)),\n        is_closure_val(get_value(eval(env, lam_expr(x, ty, body), fuel))),\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_eval.rs", "verified": true, "metadata": {"original_id": "f7a6038f28f2", "function_name": "lam_eval_closure", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_7661e9ef7394", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_fst_contains<A, B>(outputs: Set<(A, B)>, a: A, b: B)\n    \n    ensures gen_pair_fst(outputs).contains(a)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_fst_contains<A, B>(outputs: Set<(A, B)>, a: A, b: B)\n    requires outputs.contains((a, b))\n    ensures gen_pair_fst(outputs).contains(a)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_fst_contains<A, B>(outputs: Set<(A, B)>, a: A, b: B)\n    requires outputs.contains((a, b))\n    ensures gen_pair_fst(outputs).contains(a)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_pair.rs", "verified": true, "metadata": {"original_id": "7661e9ef7394", "function_name": "gen_pair_fst_contains", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2f8692a729d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2f8692a729d3", "function_name": "myfun", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_7c99829d20b4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7c99829d20b4", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_d63a421d19cf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_u8_in_bounds(n: nat)\n    \n    ensures in_bounds_u8(n)\n{\n    assert(0 <= n);\n    assert(n <= 255);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_u8_in_bounds(n: nat)\n    requires n <= 255\n    ensures in_bounds_u8(n)\n{\n    assert(0 <= n);\n    assert(n <= 255);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_u8_in_bounds(n: nat)\n    requires n <= 255\n    ensures in_bounds_u8(n)\n{\n    assert(0 <= n);\n    assert(n <= 255);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_bounded.rs", "verified": true, "metadata": {"original_id": "d63a421d19cf", "function_name": "all_u8_in_bounds", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_agreement_d4fe5ceec4fe", "task": "task_c", "input_text": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//!\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//!\n//!\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//!\n//! proof { r1.lemma_agreement(&mut r2); }\n//!\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n\n    let tracked r2 = r1.duplicate();\n\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "target_text": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "full_verified_code": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/agreement.rs", "verified": true, "metadata": {"original_id": "verus_agreement_d4fe5ceec4fe", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_e6ccf4f32602", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_height<T>(t: Tree<T>) -> nat\n    {\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } => {\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            1 + if lh > rh { lh } else { rh }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_height<T>(t: Tree<T>) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } => {\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            1 + if lh > rh { lh } else { rh }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_height<T>(t: Tree<T>) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } => {\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            1 + if lh > rh { lh } else { rh }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_tree.rs", "verified": true, "metadata": {"original_id": "e6ccf4f32602", "function_name": "tree_height", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_2f04d8216aa8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_always_arbitrary(max_size: nat)\n    \n    ensures arbitrary_tree_sized(max_size).contains(Tree::Leaf)\n{\n    assert(tree_size(Tree::Leaf) == 1);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_always_arbitrary(max_size: nat)\n    requires max_size >= 1\n    ensures arbitrary_tree_sized(max_size).contains(Tree::Leaf)\n{\n    assert(tree_size(Tree::Leaf) == 1);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leaf_always_arbitrary(max_size: nat)\n    requires max_size >= 1\n    ensures arbitrary_tree_sized(max_size).contains(Tree::Leaf)\n{\n    assert(tree_size(Tree::Leaf) == 1);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_arbitrary_tree.rs", "verified": true, "metadata": {"original_id": "2f04d8216aa8", "function_name": "leaf_always_arbitrary", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_24dfb26f36d8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N ,  { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "24dfb26f36d8", "function_name": "down_while_not_equal", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_eaccd11bea3d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_pair_bool(p: (bool, bool))\n    \n{\n    match p {\n        (false, false) => assert(enum_all_pair_bool()[0] == (false, false)),\n        (false, true) => assert(enum_all_pair_bool()[1] == (false, true)),\n        (true, false) => assert(enum_all_pair_bool()[2] == (true, false)),\n        (true, true) => assert(enum_all_pair_bool()[3] == (true, true)),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_pair_bool(p: (bool, bool))\n    ensures enum_all_pair_bool().contains(p)\n{\n    match p {\n        (false, false) => assert(enum_all_pair_bool()[0] == (false, false)),\n        (false, true) => assert(enum_all_pair_bool()[1] == (false, true)),\n        (true, false) => assert(enum_all_pair_bool()[2] == (true, false)),\n        (true, true) => assert(enum_all_pair_bool()[3] == (true, true)),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_all_complete_pair_bool(p: (bool, bool))\n    ensures enum_all_pair_bool().contains(p)\n{\n    match p {\n        (false, false) => assert(enum_all_pair_bool()[0] == (false, false)),\n        (false, true) => assert(enum_all_pair_bool()[1] == (false, true)),\n        (true, false) => assert(enum_all_pair_bool()[2] == (true, false)),\n        (true, true) => assert(enum_all_pair_bool()[3] == (true, true)),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_enum.rs", "verified": true, "metadata": {"original_id": "eaccd11bea3d", "function_name": "enum_all_complete_pair_bool", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8714d34e0d77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "8714d34e0d77", "function_name": "replace_last_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_13e2280c4f23", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn swap_swap_id<T>(s: Seq<T>, i: nat, j: nat)\n    \n    ensures swap_at(swap_at(s, i, j), i, j) =~= s\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn swap_swap_id<T>(s: Seq<T>, i: nat, j: nat)\n    requires i < s.len(), j < s.len()\n    ensures swap_at(swap_at(s, i, j), i, j) =~= s\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn swap_swap_id<T>(s: Seq<T>, i: nat, j: nat)\n    requires i < s.len(), j < s.len()\n    ensures swap_at(swap_at(s, i, j), i, j) =~= s\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_perm_swap.rs", "verified": true, "metadata": {"original_id": "13e2280c4f23", "function_name": "swap_swap_id", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_d1551cc54ff0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)  ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "d1551cc54ff0", "function_name": "myfun4", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_03383a09eecd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)  ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_impl.rs", "verified": true, "metadata": {"original_id": "03383a09eecd", "function_name": "update_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_9f8fba720391", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 ,  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9f8fba720391", "function_name": "myfun4", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_8c58d35ca07b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_beq_nat_refl(n: nat)\n    ensures beq_nat(n, n)\n    {\n    if n == 0 {\n        assert(beq_nat(0, 0));\n    } else {\n        let n1 = (n - 1) as nat;\n        ex6_beq_nat_refl(n1);\n        assert(beq_nat(n, n) == beq_nat(n1, n1));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_beq_nat_refl(n: nat)\n    ensures beq_nat(n, n)\n    decreases n\n{\n    if n == 0 {\n        assert(beq_nat(0, 0));\n    } else {\n        let n1 = (n - 1) as nat;\n        ex6_beq_nat_refl(n1);\n        assert(beq_nat(n, n) == beq_nat(n1, n1));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_beq_nat_refl(n: nat)\n    ensures beq_nat(n, n)\n    decreases n\n{\n    if n == 0 {\n        assert(beq_nat(0, 0));\n    } else {\n        let n1 = (n - 1) as nat;\n        ex6_beq_nat_refl(n1);\n        assert(beq_nat(n, n) == beq_nat(n1, n1));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "induction_verus.rs", "verified": true, "metadata": {"original_id": "8c58d35ca07b", "function_name": "ex6_beq_nat_refl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_616afdc2e333", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn triangle_is_monotonic(i: nat, j: nat)\n    \n    decreases j,\n{\n    if j == 0 {\n    } else {\n        triangle_is_monotonic(i, (j - 1) as nat);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn triangle_is_monotonic(i: nat, j: nat)\n    ensures i <= j ==> triangle(i) <= triangle(j)\n    decreases j,\n{\n    if j == 0 {\n    } else {\n        triangle_is_monotonic(i, (j - 1) as nat);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn triangle_is_monotonic(i: nat, j: nat)\n    ensures i <= j ==> triangle(i) <= triangle(j)\n    decreases j,\n{\n    if j == 0 {\n    } else {\n        triangle_is_monotonic(i, (j - 1) as nat);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "extraction_verus.rs", "verified": true, "metadata": {"original_id": "616afdc2e333", "function_name": "triangle_is_monotonic", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1fa8a0c07d95", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_is_traverse_id<A>(xs: Seq<Option<A>>)\n    \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(sequence_seq_option(xs) == Option::Some(Seq::<A>::empty()));\n        assert(traverse_seq_option(xs, |o: Option<A>| o) == Option::Some(Seq::<A>::empty()));\n    } else {\n        sequence_is_traverse_id(xs.skip(1));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_is_traverse_id<A>(xs: Seq<Option<A>>)\n    ensures sequence_seq_option(xs) == traverse_seq_option(xs, |o: Option<A>| o)\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(sequence_seq_option(xs) == Option::Some(Seq::<A>::empty()));\n        assert(traverse_seq_option(xs, |o: Option<A>| o) == Option::Some(Seq::<A>::empty()));\n    } else {\n        sequence_is_traverse_id(xs.skip(1));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_is_traverse_id<A>(xs: Seq<Option<A>>)\n    ensures sequence_seq_option(xs) == traverse_seq_option(xs, |o: Option<A>| o)\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(sequence_seq_option(xs) == Option::Some(Seq::<A>::empty()));\n        assert(traverse_seq_option(xs, |o: Option<A>| o) == Option::Some(Seq::<A>::empty()));\n    } else {\n        sequence_is_traverse_id(xs.skip(1));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_traversable.rs", "verified": true, "metadata": {"original_id": "1fa8a0c07d95", "function_name": "sequence_is_traverse_id", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_2b6913fa918f", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "2b6913fa918f", "function_name": "clone_option_vec_u8", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_36d1bb095bb5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] ,  { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) ,  { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "36d1bb095bb5", "function_name": "min_array", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_524863d0b4c0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_add(a: nat, b: nat, m: nat)\n    \n    ensures (a + b) % m == ((a % m) + (b % m)) % m\n{\n    assume((a + b) % m == ((a % m) + (b % m)) % m);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_add(a: nat, b: nat, m: nat)\n    requires m > 0\n    ensures (a + b) % m == ((a % m) + (b % m)) % m\n{\n    assume((a + b) % m == ((a % m) + (b % m)) % m);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_add(a: nat, b: nat, m: nat)\n    requires m > 0\n    ensures (a + b) % m == ((a % m) + (b % m)) % m\n{\n    assume((a + b) % m == ((a % m) + (b % m)) % m);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_mod_arith.rs", "verified": true, "metadata": {"original_id": "524863d0b4c0", "function_name": "mod_add", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_ac8769e95854", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "ac8769e95854", "function_name": "is_space_comma_dot", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_0d4bcc21706a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn subst(x: Var, s: Tm, t: Tm) -> Tm\n    {\n    match t {\n        Tm::Var { x: y } => if x == y { s } else { t },\n        Tm::Abs { x: y, ty, body } =>\n            if x == y {\n                t  // x is bound\n            } else {\n                Tm::Abs { x: y, ty, body: Box::new(subst(x, s, *body)) }\n            },\n        Tm::App { t1, t2 } =>\n            Tm::App { t1: Box::new(subst(x, s, *t1)), t2: Box::new(subst(x, s, *t2)) },\n        Tm::Tru => Tm::Tru,\n        Tm::Fls => Tm::Fls,\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn subst(x: Var, s: Tm, t: Tm) -> Tm\n    decreases t\n{\n    match t {\n        Tm::Var { x: y } => if x == y { s } else { t },\n        Tm::Abs { x: y, ty, body } =>\n            if x == y {\n                t  // x is bound\n            } else {\n                Tm::Abs { x: y, ty, body: Box::new(subst(x, s, *body)) }\n            },\n        Tm::App { t1, t2 } =>\n            Tm::App { t1: Box::new(subst(x, s, *t1)), t2: Box::new(subst(x, s, *t2)) },\n        Tm::Tru => Tm::Tru,\n        Tm::Fls => Tm::Fls,\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn subst(x: Var, s: Tm, t: Tm) -> Tm\n    decreases t\n{\n    match t {\n        Tm::Var { x: y } => if x == y { s } else { t },\n        Tm::Abs { x: y, ty, body } =>\n            if x == y {\n                t  // x is bound\n            } else {\n                Tm::Abs { x: y, ty, body: Box::new(subst(x, s, *body)) }\n            },\n        Tm::App { t1, t2 } =>\n            Tm::App { t1: Box::new(subst(x, s, *t1)), t2: Box::new(subst(x, s, *t2)) },\n        Tm::Tru => Tm::Tru,\n        Tm::Fls => Tm::Fls,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "norm_verus.rs", "verified": true, "metadata": {"original_id": "0d4bcc21706a", "function_name": "subst", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_e062fcdb9291", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e062fcdb9291", "function_name": "F", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_a20861a306ed", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "a20861a306ed", "function_name": "linear_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_cda0fddb188b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX  { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cda0fddb188b", "function_name": "append", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_d825a717b1f8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len ()  { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len () invariant 0 < index <= lists . len () , min_length == lists [0] . len () || exists | j : int | # ! [auto] 1 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () , decreases lists . len () - index , { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len () invariant 0 < index <= lists . len () , min_length == lists [0] . len () || exists | j : int | # ! [auto] 1 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () , decreases lists . len () - index , { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "d825a717b1f8", "function_name": "smallest_list_length", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_68ef5666482a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "68ef5666482a", "function_name": "element_wise_division", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_437d26afe3f0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "437d26afe3f0", "function_name": "max_array", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_6c95fc43cfca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)  ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)  ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if left < a . len () && ! a [left] { left += 1 ; } else if right > 0 && a [right - 1] { right -= 1 ; } else if left < right - 1 { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } else { break ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if left < a . len () && ! a [left] { left += 1 ; } else if right > 0 && a [right - 1] { right -= 1 ; } else if left < right - 1 { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } else { break ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if left < a . len () && ! a [left] { left += 1 ; } else if right > 0 && a [right - 1] { right -= 1 ; } else if left < right - 1 { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } else { break ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "6c95fc43cfca", "function_name": "two_way_sort", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_b76aef20e088", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "b76aef20e088", "function_name": "is_even_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_verified-storage_crashinv_t_4ec59bc784c9", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic invariant\n    // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        // invariant held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n\n        {\n            unimplemented!()\n        }\n    }\n}\n", "target_text": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic invariant\n    // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n            ensures\n                result.pred() == pred,\n                result.namespace() == namespace,\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        // invariant held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace(),\n        {\n            unimplemented!()\n        }\n    }\n}\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic invariant\n    // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n            ensures\n                result.pred() == pred,\n                result.namespace() == namespace,\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        // invariant held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace(),\n        {\n            unimplemented!()\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-storage/capybaraKV/capybarakv/src/pmem/crashinv_t.rs", "verified": true, "metadata": {"original_id": "verified-storage_crashinv_t_4ec59bc784c9", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_143e7b8672b2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fib_nonneg(n: nat)\n    \n{\n    // Trivially true since fib returns nat\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fib_nonneg(n: nat)\n    ensures fib(n) >= 0\n{\n    // Trivially true since fib returns nat\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fib_nonneg(n: nat)\n    ensures fib(n) >= 0\n{\n    // Trivially true since fib returns nat\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_induction.rs", "verified": true, "metadata": {"original_id": "143e7b8672b2", "function_name": "fib_nonneg", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_aa48f2dc3b63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn insert<V>(t: Trie<V>, key: Seq<bool>, v: V) -> Trie<V>\n    {\n    if key.len() == 0 {\n        match t {\n            Trie::Leaf => Trie::Node {\n                value: Some(v),\n                left: Box::new(Trie::Leaf),\n                right: Box::new(Trie::Leaf),\n            },\n            Trie::Node { value: _, left, right } => Trie::Node {\n                value: Some(v),\n                left,\n                right,\n            },\n        }\n    } else {\n        match t {\n            Trie::Leaf => {\n                if key[0] {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(Trie::Leaf),\n                        right: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                        right: Box::new(Trie::Leaf),\n                    }\n                }\n            }\n            Trie::Node { value, left, right } => {\n                if key[0] {\n                    Trie::Node {\n                        value,\n                        left,\n                        right: Box::new(insert(*right, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value,\n                        left: Box::new(insert(*left, key.skip(1), v)),\n                        right,\n                    }\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn insert<V>(t: Trie<V>, key: Seq<bool>, v: V) -> Trie<V>\n    decreases key.len()\n{\n    if key.len() == 0 {\n        match t {\n            Trie::Leaf => Trie::Node {\n                value: Some(v),\n                left: Box::new(Trie::Leaf),\n                right: Box::new(Trie::Leaf),\n            },\n            Trie::Node { value: _, left, right } => Trie::Node {\n                value: Some(v),\n                left,\n                right,\n            },\n        }\n    } else {\n        match t {\n            Trie::Leaf => {\n                if key[0] {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(Trie::Leaf),\n                        right: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                        right: Box::new(Trie::Leaf),\n                    }\n                }\n            }\n            Trie::Node { value, left, right } => {\n                if key[0] {\n                    Trie::Node {\n                        value,\n                        left,\n                        right: Box::new(insert(*right, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value,\n                        left: Box::new(insert(*left, key.skip(1), v)),\n                        right,\n                    }\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn insert<V>(t: Trie<V>, key: Seq<bool>, v: V) -> Trie<V>\n    decreases key.len()\n{\n    if key.len() == 0 {\n        match t {\n            Trie::Leaf => Trie::Node {\n                value: Some(v),\n                left: Box::new(Trie::Leaf),\n                right: Box::new(Trie::Leaf),\n            },\n            Trie::Node { value: _, left, right } => Trie::Node {\n                value: Some(v),\n                left,\n                right,\n            },\n        }\n    } else {\n        match t {\n            Trie::Leaf => {\n                if key[0] {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(Trie::Leaf),\n                        right: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value: None,\n                        left: Box::new(insert(Trie::Leaf, key.skip(1), v)),\n                        right: Box::new(Trie::Leaf),\n                    }\n                }\n            }\n            Trie::Node { value, left, right } => {\n                if key[0] {\n                    Trie::Node {\n                        value,\n                        left,\n                        right: Box::new(insert(*right, key.skip(1), v)),\n                    }\n                } else {\n                    Trie::Node {\n                        value,\n                        left: Box::new(insert(*left, key.skip(1), v)),\n                        right,\n                    }\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_trie_ops.rs", "verified": true, "metadata": {"original_id": "aa48f2dc3b63", "function_name": "insert", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_3815f6d0de6e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "3815f6d0de6e", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_ab8f51c2cb7e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "ab8f51c2cb7e", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_000452c4f641", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len ()  { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "000452c4f641", "function_name": "is_product_even", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_f419a57be83c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f419a57be83c", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b1c64b65abfb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX ,  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_even_list/verus_code.rs", "verified": true, "metadata": {"original_id": "b1c64b65abfb", "function_name": "find_even_numbers", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_fc4987386731", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_477_impl.rs", "verified": true, "metadata": {"original_id": "fc4987386731", "function_name": "to_lowercase", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_6b85b014a547", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn add_assoc(a: nat, b: nat, c: nat)  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn add_assoc(a: nat, b: nat, c: nat) ensures (a + b) + c == a + (b + c) {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn add_assoc(a: nat, b: nat, c: nat) ensures (a + b) + c == a + (b + c) {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_monoid.rs", "verified": true, "metadata": {"original_id": "6b85b014a547", "function_name": "add_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_41fdc36900c2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) ,  { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_2/verina_basic_2_impl.rs", "verified": true, "metadata": {"original_id": "41fdc36900c2", "function_name": "find_smallest", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_ef2fc0cb7ed7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN ,  { if x < 0 { - x } else { x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_impl.rs", "verified": true, "metadata": {"original_id": "ef2fc0cb7ed7", "function_name": "abs", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_3fa3f6e6b06f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "3fa3f6e6b06f", "function_name": "myfun", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_2e1491add538", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "2e1491add538", "function_name": "up_while_not_equal", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_ab0e0d93ca25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ab0e0d93ca25", "function_name": "contains", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_7551c5191921", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32)  ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7551c5191921", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1ed56038c628", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1ed56038c628", "function_name": "arithmetic", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_0193ba3f7f53", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_uniform(map: ClassificationMap, tolerance: nat) -> bool\n    {\n    if map.len() <= 1 {\n        true\n    } else {\n        let expected = 100nat / (map.len() as nat);\n        let p = label_percentage(map, map[0].label);\n        let diff = if p >= expected { p - expected } else { expected - p };\n        diff <= tolerance && is_uniform(map.drop_first(), tolerance)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_uniform(map: ClassificationMap, tolerance: nat) -> bool\n    decreases map.len()\n{\n    if map.len() <= 1 {\n        true\n    } else {\n        let expected = 100nat / (map.len() as nat);\n        let p = label_percentage(map, map[0].label);\n        let diff = if p >= expected { p - expected } else { expected - p };\n        diff <= tolerance && is_uniform(map.drop_first(), tolerance)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_uniform(map: ClassificationMap, tolerance: nat) -> bool\n    decreases map.len()\n{\n    if map.len() <= 1 {\n        true\n    } else {\n        let expected = 100nat / (map.len() as nat);\n        let p = label_percentage(map, map[0].label);\n        let diff = if p >= expected { p - expected } else { expected - p };\n        diff <= tolerance && is_uniform(map.drop_first(), tolerance)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_statistics_collect.rs", "verified": true, "metadata": {"original_id": "0193ba3f7f53", "function_name": "is_uniform", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_75b77bb78ae1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn has_type_simple(t: Tm, ty: Ty) -> bool\n    {\n    match t {\n        // Unit\n        Tm::Unit => ty == Ty::TUnit,\n\n        // Booleans\n        Tm::Tru => ty == Ty::TBool,\n        Tm::Fls => ty == Ty::TBool,\n\n        // Naturals\n        Tm::Nat { .. } => ty == Ty::TNat,\n        Tm::Scc { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::Prd { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::IsZro { t } => ty == Ty::TBool && has_type_simple(*t, Ty::TNat),\n\n        // Pairs: (t1, t2) : T1 * T2\n        Tm::Pair { t1, t2 } => {\n            match ty {\n                Ty::TProd { t1: ty1, t2: ty2 } =>\n                    has_type_simple(*t1, *ty1) && has_type_simple(*t2, *ty2),\n                _ => false,\n            }\n        }\n\n        // Fst: t.fst : T1 if t : T1 * T2\n        Tm::Fst { t } => {\n            exists|ty2: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty), t2: Box::new(ty2) })\n        }\n\n        // Snd: t.snd : T2 if t : T1 * T2\n        Tm::Snd { t } => {\n            exists|ty1: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty1), t2: Box::new(ty) })\n        }\n\n        // Inl: inl t as T1+T2 : T1+T2 if t : T1\n        Tm::Inl { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1, t2: _ } => has_type_simple(*t, *t1),\n                _ => false,\n            }\n        }\n\n        // Inr: inr t as T1+T2 : T1+T2 if t : T2\n        Tm::Inr { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1: _, t2 } => has_type_simple(*t, *t2),\n                _ => false,\n            }\n        }\n\n        // Nil: nil T : List T\n        Tm::Nil { ty: elem_ty } => ty == (Ty::TList { t: Box::new(elem_ty) }),\n\n        _ => false,  // Other cases need context\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn has_type_simple(t: Tm, ty: Ty) -> bool\n    decreases t\n{\n    match t {\n        // Unit\n        Tm::Unit => ty == Ty::TUnit,\n\n        // Booleans\n        Tm::Tru => ty == Ty::TBool,\n        Tm::Fls => ty == Ty::TBool,\n\n        // Naturals\n        Tm::Nat { .. } => ty == Ty::TNat,\n        Tm::Scc { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::Prd { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::IsZro { t } => ty == Ty::TBool && has_type_simple(*t, Ty::TNat),\n\n        // Pairs: (t1, t2) : T1 * T2\n        Tm::Pair { t1, t2 } => {\n            match ty {\n                Ty::TProd { t1: ty1, t2: ty2 } =>\n                    has_type_simple(*t1, *ty1) && has_type_simple(*t2, *ty2),\n                _ => false,\n            }\n        }\n\n        // Fst: t.fst : T1 if t : T1 * T2\n        Tm::Fst { t } => {\n            exists|ty2: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty), t2: Box::new(ty2) })\n        }\n\n        // Snd: t.snd : T2 if t : T1 * T2\n        Tm::Snd { t } => {\n            exists|ty1: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty1), t2: Box::new(ty) })\n        }\n\n        // Inl: inl t as T1+T2 : T1+T2 if t : T1\n        Tm::Inl { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1, t2: _ } => has_type_simple(*t, *t1),\n                _ => false,\n            }\n        }\n\n        // Inr: inr t as T1+T2 : T1+T2 if t : T2\n        Tm::Inr { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1: _, t2 } => has_type_simple(*t, *t2),\n                _ => false,\n            }\n        }\n\n        // Nil: nil T : List T\n        Tm::Nil { ty: elem_ty } => ty == (Ty::TList { t: Box::new(elem_ty) }),\n\n        _ => false,  // Other cases need context\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn has_type_simple(t: Tm, ty: Ty) -> bool\n    decreases t\n{\n    match t {\n        // Unit\n        Tm::Unit => ty == Ty::TUnit,\n\n        // Booleans\n        Tm::Tru => ty == Ty::TBool,\n        Tm::Fls => ty == Ty::TBool,\n\n        // Naturals\n        Tm::Nat { .. } => ty == Ty::TNat,\n        Tm::Scc { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::Prd { t } => ty == Ty::TNat && has_type_simple(*t, Ty::TNat),\n        Tm::IsZro { t } => ty == Ty::TBool && has_type_simple(*t, Ty::TNat),\n\n        // Pairs: (t1, t2) : T1 * T2\n        Tm::Pair { t1, t2 } => {\n            match ty {\n                Ty::TProd { t1: ty1, t2: ty2 } =>\n                    has_type_simple(*t1, *ty1) && has_type_simple(*t2, *ty2),\n                _ => false,\n            }\n        }\n\n        // Fst: t.fst : T1 if t : T1 * T2\n        Tm::Fst { t } => {\n            exists|ty2: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty), t2: Box::new(ty2) })\n        }\n\n        // Snd: t.snd : T2 if t : T1 * T2\n        Tm::Snd { t } => {\n            exists|ty1: Ty| #![auto]\n                has_type_simple(*t, Ty::TProd { t1: Box::new(ty1), t2: Box::new(ty) })\n        }\n\n        // Inl: inl t as T1+T2 : T1+T2 if t : T1\n        Tm::Inl { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1, t2: _ } => has_type_simple(*t, *t1),\n                _ => false,\n            }\n        }\n\n        // Inr: inr t as T1+T2 : T1+T2 if t : T2\n        Tm::Inr { t, ty: ann_ty } => {\n            ty == ann_ty &&\n            match ann_ty {\n                Ty::TSum { t1: _, t2 } => has_type_simple(*t, *t2),\n                _ => false,\n            }\n        }\n\n        // Nil: nil T : List T\n        Tm::Nil { ty: elem_ty } => ty == (Ty::TList { t: Box::new(elem_ty) }),\n\n        _ => false,  // Other cases need context\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "more_stlc_verus.rs", "verified": true, "metadata": {"original_id": "75b77bb78ae1", "function_name": "has_type_simple", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1839b2af5d5d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s2if_impl.rs", "verified": true, "metadata": {"original_id": "1839b2af5d5d", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_01647fd9aa11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () ,  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_iter_2_current.rs", "verified": true, "metadata": {"original_id": "01647fd9aa11", "function_name": "bit_wise_xor", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_7a07e78bbb25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , {       }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "7a07e78bbb25", "function_name": "decode_shift", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_07c1ede4547c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool) requires is_prime_precond (n as nat) , n <= 0xFFFF , { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool) requires is_prime_precond (n as nat) , n <= 0xFFFF , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_28/verina_basic_28.rs", "verified": true, "metadata": {"original_id": "07c1ede4547c", "function_name": "is_prime", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_9696f70fcf24", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9696f70fcf24", "function_name": "MaxA", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_18b96f320034", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_canyon_search/verus_code.rs", "verified": true, "metadata": {"original_id": "18b96f320034", "function_name": "canyon_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_501c3075c253", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "501c3075c253", "function_name": "triple_if", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_d885bab00260", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 ,  { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 ,  { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d885bab00260", "function_name": "modp", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_ec6952035112", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ec6952035112", "function_name": "minimum_right_shifts", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_a3a12d115e35", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a3a12d115e35", "function_name": "is_digit", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_286ab52cb934", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)  ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_82/verina_basic_82_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "286ab52cb934", "function_name": "copy_from", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_8f912cd18533", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)  ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "8f912cd18533", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_a25426d2dceb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 ,  { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found == exists | k : int | 0 <= k < j && result [k] == a [i as int] , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found == exists | k : int | 0 <= k < j && result [k] == a [i as int] , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found == exists | k : int | 0 <= k < j && result [k] == a [i as int] , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "a25426d2dceb", "function_name": "remove_duplicates", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_e049439dc7b7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e049439dc7b7", "function_name": "replace_with_colon", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_365d1b5de023", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "365d1b5de023", "function_name": "any_value_exists", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_577888bbc9cc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_reverse(s: Seq<nat>)\n    \n{\n    // This requires a more detailed proof\n    assume(reverse(reverse(s)) =~= s);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_reverse(s: Seq<nat>)\n    ensures reverse(reverse(s)) =~= s\n{\n    // This requires a more detailed proof\n    assume(reverse(reverse(s)) =~= s);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_reverse(s: Seq<nat>)\n    ensures reverse(reverse(s)) =~= s\n{\n    // This requires a more detailed proof\n    assume(reverse(reverse(s)) =~= s);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_seq_reverse.rs", "verified": true, "metadata": {"original_id": "577888bbc9cc", "function_name": "reverse_reverse", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_a30dffe76ad0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "a30dffe76ad0", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_2533c1fbb6be", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/max_index_impl.rs", "verified": true, "metadata": {"original_id": "2533c1fbb6be", "function_name": "myfun1", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_verus_oneshot_3f95b9acbbd0", "task": "task_c", "input_text": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "target_text": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "full_verified_code": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/oneshot.rs", "verified": true, "metadata": {"original_id": "verus_oneshot_3f95b9acbbd0", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_70b51eb12558", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "70b51eb12558", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_911ab3bfc998", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_nat_canonical(e: Expr) -> bool\n    {\n    match e {\n        Expr::Zero => true,\n        Expr::Var { .. } => true,\n        Expr::Succ { e } => is_nat_canonical(*e),\n        Expr::Add { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Mul { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Pred { e } =>\n            !is_zero_expr(*e) && !is_succ_expr(*e) && is_nat_canonical(*e),\n        _ => false,\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_nat_canonical(e: Expr) -> bool\n    decreases e\n{\n    match e {\n        Expr::Zero => true,\n        Expr::Var { .. } => true,\n        Expr::Succ { e } => is_nat_canonical(*e),\n        Expr::Add { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Mul { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Pred { e } =>\n            !is_zero_expr(*e) && !is_succ_expr(*e) && is_nat_canonical(*e),\n        _ => false,\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_nat_canonical(e: Expr) -> bool\n    decreases e\n{\n    match e {\n        Expr::Zero => true,\n        Expr::Var { .. } => true,\n        Expr::Succ { e } => is_nat_canonical(*e),\n        Expr::Add { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Mul { e1, e2 } =>\n            !is_zero_expr(*e1) && !is_zero_expr(*e2) &&\n            is_nat_canonical(*e1) && is_nat_canonical(*e2),\n        Expr::Pred { e } =>\n            !is_zero_expr(*e) && !is_succ_expr(*e) && is_nat_canonical(*e),\n        _ => false,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_normalize.rs", "verified": true, "metadata": {"original_id": "911ab3bfc998", "function_name": "is_nat_canonical", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_5e9cc255e917", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "5e9cc255e917", "function_name": "pairs_sum_to_zero", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_d29ad2b3aa22", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool)  { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_732_iter_3_current.rs", "verified": true, "metadata": {"original_id": "d29ad2b3aa22", "function_name": "replace_with_colon", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_728fed2aa103", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "728fed2aa103", "function_name": "to_toggle_case", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_c52c4e10370a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c52c4e10370a", "function_name": "barrier", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_65b358753fce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true ,  { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "65b358753fce", "function_name": "compare_int", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_086bd322fe63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true ,  { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "086bd322fe63", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_d8df50f35fcd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)  ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "d8df50f35fcd", "function_name": "three_distinct", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_9b65065329f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traversals_same_elements(t: Tree, x: nat)\n    ensures count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n            count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x)\n    {\n    // This requires a detailed proof about count distributing over append\n    assume(count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n           count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traversals_same_elements(t: Tree, x: nat)\n    ensures count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n            count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x)\n    decreases t\n{\n    // This requires a detailed proof about count distributing over append\n    assume(count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n           count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn traversals_same_elements(t: Tree, x: nat)\n    ensures count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n            count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x)\n    decreases t\n{\n    // This requires a detailed proof about count distributing over append\n    assume(count_in_seq(inorder(t), x) == count_in_seq(preorder(t), x) &&\n           count_in_seq(preorder(t), x) == count_in_seq(postorder(t), x));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_traverse.rs", "verified": true, "metadata": {"original_id": "9b65065329f6", "function_name": "traversals_same_elements", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_f56a30c9f3de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mod_pow(base: nat, exp: nat, m: nat) -> nat {\n    if m == 0 { 0 }\n    else if exp == 0 { (1nat % m) as nat }\n    else { ((base * mod_pow(base, (exp - 1) as nat, m)) % m) as nat }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mod_pow(base: nat, exp: nat, m: nat) -> nat decreases exp {\n    if m == 0 { 0 }\n    else if exp == 0 { (1nat % m) as nat }\n    else { ((base * mod_pow(base, (exp - 1) as nat, m)) % m) as nat }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mod_pow(base: nat, exp: nat, m: nat) -> nat decreases exp {\n    if m == 0 { 0 }\n    else if exp == 0 { (1nat % m) as nat }\n    else { ((base * mod_pow(base, (exp - 1) as nat, m)) % m) as nat }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_mod_arith.rs", "verified": true, "metadata": {"original_id": "f56a30c9f3de", "function_name": "mod_pow", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_verus_recommends_25251cfab7d9", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recommends.rs", "verified": true, "metadata": {"original_id": "verus_recommends_25251cfab7d9", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_9bcbb335e30e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_append_impl.rs", "verified": true, "metadata": {"original_id": "9bcbb335e30e", "function_name": "append_with_element", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_ab848c5aee4a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_valid(n: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_valid(n: nat)\n    ensures uf_valid(uf_init(n))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_valid(n: nat)\n    ensures uf_valid(uf_init(n))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_union_find.rs", "verified": true, "metadata": {"original_id": "ab848c5aee4a", "function_name": "init_valid", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_e2a5bbc51457", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_20/verina_basic_20_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e2a5bbc51457", "function_name": "unique_product", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_769b50debd28", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs3_impl.rs", "verified": true, "metadata": {"original_id": "769b50debd28", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_9a578c399d78", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)  ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases cols - i { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows invariant new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases rows - j { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases cols - i { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows invariant new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases rows - j { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases cols - i { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows invariant new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases rows - j { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/WIP/WIP__transpose_matrix_impl.rs", "verified": true, "metadata": {"original_id": "9a578c399d78", "function_name": "transpose", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_5ff836237121", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_nonempty_has_element<T>(inner_outputs: Set<T>, max_len: nat, s: Seq<T>)\n    \n    ensures s.len() >= 1\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_nonempty_has_element<T>(inner_outputs: Set<T>, max_len: nat, s: Seq<T>)\n    requires gen_list_nonempty_outputs(inner_outputs, max_len).contains(s), max_len >= 1\n    ensures s.len() >= 1\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_list_nonempty_has_element<T>(inner_outputs: Set<T>, max_len: nat, s: Seq<T>)\n    requires gen_list_nonempty_outputs(inner_outputs, max_len).contains(s), max_len >= 1\n    ensures s.len() >= 1\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_list.rs", "verified": true, "metadata": {"original_id": "5ff836237121", "function_name": "gen_list_nonempty_has_element", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_verus_lib_examples_85b5449808d7", "task": "task_c", "input_text": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    {\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    {\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    {\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    {\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/lib_examples.rs", "verified": true, "metadata": {"original_id": "verus_lib_examples_85b5449808d7", "function_name": "", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_9c049ef07cbf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_binders(e: Expr) -> nat\n    {\n    match e {\n        Expr::Var { .. } => 0,\n        Expr::Lam { body, .. } => 1 + count_binders(*body),\n        Expr::App { e1, e2 } => count_binders(*e1) + count_binders(*e2),\n        Expr::Tru => 0,\n        Expr::Fls => 0,\n        Expr::If { cond, then_br, else_br } =>\n            count_binders(*cond) + count_binders(*then_br) + count_binders(*else_br),\n        Expr::Zero => 0,\n        Expr::Succ { e } => count_binders(*e),\n        Expr::Pred { e } => count_binders(*e),\n        Expr::IsZero { e } => count_binders(*e),\n        Expr::Let { def, body, .. } => 1 + count_binders(*def) + count_binders(*body),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_binders(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 0,\n        Expr::Lam { body, .. } => 1 + count_binders(*body),\n        Expr::App { e1, e2 } => count_binders(*e1) + count_binders(*e2),\n        Expr::Tru => 0,\n        Expr::Fls => 0,\n        Expr::If { cond, then_br, else_br } =>\n            count_binders(*cond) + count_binders(*then_br) + count_binders(*else_br),\n        Expr::Zero => 0,\n        Expr::Succ { e } => count_binders(*e),\n        Expr::Pred { e } => count_binders(*e),\n        Expr::IsZero { e } => count_binders(*e),\n        Expr::Let { def, body, .. } => 1 + count_binders(*def) + count_binders(*body),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_binders(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 0,\n        Expr::Lam { body, .. } => 1 + count_binders(*body),\n        Expr::App { e1, e2 } => count_binders(*e1) + count_binders(*e2),\n        Expr::Tru => 0,\n        Expr::Fls => 0,\n        Expr::If { cond, then_br, else_br } =>\n            count_binders(*cond) + count_binders(*then_br) + count_binders(*else_br),\n        Expr::Zero => 0,\n        Expr::Succ { e } => count_binders(*e),\n        Expr::Pred { e } => count_binders(*e),\n        Expr::IsZero { e } => count_binders(*e),\n        Expr::Let { def, body, .. } => 1 + count_binders(*def) + count_binders(*body),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_gen_expr.rs", "verified": true, "metadata": {"original_id": "9c049ef07cbf", "function_name": "count_binders", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_cf96657aad73", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) ,  { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_2/verina_basic_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cf96657aad73", "function_name": "find_smallest", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_18be5efd162d", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) decreases numbers . len () , { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) requires intersperse_quantified (numbers , delimiter , interspersed) ,  { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 { assert (interspersed . len () == 1) ; assert (interspersed [even (0)] == numbers [0]) ; } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 { assert (is [i] == numbers . last ()) ; assert (interspersed [even (i / 2)] == numbers [i / 2]) ; assert (i / 2 == numbers . len () - 1) ; } else { assert (is [i] == delimiter) ; assert (interspersed [odd ((i - 1) / 2)] == delimiter) ; } } }) ; } assert (interspersed =~= intersperse_spec (numbers , delimiter)) ; }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64)  { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >)  { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , result . len () == if i == 0 { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , decreases numbers . len () - i , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; } proof { assert (intersperse_quantified (numbers @ , delimiter , result @)) ; intersperse_quantified_is_spec (numbers @ , delimiter , result @) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) decreases numbers . len () , { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) requires intersperse_quantified (numbers , delimiter , interspersed) , ensures interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 { assert (interspersed . len () == 1) ; assert (interspersed [even (0)] == numbers [0]) ; } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 { assert (is [i] == numbers . last ()) ; assert (interspersed [even (i / 2)] == numbers [i / 2]) ; assert (i / 2 == numbers . len () - 1) ; } else { assert (is [i] == delimiter) ; assert (interspersed [odd ((i - 1) / 2)] == delimiter) ; } } }) ; } assert (interspersed =~= intersperse_spec (numbers , delimiter)) ; }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64) ensures numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () , { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >) ensures result @ == intersperse_spec (numbers @ , delimiter) , { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , result . len () == if i == 0 { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , decreases numbers . len () - i , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; } proof { assert (intersperse_quantified (numbers @ , delimiter , result @)) ; intersperse_quantified_is_spec (numbers @ , delimiter , result @) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) decreases numbers . len () , { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) requires intersperse_quantified (numbers , delimiter , interspersed) , ensures interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 { assert (interspersed . len () == 1) ; assert (interspersed [even (0)] == numbers [0]) ; } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 { assert (is [i] == numbers . last ()) ; assert (interspersed [even (i / 2)] == numbers [i / 2]) ; assert (i / 2 == numbers . len () - 1) ; } else { assert (is [i] == delimiter) ; assert (interspersed [odd ((i - 1) / 2)] == delimiter) ; } } }) ; } assert (interspersed =~= intersperse_spec (numbers , delimiter)) ; }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64) ensures numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () , { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >) ensures result @ == intersperse_spec (numbers @ , delimiter) , { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , result . len () == if i == 0 { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , decreases numbers . len () - i , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; } proof { assert (intersperse_quantified (numbers @ , delimiter , result @)) ; intersperse_quantified_is_spec (numbers @ , delimiter , result @) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/005-intersperse_impl.rs", "verified": true, "metadata": {"original_id": "18be5efd162d", "function_name": "intersperse", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_9c0664056fa4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)  ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { result . push (second [i]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { result . push (second [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "9c0664056fa4", "function_name": "replace_last_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_69541fdb3e6e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn p_bound_remove<V>(m: PartialMap<V>, k: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn p_bound_remove<V>(m: PartialMap<V>, k: nat)\n    ensures !p_bound(p_remove(m, k), k)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn p_bound_remove<V>(m: PartialMap<V>, k: nat)\n    ensures !p_bound(p_remove(m, k), k)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_map_partial.rs", "verified": true, "metadata": {"original_id": "69541fdb3e6e", "function_name": "p_bound_remove", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_049e286d6201", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "049e286d6201", "function_name": "is_greater", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_771269f016fc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn quicksort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    {\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let rest = s.subrange(1, s.len() as int);\n        let lo = filter_le(rest, pivot);\n        let hi = filter_gt(rest, pivot);\n        quicksort_fuel(lo, (fuel - 1) as nat) + seq![pivot] + quicksort_fuel(hi, (fuel - 1) as nat)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn quicksort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    decreases fuel\n{\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let rest = s.subrange(1, s.len() as int);\n        let lo = filter_le(rest, pivot);\n        let hi = filter_gt(rest, pivot);\n        quicksort_fuel(lo, (fuel - 1) as nat) + seq![pivot] + quicksort_fuel(hi, (fuel - 1) as nat)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn quicksort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    decreases fuel\n{\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let rest = s.subrange(1, s.len() as int);\n        let lo = filter_le(rest, pivot);\n        let hi = filter_gt(rest, pivot);\n        quicksort_fuel(lo, (fuel - 1) as nat) + seq![pivot] + quicksort_fuel(hi, (fuel - 1) as nat)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_quick.rs", "verified": true, "metadata": {"original_id": "771269f016fc", "function_name": "quicksort_fuel", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_08e5cbd8d9f4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len ()  { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "08e5cbd8d9f4", "function_name": "last_position", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_5b95a9c06851", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn parent_index(i: nat) -> nat\n    {\n    if i <= 1 { 0 } else { (i / 2) as nat }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn parent_index(i: nat) -> nat\n    decreases i\n{\n    if i <= 1 { 0 } else { (i / 2) as nat }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn parent_index(i: nat) -> nat\n    decreases i\n{\n    if i <= 1 { 0 } else { (i / 2) as nat }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_fenwick_tree.rs", "verified": true, "metadata": {"original_id": "5b95a9c06851", "function_name": "parent_index", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_a5cc4bb71e8b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a5cc4bb71e8b", "function_name": "sum_powers_helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_8d55fdacb06e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn forall_gt(t: Treap, bound: int) -> bool {\n    match t { Treap::E => true, Treap::T { key, left, right, .. } => key > bound && forall_gt(*left, bound) && forall_gt(*right, bound) }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn forall_gt(t: Treap, bound: int) -> bool decreases t {\n    match t { Treap::E => true, Treap::T { key, left, right, .. } => key > bound && forall_gt(*left, bound) && forall_gt(*right, bound) }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn forall_gt(t: Treap, bound: int) -> bool decreases t {\n    match t { Treap::E => true, Treap::T { key, left, right, .. } => key > bound && forall_gt(*left, bound) && forall_gt(*right, bound) }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_treap.rs", "verified": true, "metadata": {"original_id": "8d55fdacb06e", "function_name": "forall_gt", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_8bb68411a318", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn aequiv_refl(a: AExp)\n    \n{\n    // Trivially true by definition\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn aequiv_refl(a: AExp)\n    ensures aequiv(a, a)\n{\n    // Trivially true by definition\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn aequiv_refl(a: AExp)\n    ensures aequiv(a, a)\n{\n    // Trivially true by definition\n}\n\n} // verus!", "source": "coq_translation", "source_file": "equiv_verus.rs", "verified": true, "metadata": {"original_id": "8bb68411a318", "function_name": "aequiv_refl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b749d780e75e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "b749d780e75e", "function_name": "element_wise_subtract", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_db82da583b3b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >)  ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/string_xor_impl.rs", "verified": true, "metadata": {"original_id": "db82da583b3b", "function_name": "xor_strings", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_382c27bf63f9", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/linearsearch_impl.rs", "verified": true, "metadata": {"original_id": "382c27bf63f9", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_ca65ef766ffb", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 ,  { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/findmax_impl.rs", "verified": true, "metadata": {"original_id": "ca65ef766ffb", "function_name": "find_max", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_6e704e06adc5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @)  { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6e704e06adc5", "function_name": "is_peak_valley", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_06a9fe1f0d30", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_trans(a: nat, b: nat, c: nat)\n    \n    ensures ltb(a, c)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_trans(a: nat, b: nat, c: nat)\n    requires ltb(a, b), ltb(b, c)\n    ensures ltb(a, c)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_trans(a: nat, b: nat, c: nat)\n    requires ltb(a, b), ltb(b, c)\n    ensures ltb(a, c)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_comparison.rs", "verified": true, "metadata": {"original_id": "06a9fe1f0d30", "function_name": "ltb_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_816e562fc88b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_or_either_true(p1: Property, p2: Property)\n    requires eval_property(p1) || eval_property(p2)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_or_either_true(p1: Property, p2: Property)\n    requires eval_property(p1) || eval_property(p2)\n    ensures eval_property(prop_or(p1, p2))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_or_either_true(p1: Property, p2: Property)\n    requires eval_property(p1) || eval_property(p2)\n    ensures eval_property(prop_or(p1, p2))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_checker_property.rs", "verified": true, "metadata": {"original_id": "816e562fc88b", "function_name": "prop_or_either_true", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_61ad0e81a480", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX  { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "61ad0e81a480", "function_name": "has_close_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_a3d479510faf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof {   } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a3d479510faf", "function_name": "any_value_exists", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_e826955ded98", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , { if main [idx + i] != sub [i] { assert (main @ [idx + i as int] != sub @ [i as int]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @ == false) ; return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx + j] == sub @ [j]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , decreases sub . len () - i , { if main [idx + i] != sub [i] { assert (main @ [idx + i as int] != sub @ [i as int]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @ == false) ; return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx + j] == sub @ [j]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , decreases sub . len () - i , { if main [idx + i] != sub [i] { assert (main @ [idx + i as int] != sub @ [i as int]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @ == false) ; return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx + j] == sub @ [j]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_576_v2_impl.rs", "verified": true, "metadata": {"original_id": "e826955ded98", "function_name": "sub_array_at_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_aca46782de11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_neq_nat_sound(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_neq_nat_sound(a: nat, b: nat)\n    ensures dec_to_bool(dec_neq_nat(a, b)) <==> (a != b)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_neq_nat_sound(a: nat, b: nat)\n    ensures dec_to_bool(dec_neq_nat(a, b)) <==> (a != b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_eq.rs", "verified": true, "metadata": {"original_id": "aca46782de11", "function_name": "dec_neq_nat_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_33cace39dc81", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "33cace39dc81", "function_name": "partition_odd_even", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_0cca59d8cea0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i {    let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "0cca59d8cea0", "function_name": "element_wise_divide", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_verified-memory-allocator_bitmap_78a931c15aa7", "task": "task_c", "input_text": "#![allow(unused_imports)]\n\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\nuse vstd::raw_ptr::*;\nuse vstd::*;\nuse vstd::set_lib::*;\n\nverus!{\n\n/*\n\ntype G = crate::os_mem::MemChunk;\ntype K = int;\n\npub open spec fn entry_inv(k: K, user_idx: int, g: G) -> bool {\n    g.wf()\n      && g.os_exact_range(\n            k + user_idx * crate::arena::ARENA_BLOCK_SIZE,\n            crate::arena::ARENA_BLOCK_SIZE as int\n        )\n      && g.has_pointsto_for_all_read_write()\n}\n\npub open spec fn map_has_range(m: Map<int, G>, start: int, end: int, k: K) -> bool {\n    (forall |i| start <= i < end ==> m.dom().contains(i))\n    && (forall |i| start <= i < end ==> entry_inv(k, i, #[trigger] m.index(i)))\n}\n\n// field_idx = index into the data array (0 <= field_idx < data.len())\n// bit_idx = index of a bit within a word (0 <= bit_idx < usize::BITS)\n// user_idx = index of object from user perspective\n//      (user_idx = field_idx * usize::BITS + bit_idx)\n\nstruct_with_invariants!{\n    pub struct Bitmap {\n        data: Vec<AtomicUsize<_, Map<int, G>, _>>,\n        ghost k: K,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            self.data.len() < 0x1000000\n        }\n\n        invariant\n            on data\n            with (k)\n            forall |field_idx: int|\n            where (0 <= field_idx < self.data@.len())\n            specifically (self.data@.index(field_idx))\n            is (v: usize, gmap: Map<int, G>)\n        {\n            forall |bitidx: int|\n                ! #[trigger] has_bit(v, bitidx)\n                ==> gmap.dom().contains(field_idx * usize::BITS + bitidx)\n                    && entry_inv(k,\n                        field_idx * usize::BITS + bitidx,\n                        gmap.index(field_idx * usize::BITS + bitidx))\n        }\n    }\n}\n\npub closed spec fn has_bit(v: usize, i: int) -> bool {\n    (0 <= i < usize::BITS && ((v >> (i as usize)) & 1usize) != 0)\n}\n\nimpl Bitmap {\n    pub closed spec fn len(&self) -> nat {\n        self.data@.len()\n    }\n\n    pub closed spec fn constant(&self) -> int {\n        self.k\n    }\n\n    pub fn bitmap_try_find_from_claim_across(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n        ensures ({\n            let (success, user_idx, tr_map) = res;\n            success ==> {\n                &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n            }\n        }),\n    {\n        if count == 1 {\n            return self.bitmap_try_find_from_claim(start_field_idx, count);\n        }\n\n        assume(false); loop { }\n    }\n\n    fn bitmap_try_find_from_claim(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let mut idx = start_field_idx;\n        let mut visited = 0;\n        let bitmap_fields = self.data.len();\n        while visited < bitmap_fields\n            invariant\n                self.wf(),\n                0 <= start_field_idx < self.data@.len(),\n                1 <= count < usize::BITS,\n                visited <= bitmap_fields,\n                bitmap_fields == self.data@.len(),\n        {\n            if idx >= bitmap_fields {\n                idx = 0;\n            }\n\n            let (success, user_idx, tr_map) =\n                self.bitmap_try_find_claim_field(idx, count);\n            if success {\n                return (true, user_idx, tr_map);\n            }\n\n            visited = visited + 1;\n            idx = idx + 1;\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    fn bitmap_try_find_claim_field(&self, field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& usize::BITS * field_idx <= user_idx\n            &&& user_idx + count <= usize::BITS * (field_idx + 1)\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let atomic = &self.data[field_idx];\n\n        let mut map = atomic.load();\n        if map == !(0usize) {\n            return (false, 0, Tracked(Map::tracked_empty()));\n        }\n\n        assert((1usize << count) >= 1usize) by(bit_vector)\n             { }\n\n        let mask = (1usize << count) - 1;\n        let bitidx_max = usize::BITS as usize - count;\n\n        let mut bitidx = crate::bin_sizes::trailing_zeros(map) as usize;\n        let mut m = mask << bitidx;\n\n        while bitidx <= bitidx_max\n            invariant\n                self.wf(),\n                atomic == self.data@.index(field_idx as int),\n                0 <= field_idx < self.data@.len(),\n                1 <= count <= usize::BITS,\n                bitidx_max == usize::BITS - count,\n                m == mask << bitidx,\n                mask == (1usize << count) - 1,\n        {\n            let mapm = map & m;\n            if mapm == 0 {\n                let tracked mut res_map: Map<int, G>;\n                proof { res_map = Map::tracked_empty(); }\n\n                let newmap = map | m;\n                let res = my_atomic_with_ghost!(\n                    atomic => compare_exchange_weak(map, newmap);\n                    update old_v -> new_v;\n                    returning res;\n                    ghost gmap =>\n                {\n                    if res.is_Ok() {\n                        let range = set_int_range(\n                            usize::BITS * field_idx + bitidx,\n                            usize::BITS * field_idx + bitidx + count);\n\n                        verus_proof_expr!({\n                        assert forall |i| range.contains(i) implies #[trigger] gmap.dom().contains(i)\n                        by {\n                            assume(!has_bit(old_v, i - usize::BITS * field_idx));\n                        }\n                        });\n\n                        res_map = gmap.tracked_remove_keys(range);\n\n                        assume(bitidx + count < usize::BITS);\n\n                        let bit = bitidx;\n\n                        verus_proof_expr!({\n                        assert forall |bitidx0: int|\n                            ! #[trigger] has_bit(new_v, bitidx0)\n                            implies gmap.dom().contains(field_idx * usize::BITS + bitidx0)\n                                && entry_inv(self.k,\n                                    field_idx * usize::BITS + bitidx0,\n                                    gmap.index(field_idx * usize::BITS + bitidx0))\n                        by {\n                            assert(m == sub(1usize << count,  1) << bitidx);\n                            assert(new_v == old_v | m);\n                            assert(old_v & m == 0);\n\n                            if bitidx <= bitidx0 < bitidx + count {\n                                let bi = bitidx0 as usize;\n\n                                assert(((new_v >> bi) & 1usize) != 0usize)\n                                  by(bit_vector)\n\n                                { }\n\n                                assert(false);\n                            } else {\n                                if bitidx0 >= usize::BITS || bitidx0 < 0 {\n                                    assert(!has_bit(old_v, bitidx0));\n                                } else {\n                                    let bi = bitidx0 as usize;\n                                    assert(add(bitidx, count) == bitidx + count);\n\n                                    if bit > bi {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n\n                                        { }\n                                    } else {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n\n                                        { }\n                                    }\n                                    assert(!has_bit(old_v, bitidx0));\n                                }\n                            }\n                        }\n                        });\n                    }\n                });\n\n                match res {\n                    Result::Ok(_) => {\n                        let user_idx = usize::BITS as usize * field_idx + bitidx;\n                        return (true, user_idx, Tracked(res_map));\n                    }\n                    Result::Err(updated_map) => {\n                        map = updated_map;\n                    }\n                }\n            } else {\n                let shift = if count == 1 {\n                    1\n                } else {\n                    let tz = crate::bin_sizes::trailing_zeros(mapm) as usize;\n                    assume(tz + 1 >= bitidx);\n                    tz + 1 - bitidx\n                };\n\n                assert(((mask << bitidx) << shift) == mask << add(bitidx, shift))\n                  by(bit_vector)\n\n                    { }\n\n                bitidx = bitidx + shift;\n                m = m << shift;\n\n            }\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    //pub bitmap_try_find_claim_field_across(&self, idx: usize,\n}\n\n*/\n\n}\n", "target_text": "#![allow(unused_imports)]\n\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\nuse vstd::raw_ptr::*;\nuse vstd::*;\nuse vstd::set_lib::*;\n\nverus!{\n\n/*\n\ntype G = crate::os_mem::MemChunk;\ntype K = int;\n\npub open spec fn entry_inv(k: K, user_idx: int, g: G) -> bool {\n    g.wf()\n      && g.os_exact_range(\n            k + user_idx * crate::arena::ARENA_BLOCK_SIZE,\n            crate::arena::ARENA_BLOCK_SIZE as int\n        )\n      && g.has_pointsto_for_all_read_write()\n}\n\npub open spec fn map_has_range(m: Map<int, G>, start: int, end: int, k: K) -> bool {\n    (forall |i| start <= i < end ==> m.dom().contains(i))\n    && (forall |i| start <= i < end ==> entry_inv(k, i, #[trigger] m.index(i)))\n}\n\n// field_idx = index into the data array (0 <= field_idx < data.len())\n// bit_idx = index of a bit within a word (0 <= bit_idx < usize::BITS)\n// user_idx = index of object from user perspective\n//      (user_idx = field_idx * usize::BITS + bit_idx)\n\nstruct_with_invariants!{\n    pub struct Bitmap {\n        data: Vec<AtomicUsize<_, Map<int, G>, _>>,\n        ghost k: K,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            self.data.len() < 0x1000000\n        }\n\n        invariant\n            on data\n            with (k)\n            forall |field_idx: int|\n            where (0 <= field_idx < self.data@.len())\n            specifically (self.data@.index(field_idx))\n            is (v: usize, gmap: Map<int, G>)\n        {\n            forall |bitidx: int| \n                ! #[trigger] has_bit(v, bitidx)\n                ==> gmap.dom().contains(field_idx * usize::BITS + bitidx)\n                    && entry_inv(k,\n                        field_idx * usize::BITS + bitidx,\n                        gmap.index(field_idx * usize::BITS + bitidx))\n        }\n    }\n}\n\npub closed spec fn has_bit(v: usize, i: int) -> bool {\n    (0 <= i < usize::BITS && ((v >> (i as usize)) & 1usize) != 0)\n}\n\nimpl Bitmap {\n    pub closed spec fn len(&self) -> nat {\n        self.data@.len()\n    }\n\n    pub closed spec fn constant(&self) -> int {\n        self.k\n    }\n\n    pub fn bitmap_try_find_from_claim_across(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.len(),\n        ensures ({\n            let (success, user_idx, tr_map) = res;\n            success ==> {\n                &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n            }\n        }),\n    {\n        if count == 1 {\n            return self.bitmap_try_find_from_claim(start_field_idx, count);\n        }\n\n        assume(false); loop { }\n    }\n\n    fn bitmap_try_find_from_claim(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let mut idx = start_field_idx;\n        let mut visited = 0;\n        let bitmap_fields = self.data.len();\n        while visited < bitmap_fields\n            invariant\n                self.wf(),\n                0 <= start_field_idx < self.data@.len(),\n                1 <= count < usize::BITS,\n                visited <= bitmap_fields,\n                bitmap_fields == self.data@.len(),\n        {\n            if idx >= bitmap_fields {\n                idx = 0;\n            }\n\n            let (success, user_idx, tr_map) =\n                self.bitmap_try_find_claim_field(idx, count);\n            if success {\n                return (true, user_idx, tr_map);\n            }\n\n            visited = visited + 1;\n            idx = idx + 1;\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    fn bitmap_try_find_claim_field(&self, field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& usize::BITS * field_idx <= user_idx\n            &&& user_idx + count <= usize::BITS * (field_idx + 1)\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let atomic = &self.data[field_idx];\n\n        let mut map = atomic.load();\n        if map == !(0usize) {\n            return (false, 0, Tracked(Map::tracked_empty()));\n        }\n\n        assert((1usize << count) >= 1usize) by(bit_vector)\n            requires count < 64usize { }\n\n        let mask = (1usize << count) - 1;\n        let bitidx_max = usize::BITS as usize - count;\n\n        let mut bitidx = crate::bin_sizes::trailing_zeros(map) as usize;\n        let mut m = mask << bitidx;\n\n        while bitidx <= bitidx_max\n            invariant\n                self.wf(),\n                atomic == self.data@.index(field_idx as int),\n                0 <= field_idx < self.data@.len(),\n                1 <= count <= usize::BITS,\n                bitidx_max == usize::BITS - count,\n                m == mask << bitidx,\n                mask == (1usize << count) - 1,\n        {\n            let mapm = map & m;\n            if mapm == 0 {\n                let tracked mut res_map: Map<int, G>;\n                proof { res_map = Map::tracked_empty(); }\n\n                let newmap = map | m;\n                let res = my_atomic_with_ghost!(\n                    atomic => compare_exchange_weak(map, newmap);\n                    update old_v -> new_v;\n                    returning res;\n                    ghost gmap =>\n                {\n                    if res.is_Ok() {\n                        let range = set_int_range(\n                            usize::BITS * field_idx + bitidx,\n                            usize::BITS * field_idx + bitidx + count);\n\n                        verus_proof_expr!({\n                        assert forall |i| range.contains(i) implies #[trigger] gmap.dom().contains(i)\n                        by {\n                            assume(!has_bit(old_v, i - usize::BITS * field_idx));\n                        }\n                        });\n\n                        res_map = gmap.tracked_remove_keys(range);\n\n                        assume(bitidx + count < usize::BITS);\n\n                        let bit = bitidx;\n\n                        verus_proof_expr!({\n                        assert forall |bitidx0: int| \n                            ! #[trigger] has_bit(new_v, bitidx0)\n                            implies gmap.dom().contains(field_idx * usize::BITS + bitidx0)\n                                && entry_inv(self.k,\n                                    field_idx * usize::BITS + bitidx0,\n                                    gmap.index(field_idx * usize::BITS + bitidx0))\n                        by {\n                            assert(m == sub(1usize << count,  1) << bitidx);\n                            assert(new_v == old_v | m);\n                            assert(old_v & m == 0);\n\n                            if bitidx <= bitidx0 < bitidx + count {\n                                let bi = bitidx0 as usize;\n\n                                assert(((new_v >> bi) & 1usize) != 0usize)\n                                  by(bit_vector)\n                                requires\n                                  bitidx <= bi < add(bitidx, count) < 64usize,\n                                  new_v == old_v | m,\n                                  m == sub(1usize << count, 1) << bitidx,\n                                  old_v & m == 0usize,\n                                  1usize <= count <= (64usize)\n                                { }\n\n                                assert(false);\n                            } else {\n                                if bitidx0 >= usize::BITS || bitidx0 < 0 {\n                                    assert(!has_bit(old_v, bitidx0));\n                                } else {\n                                    let bi = bitidx0 as usize;\n                                    assert(add(bitidx, count) == bitidx + count);\n\n                                    if bit > bi {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bitidx > bi,\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    } else {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bi >= add(bitidx, count),\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    }\n                                    assert(!has_bit(old_v, bitidx0));\n                                }\n                            }\n                        }\n                        });\n                    }\n                });\n\n                match res {\n                    Result::Ok(_) => {\n                        let user_idx = usize::BITS as usize * field_idx + bitidx;\n                        return (true, user_idx, Tracked(res_map));\n                    }\n                    Result::Err(updated_map) => {\n                        map = updated_map;\n                    }\n                }\n            } else {\n                let shift = if count == 1 {\n                    1\n                } else {\n                    let tz = crate::bin_sizes::trailing_zeros(mapm) as usize;\n                    assume(tz + 1 >= bitidx);\n                    tz + 1 - bitidx\n                };\n\n                assert(((mask << bitidx) << shift) == mask << add(bitidx, shift))\n                  by(bit_vector)\n                    requires\n                        bitidx <= 64usize,\n                        shift <= 64usize,\n                        add(bitidx, shift) <= 64usize,\n                    { }\n\n                bitidx = bitidx + shift;\n                m = m << shift;\n\n            }\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n        \n\n    //pub bitmap_try_find_claim_field_across(&self, idx: usize, \n}\n\n*/\n\n}\n", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\nuse vstd::raw_ptr::*;\nuse vstd::*;\nuse vstd::set_lib::*;\n\nverus!{\n\n/*\n\ntype G = crate::os_mem::MemChunk;\ntype K = int;\n\npub open spec fn entry_inv(k: K, user_idx: int, g: G) -> bool {\n    g.wf()\n      && g.os_exact_range(\n            k + user_idx * crate::arena::ARENA_BLOCK_SIZE,\n            crate::arena::ARENA_BLOCK_SIZE as int\n        )\n      && g.has_pointsto_for_all_read_write()\n}\n\npub open spec fn map_has_range(m: Map<int, G>, start: int, end: int, k: K) -> bool {\n    (forall |i| start <= i < end ==> m.dom().contains(i))\n    && (forall |i| start <= i < end ==> entry_inv(k, i, #[trigger] m.index(i)))\n}\n\n// field_idx = index into the data array (0 <= field_idx < data.len())\n// bit_idx = index of a bit within a word (0 <= bit_idx < usize::BITS)\n// user_idx = index of object from user perspective\n//      (user_idx = field_idx * usize::BITS + bit_idx)\n\nstruct_with_invariants!{\n    pub struct Bitmap {\n        data: Vec<AtomicUsize<_, Map<int, G>, _>>,\n        ghost k: K,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            self.data.len() < 0x1000000\n        }\n\n        invariant\n            on data\n            with (k)\n            forall |field_idx: int|\n            where (0 <= field_idx < self.data@.len())\n            specifically (self.data@.index(field_idx))\n            is (v: usize, gmap: Map<int, G>)\n        {\n            forall |bitidx: int| \n                ! #[trigger] has_bit(v, bitidx)\n                ==> gmap.dom().contains(field_idx * usize::BITS + bitidx)\n                    && entry_inv(k,\n                        field_idx * usize::BITS + bitidx,\n                        gmap.index(field_idx * usize::BITS + bitidx))\n        }\n    }\n}\n\npub closed spec fn has_bit(v: usize, i: int) -> bool {\n    (0 <= i < usize::BITS && ((v >> (i as usize)) & 1usize) != 0)\n}\n\nimpl Bitmap {\n    pub closed spec fn len(&self) -> nat {\n        self.data@.len()\n    }\n\n    pub closed spec fn constant(&self) -> int {\n        self.k\n    }\n\n    pub fn bitmap_try_find_from_claim_across(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.len(),\n        ensures ({\n            let (success, user_idx, tr_map) = res;\n            success ==> {\n                &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n            }\n        }),\n    {\n        if count == 1 {\n            return self.bitmap_try_find_from_claim(start_field_idx, count);\n        }\n\n        assume(false); loop { }\n    }\n\n    fn bitmap_try_find_from_claim(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let mut idx = start_field_idx;\n        let mut visited = 0;\n        let bitmap_fields = self.data.len();\n        while visited < bitmap_fields\n            invariant\n                self.wf(),\n                0 <= start_field_idx < self.data@.len(),\n                1 <= count < usize::BITS,\n                visited <= bitmap_fields,\n                bitmap_fields == self.data@.len(),\n        {\n            if idx >= bitmap_fields {\n                idx = 0;\n            }\n\n            let (success, user_idx, tr_map) =\n                self.bitmap_try_find_claim_field(idx, count);\n            if success {\n                return (true, user_idx, tr_map);\n            }\n\n            visited = visited + 1;\n            idx = idx + 1;\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    fn bitmap_try_find_claim_field(&self, field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& usize::BITS * field_idx <= user_idx\n            &&& user_idx + count <= usize::BITS * (field_idx + 1)\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let atomic = &self.data[field_idx];\n\n        let mut map = atomic.load();\n        if map == !(0usize) {\n            return (false, 0, Tracked(Map::tracked_empty()));\n        }\n\n        assert((1usize << count) >= 1usize) by(bit_vector)\n            requires count < 64usize { }\n\n        let mask = (1usize << count) - 1;\n        let bitidx_max = usize::BITS as usize - count;\n\n        let mut bitidx = crate::bin_sizes::trailing_zeros(map) as usize;\n        let mut m = mask << bitidx;\n\n        while bitidx <= bitidx_max\n            invariant\n                self.wf(),\n                atomic == self.data@.index(field_idx as int),\n                0 <= field_idx < self.data@.len(),\n                1 <= count <= usize::BITS,\n                bitidx_max == usize::BITS - count,\n                m == mask << bitidx,\n                mask == (1usize << count) - 1,\n        {\n            let mapm = map & m;\n            if mapm == 0 {\n                let tracked mut res_map: Map<int, G>;\n                proof { res_map = Map::tracked_empty(); }\n\n                let newmap = map | m;\n                let res = my_atomic_with_ghost!(\n                    atomic => compare_exchange_weak(map, newmap);\n                    update old_v -> new_v;\n                    returning res;\n                    ghost gmap =>\n                {\n                    if res.is_Ok() {\n                        let range = set_int_range(\n                            usize::BITS * field_idx + bitidx,\n                            usize::BITS * field_idx + bitidx + count);\n\n                        verus_proof_expr!({\n                        assert forall |i| range.contains(i) implies #[trigger] gmap.dom().contains(i)\n                        by {\n                            assume(!has_bit(old_v, i - usize::BITS * field_idx));\n                        }\n                        });\n\n                        res_map = gmap.tracked_remove_keys(range);\n\n                        assume(bitidx + count < usize::BITS);\n\n                        let bit = bitidx;\n\n                        verus_proof_expr!({\n                        assert forall |bitidx0: int| \n                            ! #[trigger] has_bit(new_v, bitidx0)\n                            implies gmap.dom().contains(field_idx * usize::BITS + bitidx0)\n                                && entry_inv(self.k,\n                                    field_idx * usize::BITS + bitidx0,\n                                    gmap.index(field_idx * usize::BITS + bitidx0))\n                        by {\n                            assert(m == sub(1usize << count,  1) << bitidx);\n                            assert(new_v == old_v | m);\n                            assert(old_v & m == 0);\n\n                            if bitidx <= bitidx0 < bitidx + count {\n                                let bi = bitidx0 as usize;\n\n                                assert(((new_v >> bi) & 1usize) != 0usize)\n                                  by(bit_vector)\n                                requires\n                                  bitidx <= bi < add(bitidx, count) < 64usize,\n                                  new_v == old_v | m,\n                                  m == sub(1usize << count, 1) << bitidx,\n                                  old_v & m == 0usize,\n                                  1usize <= count <= (64usize)\n                                { }\n\n                                assert(false);\n                            } else {\n                                if bitidx0 >= usize::BITS || bitidx0 < 0 {\n                                    assert(!has_bit(old_v, bitidx0));\n                                } else {\n                                    let bi = bitidx0 as usize;\n                                    assert(add(bitidx, count) == bitidx + count);\n\n                                    if bit > bi {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bitidx > bi,\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    } else {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bi >= add(bitidx, count),\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    }\n                                    assert(!has_bit(old_v, bitidx0));\n                                }\n                            }\n                        }\n                        });\n                    }\n                });\n\n                match res {\n                    Result::Ok(_) => {\n                        let user_idx = usize::BITS as usize * field_idx + bitidx;\n                        return (true, user_idx, Tracked(res_map));\n                    }\n                    Result::Err(updated_map) => {\n                        map = updated_map;\n                    }\n                }\n            } else {\n                let shift = if count == 1 {\n                    1\n                } else {\n                    let tz = crate::bin_sizes::trailing_zeros(mapm) as usize;\n                    assume(tz + 1 >= bitidx);\n                    tz + 1 - bitidx\n                };\n\n                assert(((mask << bitidx) << shift) == mask << add(bitidx, shift))\n                  by(bit_vector)\n                    requires\n                        bitidx <= 64usize,\n                        shift <= 64usize,\n                        add(bitidx, shift) <= 64usize,\n                    { }\n\n                bitidx = bitidx + shift;\n                m = m << shift;\n\n            }\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n        \n\n    //pub bitmap_try_find_claim_field_across(&self, idx: usize, \n}\n\n*/\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-memory-allocator/verus-mimalloc/bitmap.rs", "verified": true, "metadata": {"original_id": "verified-memory-allocator_bitmap_78a931c15aa7", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_07fb3dfabcde", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "07fb3dfabcde", "function_name": "bubble_outer", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_98a08476d7a8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_map_composition<A, B, C>(\n    gen_a: spec_fn(nat, nat) -> A,\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> C,\n    seed: nat,\n    size: nat\n)\n    \n{\n    // LHS: g(f(gen_a(seed, size)))\n    // RHS: g(gen_map(gen_a, f, seed, size)) = g(f(gen_a(seed, size)))\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_map_composition<A, B, C>(\n    gen_a: spec_fn(nat, nat) -> A,\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> C,\n    seed: nat,\n    size: nat\n)\n    ensures gen_map(gen_a, |a: A| g(f(a)), seed, size) ==\n            gen_map(|s: nat, sz: nat| gen_map(gen_a, f, s, sz), g, seed, size)\n{\n    // LHS: g(f(gen_a(seed, size)))\n    // RHS: g(gen_map(gen_a, f, seed, size)) = g(f(gen_a(seed, size)))\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_map_composition<A, B, C>(\n    gen_a: spec_fn(nat, nat) -> A,\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> C,\n    seed: nat,\n    size: nat\n)\n    ensures gen_map(gen_a, |a: A| g(f(a)), seed, size) ==\n            gen_map(|s: nat, sz: nat| gen_map(gen_a, f, s, sz), g, seed, size)\n{\n    // LHS: g(f(gen_a(seed, size)))\n    // RHS: g(gen_map(gen_a, f, seed, size)) = g(f(gen_a(seed, size)))\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_gen.rs", "verified": true, "metadata": {"original_id": "98a08476d7a8", "function_name": "gen_map_composition", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_c9556ae06624", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "c9556ae06624", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_2f2bfa02f75a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn const_fold_preserves_eval(e: Expr) ensures eval(const_fold(e)) == eval(e) {\n    reveal_with_fuel(eval, 2); reveal_with_fuel(const_fold, 2);\n    match e { Expr::Const(_) => {} Expr::Add { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } Expr::Mul { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn const_fold_preserves_eval(e: Expr) ensures eval(const_fold(e)) == eval(e) decreases e {\n    reveal_with_fuel(eval, 2); reveal_with_fuel(const_fold, 2);\n    match e { Expr::Const(_) => {} Expr::Add { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } Expr::Mul { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn const_fold_preserves_eval(e: Expr) ensures eval(const_fold(e)) == eval(e) decreases e {\n    reveal_with_fuel(eval, 2); reveal_with_fuel(const_fold, 2);\n    match e { Expr::Const(_) => {} Expr::Add { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } Expr::Mul { left, right } => { const_fold_preserves_eval(*left); const_fold_preserves_eval(*right); } }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_expression.rs", "verified": true, "metadata": {"original_id": "2f2bfa02f75a", "function_name": "const_fold_preserves_eval", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4857965ef5fc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fresh_for_singleton(x: Id)\n    \n{\n    let s = Set::empty().insert(x);\n    assert(!s.contains(x + 1));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fresh_for_singleton(x: Id)\n    ensures is_fresh_for_set(x + 1, Set::empty().insert(x))\n{\n    let s = Set::empty().insert(x);\n    assert(!s.contains(x + 1));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn fresh_for_singleton(x: Id)\n    ensures is_fresh_for_set(x + 1, Set::empty().insert(x))\n{\n    let s = Set::empty().insert(x);\n    assert(!s.contains(x + 1));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_ident.rs", "verified": true, "metadata": {"original_id": "4857965ef5fc", "function_name": "fresh_for_singleton", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_28778e12784d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms1_impl.rs", "verified": true, "metadata": {"original_id": "28778e12784d", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_10a228758399", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_iter_2_current.rs", "verified": true, "metadata": {"original_id": "10a228758399", "function_name": "monotonic", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_d162cf968338", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn well_typed_is_safe(e: Expr, ty: Ty)\n    \n    ensures !is_stuck(e)\n{\n    // By progress, well-typed closed term is value or can step\n    // Hence not stuck\n    assume(!is_stuck(e));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn well_typed_is_safe(e: Expr, ty: Ty)\n    requires has_type(empty_ctx(), e, ty)\n    ensures !is_stuck(e)\n{\n    // By progress, well-typed closed term is value or can step\n    // Hence not stuck\n    assume(!is_stuck(e));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn well_typed_is_safe(e: Expr, ty: Ty)\n    requires has_type(empty_ctx(), e, ty)\n    ensures !is_stuck(e)\n{\n    // By progress, well-typed closed term is value or can step\n    // Hence not stuck\n    assume(!is_stuck(e));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_soundness.rs", "verified": true, "metadata": {"original_id": "d162cf968338", "function_name": "well_typed_is_safe", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_0e8596649a9d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "0e8596649a9d", "function_name": "remove_duplicates", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_7abf24a196b4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7abf24a196b4", "function_name": "is_peak_valley", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_58e243ceeaa3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn bucket_contains(bucket: Seq<(nat, nat)>, k: nat) -> bool {\n    bucket.len() > 0 && (bucket[0].0 == k || bucket_contains(bucket.skip(1), k))\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn bucket_contains(bucket: Seq<(nat, nat)>, k: nat) -> bool decreases bucket.len() {\n    bucket.len() > 0 && (bucket[0].0 == k || bucket_contains(bucket.skip(1), k))\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn bucket_contains(bucket: Seq<(nat, nat)>, k: nat) -> bool decreases bucket.len() {\n    bucket.len() > 0 && (bucket[0].0 == k || bucket_contains(bucket.skip(1), k))\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_hash_def.rs", "verified": true, "metadata": {"original_id": "58e243ceeaa3", "function_name": "bucket_contains", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_fef19b915102", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or4_sound(d1: Dec, d2: Dec, d3: Dec, d4: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or4_sound(d1: Dec, d2: Dec, d3: Dec, d4: Dec)\n    ensures dec_to_bool(dec_or4(d1, d2, d3, d4)) ==\n        (dec_to_bool(d1) || dec_to_bool(d2) || dec_to_bool(d3) || dec_to_bool(d4))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or4_sound(d1: Dec, d2: Dec, d3: Dec, d4: Dec)\n    ensures dec_to_bool(dec_or4(d1, d2, d3, d4)) ==\n        (dec_to_bool(d1) || dec_to_bool(d2) || dec_to_bool(d3) || dec_to_bool(d4))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "fef19b915102", "function_name": "dec_or4_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_58fb96ec49ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58fb96ec49ca", "function_name": "largest_prime_factor", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_322bd234c857", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "322bd234c857", "function_name": "replace_chars", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_d07b7e8b87ad", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)  ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)  ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d07b7e8b87ad", "function_name": "query_fast", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_350cc2d5a451", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "350cc2d5a451", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_05b5ba19fc41", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)  ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_43/verina_advanced_43_iter_0_original.rs", "verified": true, "metadata": {"original_id": "05b5ba19fc41", "function_name": "max_strength", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_713dd99cc41d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn some_not_none<T>(x: T)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn some_not_none<T>(x: T)\n    ensures is_some(Some(x)), !is_none(Some(x))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn some_not_none<T>(x: T)\n    ensures is_some(Some(x)), !is_none(Some(x))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_option_def.rs", "verified": true, "metadata": {"original_id": "713dd99cc41d", "function_name": "some_not_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_d5bc24f83307", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d5bc24f83307", "function_name": "is_prime", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_951db7c77c7e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn continue_means_not_complete(config: RunnerConfig, stats: TestStats)\n    \n    ensures !is_complete(config, stats)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn continue_means_not_complete(config: RunnerConfig, stats: TestStats)\n    requires should_continue(config, stats)\n    ensures !is_complete(config, stats)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn continue_means_not_complete(config: RunnerConfig, stats: TestStats)\n    requires should_continue(config, stats)\n    ensures !is_complete(config, stats)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_runner_basic.rs", "verified": true, "metadata": {"original_id": "951db7c77c7e", "function_name": "continue_means_not_complete", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_1c0dbd75131f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/conda_impl.rs", "verified": true, "metadata": {"original_id": "1c0dbd75131f", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_563efd003869", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "563efd003869", "function_name": "min_array", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_f419a57be83c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f419a57be83c", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_8533df8b482a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "8533df8b482a", "function_name": "remove_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_dd551f039110", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn pq_insert_helper_sorted(x: nat, s: Seq<nat>)\n    requires sorted(s)\n    ensures sorted(pq_insert_helper(x, s))\n    {\n    reveal_with_fuel(sorted, 3);\n    reveal_with_fuel(pq_insert_helper, 3);\n    if s.len() == 0 {\n    } else if x <= s[0] {\n        assert((seq![x] + s)[0] == x);\n        assert((seq![x] + s).skip(1) =~= s);\n    } else {\n        pq_insert_helper_sorted(x, s.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(pq_insert_helper(x, s)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn pq_insert_helper_sorted(x: nat, s: Seq<nat>)\n    requires sorted(s)\n    ensures sorted(pq_insert_helper(x, s))\n    decreases s.len()\n{\n    reveal_with_fuel(sorted, 3);\n    reveal_with_fuel(pq_insert_helper, 3);\n    if s.len() == 0 {\n    } else if x <= s[0] {\n        assert((seq![x] + s)[0] == x);\n        assert((seq![x] + s).skip(1) =~= s);\n    } else {\n        pq_insert_helper_sorted(x, s.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(pq_insert_helper(x, s)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn pq_insert_helper_sorted(x: nat, s: Seq<nat>)\n    requires sorted(s)\n    ensures sorted(pq_insert_helper(x, s))\n    decreases s.len()\n{\n    reveal_with_fuel(sorted, 3);\n    reveal_with_fuel(pq_insert_helper, 3);\n    if s.len() == 0 {\n    } else if x <= s[0] {\n        assert((seq![x] + s)[0] == x);\n        assert((seq![x] + s).skip(1) =~= s);\n    } else {\n        pq_insert_helper_sorted(x, s.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(pq_insert_helper(x, s)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_priqueue_def.rs", "verified": true, "metadata": {"original_id": "dd551f039110", "function_name": "pq_insert_helper_sorted", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_79e4faecada6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)  ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "79e4faecada6", "function_name": "binary_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2a7de770b1a3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_size_positive(ty: Ty)\n    ensures ty_size(ty) >= 1\n    {\n    match ty {\n        Ty::TBool => {}\n        Ty::TNat => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_size_positive(ty: Ty)\n    ensures ty_size(ty) >= 1\n    decreases ty\n{\n    match ty {\n        Ty::TBool => {}\n        Ty::TNat => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_size_positive(ty: Ty)\n    ensures ty_size(ty) >= 1\n    decreases ty\n{\n    match ty {\n        Ty::TBool => {}\n        Ty::TNat => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_type.rs", "verified": true, "metadata": {"original_id": "2a7de770b1a3", "function_name": "ty_size_positive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_e6b58a67275b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () ,  { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e6b58a67275b", "function_name": "is_smaller", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_42e16574ca4e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_split(p: bool, q: bool)\n    \n    ensures p, q\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_split(p: bool, q: bool)\n    requires p && q\n    ensures p, q\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn conj_split(p: bool, q: bool)\n    requires p && q\n    ensures p, q\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "42e16574ca4e", "function_name": "conj_split", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c8dd4b36aa98", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "c8dd4b36aa98", "function_name": "list_deep_clone", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_954cb6321571", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)  ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_product_impl.rs", "verified": true, "metadata": {"original_id": "954cb6321571", "function_name": "array_product", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_7e4f191e6a5d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7e4f191e6a5d", "function_name": "longest_prefix", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_d059178c6f16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)  ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "d059178c6f16", "function_name": "array_product", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_a268b32765ce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_47/verina_advanced_47_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a268b32765ce", "function_name": "merge_intervals", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_69b3fbda5b5e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 ,  { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "69b3fbda5b5e", "function_name": "conditional_average", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_45948c0dcced", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "45948c0dcced", "function_name": "in_array_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_9ddb25988061", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ring_add_comm_nat(a: nat, b: nat)\n    \n{\n    assert((a + b) as nat == (b + a) as nat);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ring_add_comm_nat(a: nat, b: nat)\n    ensures ring_add_nat(a, b) == ring_add_nat(b, a)\n{\n    assert((a + b) as nat == (b + a) as nat);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ring_add_comm_nat(a: nat, b: nat)\n    ensures ring_add_nat(a, b) == ring_add_nat(b, a)\n{\n    assert((a + b) as nat == (b + a) as nat);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_ring.rs", "verified": true, "metadata": {"original_id": "9ddb25988061", "function_name": "ring_add_comm_nat", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_67588e015e9d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 ,  { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "67588e015e9d", "function_name": "smallest_num", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_d25a6e7acc46", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "d25a6e7acc46", "function_name": "is_odd_at_odd_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_74e74503ed04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "74e74503ed04", "function_name": "is_even_at_even_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1e814eec8fb0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn join_assoc(a: nat, b: nat, c: nat)  {}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn join_assoc(a: nat, b: nat, c: nat) ensures join(join(a, b), c) == join(a, join(b, c)) {}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn join_assoc(a: nat, b: nat, c: nat) ensures join(join(a, b), c) == join(a, join(b, c)) {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_lattice.rs", "verified": true, "metadata": {"original_id": "1e814eec8fb0", "function_name": "join_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_3d27422846e8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) ,  { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_8/verina_basic_8_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3d27422846e8", "function_name": "my_min", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_08e5cbd8d9f4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem ,  { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "08e5cbd8d9f4", "function_name": "last_position", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_292f839cb54c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int)  ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)  ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "292f839cb54c", "function_name": "count_identical_position", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_0d7fc03d6b31", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "0d7fc03d6b31", "function_name": "find_first_odd", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_54831fba50a1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "54831fba50a1", "function_name": "concat", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_abf8f6912145", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_or_intro_right(a: bool, b: bool)\n    requires b,\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_or_intro_right(a: bool, b: bool)\n    requires b,\n    ensures a || b\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_or_intro_right(a: bool, b: bool)\n    requires b,\n    ensures a || b\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "proofobjects_verus.rs", "verified": true, "metadata": {"original_id": "abf8f6912145", "function_name": "lemma_or_intro_right", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_5dacaca36979", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , {       }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5dacaca36979", "function_name": "encode_shift", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_3b02c10bafef", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lookup_insert_neq(d: nat, k1: nat, k2: nat, v: nat, t: Tree)\n    requires k1 != k2\n    ensures lookup(d, k1, insert(k2, v, t)) == lookup(d, k1, t)\n    {\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k2 < key {\n                if k1 < key {\n                    lookup_insert_neq(d, k1, k2, v, *left);\n                }\n            } else if k2 > key {\n                if k1 > key {\n                    lookup_insert_neq(d, k1, k2, v, *right);\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lookup_insert_neq(d: nat, k1: nat, k2: nat, v: nat, t: Tree)\n    requires k1 != k2\n    ensures lookup(d, k1, insert(k2, v, t)) == lookup(d, k1, t)\n    decreases t\n{\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k2 < key {\n                if k1 < key {\n                    lookup_insert_neq(d, k1, k2, v, *left);\n                }\n            } else if k2 > key {\n                if k1 > key {\n                    lookup_insert_neq(d, k1, k2, v, *right);\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lookup_insert_neq(d: nat, k1: nat, k2: nat, v: nat, t: Tree)\n    requires k1 != k2\n    ensures lookup(d, k1, insert(k2, v, t)) == lookup(d, k1, t)\n    decreases t\n{\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k2 < key {\n                if k1 < key {\n                    lookup_insert_neq(d, k1, k2, v, *left);\n                }\n            } else if k2 > key {\n                if k1 > key {\n                    lookup_insert_neq(d, k1, k2, v, *right);\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_def.rs", "verified": true, "metadata": {"original_id": "3b02c10bafef", "function_name": "lookup_insert_neq", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_3231df2aa7bd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_halts(t: Tm)\n    \n    ensures halts(t)\n{\n    // A value evaluates to itself with 0 fuel\n    assert(eval(t, 0) == t);\n    assert(halts_with_fuel(t, 0));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_halts(t: Tm)\n    requires value(t)\n    ensures halts(t)\n{\n    // A value evaluates to itself with 0 fuel\n    assert(eval(t, 0) == t);\n    assert(halts_with_fuel(t, 0));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_halts(t: Tm)\n    requires value(t)\n    ensures halts(t)\n{\n    // A value evaluates to itself with 0 fuel\n    assert(eval(t, 0) == t);\n    assert(halts_with_fuel(t, 0));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "norm_verus.rs", "verified": true, "metadata": {"original_id": "3231df2aa7bd", "function_name": "value_halts", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_ca4fd00d9375", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN ,  { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX  { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ca4fd00d9375", "function_name": "has_close_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a489c85fb9c5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_some_complete<T>(inner_outputs: Set<T>, x: T)\n    requires inner_outputs.contains(x)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_some_complete<T>(inner_outputs: Set<T>, x: T)\n    requires inner_outputs.contains(x)\n    ensures gen_some_outputs(inner_outputs).contains(Option::Some(x))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_some_complete<T>(inner_outputs: Set<T>, x: T)\n    requires inner_outputs.contains(x)\n    ensures gen_some_outputs(inner_outputs).contains(Option::Some(x))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_option.rs", "verified": true, "metadata": {"original_id": "a489c85fb9c5", "function_name": "gen_some_complete", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_5e01128ac24e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_trivial(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_trivial(p: bool)\n    ensures prop_when(false, p)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_when_trivial(p: bool)\n    ensures prop_when(false, p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_bool.rs", "verified": true, "metadata": {"original_id": "5e01128ac24e", "function_name": "prop_when_trivial", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_d5d2a6c1d6f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_irrefl(a: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_irrefl(a: nat)\n    ensures !ltb(a, a)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ltb_irrefl(a: nat)\n    ensures !ltb(a, a)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_comparison.rs", "verified": true, "metadata": {"original_id": "d5d2a6c1d6f6", "function_name": "ltb_irrefl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_9f43baeac6bf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ,  { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , ensures odd_index < v . len () , { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , ensures odd_index < v . len () , { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "9f43baeac6bf", "function_name": "choose_odd", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_6f058fa97b77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1  { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_43/verina_basic_43_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6f058fa97b77", "function_name": "sum_of_fourth_power_of_odd_numbers", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_6c57323acece", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64)  ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_CombNK/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6c57323acece", "function_name": "comb_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_a2378f16ca4f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "a2378f16ca4f", "function_name": "reverse", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_4ed022cb7ba8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "4ed022cb7ba8", "function_name": "bubble_inner", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_2a8db183c2ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2a8db183c2ea", "function_name": "find_even_numbers", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_3f28bf6a6158", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool recommends n >= 0 decreases n { if n == 0 { true } else if n > 0 { ! even (n - 1) } else { arbitrary () } }\nproof fn lemma_even_mod_equiv (n : nat) ensures even (n as int) <==> (n % 2 == 0) decreases n { if n == 0 { assert (even (0int) == true) ; assert (0nat % 2 == 0) ; } else if n == 1 { assert (even (1int) == ! even (0int)) ; assert (! even (0int) == false) ; assert (1nat % 2 == 1) ; } else { lemma_even_mod_equiv ((n - 1) as nat) ; assert (even (n as int) == ! even ((n - 1) as int)) ; assert (((n - 1) % 2 == 0) ==> (n % 2 == 1)) ; assert (((n - 1) % 2 == 1) ==> (n % 2 == 0)) ; } }\nfn is_even (n : u32) -> (r : bool)  ensures r <==> even (n as int) { proof { lemma_even_mod_equiv (n as nat) ; } n % 2 == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool recommends n >= 0 decreases n { if n == 0 { true } else if n > 0 { ! even (n - 1) } else { arbitrary () } }\nproof fn lemma_even_mod_equiv (n : nat) ensures even (n as int) <==> (n % 2 == 0) decreases n { if n == 0 { assert (even (0int) == true) ; assert (0nat % 2 == 0) ; } else if n == 1 { assert (even (1int) == ! even (0int)) ; assert (! even (0int) == false) ; assert (1nat % 2 == 1) ; } else { lemma_even_mod_equiv ((n - 1) as nat) ; assert (even (n as int) == ! even ((n - 1) as int)) ; assert (((n - 1) % 2 == 0) ==> (n % 2 == 1)) ; assert (((n - 1) % 2 == 1) ==> (n % 2 == 0)) ; } }\nfn is_even (n : u32) -> (r : bool) requires n >= 0 , ensures r <==> even (n as int) { proof { lemma_even_mod_equiv (n as nat) ; } n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool recommends n >= 0 decreases n { if n == 0 { true } else if n > 0 { ! even (n - 1) } else { arbitrary () } }\nproof fn lemma_even_mod_equiv (n : nat) ensures even (n as int) <==> (n % 2 == 0) decreases n { if n == 0 { assert (even (0int) == true) ; assert (0nat % 2 == 0) ; } else if n == 1 { assert (even (1int) == ! even (0int)) ; assert (! even (0int) == false) ; assert (1nat % 2 == 1) ; } else { lemma_even_mod_equiv ((n - 1) as nat) ; assert (even (n as int) == ! even ((n - 1) as int)) ; assert (((n - 1) % 2 == 0) ==> (n % 2 == 1)) ; assert (((n - 1) % 2 == 1) ==> (n % 2 == 0)) ; } }\nfn is_even (n : u32) -> (r : bool) requires n >= 0 , ensures r <==> even (n as int) { proof { lemma_even_mod_equiv (n as nat) ; } n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "3f28bf6a6158", "function_name": "is_even", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_a4e87be98e60", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_implies_le(e: RtStep1)\n    requires rt_inv(e)\n    \n    decreases e\n{\n    match e {\n        RtStep1::Refl { x: _ } => {\n        }\n        RtStep1::Snoc { prev, y } => {\n            let p = *prev;\n            lemma_rt_implies_le(p);\n            // rt_inv(e) implies step1(rt_rhs(p), y), hence y = rt_rhs(p) + 1.\n            assert(step1(rt_rhs(p), y));\n            assert(rt_rhs(p) < y);\n            // Combine: rt_lhs(p) <= rt_rhs(p) < y, and rt_lhs(e)=rt_lhs(p), rt_rhs(e)=y.\n            assert(rt_lhs(p) <= y);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_implies_le(e: RtStep1)\n    requires rt_inv(e)\n    ensures rt_lhs(e) <= rt_rhs(e)\n    decreases e\n{\n    match e {\n        RtStep1::Refl { x: _ } => {\n        }\n        RtStep1::Snoc { prev, y } => {\n            let p = *prev;\n            lemma_rt_implies_le(p);\n            // rt_inv(e) implies step1(rt_rhs(p), y), hence y = rt_rhs(p) + 1.\n            assert(step1(rt_rhs(p), y));\n            assert(rt_rhs(p) < y);\n            // Combine: rt_lhs(p) <= rt_rhs(p) < y, and rt_lhs(e)=rt_lhs(p), rt_rhs(e)=y.\n            assert(rt_lhs(p) <= y);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_rt_implies_le(e: RtStep1)\n    requires rt_inv(e)\n    ensures rt_lhs(e) <= rt_rhs(e)\n    decreases e\n{\n    match e {\n        RtStep1::Refl { x: _ } => {\n        }\n        RtStep1::Snoc { prev, y } => {\n            let p = *prev;\n            lemma_rt_implies_le(p);\n            // rt_inv(e) implies step1(rt_rhs(p), y), hence y = rt_rhs(p) + 1.\n            assert(step1(rt_rhs(p), y));\n            assert(rt_rhs(p) < y);\n            // Combine: rt_lhs(p) <= rt_rhs(p) < y, and rt_lhs(e)=rt_lhs(p), rt_rhs(e)=y.\n            assert(rt_lhs(p) <= y);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "rel_verus.rs", "verified": true, "metadata": {"original_id": "a4e87be98e60", "function_name": "lemma_rt_implies_le", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_193ced81e2b1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "193ced81e2b1", "function_name": "is_integer", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_2229ff3b20ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_24/verina_advanced_24_impl.rs", "verified": true, "metadata": {"original_id": "2229ff3b20ec", "function_name": "binary_search_position", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_8640e6ee29f2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "8640e6ee29f2", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_750e0222ff80", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "750e0222ff80", "function_name": "shared_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_697f62ffc502", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "697f62ffc502", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_3ccfcadca9d5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn example_unit_type()\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn example_unit_type()\n    ensures has_type(empty_store_typing(), Tm::Unit, Ty::TUnit)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn example_unit_type()\n    ensures has_type(empty_store_typing(), Tm::Unit, Ty::TUnit)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "references_verus.rs", "verified": true, "metadata": {"original_id": "3ccfcadca9d5", "function_name": "example_unit_type", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_4230f034f4f9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "4230f034f4f9", "function_name": "last_position", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_be8112c0bae7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "be8112c0bae7", "function_name": "split_and_append", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_bda45de2df39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)  ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "bda45de2df39", "function_name": "element_wise_divide", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_87ff0947783d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "87ff0947783d", "function_name": "triple_conditions", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_ba1c83625e4a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn double_neg_intro(p: bool)\n    \n    ensures !!p\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn double_neg_intro(p: bool)\n    requires p\n    ensures !!p\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn double_neg_intro(p: bool)\n    requires p\n    ensures !!p\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_negation.rs", "verified": true, "metadata": {"original_id": "ba1c83625e4a", "function_name": "double_neg_intro", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_aea37c8e85e0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn material_impl(p: bool, q: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn material_impl(p: bool, q: bool)\n    ensures (p ==> q) <==> (!p || q)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn material_impl(p: bool, q: bool)\n    ensures (p ==> q) <==> (!p || q)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "aea37c8e85e0", "function_name": "material_impl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_e1276ff57bb5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn merge_sorted(s1: Seq<nat>, s2: Seq<nat>)\n    requires sorted(s1), sorted(s2)\n    ensures sorted(merge(s1, s2))\n    {\n    reveal_with_fuel(merge, 3);\n    reveal_with_fuel(sorted, 3);\n    if s1.len() == 0 {\n    } else if s2.len() == 0 {\n    } else if s1[0] <= s2[0] {\n        merge_sorted(s1.skip(1), s2);\n    } else {\n        merge_sorted(s1, s2.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(merge(s1, s2)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn merge_sorted(s1: Seq<nat>, s2: Seq<nat>)\n    requires sorted(s1), sorted(s2)\n    ensures sorted(merge(s1, s2))\n    decreases s1.len() + s2.len()\n{\n    reveal_with_fuel(merge, 3);\n    reveal_with_fuel(sorted, 3);\n    if s1.len() == 0 {\n    } else if s2.len() == 0 {\n    } else if s1[0] <= s2[0] {\n        merge_sorted(s1.skip(1), s2);\n    } else {\n        merge_sorted(s1, s2.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(merge(s1, s2)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn merge_sorted(s1: Seq<nat>, s2: Seq<nat>)\n    requires sorted(s1), sorted(s2)\n    ensures sorted(merge(s1, s2))\n    decreases s1.len() + s2.len()\n{\n    reveal_with_fuel(merge, 3);\n    reveal_with_fuel(sorted, 3);\n    if s1.len() == 0 {\n    } else if s2.len() == 0 {\n    } else if s1[0] <= s2[0] {\n        merge_sorted(s1.skip(1), s2);\n    } else {\n        merge_sorted(s1, s2.skip(1));\n    }\n    // Complex inductive proof - assume correctness\n    assume(sorted(merge(s1, s2)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_merge.rs", "verified": true, "metadata": {"original_id": "e1276ff57bb5", "function_name": "merge_sorted", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_51edac1848df", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_count_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_count_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    ensures try_shrink(state, candidate, still_fails).shrink_count == state.shrink_count + 1\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_count_increases(state: ShrinkState, candidate: nat, still_fails: bool)\n    ensures try_shrink(state, candidate, still_fails).shrink_count == state.shrink_count + 1\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_runner_shrink.rs", "verified": true, "metadata": {"original_id": "51edac1848df", "function_name": "shrink_count_increases", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_0c10f306fe6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_f84f5a8a60ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_nandb_def(b1: bool, b2: bool)\n    \n{\n    assert(nandb(b1, b2) == negb(andb(b1, b2)));\n    assert(negb(andb(b1, b2)) == !(b1 && b2));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_nandb_def(b1: bool, b2: bool)\n    ensures nandb(b1, b2) == !(b1 && b2)\n{\n    assert(nandb(b1, b2) == negb(andb(b1, b2)));\n    assert(negb(andb(b1, b2)) == !(b1 && b2));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex4_nandb_def(b1: bool, b2: bool)\n    ensures nandb(b1, b2) == !(b1 && b2)\n{\n    assert(nandb(b1, b2) == negb(andb(b1, b2)));\n    assert(negb(andb(b1, b2)) == !(b1 && b2));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "f84f5a8a60ee", "function_name": "ex4_nandb_def", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_9b562aba017e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32) requires nums . len () > 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32) requires nums . len () > 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_1/verina_advanced_1_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9b562aba017e", "function_name": "find_single_number", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_1a2824875b68", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)  ensures r == 3 * x { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1a2824875b68", "function_name": "Triple1", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_76d66feff36e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s42if_impl.rs", "verified": true, "metadata": {"original_id": "76d66feff36e", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_cba32b42d8d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cba32b42d8d3", "function_name": "contains", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_a7b74e361717", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_14/verina_advanced_14.rs", "verified": true, "metadata": {"original_id": "a7b74e361717", "function_name": "if_power_of_four", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_8c284a4963a0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len ()  { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c284a4963a0", "function_name": "pluck_smallest_even", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_vostd_array_ptr_6a87e02b8f48", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr;\nuse vstd::set;\nuse vstd::set_lib;\n\nuse core::marker::PhantomData;\n\nverus! {\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ArrayPtr<V, const N: usize> {\n    pub addr: usize,\n    pub index: usize,\n    pub _type: PhantomData<[V; N]>,\n}\n\n#[verifier::external_body]\n#[verifier::accept_recursive_types(V)]\npub tracked struct PointsToArray<V, const N: usize> {\n    phantom: core::marker::PhantomData<[V; N]>,\n    no_copy: NoCopy,\n}\n\npub ghost struct PointsToArrayData<V, const N: usize> {\n    pub ptr: *mut [V; N],\n    pub value: [raw_ptr::MemContents<V>; N],\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub uninterp spec fn mem_contents_unwrap<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> (res: raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub uninterp spec fn mem_contents_wrap<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n) -> (res: [raw_ptr::MemContents<V>; N]);\n\npub axiom fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n;\n\npub axiom fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n\n    ensures\n        res.is_uninit(),\n;\n\npub axiom fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n;\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    uninterp spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(self) -> *mut [V; N] {\n        self@.ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self@.value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\nbroadcast use {\n    raw_ptr::group_raw_ptr_axioms,\n    set_lib::group_set_lib_default,\n    set::group_set_axioms,\n};\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub exec fn addr(&self) -> usize\n        returns\n            self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n            res.index == 0,\n    {\n        Self { addr, index: 0, _type: PhantomData }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub exec fn add(self, off: usize) -> Self\n\n    {\n        Self { addr: self.addr, index: (self.index + off) as usize, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn is_pptr(self, ptr: ArrayPtr<V, N>) -> bool {\n        ptr.addr == self.addr()\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n\n        ensures\n            self.wf(),\n            self.addr() == old(self).addr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res@.ptr == pt@.ptr,\n            res@.value == mem_contents_wrap(pt@.opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res@.ptr == self@.ptr,\n            res@.opt_value == mem_contents_unwrap(self@.value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V: Sized, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm@.value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, index: 0, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.is_pptr(p));\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(points_to@.value, perm_ptr.opt_value());\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V)\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[self.index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(self.index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), self.index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: V) where\n        V: Copy,\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[self.index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(self.index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), self.index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n        opens_invariants none\n        no_unwind\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr;\nuse vstd::set;\nuse vstd::set_lib;\n\nuse core::marker::PhantomData;\n\nverus! {\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ArrayPtr<V, const N: usize> {\n    pub addr: usize,\n    pub index: usize,\n    pub _type: PhantomData<[V; N]>,\n}\n\n#[verifier::external_body]\n#[verifier::accept_recursive_types(V)]\npub tracked struct PointsToArray<V, const N: usize> {\n    phantom: core::marker::PhantomData<[V; N]>,\n    no_copy: NoCopy,\n}\n\npub ghost struct PointsToArrayData<V, const N: usize> {\n    pub ptr: *mut [V; N],\n    pub value: [raw_ptr::MemContents<V>; N],\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub uninterp spec fn mem_contents_unwrap<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> (res: raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub uninterp spec fn mem_contents_wrap<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n) -> (res: [raw_ptr::MemContents<V>; N]);\n\npub axiom fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n;\n\npub axiom fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n;\n\npub axiom fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n;\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    uninterp spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(self) -> *mut [V; N] {\n        self@.ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self@.value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\nbroadcast use {\n    raw_ptr::group_raw_ptr_axioms,\n    set_lib::group_set_lib_default,\n    set::group_set_axioms,\n};\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub exec fn addr(&self) -> usize\n        returns\n            self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n            res.index == 0,\n    {\n        Self { addr, index: 0, _type: PhantomData }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub exec fn add(self, off: usize) -> Self\n        requires\n            self.index + off\n                <= N  // C standard style: don't exceed one-past the end of the array\n            ,\n    {\n        Self { addr: self.addr, index: (self.index + off) as usize, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn is_pptr(self, ptr: ArrayPtr<V, N>) -> bool {\n        ptr.addr == self.addr()\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.addr() == old(self).addr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res@.ptr == pt@.ptr,\n            res@.value == mem_contents_wrap(pt@.opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res@.ptr == self@.ptr,\n            res@.opt_value == mem_contents_unwrap(self@.value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V: Sized, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm@.value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, index: 0, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.is_pptr(p));\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(points_to@.value, perm_ptr.opt_value());\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[self.index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(self.index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), self.index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: V) where\n        V: Copy,\n\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[self.index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(self.index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), self.index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n        opens_invariants none\n        no_unwind\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr;\nuse vstd::set;\nuse vstd::set_lib;\n\nuse core::marker::PhantomData;\n\nverus! {\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ArrayPtr<V, const N: usize> {\n    pub addr: usize,\n    pub index: usize,\n    pub _type: PhantomData<[V; N]>,\n}\n\n#[verifier::external_body]\n#[verifier::accept_recursive_types(V)]\npub tracked struct PointsToArray<V, const N: usize> {\n    phantom: core::marker::PhantomData<[V; N]>,\n    no_copy: NoCopy,\n}\n\npub ghost struct PointsToArrayData<V, const N: usize> {\n    pub ptr: *mut [V; N],\n    pub value: [raw_ptr::MemContents<V>; N],\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub uninterp spec fn mem_contents_unwrap<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> (res: raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub uninterp spec fn mem_contents_wrap<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n) -> (res: [raw_ptr::MemContents<V>; N]);\n\npub axiom fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n;\n\npub axiom fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n;\n\npub axiom fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n;\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    uninterp spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(self) -> *mut [V; N] {\n        self@.ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self@.value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\nbroadcast use {\n    raw_ptr::group_raw_ptr_axioms,\n    set_lib::group_set_lib_default,\n    set::group_set_axioms,\n};\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub exec fn addr(&self) -> usize\n        returns\n            self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n            res.index == 0,\n    {\n        Self { addr, index: 0, _type: PhantomData }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub exec fn add(self, off: usize) -> Self\n        requires\n            self.index + off\n                <= N  // C standard style: don't exceed one-past the end of the array\n            ,\n    {\n        Self { addr: self.addr, index: (self.index + off) as usize, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn is_pptr(self, ptr: ArrayPtr<V, N>) -> bool {\n        ptr.addr == self.addr()\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.addr() == old(self).addr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res@.ptr == pt@.ptr,\n            res@.value == mem_contents_wrap(pt@.opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res@.ptr == self@.ptr,\n            res@.opt_value == mem_contents_unwrap(self@.value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V: Sized, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm@.value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, index: 0, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.is_pptr(p));\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(points_to@.value, perm_ptr.opt_value());\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[self.index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(self.index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), self.index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: V) where\n        V: Copy,\n\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[self.index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(self.index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), self.index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n        opens_invariants none\n        no_unwind\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/array_ptr.rs", "verified": true, "metadata": {"original_id": "vostd_array_ptr_6a87e02b8f48", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_d8a6a96c02c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn exists_range_helper(lo: nat, hi: nat, p: spec_fn(nat) -> bool, i: nat) -> bool\n    {\n    if i >= hi {\n        false\n    } else if p(i) {\n        true\n    } else {\n        exists_range_helper(lo, hi, p, i + 1)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn exists_range_helper(lo: nat, hi: nat, p: spec_fn(nat) -> bool, i: nat) -> bool\n    decreases hi - i when i <= hi\n{\n    if i >= hi {\n        false\n    } else if p(i) {\n        true\n    } else {\n        exists_range_helper(lo, hi, p, i + 1)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn exists_range_helper(lo: nat, hi: nat, p: spec_fn(nat) -> bool, i: nat) -> bool\n    decreases hi - i when i <= hi\n{\n    if i >= hi {\n        false\n    } else if p(i) {\n        true\n    } else {\n        exists_range_helper(lo, hi, p, i + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_exists.rs", "verified": true, "metadata": {"original_id": "d8a6a96c02c7", "function_name": "exists_range_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_a487cda08e77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e ,  { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) ,  { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a487cda08e77", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_452321dd1361", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32)  ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)  ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "452321dd1361", "function_name": "has_close_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_cfa994b93799", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) ,  { arr [k - 1] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { arr [k - 1] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { arr [k - 1] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_4/verina_basic_4_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cfa994b93799", "function_name": "kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_99cc05c86ad3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_pair_zero_zero()\n    \n{\n    assert(shrink_nat(0).len() == 0);\n    let result = shrink_pair_nat((0, 0));\n    let first_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    let second_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    assert(first_shrinks =~= Seq::<(nat, nat)>::empty());\n    assert(second_shrinks =~= Seq::<(nat, nat)>::empty());\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_pair_zero_zero()\n    ensures shrink_pair_nat((0, 0)).len() == 0\n{\n    assert(shrink_nat(0).len() == 0);\n    let result = shrink_pair_nat((0, 0));\n    let first_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    let second_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    assert(first_shrinks =~= Seq::<(nat, nat)>::empty());\n    assert(second_shrinks =~= Seq::<(nat, nat)>::empty());\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_pair_zero_zero()\n    ensures shrink_pair_nat((0, 0)).len() == 0\n{\n    assert(shrink_nat(0).len() == 0);\n    let result = shrink_pair_nat((0, 0));\n    let first_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    let second_shrinks = Seq::new(0nat, |i: int| (0nat, 0nat));\n    assert(first_shrinks =~= Seq::<(nat, nat)>::empty());\n    assert(second_shrinks =~= Seq::<(nat, nat)>::empty());\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "99cc05c86ad3", "function_name": "shrink_pair_zero_zero", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_c5e0e1ff8db1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 ,  { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "c5e0e1ff8db1", "function_name": "all_sequence_equal_length", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_d245d4d43e16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_add_shifts(lo: int, hi: int, k: int)\n    \n{\n    assert forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n        in_int_range(n, lo + k, hi + k) by {\n        if gen_int_add(choose_int_outputs(lo, hi), k).contains(n) {\n            let m = choose|m: int| choose_int_outputs(lo, hi).contains(m) && m + k == n;\n            assert(in_int_range(m, lo, hi));\n            assert(n == m + k);\n        }\n        if in_int_range(n, lo + k, hi + k) {\n            let m = n - k;\n            assert(choose_int_outputs(lo, hi).contains(m));\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_add_shifts(lo: int, hi: int, k: int)\n    ensures\n        forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n            in_int_range(n, lo + k, hi + k)\n{\n    assert forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n        in_int_range(n, lo + k, hi + k) by {\n        if gen_int_add(choose_int_outputs(lo, hi), k).contains(n) {\n            let m = choose|m: int| choose_int_outputs(lo, hi).contains(m) && m + k == n;\n            assert(in_int_range(m, lo, hi));\n            assert(n == m + k);\n        }\n        if in_int_range(n, lo + k, hi + k) {\n            let m = n - k;\n            assert(choose_int_outputs(lo, hi).contains(m));\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_add_shifts(lo: int, hi: int, k: int)\n    ensures\n        forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n            in_int_range(n, lo + k, hi + k)\n{\n    assert forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n        in_int_range(n, lo + k, hi + k) by {\n        if gen_int_add(choose_int_outputs(lo, hi), k).contains(n) {\n            let m = choose|m: int| choose_int_outputs(lo, hi).contains(m) && m + k == n;\n            assert(in_int_range(m, lo, hi));\n            assert(n == m + k);\n        }\n        if in_int_range(n, lo + k, hi + k) {\n            let m = n - k;\n            assert(choose_int_outputs(lo, hi).contains(m));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "d245d4d43e16", "function_name": "gen_int_add_shifts", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_d77037bebfb8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_weight(g: Graph, tree_edges: Seq<nat>) -> nat {\n    if tree_edges.len() == 0 { 0 }\n    else { g.edges[tree_edges[0] as int].weight + tree_weight(g, tree_edges.skip(1)) }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_weight(g: Graph, tree_edges: Seq<nat>) -> nat decreases tree_edges.len() {\n    if tree_edges.len() == 0 { 0 }\n    else { g.edges[tree_edges[0] as int].weight + tree_weight(g, tree_edges.skip(1)) }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_weight(g: Graph, tree_edges: Seq<nat>) -> nat decreases tree_edges.len() {\n    if tree_edges.len() == 0 { 0 }\n    else { g.edges[tree_edges[0] as int].weight + tree_weight(g, tree_edges.skip(1)) }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_spanning_tree.rs", "verified": true, "metadata": {"original_id": "d77037bebfb8", "function_name": "tree_weight", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1552bba1dfdd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn get_or_insert_none(default: nat)\n    \n{\n    // Trivially true\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn get_or_insert_none(default: nat)\n    ensures get_or_insert(Option::<nat>::None, default) == (Option::Some(default), default)\n{\n    // Trivially true\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn get_or_insert_none(default: nat)\n    ensures get_or_insert(Option::<nat>::None, default) == (Option::Some(default), default)\n{\n    // Trivially true\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_default.rs", "verified": true, "metadata": {"original_id": "1552bba1dfdd", "function_name": "get_or_insert_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b0cca78820da", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_complement(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_complement(p: bool)\n    ensures conj_complement(p)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_complement(p: bool)\n    ensures conj_complement(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "b0cca78820da", "function_name": "verify_conj_complement", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7b3ff3eab4b6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 ,  { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7b3ff3eab4b6", "function_name": "smallest_num", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_c19ba825f92e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c19ba825f92e", "function_name": "replace_blanks_with_chars", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_43973fae6ed6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_trans(b1: Bag, b2: Bag, b3: Bag)\n    requires bag_eq(b1, b2), bag_eq(b2, b3)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_trans(b1: Bag, b2: Bag, b3: Bag)\n    requires bag_eq(b1, b2), bag_eq(b2, b3)\n    ensures bag_eq(b1, b3)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bag_eq_trans(b1: Bag, b2: Bag, b3: Bag)\n    requires bag_eq(b1, b2), bag_eq(b2, b3)\n    ensures bag_eq(b1, b3)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_multiset_perm.rs", "verified": true, "metadata": {"original_id": "43973fae6ed6", "function_name": "bag_eq_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_886aca454df9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_142_iter_4_current.rs", "verified": true, "metadata": {"original_id": "886aca454df9", "function_name": "count_identical_position", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_82a6afc28513", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leb_neq_ltb(a: nat, b: nat)\n    requires leb(a, b), a != b\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leb_neq_ltb(a: nat, b: nat)\n    requires leb(a, b), a != b\n    ensures ltb(a, b)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn leb_neq_ltb(a: nat, b: nat)\n    requires leb(a, b), a != b\n    ensures ltb(a, b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_comparison.rs", "verified": true, "metadata": {"original_id": "82a6afc28513", "function_name": "leb_neq_ltb", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_be934c016697", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_bound(a: nat, m: nat)\n    \n    ensures a % m < m\n{}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_bound(a: nat, m: nat)\n    requires m > 0\n    ensures a % m < m\n{}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mod_bound(a: nat, m: nat)\n    requires m > 0\n    ensures a % m < m\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_mod_arith.rs", "verified": true, "metadata": {"original_id": "be934c016697", "function_name": "mod_bound", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_18e19141fc74", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 ,  { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "18e19141fc74", "function_name": "is_sorted", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_80ac35f4ccfb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)  ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_77/verina_advanced_77_iter_0_original.rs", "verified": true, "metadata": {"original_id": "80ac35f4ccfb", "function_name": "trap_rain_water", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_90d51220e05f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut k = 2 ; while k < n invariant 2 <= k <= n , forall | j : int | 2 <= j < k ==> ! is_divisible (n as int , j) , { if n % k == 0 { assert (is_divisible (n as int , k as int)) ; assert (2 <= k < n) ; return true ; } k = k + 1 ; } assert (k == n) ; assert (forall | j : int | 2 <= j < n ==> ! is_divisible (n as int , j)) ; return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut k = 2 ; while k < n invariant 2 <= k <= n , forall | j : int | 2 <= j < k ==> ! is_divisible (n as int , j) , decreases n - k { if n % k == 0 { assert (is_divisible (n as int , k as int)) ; assert (2 <= k < n) ; return true ; } k = k + 1 ; } assert (k == n) ; assert (forall | j : int | 2 <= j < n ==> ! is_divisible (n as int , j)) ; return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut k = 2 ; while k < n invariant 2 <= k <= n , forall | j : int | 2 <= j < k ==> ! is_divisible (n as int , j) , decreases n - k { if n % k == 0 { assert (is_divisible (n as int , k as int)) ; assert (2 <= k < n) ; return true ; } k = k + 1 ; } assert (k == n) ; assert (forall | j : int | 2 <= j < n ==> ! is_divisible (n as int , j)) ; return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "90d51220e05f", "function_name": "is_non_prime", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_fdff90987a6f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fdff90987a6f", "function_name": "unique", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_b1cdb1d7cb54", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 5 * (N as i32)) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * (N as i32)) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s42if_impl.rs", "verified": true, "metadata": {"original_id": "b1cdb1d7cb54", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_verus_broadcast_proof_a0c86e101dd0", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n\n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n\n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n\n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n\n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //    { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n\n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n\n} // verus!", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/broadcast_proof.rs", "verified": true, "metadata": {"original_id": "verus_broadcast_proof_a0c86e101dd0", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_d5076568e671", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "d5076568e671", "function_name": "element_wise_division", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_78046adc9be3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_smaller<T>(s: Seq<T>)\n    \n    ensures shrink_seq_head(s).len() < s.len()\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_smaller<T>(s: Seq<T>)\n    requires s.len() > 0\n    ensures shrink_seq_head(s).len() < s.len()\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_smaller<T>(s: Seq<T>)\n    requires s.len() > 0\n    ensures shrink_seq_head(s).len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_shrinking.rs", "verified": true, "metadata": {"original_id": "78046adc9be3", "function_name": "verify_shrink_seq_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2a643fceefe9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2a643fceefe9", "function_name": "is_non_prime", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_38fe560be03b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn rb_insert_aux(k: int, v: nat, t: RBTree) -> RBTree\n    {\n    match t {\n        RBTree::E => RBTree::T {\n            color: Color::Red,\n            left: Box::new(RBTree::E),\n            key: k,\n            value: v,\n            right: Box::new(RBTree::E),\n        },\n        RBTree::T { color, left, key, value, right } =>\n            if k < key {\n                balance(color, rb_insert_aux(k, v, *left), key, value, *right)\n            } else if k > key {\n                balance(color, *left, key, value, rb_insert_aux(k, v, *right))\n            } else {\n                // Key exists, update value\n                RBTree::T { color, left, key, value: v, right }\n            }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn rb_insert_aux(k: int, v: nat, t: RBTree) -> RBTree\n    decreases t\n{\n    match t {\n        RBTree::E => RBTree::T {\n            color: Color::Red,\n            left: Box::new(RBTree::E),\n            key: k,\n            value: v,\n            right: Box::new(RBTree::E),\n        },\n        RBTree::T { color, left, key, value, right } =>\n            if k < key {\n                balance(color, rb_insert_aux(k, v, *left), key, value, *right)\n            } else if k > key {\n                balance(color, *left, key, value, rb_insert_aux(k, v, *right))\n            } else {\n                // Key exists, update value\n                RBTree::T { color, left, key, value: v, right }\n            }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn rb_insert_aux(k: int, v: nat, t: RBTree) -> RBTree\n    decreases t\n{\n    match t {\n        RBTree::E => RBTree::T {\n            color: Color::Red,\n            left: Box::new(RBTree::E),\n            key: k,\n            value: v,\n            right: Box::new(RBTree::E),\n        },\n        RBTree::T { color, left, key, value, right } =>\n            if k < key {\n                balance(color, rb_insert_aux(k, v, *left), key, value, *right)\n            } else if k > key {\n                balance(color, *left, key, value, rb_insert_aux(k, v, *right))\n            } else {\n                // Key exists, update value\n                RBTree::T { color, left, key, value: v, right }\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_redblack_insert.rs", "verified": true, "metadata": {"original_id": "38fe560be03b", "function_name": "rb_insert_aux", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_f417526be3c4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len ()  { let mut j = 0 ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f417526be3c4", "function_name": "has_close_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_assert_verus_vecdeque_test_3d17853271e4", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n\n    v2.push_back(5);\n\n    v2.push_back(7);\n\n    v2.insert(1, 6);\n\n    v1.append(&mut v2);\n\n    v1.remove(2);\n\n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n    assert(v1@ == seq![4u32]);\n\n    v2.push_back(5);\n    assert(v2.len() == 1);\n    v2.push_back(7);\n    assert(v2@.len() == 2);\n    v2.insert(1, 6);\n    assert(v2@ == seq![5u32, 6u32, 7u32]);\n\n    v1.append(&mut v2);\n    assert(v2@.len() == 0);\n    assert(v1@.len() == 4);\n    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);\n    v1.remove(2);\n    assert(v1@ == seq![4u32, 5u32, 7u32]);\n    \n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n    assert(v1@ == seq![10u32, 11u32]);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n        assert(x > 9);\n        assert(x < 12);\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n    assert(v1@ == seq![4u32]);\n\n    v2.push_back(5);\n    assert(v2.len() == 1);\n    v2.push_back(7);\n    assert(v2@.len() == 2);\n    v2.insert(1, 6);\n    assert(v2@ == seq![5u32, 6u32, 7u32]);\n\n    v1.append(&mut v2);\n    assert(v2@.len() == 0);\n    assert(v1@.len() == 4);\n    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);\n    v1.remove(2);\n    assert(v1@ == seq![4u32, 5u32, 7u32]);\n    \n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n    assert(v1@ == seq![10u32, 11u32]);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n        assert(x > 9);\n        assert(x < 12);\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/std_test/vecdeque_test.rs", "verified": true, "metadata": {"original_id": "verus_vecdeque_test_3d17853271e4", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_45023ec76be0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_acc_len(s: Seq<nat>, acc: Seq<nat>)\n    ensures reverse_acc(s, acc).len() == s.len() + acc.len()\n    {\n    reveal_with_fuel(reverse_acc, 2);\n    if s.len() > 0 {\n        reverse_acc_len(s.skip(1), seq![s[0]] + acc);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_acc_len(s: Seq<nat>, acc: Seq<nat>)\n    ensures reverse_acc(s, acc).len() == s.len() + acc.len()\n    decreases s.len()\n{\n    reveal_with_fuel(reverse_acc, 2);\n    if s.len() > 0 {\n        reverse_acc_len(s.skip(1), seq![s[0]] + acc);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reverse_acc_len(s: Seq<nat>, acc: Seq<nat>)\n    ensures reverse_acc(s, acc).len() == s.len() + acc.len()\n    decreases s.len()\n{\n    reveal_with_fuel(reverse_acc, 2);\n    if s.len() > 0 {\n        reverse_acc_len(s.skip(1), seq![s[0]] + acc);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_seq_reverse.rs", "verified": true, "metadata": {"original_id": "45023ec76be0", "function_name": "reverse_acc_len", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_ae34894f2210", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_624_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ae34894f2210", "function_name": "to_uppercase", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_5616d06bce3a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_nat_smaller(n: nat, i: int)\n    requires 0 <= i < shrink_nat(n).len() as int\n    \n{\n    if n == 0 {\n        // Vacuously true - empty sequence\n    } else {\n        let half = (n / 2) as nat;\n        if half == 0 {\n            assert(shrink_nat(n) =~= seq![0nat]);\n            assert(shrink_nat(n)[0] == 0);\n            assert(0 < n);\n        } else {\n            assert(shrink_nat(n) =~= seq![0nat, half]);\n            if i == 0 {\n                assert(shrink_nat(n)[0] == 0);\n                assert(0 < n);\n            } else {\n                assert(shrink_nat(n)[1] == half);\n                assert(half < n);\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_nat_smaller(n: nat, i: int)\n    requires 0 <= i < shrink_nat(n).len() as int\n    ensures shrink_nat(n)[i] < n\n{\n    if n == 0 {\n        // Vacuously true - empty sequence\n    } else {\n        let half = (n / 2) as nat;\n        if half == 0 {\n            assert(shrink_nat(n) =~= seq![0nat]);\n            assert(shrink_nat(n)[0] == 0);\n            assert(0 < n);\n        } else {\n            assert(shrink_nat(n) =~= seq![0nat, half]);\n            if i == 0 {\n                assert(shrink_nat(n)[0] == 0);\n                assert(0 < n);\n            } else {\n                assert(shrink_nat(n)[1] == half);\n                assert(half < n);\n            }\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_nat_smaller(n: nat, i: int)\n    requires 0 <= i < shrink_nat(n).len() as int\n    ensures shrink_nat(n)[i] < n\n{\n    if n == 0 {\n        // Vacuously true - empty sequence\n    } else {\n        let half = (n / 2) as nat;\n        if half == 0 {\n            assert(shrink_nat(n) =~= seq![0nat]);\n            assert(shrink_nat(n)[0] == 0);\n            assert(0 < n);\n        } else {\n            assert(shrink_nat(n) =~= seq![0nat, half]);\n            if i == 0 {\n                assert(shrink_nat(n)[0] == 0);\n                assert(0 < n);\n            } else {\n                assert(shrink_nat(n)[1] == half);\n                assert(half < n);\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "5616d06bce3a", "function_name": "shrink_nat_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_56e6b68b28eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "56e6b68b28eb", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_81a63418f7a2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 ,  { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "81a63418f7a2", "function_name": "findMax", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_f8a4ea34e547", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool)  { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool) ensures b == positive (v @) { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool) ensures b == positive (v @) { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8a4ea34e547", "function_name": "mpositive", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_fa2d0ffe8f36", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn nat_max_assoc(a: nat, b: nat, c: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn nat_max_assoc(a: nat, b: nat, c: nat)\n    ensures nat_max(nat_max(a, b), c) == nat_max(a, nat_max(b, c))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn nat_max_assoc(a: nat, b: nat, c: nat)\n    ensures nat_max(nat_max(a, b), c) == nat_max(a, nat_max(b, c))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_semigroup.rs", "verified": true, "metadata": {"original_id": "fa2d0ffe8f36", "function_name": "nat_max_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_307b699e2cfc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs5_impl.rs", "verified": true, "metadata": {"original_id": "307b699e2cfc", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_b61aea969787", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)  ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b61aea969787", "function_name": "update_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_95c98c5dcabd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "95c98c5dcabd", "function_name": "double_array_elements_aux", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_0211e573ceeb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_transitive(x: nat, y: nat, z: nat)\n    \n    ensures dec_to_bool(dec_eq_nat(x, z))\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_transitive(x: nat, y: nat, z: nat)\n    requires dec_to_bool(dec_eq_nat(x, y)), dec_to_bool(dec_eq_nat(y, z))\n    ensures dec_to_bool(dec_eq_nat(x, z))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_transitive(x: nat, y: nat, z: nat)\n    requires dec_to_bool(dec_eq_nat(x, y)), dec_to_bool(dec_eq_nat(y, z))\n    ensures dec_to_bool(dec_eq_nat(x, z))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_eq.rs", "verified": true, "metadata": {"original_id": "0211e573ceeb", "function_name": "dec_eq_nat_transitive", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_4f53cba43f6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)  ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "4f53cba43f6d", "function_name": "iter_copy", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c515cba66359", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c515cba66359", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_6c69f2a0ee72", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6c69f2a0ee72", "function_name": "shared_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_e34eadb283bf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_add_0_n(n: nat)\n    \n{\n    assert(add(0, n) == n);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_add_0_n(n: nat)\n    ensures add(0, n) == n\n{\n    assert(add(0, n) == n);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_add_0_n(n: nat)\n    ensures add(0, n) == n\n{\n    assert(add(0, n) == n);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "e34eadb283bf", "function_name": "ex6_add_0_n", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_619cdc245f26", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/replace_impl.rs", "verified": true, "metadata": {"original_id": "619cdc245f26", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_5086ae4db97e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "5086ae4db97e", "function_name": "myfun4", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_35bca52fc32b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_types_in_size_one()\n    \n{\n    assert(ty_size(Ty::TBool) == 1);\n    assert(ty_size(Ty::TNat) == 1);\n    assert(ty_size(Ty::TUnit) == 1);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_types_in_size_one()\n    ensures\n        types_of_size(1).contains(Ty::TBool),\n        types_of_size(1).contains(Ty::TNat),\n        types_of_size(1).contains(Ty::TUnit),\n{\n    assert(ty_size(Ty::TBool) == 1);\n    assert(ty_size(Ty::TNat) == 1);\n    assert(ty_size(Ty::TUnit) == 1);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn base_types_in_size_one()\n    ensures\n        types_of_size(1).contains(Ty::TBool),\n        types_of_size(1).contains(Ty::TNat),\n        types_of_size(1).contains(Ty::TUnit),\n{\n    assert(ty_size(Ty::TBool) == 1);\n    assert(ty_size(Ty::TNat) == 1);\n    assert(ty_size(Ty::TUnit) == 1);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_gen_type.rs", "verified": true, "metadata": {"original_id": "35bca52fc32b", "function_name": "base_types_in_size_one", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_afbb7a929727", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { x . checked_add (y) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_impl.rs", "verified": true, "metadata": {"original_id": "afbb7a929727", "function_name": "add", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_af931a99b1cc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_73/verina_advanced_73.rs", "verified": true, "metadata": {"original_id": "af931a99b1cc", "function_name": "search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_827177e88870", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)  ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)  ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "827177e88870", "function_name": "min_array", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_8f3fd5a0a3d4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "8f3fd5a0a3d4", "function_name": "array_copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_7d2efeadcd9b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >) requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] , ensures match result { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high  { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >) requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] , ensures match result { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high invariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target , decreases high - low , { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >) requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] , ensures match result { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high invariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target , decreases high - low , { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "7d2efeadcd9b", "function_name": "binary_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_c7975defa497", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () ,  { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "c7975defa497", "function_name": "remove_kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a983b4acc9bb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn existence_from_witness(n: nat, pred: spec_fn(nat) -> bool)\n    \n    ensures exists|x: nat| #[trigger] pred(x)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn existence_from_witness(n: nat, pred: spec_fn(nat) -> bool)\n    requires pred(n)\n    ensures exists|x: nat| #[trigger] pred(x)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn existence_from_witness(n: nat, pred: spec_fn(nat) -> bool)\n    requires pred(n)\n    ensures exists|x: nat| #[trigger] pred(x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "a983b4acc9bb", "function_name": "existence_from_witness", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_e8c9dc06390f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e8c9dc06390f", "function_name": "is_even_at_even_index", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7c904adc7a69", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 ,  { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "7c904adc7a69", "function_name": "max", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_a5e0b7c7c7d7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn triangle(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn triangle(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn triangle(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "extraction_verus.rs", "verified": true, "metadata": {"original_id": "a5e0b7c7c7d7", "function_name": "triangle", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_09faa3d174a3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true ,  { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "09faa3d174a3", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_verus_statics_af0e1e25c69a", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/statics.rs", "verified": true, "metadata": {"original_id": "verus_statics_af0e1e25c69a", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_fee542870c4e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N ,  { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condn_impl.rs", "verified": true, "metadata": {"original_id": "fee542870c4e", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_e2ed5df5f5bf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)  ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "e2ed5df5f5bf", "function_name": "myfun2", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_verus_adts_7172b41de434", "task": "task_c", "input_text": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/adts.rs", "verified": true, "metadata": {"original_id": "verus_adts_7172b41de434", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_a73f2758dd9f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    \n    ensures sequence_option(xs) == Option::<Seq<nat>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    requires 0 <= k < xs.len() as int,\n             xs[k] == Option::<nat>::None\n    ensures sequence_option(xs) == Option::<Seq<nat>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn sequence_option_any_none(xs: Seq<Option<nat>>, k: int)\n    requires 0 <= k < xs.len() as int,\n             xs[k] == Option::<nat>::None\n    ensures sequence_option(xs) == Option::<Seq<nat>>::None\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        // Vacuously true\n    } else if k == 0 {\n        assert(xs[0] == Option::<nat>::None);\n    } else {\n        // None is in the tail\n        sequence_option_any_none(xs.skip(1), k - 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_applicative.rs", "verified": true, "metadata": {"original_id": "a73f2758dd9f", "function_name": "sequence_option_any_none", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_7294e23a4b17", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)  ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_68/verina_basic_68_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7294e23a4b17", "function_name": "linear_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_5bbab599ec56", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32)  { if x >= y { x } else { y } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "5bbab599ec56", "function_name": "Max", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_47eacb8efff5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "47eacb8efff5", "function_name": "replace_chars", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_27d2755c5821", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)  ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "27d2755c5821", "function_name": "is_non_prime", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_292f839cb54c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "292f839cb54c", "function_name": "count_identical_position", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_d0ce9f93b5b4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "d0ce9f93b5b4", "function_name": "to_toggle_case", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_3b05d90ede66", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool)  ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_impl.rs", "verified": true, "metadata": {"original_id": "3b05d90ede66", "function_name": "is_divisible_by_11", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_7cefa7ad8266", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn successful_bounded(state: ShrinkState)\n    \n{\n    // Initial state has both 0, and try_shrink maintains invariant\n    assume(state.successful_shrinks <= state.shrink_count);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn successful_bounded(state: ShrinkState)\n    ensures state.successful_shrinks <= state.shrink_count\n{\n    // Initial state has both 0, and try_shrink maintains invariant\n    assume(state.successful_shrinks <= state.shrink_count);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn successful_bounded(state: ShrinkState)\n    ensures state.successful_shrinks <= state.shrink_count\n{\n    // Initial state has both 0, and try_shrink maintains invariant\n    assume(state.successful_shrinks <= state.shrink_count);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_runner_shrink.rs", "verified": true, "metadata": {"original_id": "7cefa7ad8266", "function_name": "successful_bounded", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_56ca9be41886", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "56ca9be41886", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_12ba67f917ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_refl(t: Ty)\n    \n    decreases t\n{\n    match t {\n        Ty::TBool => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_eq_refl(*t1);\n            ty_eq_refl(*t2);\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_refl(t: Ty)\n    ensures ty_eq(t, t)\n    decreases t\n{\n    match t {\n        Ty::TBool => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_eq_refl(*t1);\n            ty_eq_refl(*t2);\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_eq_refl(t: Ty)\n    ensures ty_eq(t, t)\n    decreases t\n{\n    match t {\n        Ty::TBool => {}\n        Ty::TArrow { t1, t2 } => {\n            ty_eq_refl(*t1);\n            ty_eq_refl(*t2);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "typechecking_verus.rs", "verified": true, "metadata": {"original_id": "12ba67f917ec", "function_name": "ty_eq_refl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_fb83c36fdc2e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_size<T>(t: Tree<T>) -> nat\n    {\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } =>\n            1 + tree_size(*left) + tree_size(*right),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_size<T>(t: Tree<T>) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } =>\n            1 + tree_size(*left) + tree_size(*right),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_size<T>(t: Tree<T>) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } =>\n            1 + tree_size(*left) + tree_size(*right),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_tree.rs", "verified": true, "metadata": {"original_id": "fb83c36fdc2e", "function_name": "tree_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_e21ff055c8d8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e21ff055c8d8", "function_name": "is_even_at_even_index", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_91799f90b830", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    requires n > 0\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    requires n > 0\n    ensures shrink_nat_dec(n) < n\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_nat_dec_smaller(n: nat)\n    requires n > 0\n    ensures shrink_nat_dec(n) < n\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_shrinking.rs", "verified": true, "metadata": {"original_id": "91799f90b830", "function_name": "verify_shrink_nat_dec_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_86698098f817", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "86698098f817", "function_name": "secondSmallest", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_191bf0a53059", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "191bf0a53059", "function_name": "is_integer", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_c646d6a1dc07", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i , { a . set (i , N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i , { a . set (i , N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i , { a . set (i , N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina2_impl.rs", "verified": true, "metadata": {"original_id": "c646d6a1dc07", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_c3cc4658647f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 ,  { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "c3cc4658647f", "function_name": "prime_num", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_b46b25419bbd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "b46b25419bbd", "function_name": "myfun2", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_f4639301b0fc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () ,  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f4639301b0fc", "function_name": "bubbleSorta", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_ca7d8ff7a219", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)  ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "ca7d8ff7a219", "function_name": "index_wise_addition", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_a60d60ed2903", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_option_map_comp<A, B, C>(o: Option<A>, f: spec_fn(A) -> B, g: spec_fn(B) -> C)\n    \n{\n    match o {\n        Option::None => {\n            assert(option_map(option_map(o, f), g) == Option::<C>::None);\n            assert(option_map(o, |a: A| g(f(a))) == Option::<C>::None);\n        }\n        Option::Some(x) => {\n            assert(option_map(option_map(o, f), g) == Option::Some(g(f(x))));\n            assert(option_map(o, |a: A| g(f(a))) == Option::Some(g(f(x))));\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_option_map_comp<A, B, C>(o: Option<A>, f: spec_fn(A) -> B, g: spec_fn(B) -> C)\n    ensures option_map(option_map(o, f), g) == option_map(o, |a: A| g(f(a)))\n{\n    match o {\n        Option::None => {\n            assert(option_map(option_map(o, f), g) == Option::<C>::None);\n            assert(option_map(o, |a: A| g(f(a))) == Option::<C>::None);\n        }\n        Option::Some(x) => {\n            assert(option_map(option_map(o, f), g) == Option::Some(g(f(x))));\n            assert(option_map(o, |a: A| g(f(a))) == Option::Some(g(f(x))));\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_option_map_comp<A, B, C>(o: Option<A>, f: spec_fn(A) -> B, g: spec_fn(B) -> C)\n    ensures option_map(option_map(o, f), g) == option_map(o, |a: A| g(f(a)))\n{\n    match o {\n        Option::None => {\n            assert(option_map(option_map(o, f), g) == Option::<C>::None);\n            assert(option_map(o, |a: A| g(f(a))) == Option::<C>::None);\n        }\n        Option::Some(x) => {\n            assert(option_map(option_map(o, f), g) == Option::Some(g(f(x))));\n            assert(option_map(o, |a: A| g(f(a))) == Option::Some(g(f(x))));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "poly_verus.rs", "verified": true, "metadata": {"original_id": "a60d60ed2903", "function_name": "ex10_option_map_comp", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_dfab1c7c31dc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; }  index += 1 ; }  upper_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dfab1c7c31dc", "function_name": "to_uppercase", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_50409ef99fb0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool)  ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_55/verina_basic_55_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "50409ef99fb0", "function_name": "compare", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_647733a81b77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn modus_ponens(p: bool, q: bool)\n    requires p, p ==> q\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn modus_ponens(p: bool, q: bool)\n    requires p, p ==> q\n    ensures q\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn modus_ponens(p: bool, q: bool)\n    requires p, p ==> q\n    ensures q\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "647733a81b77", "function_name": "modus_ponens", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_cb3b4c22af88", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0  { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb3b4c22af88", "function_name": "minArray", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_8f343f78db7d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    \n    ensures shrink_seq_nat(xs)[i].len() < xs.len()\n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    requires xs.len() > 1,\n             0 <= i < xs.len() as int\n    ensures shrink_seq_nat(xs)[i].len() < xs.len()\n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_shorter(xs: Seq<nat>, i: int)\n    requires xs.len() > 1,\n             0 <= i < xs.len() as int\n    ensures shrink_seq_nat(xs)[i].len() < xs.len()\n{\n    assert(shrink_seq_nat(xs)[i] == xs.remove(i));\n    assert(xs.remove(i).len() == xs.len() - 1);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_arbitrary.rs", "verified": true, "metadata": {"original_id": "8f343f78db7d", "function_name": "shrink_seq_shorter", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_16a922d07ab2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)  ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "16a922d07ab2", "function_name": "binary_search_loop", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_e4f92ff67020", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3  { x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_100/verina_basic_100_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e4f92ff67020", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_36ef68a1fdb4", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int)  ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64)  ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64)  ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "36ef68a1fdb4", "function_name": "align_checked_u64", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f1b4ceec868b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_is_some_sound<T>(opt: Option<T>)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_is_some_sound<T>(opt: Option<T>)\n    ensures dec_to_bool(dec_is_some(opt)) <==> opt.is_some()\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_is_some_sound<T>(opt: Option<T>)\n    ensures dec_to_bool(dec_is_some(opt)) <==> opt.is_some()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_option.rs", "verified": true, "metadata": {"original_id": "f1b4ceec868b", "function_name": "dec_is_some_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1c9aefc878f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1c9aefc878f6", "function_name": "sort_intervals", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_dca03ef7f26c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dca03ef7f26c", "function_name": "iter_copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_7157a8cdb4f1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7157a8cdb4f1", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_9ecf147a7a6c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ;      } ;   } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9ecf147a7a6c", "function_name": "kth_element", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_f667faf54409", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "f667faf54409", "function_name": "shared_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_1ac7e1ec2492", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge_sort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    {\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let s1 = split_first(s);\n        let s2 = split_second(s);\n        let sorted1 = merge_sort_fuel(s1, (fuel - 1) as nat);\n        let sorted2 = merge_sort_fuel(s2, (fuel - 1) as nat);\n        merge(sorted1, sorted2)\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge_sort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    decreases fuel\n{\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let s1 = split_first(s);\n        let s2 = split_second(s);\n        let sorted1 = merge_sort_fuel(s1, (fuel - 1) as nat);\n        let sorted2 = merge_sort_fuel(s2, (fuel - 1) as nat);\n        merge(sorted1, sorted2)\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn merge_sort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    decreases fuel\n{\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let s1 = split_first(s);\n        let s2 = split_second(s);\n        let sorted1 = merge_sort_fuel(s1, (fuel - 1) as nat);\n        let sorted2 = merge_sort_fuel(s2, (fuel - 1) as nat);\n        merge(sorted1, sorted2)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_merge.rs", "verified": true, "metadata": {"original_id": "1ac7e1ec2492", "function_name": "merge_sort_fuel", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_9d1ba670100f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)  ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_2d584196c6a2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2d584196c6a2", "function_name": "increasing_triplet", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_a390392acdae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "a390392acdae", "function_name": "has_common_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_f2a35c61be7a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_12/verina_advanced_12_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f2a35c61be7a", "function_name": "first_duplicate", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_ab9a64c09140", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 ,  { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "ab9a64c09140", "function_name": "smallest_num", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_fb8fe6ce0b4c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_impl.rs", "verified": true, "metadata": {"original_id": "fb8fe6ce0b4c", "function_name": "number_to_char_impl", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_dd95f84a9c77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_nat_nonzero_implies_not_zero(n: nat)\n    \n    ensures n != 0\n{\n    if n == 0 {\n        // Impossible branch given precondition.\n        assert(false);\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_nat_nonzero_implies_not_zero(n: nat)\n    requires n > 0,\n    ensures n != 0\n{\n    if n == 0 {\n        // Impossible branch given precondition.\n        assert(false);\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_nat_nonzero_implies_not_zero(n: nat)\n    requires n > 0,\n    ensures n != 0\n{\n    if n == 0 {\n        // Impossible branch given precondition.\n        assert(false);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "tactics_verus.rs", "verified": true, "metadata": {"original_id": "dd95f84a9c77", "function_name": "ex10_nat_nonzero_implies_not_zero", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_0060035f6dab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0060035f6dab", "function_name": "bubble_outer", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_33692cd4e3cb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >) requires src . len () >= s_start + len , dest . len () >= d_start + len , ensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) , { let mut result = dest ; let mut i = 0 ; while i < len  { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >) requires src . len () >= s_start + len , dest . len () >= d_start + len , ensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) , { let mut result = dest ; let mut i = 0 ; while i < len invariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) , decreases len - i { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >) requires src . len () >= s_start + len , dest . len () >= d_start + len , ensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) , { let mut result = dest ; let mut i = 0 ; while i < len invariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) , decreases len - i { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_copy_part/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "33692cd4e3cb", "function_name": "copy_impl", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_17dbe9409d72", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "17dbe9409d72", "function_name": "array_copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_43c7a0bb9fd0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    \n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "poly_verus.rs", "verified": true, "metadata": {"original_id": "43c7a0bb9fd0", "function_name": "lemma_reverse_index", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f9238c09f8da", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_has_greater_than(n: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_has_greater_than(n: nat)\n    ensures has_greater_than(n)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_has_greater_than(n: nat)\n    ensures has_greater_than(n)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "f9238c09f8da", "function_name": "verify_has_greater_than", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_f40f8420ea24", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn complete_implies_balanced(t: Tree) requires is_complete(t)  decreases t {\n    reveal_with_fuel(is_complete, 2); reveal_with_fuel(is_balanced, 2);\n    match t { Tree::E => {} Tree::T { left, right, .. } => { complete_implies_balanced(*left); complete_implies_balanced(*right); } }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn complete_implies_balanced(t: Tree) requires is_complete(t) ensures is_balanced(t) decreases t {\n    reveal_with_fuel(is_complete, 2); reveal_with_fuel(is_balanced, 2);\n    match t { Tree::E => {} Tree::T { left, right, .. } => { complete_implies_balanced(*left); complete_implies_balanced(*right); } }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn complete_implies_balanced(t: Tree) requires is_complete(t) ensures is_balanced(t) decreases t {\n    reveal_with_fuel(is_complete, 2); reveal_with_fuel(is_balanced, 2);\n    match t { Tree::E => {} Tree::T { left, right, .. } => { complete_implies_balanced(*left); complete_implies_balanced(*right); } }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_balance.rs", "verified": true, "metadata": {"original_id": "f40f8420ea24", "function_name": "complete_implies_balanced", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_b39d5d780de1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int)  ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32)  ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b39d5d780de1", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_7d46e285c123", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn cequiv_trans(c1: Com, c2: Com, c3: Com)\n    requires\n        cequiv(c1, c2),\n        cequiv(c2, c3),\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn cequiv_trans(c1: Com, c2: Com, c3: Com)\n    requires\n        cequiv(c1, c2),\n        cequiv(c2, c3),\n    ensures cequiv(c1, c3)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn cequiv_trans(c1: Com, c2: Com, c3: Com)\n    requires\n        cequiv(c1, c2),\n        cequiv(c2, c3),\n    ensures cequiv(c1, c3)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "equiv_verus.rs", "verified": true, "metadata": {"original_id": "7d46e285c123", "function_name": "cequiv_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_03eac0aaafc2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_reflexive(x: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_reflexive(x: nat)\n    ensures dec_to_bool(dec_eq_nat(x, x))\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_nat_reflexive(x: nat)\n    ensures dec_to_bool(dec_eq_nat(x, x))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_eq.rs", "verified": true, "metadata": {"original_id": "03eac0aaafc2", "function_name": "dec_eq_nat_reflexive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_484f0a6325c6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)  ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/smallest_list_length_iter_2_current.rs", "verified": true, "metadata": {"original_id": "484f0a6325c6", "function_name": "smallest_list_length", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_3a261bf6d204", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; }  result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "3a261bf6d204", "function_name": "array_copy", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_15b839565212", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)  ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)  ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_current.rs", "verified": true, "metadata": {"original_id": "15b839565212", "function_name": "secondSmallest", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_6c8caa643a82", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool)  { val . len () < 1024 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool) ensures b == valid_value (val @) { val . len () < 1024 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool) ensures b == valid_value (val @) { val . len () < 1024 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "6c8caa643a82", "function_name": "is_value_valid", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_140b59b541a3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_option_contains_sound<T>(opt: Option<T>, x: T, eq: spec_fn(T, T) -> bool)\n    \n    ensures dec_to_bool(dec_option_contains(opt, x, eq)) <==>\n        (opt.is_some() && opt.unwrap() == x)\n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_option_contains_sound<T>(opt: Option<T>, x: T, eq: spec_fn(T, T) -> bool)\n    requires forall|a: T, b: T| #[trigger] eq(a, b) <==> (a == b)\n    ensures dec_to_bool(dec_option_contains(opt, x, eq)) <==>\n        (opt.is_some() && opt.unwrap() == x)\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_option_contains_sound<T>(opt: Option<T>, x: T, eq: spec_fn(T, T) -> bool)\n    requires forall|a: T, b: T| #[trigger] eq(a, b) <==> (a == b)\n    ensures dec_to_bool(dec_option_contains(opt, x, eq)) <==>\n        (opt.is_some() && opt.unwrap() == x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_option.rs", "verified": true, "metadata": {"original_id": "140b59b541a3", "function_name": "dec_option_contains_sound", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2a8db183c2ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2a8db183c2ea", "function_name": "find_even_numbers", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_d3058115cf51", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len ()  { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "d3058115cf51", "function_name": "intersperse", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_cf16f3478de7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , result . len () == i , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < i ==> result [j as int] == arr1 [j] * arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert ((i as int) < arr1 . len ()) ; assert ((i as int) < arr2 . len ()) ; assert (MIN <= arr1 [i as int] * arr2 [i as int] <= MAX) ; let product = arr1 [i] * arr2 [i] ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , result . len () == i , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < i ==> result [j as int] == arr1 [j] * arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert ((i as int) < arr1 . len ()) ; assert ((i as int) < arr2 . len ()) ; assert (MIN <= arr1 [i as int] * arr2 [i as int] <= MAX) ; let product = arr1 [i] * arr2 [i] ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , result . len () == i , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < i ==> result [j as int] == arr1 [j] * arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert ((i as int) < arr1 . len ()) ; assert ((i as int) < arr2 . len ()) ; assert (MIN <= arr1 [i as int] * arr2 [i as int] <= MAX) ; let product = arr1 [i] * arr2 [i] ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_445_impl.rs", "verified": true, "metadata": {"original_id": "cf16f3478de7", "function_name": "element_wise_multiplication", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_88733084b74c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos  { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i , { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j , { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos invariant k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases (l - at_pos) - k , { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i , { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j , { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos invariant k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases (l - at_pos) - k , { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_64/verina_basic_64_iter_3_current.rs", "verified": true, "metadata": {"original_id": "88733084b74c", "function_name": "insert", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_dd6c17a7f567", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)  ensures r == 3 * x { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dd6c17a7f567", "function_name": "Triple1", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_74a636be81c5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lhs(self) -> nat\n        {\n        match self {\n            LeEv::Refl(n) => n,\n            LeEv::Step(p) => (*p).lhs(),\n        }\n    }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lhs(self) -> nat\n        decreases self\n    {\n        match self {\n            LeEv::Refl(n) => n,\n            LeEv::Step(p) => (*p).lhs(),\n        }\n    }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lhs(self) -> nat\n        decreases self\n    {\n        match self {\n            LeEv::Refl(n) => n,\n            LeEv::Step(p) => (*p).lhs(),\n        }\n    }\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "74a636be81c5", "function_name": "lhs", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_a70f23c8aa9d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a70f23c8aa9d", "function_name": "F", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_96ccb9a459e0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { let mut i = 0 ; while i < chords . len () invariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - i { let mut j = i + 1 ; while j < chords . len () invariant 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - j { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { let mut i = 0 ; while i < chords . len () invariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - i { let mut j = i + 1 ; while j < chords . len () invariant 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - j { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { let mut i = 0 ; while i < chords . len () invariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - i { let mut j = i + 1 ; while j < chords . len () invariant 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - j { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_13/verina_advanced_13_iter_3_current.rs", "verified": true, "metadata": {"original_id": "96ccb9a459e0", "function_name": "has_chord_intersection", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_292f839cb54c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () ,  { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () ,  { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "292f839cb54c", "function_name": "count_identical_position", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_f3d4eec1b1ad", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_49/verina_basic_49_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f3d4eec1b1ad", "function_name": "find_first_odd", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_cdab3d5f9cc9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) ensures ({ let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len () invariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () , { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) ensures ({ let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len () invariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () , decreases arr @ . len () - i { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) ensures ({ let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len () invariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () , decreases arr @ . len () - i { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/136-largest_smallest_integers_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cdab3d5f9cc9", "function_name": "largest_smallest_integers", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_0e436006d696", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_230_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0e436006d696", "function_name": "replace_blanks_with_chars", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_387a10ca44b8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_preserves_others(k1: nat, k2: nat, t: Tree)\n    requires is_bst(t), k1 != k2, contains(k2, t)\n    \n    decreases t\n{\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k1 < key {\n                if k2 < key {\n                    delete_preserves_others(k1, k2, *left);\n                }\n            } else if k1 > key {\n                if k2 > key {\n                    delete_preserves_others(k1, k2, *right);\n                }\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(contains(k2, delete(k1, t)));\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_preserves_others(k1: nat, k2: nat, t: Tree)\n    requires is_bst(t), k1 != k2, contains(k2, t)\n    ensures contains(k2, delete(k1, t))\n    decreases t\n{\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k1 < key {\n                if k2 < key {\n                    delete_preserves_others(k1, k2, *left);\n                }\n            } else if k1 > key {\n                if k2 > key {\n                    delete_preserves_others(k1, k2, *right);\n                }\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(contains(k2, delete(k1, t)));\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn delete_preserves_others(k1: nat, k2: nat, t: Tree)\n    requires is_bst(t), k1 != k2, contains(k2, t)\n    ensures contains(k2, delete(k1, t))\n    decreases t\n{\n    reveal_with_fuel(contains, 3);\n    reveal_with_fuel(delete, 3);\n    reveal_with_fuel(is_bst, 3);\n    match t {\n        Tree::E => {}\n        Tree::T { left, key, value: _, right } => {\n            if k1 < key {\n                if k2 < key {\n                    delete_preserves_others(k1, k2, *left);\n                }\n            } else if k1 > key {\n                if k2 > key {\n                    delete_preserves_others(k1, k2, *right);\n                }\n            }\n        }\n    }\n    // Complex inductive proof - assume correctness\n    assume(contains(k2, delete(k1, t)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_delete.rs", "verified": true, "metadata": {"original_id": "387a10ca44b8", "function_name": "delete_preserves_others", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_5e3e6d7dd671", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_mul_0_r(n: nat)\n    ensures mul(n, 0) == 0\n    {\n    if n == 0 {\n    } else {\n        lemma_mul_0_r((n - 1) as nat);\n        // mul(n,0) = add(0, mul(n-1,0))\n        // add(0,x)=x\n        lemma_add_0_l(mul((n - 1) as nat, 0));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_mul_0_r(n: nat)\n    ensures mul(n, 0) == 0\n    decreases n\n{\n    if n == 0 {\n    } else {\n        lemma_mul_0_r((n - 1) as nat);\n        // mul(n,0) = add(0, mul(n-1,0))\n        // add(0,x)=x\n        lemma_add_0_l(mul((n - 1) as nat, 0));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_mul_0_r(n: nat)\n    ensures mul(n, 0) == 0\n    decreases n\n{\n    if n == 0 {\n    } else {\n        lemma_mul_0_r((n - 1) as nat);\n        // mul(n,0) = add(0, mul(n-1,0))\n        // add(0,x)=x\n        lemma_add_0_l(mul((n - 1) as nat, 0));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprinciples_verus.rs", "verified": true, "metadata": {"original_id": "5e3e6d7dd671", "function_name": "lemma_mul_0_r", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_0cd632baea02", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () ,  { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "0cd632baea02", "function_name": "is_smaller", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_4ebba314eff1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] {  } return true ; } } }  } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "4ebba314eff1", "function_name": "has_common_element", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_afa8ad47d9ce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "afa8ad47d9ce", "function_name": "barrier", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_5a105fbd6d3c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)  ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/index_wise_addition_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5a105fbd6d3c", "function_name": "index_wise_addition", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_ec45183af665", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "ec45183af665", "function_name": "insert_before_each", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_6591477db4b5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_45/verina_advanced_45.rs", "verified": true, "metadata": {"original_id": "6591477db4b5", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_8fb147cd055a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_is_normal(t: Tm)\n    requires value(t)\n    \n{\n    match t {\n        Tm::C { .. } => {}\n        Tm::P { .. } => {}  // Not a value, so precondition is false\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_is_normal(t: Tm)\n    requires value(t)\n    ensures !can_reduce_pcc(t)\n{\n    match t {\n        Tm::C { .. } => {}\n        Tm::P { .. } => {}  // Not a value, so precondition is false\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn value_is_normal(t: Tm)\n    requires value(t)\n    ensures !can_reduce_pcc(t)\n{\n    match t {\n        Tm::C { .. } => {}\n        Tm::P { .. } => {}  // Not a value, so precondition is false\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "smallstep_verus.rs", "verified": true, "metadata": {"original_id": "8fb147cd055a", "function_name": "value_is_normal", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_21723d6ef86c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 ,  { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_double_array_elements/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "21723d6ef86c", "function_name": "double_array_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_60f8fbfb8ee1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_values_from<T>(t: Tree<T>, values: Set<T>) -> bool\n    {\n    match t {\n        Tree::Leaf => true,\n        Tree::Node { left, value, right } =>\n            values.contains(value) &&\n            all_values_from(*left, values) &&\n            all_values_from(*right, values),\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_values_from<T>(t: Tree<T>, values: Set<T>) -> bool\n    decreases t\n{\n    match t {\n        Tree::Leaf => true,\n        Tree::Node { left, value, right } =>\n            values.contains(value) &&\n            all_values_from(*left, values) &&\n            all_values_from(*right, values),\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn all_values_from<T>(t: Tree<T>, values: Set<T>) -> bool\n    decreases t\n{\n    match t {\n        Tree::Leaf => true,\n        Tree::Node { left, value, right } =>\n            values.contains(value) &&\n            all_values_from(*left, values) &&\n            all_values_from(*right, values),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_tree.rs", "verified": true, "metadata": {"original_id": "60f8fbfb8ee1", "function_name": "all_values_from", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_7b159930815e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , { for j in 0 .. list2 . len () invariant i < list1 . len () , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if list1 [i] == list2 [j] { return true ; } } }  false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , { for j in 0 .. list2 . len () invariant i < list1 . len () , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if list1 [i] == list2 [j] { return true ; } } } assert (forall | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj]) ; false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , { for j in 0 .. list2 . len () invariant i < list1 . len () , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if list1 [i] == list2 [j] { return true ; } } } assert (forall | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj]) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "7b159930815e", "function_name": "has_common_element", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_d414c654958d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    \n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(all_foldr(xs, p));\n    } else {\n        all_foldr_correct(xs.skip(1), p);\n        assert(all_foldr(xs, p) == (p(xs[0]) && all_foldr(xs.skip(1), p)));\n\n        // Forward direction: all_foldr(xs, p) ==> forall|i| ...\n        if all_foldr(xs, p) {\n            assert(p(xs[0]));\n            assert(all_foldr(xs.skip(1), p));\n            assert forall|i: int| 0 <= i < xs.len() as int implies p(xs[i]) by {\n                if i == 0 {\n                    assert(p(xs[0]));\n                } else {\n                    assert(0 <= i - 1 < xs.skip(1).len() as int);\n                    assert(xs.skip(1)[i - 1] == xs[i]);\n                }\n            };\n        }\n\n        // Backward direction: (forall|i| ...) ==> all_foldr(xs, p)\n        if forall|i: int| 0 <= i < xs.len() as int ==> p(xs[i]) {\n            assert(p(xs[0]));\n            assert forall|j: int| 0 <= j < xs.skip(1).len() as int implies p(xs.skip(1)[j]) by {\n                assert(xs.skip(1)[j] == xs[j + 1]);\n                assert(p(xs[j + 1]));\n            };\n        }\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    ensures all_foldr(xs, p) <==> forall|i: int| 0 <= i < xs.len() as int ==> p(xs[i])\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(all_foldr(xs, p));\n    } else {\n        all_foldr_correct(xs.skip(1), p);\n        assert(all_foldr(xs, p) == (p(xs[0]) && all_foldr(xs.skip(1), p)));\n\n        // Forward direction: all_foldr(xs, p) ==> forall|i| ...\n        if all_foldr(xs, p) {\n            assert(p(xs[0]));\n            assert(all_foldr(xs.skip(1), p));\n            assert forall|i: int| 0 <= i < xs.len() as int implies p(xs[i]) by {\n                if i == 0 {\n                    assert(p(xs[0]));\n                } else {\n                    assert(0 <= i - 1 < xs.skip(1).len() as int);\n                    assert(xs.skip(1)[i - 1] == xs[i]);\n                }\n            };\n        }\n\n        // Backward direction: (forall|i| ...) ==> all_foldr(xs, p)\n        if forall|i: int| 0 <= i < xs.len() as int ==> p(xs[i]) {\n            assert(p(xs[0]));\n            assert forall|j: int| 0 <= j < xs.skip(1).len() as int implies p(xs.skip(1)[j]) by {\n                assert(xs.skip(1)[j] == xs[j + 1]);\n                assert(p(xs[j + 1]));\n            };\n        }\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn all_foldr_correct<A>(xs: Seq<A>, p: spec_fn(A) -> bool)\n    ensures all_foldr(xs, p) <==> forall|i: int| 0 <= i < xs.len() as int ==> p(xs[i])\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(all_foldr(xs, p));\n    } else {\n        all_foldr_correct(xs.skip(1), p);\n        assert(all_foldr(xs, p) == (p(xs[0]) && all_foldr(xs.skip(1), p)));\n\n        // Forward direction: all_foldr(xs, p) ==> forall|i| ...\n        if all_foldr(xs, p) {\n            assert(p(xs[0]));\n            assert(all_foldr(xs.skip(1), p));\n            assert forall|i: int| 0 <= i < xs.len() as int implies p(xs[i]) by {\n                if i == 0 {\n                    assert(p(xs[0]));\n                } else {\n                    assert(0 <= i - 1 < xs.skip(1).len() as int);\n                    assert(xs.skip(1)[i - 1] == xs[i]);\n                }\n            };\n        }\n\n        // Backward direction: (forall|i| ...) ==> all_foldr(xs, p)\n        if forall|i: int| 0 <= i < xs.len() as int ==> p(xs[i]) {\n            assert(p(xs[0]));\n            assert forall|j: int| 0 <= j < xs.skip(1).len() as int implies p(xs.skip(1)[j]) by {\n                assert(xs.skip(1)[j] == xs[j + 1]);\n                assert(p(xs[j + 1]));\n            };\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "d414c654958d", "function_name": "all_foldr_correct", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_9ca61254863f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "9ca61254863f", "function_name": "is_non_prime", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_a881866dcd18", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_comm(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_comm(a: nat, b: nat)\n    ensures a * b == b * a\n{\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_comm(a: nat, b: nat)\n    ensures a * b == b * a\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "a881866dcd18", "function_name": "mul_comm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_4e3daaaa2b28", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "4e3daaaa2b28", "function_name": "is_digit", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_060d7318ed68", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)  ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "060d7318ed68", "function_name": "number_to_char_impl", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_452321dd1361", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN ,  { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX  { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "452321dd1361", "function_name": "has_close_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b41dac90da0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn id_eq_decidable(x: Id, y: Id)\n    \n{\n    // Trivially true by classical logic\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn id_eq_decidable(x: Id, y: Id)\n    ensures id_eq(x, y) || !id_eq(x, y)\n{\n    // Trivially true by classical logic\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn id_eq_decidable(x: Id, y: Id)\n    ensures id_eq(x, y) || !id_eq(x, y)\n{\n    // Trivially true by classical logic\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_ident.rs", "verified": true, "metadata": {"original_id": "b41dac90da0f", "function_name": "id_eq_decidable", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_5e43ef69574e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "5e43ef69574e", "function_name": "max_array", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_d5076568e671", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "d5076568e671", "function_name": "element_wise_division", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_578807370209", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn min_in_seq(s: Seq<nat>)\n    requires s.len() > 0\n    \n    decreases s.len()\n{\n    reveal_with_fuel(find_min, 2);\n    if s.len() == 1 {\n    } else {\n        min_in_seq(s.skip(1));\n    }\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn min_in_seq(s: Seq<nat>)\n    requires s.len() > 0\n    ensures s.contains(find_min(s))\n    decreases s.len()\n{\n    reveal_with_fuel(find_min, 2);\n    if s.len() == 1 {\n    } else {\n        min_in_seq(s.skip(1));\n    }\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn min_in_seq(s: Seq<nat>)\n    requires s.len() > 0\n    ensures s.contains(find_min(s))\n    decreases s.len()\n{\n    reveal_with_fuel(find_min, 2);\n    if s.len() == 1 {\n    } else {\n        min_in_seq(s.skip(1));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_selection.rs", "verified": true, "metadata": {"original_id": "578807370209", "function_name": "min_in_seq", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_59006ed52bd0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)  ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "59006ed52bd0", "function_name": "append", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_41cf03444a7d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_impl.rs", "verified": true, "metadata": {"original_id": "41cf03444a7d", "function_name": "max_strength", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_e84eb3384716", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof2_assoc<T>(gen1: Set<T>, gen2: Set<T>, gen3: Set<T>)\n    \n{\n    // Union is associative\n}\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof2_assoc<T>(gen1: Set<T>, gen2: Set<T>, gen3: Set<T>)\n    ensures oneof2(oneof2(gen1, gen2), gen3) =~= oneof2(gen1, oneof2(gen2, gen3))\n{\n    // Union is associative\n}\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof2_assoc<T>(gen1: Set<T>, gen2: Set<T>, gen3: Set<T>)\n    ensures oneof2(oneof2(gen1, gen2), gen3) =~= oneof2(gen1, oneof2(gen2, gen3))\n{\n    // Union is associative\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_oneof.rs", "verified": true, "metadata": {"original_id": "e84eb3384716", "function_name": "oneof2_assoc", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_faef24e15316", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "faef24e15316", "function_name": "is_even_at_even_index", "bug_type": "missing_decreases"}}
