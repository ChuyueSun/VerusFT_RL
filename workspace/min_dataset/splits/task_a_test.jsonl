{"id": "task_a_d9f4e31ca8da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "target_text": "requires p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d9f4e31ca8da", "function_name": "modmul", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0cd632baea02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut idx = 0 ; while idx < arr1 . len ()  {  if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - idx\ninvariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "0cd632baea02", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_43adf6cc9347", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0  { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases i\ninvariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0 invariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] , decreases i { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "43adf6cc9347", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_55cfdc94cc4a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "55cfdc94cc4a", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ad595921fb84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "ad595921fb84", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_datatypes_d92f3245f800", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n\n{\n    let o = Point { x: -p.y, y: p.x };\n\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n\n{\n\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires bev is Soda, bev is Coffee\nensures o.len2() == p.len2()", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/datatypes.rs", "verified": true, "metadata": {"original_id": "verus_datatypes_d92f3245f800", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0a223afbb7a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/array_append_strong_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0a223afbb7a1", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0b6837913b8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/057-monotonic_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0b6837913b8e", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_lib_c84f959a601d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the  {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n}\n\n} // verus!\n", "target_text": "ensures new_token@.instance_id() == instance.id() && new_token@.value() == true, new_token@.instance_id() == instance.id() && new_token@.value() == true\ninvariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter)", "full_verified_code": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n                    assert(pre.y <= pre.z);\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n                        assert(pre.y <= pre.z);\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n                        assert(pre.y <= pre.z);\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/state_machine_macro_usage/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_c84f959a601d", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2e7cedc68edf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_103/verina_basic_103_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2e7cedc68edf", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8fce6e46a3e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "8fce6e46a3e5", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d1dd43ef56dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d1dd43ef56dd", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ef07e1ebdfb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ef07e1ebdfb8", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3406b6f065de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "3406b6f065de", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ed3f59736a95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start_idx <= lst . len () \ndecreases lst . len () - start_idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_73/verina_advanced_73_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ed3f59736a95", "function_name": "search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_56ade0e9e02d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1\nensures result >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "56ade0e9e02d", "function_name": "max_coverage_after_removing_one", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bbba8f4e1bfa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condg_impl.rs", "verified": true, "metadata": {"original_id": "bbba8f4e1bfa", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_41cf03444a7d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)\ndecreases nums . len () - i\ninvariant 0 <= i <= nums . len () , nums . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_impl.rs", "verified": true, "metadata": {"original_id": "41cf03444a7d", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4b532462b50b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4b532462b50b", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_816a9baf89c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires old (v) . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "816a9baf89c3", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_15316c192ba9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "15316c192ba9", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ddcc6d106cdf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ddcc6d106cdf", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a71ab9dcb389", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_binary_search/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a71ab9dcb389", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9fcf5e920c1b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_307_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9fcf5e920c1b", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9834fd20a165", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { new_char } else { str1 [i] }) , { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "9834fd20a165", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3dab0ffa2913", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len ()  { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx = idx + 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - idx\ninvariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx = idx + 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "3dab0ffa2913", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_11987890251d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires old (v) . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "11987890251d", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verified-storage_crashinv_t_4ec59bc784c9", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        //\n        {\n            unimplemented!()\n        }\n    }\n}\n", "target_text": "requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash()\nensures result.pred() == pred,\n                result.namespace() == namespace, result.constant() == self.pred(),\n                result.namespace() == self.namespace(), that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\ninvariant // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>, held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic invariant\n    // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n            ensures\n                result.pred() == pred,\n                result.namespace() == namespace,\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        // invariant held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace(),\n        {\n            unimplemented!()\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-storage/capybaraKV/capybarakv/src/pmem/crashinv_t.rs", "verified": true, "metadata": {"original_id": "verified-storage_crashinv_t_4ec59bc784c9", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1b6ca1d9ff6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1b6ca1d9ff6b", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1f74c30eea6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/choose_odd.rs", "verified": true, "metadata": {"original_id": "1f74c30eea6b", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d13e9b30a13d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int)   { 1int } else { 0int }) , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ;        }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)   { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  {  if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; }     count }\n\n} // verus!", "target_text": "requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () \nensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i], 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count \ndecreases s1 . len () , s2 . len () , s3 . len () , i , arr1 . len () - i \ninvariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "d13e9b30a13d", "function_name": "count_identical_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_16834247ba4d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_1_current.rs", "verified": true, "metadata": {"original_id": "16834247ba4d", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9f43baeac6bf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 \nensures odd_index < v . len () \ndecreases v . len () - i\ninvariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , ensures odd_index < v . len () , { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "9f43baeac6bf", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7b6b6e7b4184", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "7b6b6e7b4184", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9da300340c57", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_44/verina_advanced_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9da300340c57", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_fea20d875003", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i \ninvariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "fea20d875003", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dc2d76ce2db1", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "dc2d76ce2db1", "function_name": "helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f4ff2bf9c6d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2_impl.rs", "verified": true, "metadata": {"original_id": "f4ff2bf9c6d5", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6ece0c03585d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "6ece0c03585d", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2c35719f4dbe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "2c35719f4dbe", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_eacd0ad24593", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "eacd0ad24593", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6c8caa643a82", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool)  { val . len () < 1024 }\n\n} // verus!", "target_text": "ensures b == valid_value (val @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool) ensures b == valid_value (val @) { val . len () < 1024 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "6c8caa643a82", "function_name": "is_value_valid", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d2dfd0f1cbe2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i, list @ . len () - j\ninvariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d2dfd0f1cbe2", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a899b374f623", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a899b374f623", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b079a0134c6d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "b079a0134c6d", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ae19e8f7dd92", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int)  { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ;    }\nfn triple (x : i32) -> (result : i32)   {  x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_98/verina_basic_98_impl.rs", "verified": true, "metadata": {"original_id": "ae19e8f7dd92", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5ba740165f1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut k : usize = 0 ; while k <= p  { let mut l : usize = p + 1 ; while l < arr . len ()  { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - k, arr . len () - l\ninvariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "5ba740165f1a", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d745fce2eea3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len ()  { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - j\ninvariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "d745fce2eea3", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6dae6f771c10", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6dae6f771c10", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f397da29f9f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f397da29f9f7", "function_name": "bubbleSort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8b7ef890f90f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ndecreases a . len () - i\ninvariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "8b7ef890f90f", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_monotonic_counter_1a36c6e4f57c", "task": "task_a", "input_text": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//!\n//!\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//!  {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n         { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n\n        {\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n\n         {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n\n         {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n         { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n\n    let tracked mut lower_bound = half1.extract_lower_bound();\n\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n\n}\n\n} // verus!\n", "target_text": "requires self.id() == other.id(),\n            self@.n() == other@.n(), self@ is FullRightToAdvance, old(self)@ is FullRightToAdvance, old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance, old(self).id() == other.id()\nensures result@ == (MonotonicCounterResourceValue::FullRightToAdvance, r.id() == self.id(),\n            r@.n() == self@.op(other@).n(), (, self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance, old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance, out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound, self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n()\ninvariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof", "full_verified_code": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/monotonic_counter.rs", "verified": true, "metadata": {"original_id": "verus_monotonic_counter_1a36c6e4f57c", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2745f0d713b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 \nensures result >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2745f0d713b9", "function_name": "abs_diff", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9527f2d135b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ninvariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int) { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9527f2d135b3", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d06bc91882dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { let mut i = 0 ; while i < lst . len () - 1  { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ndecreases lst . len () - 1 - i \ninvariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i , { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "d06bc91882dd", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f8c095391aa0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8c095391aa0", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2ea1bb6c0ea6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 5 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 5 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "2ea1bb6c0ea6", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1385bd8547cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len ()  { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - i\ninvariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len () invariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) , decreases str . len () - i { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/027-flip_case_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1385bd8547cb", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_67588e015e9d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "67588e015e9d", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_74c99236de02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "74c99236de02", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f4cde1453d44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f4cde1453d44", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1ed56038c628", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1ed56038c628", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9d1ba670100f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size\ndecreases a . len (), size - i\ninvariant i <= size , result . len () == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6d83f1c8cca4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6d83f1c8cca4", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9879df0d9b53", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases k - 1 - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "9879df0d9b53", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6fc6d123b071", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6fc6d123b071", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4e2998c1460f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_28/verina_advanced_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4e2998c1460f", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f7e30aac2398", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { for i in 0 .. a . len ()  { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ninvariant forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f7e30aac2398", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7b4e306fcb99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "7b4e306fcb99", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_629e386f9130", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_97/verina_basic_97_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "629e386f9130", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_99db684ec04d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nproof fn lemma_vec_push < T > (vec : Seq < T > , i : T , l : usize)   { }\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool)  { let mut idx = 0 ; while idx < str . len ()  { if str [idx] == key { return true ; } idx += 1 ; } false }\nfn remove_elements (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { let elem = arr1 [idx] ; if ! contains (arr2 , elem) {  result . push (elem) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "requires l == vec . len () \nensures forall | k : int | 0 <= k < vec . len () ==> # [trigger] vec [k] == vec . push (i) [k] , vec . push (i) . index (l as int) == i , result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < arr1 . len () ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) \ndecreases str . len () - idx , arr1 . len () - idx \ninvariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , 0 <= idx <= arr1 . len () , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < idx ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nproof fn lemma_vec_push < T > (vec : Seq < T > , i : T , l : usize) requires l == vec . len () , ensures forall | k : int | 0 <= k < vec . len () ==> # [trigger] vec [k] == vec . push (i) [k] , vec . push (i) . index (l as int) == i , { }\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , decreases str . len () - idx , { if str [idx] == key { return true ; } idx += 1 ; } false }\nfn remove_elements (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < arr1 . len () ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < idx ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) , decreases arr1 . len () - idx , { let elem = arr1 [idx] ; if ! contains (arr2 , elem) { proof { let old_result = result @ ; let old_len = result . len () ; lemma_vec_push (old_result , elem , old_len) ; } result . push (elem) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_161_impl.rs", "verified": true, "metadata": {"original_id": "99db684ec04d", "function_name": "remove_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7fec2997bd0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i = i - 1 ;    result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i , list . len () - j \ninvariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , result @ == list @ . subrange (i as int , n as int) . reverse () , n <= j <= list . len () , result @ . len () == (n + (j - n)) as int , result @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , result @ == list @ . subrange (i as int , n as int) . reverse () , decreases i , { i = i - 1 ; assert (i < n) ; assert (n < list @ . len ()) ; assert (i < list @ . len ()) ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list . len () , result @ . len () == (n + (j - n)) as int , result @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , j as int)) , decreases list . len () - j , { result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "7fec2997bd0b", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_24dfb26f36d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32)   { let mut i = N ; while i != 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "24dfb26f36d8", "function_name": "down_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ee4d5b5fba77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x < 0 { - x } else { x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ee4d5b5fba77", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cdcddf5c4b3d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "cdcddf5c4b3d", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8c1f49608d2b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_28/verina_advanced_28.rs", "verified": true, "metadata": {"original_id": "8c1f49608d2b", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verified-storage_math_v_c45695888d25", "task": "task_a", "input_text": "#![allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n    pub proof fn lemma_mod_auto_basics(n: int, x: int)\n\n    {\n        lemma_fundamental_div_mod(x, n);\n        lemma_fundamental_div_mod(x + n, n);\n        lemma_fundamental_div_mod(x - n, n);\n        let zp = (x + n) / n - x / n - 1;\n        let zm = (x - n) / n - x / n + 1;\n        lemma_mul_is_distributive_sub(n, (x + n) / n, x / n + 1);\n        lemma_mul_is_distributive_add(n, x / n, 1);\n\n        lemma_mul_is_distributive_sub(n, (x - n) / n, x / n - 1);\n        lemma_mul_is_distributive_sub(n, x / n, 1);\n\n        if (zp > 0) { lemma_mul_inequality(1, zp, n); }\n        if (zp < 0) { lemma_mul_inequality(zp, -1, n); }\n        if (zp == 0) { lemma_mul_by_zero_is_zero(n); }\n        if (zm > 0) { lemma_mul_inequality(1, zm, n); }\n        if (zm < 0) { lemma_mul_inequality(zm, -1, n); }\n        if 0 <= x < n {\n            lemma_basic_div_specific_divisor(n);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order_alt(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order_alt(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n\n        }\n    }\n\n    pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n\n            lemma_div_relation_when_mods_have_same_order(d, x, y);\n\n            let z_mod_d = x % d + (z - x);\n\n                lemma_mul_is_commutative(d, (x / d));\n            }\n            lemma_fundamental_div_mod_converse(z, d, (x / d), z_mod_d);\n        }\n    }\n\n    pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n\n            lemma_div_relation_when_mods_have_different_order(d, x, y);\n\n            if y % d < z % d < x % d {\n                lemma_div_relation_when_mods_have_different_order(d, z, y);\n                lemma_div_relation_when_mods_have_same_order(d, z, x);\n\n            }\n        }\n    }\n\n    pub proof fn lemma_mod_addition_when_bounded(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_fundamental_div_mod_converse(x + y, d, x / d, x % d + y);\n    }\n\n    pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n\n        lemma_div_relation_when_mods_have_same_order_alt(d, x, y);\n\n    }\n\n    pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n\n        lemma_div_relation_when_mods_have_different_order_alt(d, x, y);\n\n    }\n\n    pub proof fn lemma_mod_equal(x: int, y: int, d: int)\n\n    {\n        lemma_mod_difference_equal(x, y, d);\n    }\n\n    pub proof fn lemma_mod_equal_converse(x: int, y: int, d: int)\n\n    {}\n\n    pub proof fn lemma_mod_not_equal(x: int, y: int, d: int)\n\n    {\n        if x % d == y % d {\n            if x < y {\n                lemma_mod_equal(x, y, d);\n\n            } else {\n\n            }\n        }\n\n    }\n\n    #[verifier(nonlinear)]\n    pub proof fn lemma_mul_div_equal(x: int, q: int, d: int)\n\n    {}\n\n    pub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n\n    {\n\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 1);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 2);\n\n        lemma_mul_div_equal(x + y, (x / d + 1), d);\n\n        lemma_fundamental_div_mod(x + y, d);\n\n    }\n\n}\n", "target_text": "requires n > 0, d > 0,\n            x < y,\n            y - x <= d,\n            x % d < y % d, d > 0,\n            x <= y,\n            y - x < d,\n            x % d <= y % d, d > 0,\n            x < y,\n            y - x <= d,\n            y % d <= x % d, d > 0,\n            x <= y,\n            y - x < d,\n            y % d < x % d, d > 0,\n            x % d < y % d,\n            y - x <= d,\n            x <= z <= y, d > 0,\n            y % d < x % d,\n            y - x <= d,\n            x <= z <= y, d > 0,\n            y >= 0,\n            (x % d) + y < d, d > 0,\n            x <= y,\n            x % d <= y % d,\n            y - x < d, d > 0,\n            x <= y,\n            x % d > y % d,\n            y - x < d, d > 0,\n            x <= y,\n            x % d == y % d,\n            y - x < d, d > 0,\n            x == y, d > 0,\n            y - x < d,\n            y - x >= 0,\n            x != y, q * d <= x < (q + 1) * d, d > 0,\n            (x % d) + y >= d,\n            0 <= y < d\nensures (x + n) % n == x % n,\n            (x - n) % n == x % n,\n            (x + n) / n == x / n + 1,\n            (x - n) / n == x / n - 1,\n            0 <= x < n <==> x % n == x, y / d == x / d, y / d == x / d, y / d == x / d + 1, y / d == x / d + 1, x % d <= z % d <= y % d, z % d <= y % d || z % d >= x % d, (x + y) % d == (x % d) + y, y % d - x % d == y - x, d - (x % d) + (y % d) == y - x, x == y, x % d == y % d, x % d != y % d, (x / d) == q, (x % d) + y - d == (x + y) % d", "full_verified_code": "#![allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n    pub proof fn lemma_mod_auto_basics(n: int, x: int)\n        requires\n            n > 0\n        ensures\n            (x + n) % n == x % n,\n            (x - n) % n == x % n,\n            (x + n) / n == x / n + 1,\n            (x - n) / n == x / n - 1,\n            0 <= x < n <==> x % n == x,\n    {\n        lemma_fundamental_div_mod(x, n);\n        lemma_fundamental_div_mod(x + n, n);\n        lemma_fundamental_div_mod(x - n, n);\n        let zp = (x + n) / n - x / n - 1;\n        let zm = (x - n) / n - x / n + 1;\n        lemma_mul_is_distributive_sub(n, (x + n) / n, x / n + 1);\n        lemma_mul_is_distributive_add(n, x / n, 1);\n        assert (n * zp == n * ((x + n) / n) - n * (x / n) - n * 1);\n        assert (0 == n * zp + ((x + n) % n) - (x % n));\n        lemma_mul_is_distributive_sub(n, (x - n) / n, x / n - 1);\n        lemma_mul_is_distributive_sub(n, x / n, 1);\n        assert (n * zm == n * ((x - n) / n) - n * (x / n) + n * 1);\n        assert (0 == n * zm + ((x - n) % n) - (x % n));\n        if (zp > 0) { lemma_mul_inequality(1, zp, n); }\n        if (zp < 0) { lemma_mul_inequality(zp, -1, n); }\n        if (zp == 0) { lemma_mul_by_zero_is_zero(n); }\n        if (zm > 0) { lemma_mul_inequality(1, zm, n); }\n        if (zm < 0) { lemma_mul_inequality(zm, -1, n); }\n        if 0 <= x < n {\n            lemma_basic_div_specific_divisor(n);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            x % d < y % d\n        ensures\n            y / d == x / d\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 1 * d);\n            assert ((y / d) * d - (x / d) * d >= d);\n            assert (false);\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n            assert (((y / d) - (x / d)) * d <= (-1) * d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order_alt(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            x % d <= y % d\n        ensures\n            y / d == x / d\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 1 * d);\n            assert (false);\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n            assert (((y / d) - (x / d)) * d <= (-1) * d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            y % d <= x % d\n        ensures\n            y / d == x / d + 1\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 2 * d);\n            assert (false);\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n            assert (0 * d <= ((x / d) - (y / d)) * d);\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n            assert (d * ((x / d) - (y / d)) == d * (x / d) - d * (y / d));\n            assert (0 * d <= x - y - x % d + y % d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order_alt(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            y % d < x % d\n        ensures\n            y / d == x / d + 1\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n            assert (((y / d) - (x / d)) * d >= 2 * d);\n            assert (false);\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n            assert (0 * d <= ((x / d) - (y / d)) * d);\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n            assert (d * ((x / d) - (y / d)) == d * (x / d) - d * (y / d));\n            assert (0 * d <= x - y - x % d + y % d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n        requires\n            d > 0,\n            x % d < y % d,\n            y - x <= d,\n            x <= z <= y\n        ensures\n            x % d <= z % d <= y % d\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n            assert (y % d == x % d);\n            assert (false);\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n            assert (d * (y / d) - d * (x / d) + y % d - x % d < d);\n            assert (d * (y / d) - d * (x / d) < d);\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n            assert (d * ((y / d) - (x / d)) < d);\n\n            lemma_div_relation_when_mods_have_same_order(d, x, y);\n\n            let z_mod_d = x % d + (z - x);\n            assert (z == (x / d) * d + z_mod_d) by {\n                assert (z == d * (x / d) + z_mod_d);\n                lemma_mul_is_commutative(d, (x / d));\n            }\n            lemma_fundamental_div_mod_converse(z, d, (x / d), z_mod_d);\n        }\n    }\n\n    pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n        requires\n            d > 0,\n            y % d < x % d,\n            y - x <= d,\n            x <= z <= y\n        ensures\n            z % d <= y % d || z % d >= x % d\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n            assert (y % d == x % d);\n            assert (false);\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n            assert (d * (y / d) - d * (x / d) + y % d - x % d >= 0);\n            assert (d * (y / d) - d * (x / d) >= 0);\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n            assert (d * ((y / d) - (x / d)) >= 0);\n\n            lemma_div_relation_when_mods_have_different_order(d, x, y);\n\n            if y % d < z % d < x % d {\n                lemma_div_relation_when_mods_have_different_order(d, z, y);\n                lemma_div_relation_when_mods_have_same_order(d, z, x);\n                assert (false);\n            }\n        }\n    }\n\n    pub proof fn lemma_mod_addition_when_bounded(x: int, y: int, d: int)\n        requires\n            d > 0,\n            y >= 0,\n            (x % d) + y < d,\n        ensures\n            (x + y) % d == (x % d) + y\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_fundamental_div_mod_converse(x + y, d, x / d, x % d + y);\n    }\n\n    pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d <= y % d,\n            y - x < d\n        ensures\n            y % d - x % d == y - x\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        assert (d * (y / d) - d * (x / d) + y % d - x % d == y - x);\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n        assert (d * (y / d - x / d) + y % d - x % d == y - x);\n        assert (0 <= d * (y / d - x / d) + y % d - x % d < d);\n        lemma_div_relation_when_mods_have_same_order_alt(d, x, y);\n        assert (y / d == x / d);\n    }\n\n    pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d > y % d,\n            y - x < d\n        ensures\n            d - (x % d) + (y % d) == y - x\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n        assert (d * (y / d) - d * (x / d) + y % d - x % d == y - x);\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n        assert (d * (y / d - x / d) + y % d - x % d == y - x);\n        assert (0 <= d * (y / d - x / d) + y % d - x % d < d);\n        lemma_div_relation_when_mods_have_different_order_alt(d, x, y);\n        assert (y / d == x / d + 1);\n        assert (y / d - x / d == 1 ==> d * (y / d - x / d) == d) by (nonlinear_arith);\n    }\n\n    pub proof fn lemma_mod_equal(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d == y % d,\n            y - x < d\n        ensures\n            x == y\n    {\n        lemma_mod_difference_equal(x, y, d);\n    }\n\n    pub proof fn lemma_mod_equal_converse(x: int, y: int, d: int)\n        requires \n            d > 0,\n            x == y,\n        ensures \n            x % d == y % d\n    {}\n\n    pub proof fn lemma_mod_not_equal(x: int, y: int, d: int) \n        requires \n            d > 0,\n            y - x < d,\n            y - x >= 0,\n            x != y,\n        ensures \n            x % d != y % d\n    {\n        if x % d == y % d {\n            if x < y {\n                lemma_mod_equal(x, y, d);\n                assert(false);\n            } else {\n                assert(y - x < 0);\n                assert(false);\n            }\n        }\n\n    }\n\n    #[verifier(nonlinear)]\n    pub proof fn lemma_mul_div_equal(x: int, q: int, d: int)\n        requires\n            q * d <= x < (q + 1) * d\n        ensures\n            (x / d) == q\n    {}\n\n    pub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n        requires\n            d > 0,\n            (x % d) + y >= d,\n            0 <= y < d\n        ensures\n            (x % d) + y - d == (x + y) % d\n    {\n        assert(d <= (x % d) + y < 2 * d);\n        assert((x / d) * d + d <= (x / d) * d + (x % d) + y < (x / d) * d + 2 * d);\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 1);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 2);\n        assert((x / d + 1) * d <= x + y < (x / d + 2) * d);\n        lemma_mul_div_equal(x + y, (x / d + 1), d);\n        assert(x / d + 1 == (x + y) / d);\n        lemma_fundamental_div_mod(x + y, d);\n        assert(x + y == d * ((x + y) / d) + (x + y) % d);\n    }\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-storage/pmemlog/src/math_v.rs", "verified": true, "metadata": {"original_id": "verified-storage_math_v_c45695888d25", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_53783bc47f7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires merge_intervals_precond (intervals @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_47/verina_advanced_47.rs", "verified": true, "metadata": {"original_id": "53783bc47f7a", "function_name": "merge_intervals", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e13ed677bb0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32)   { let mut max = a [0] ; let mut index = 1 ; while index < a . len ()  { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m \ndecreases a . len () - index \ninvariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut index = 1 ; while index < a . len () invariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max , decreases a . len () - index , { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e13ed677bb0c", "function_name": "MaxA", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_17f671e04a49", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - i\ninvariant 0 <= i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant 0 <= i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "17f671e04a49", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_87fad8385ba9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "87fad8385ba9", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b3811a931a4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/053-add_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b3811a931a4b", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eadce0a1fdef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "eadce0a1fdef", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_81d10428ea86", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "81d10428ea86", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_34bfca31cda2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "34bfca31cda2", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_326dcb4a9e07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { 0 }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "326dcb4a9e07", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_59e692559f08", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "requires d > 0\nensures result == sum_of_digits (x as nat), result == is_sum_divisible_by (x as nat , d as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "59e692559f08", "function_name": "is_sum_divisible_by_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_58fb96ec49ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1 ; let mut i = 2 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i, n + 1 - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58fb96ec49ca", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_584be3ed198e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,)  { }\n\n} // verus!", "target_text": "requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,) requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "584be3ed198e", "function_name": "create_all_state", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3af70fcd4ee1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "3af70fcd4ee1", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_305d04ab1d29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "305d04ab1d29", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_43fe1daa1d32", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "43fe1daa1d32", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_07c9e6877f8b", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >)  { x . checked_pow (exp) }\n\n} // verus!", "target_text": "ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >) ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX , { x . checked_pow (exp) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/not_finished_proof/076-is_simple_power_impl.rs", "verified": true, "metadata": {"original_id": "07c9e6877f8b", "function_name": "ex_checked_pow", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c5475d6423de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "c5475d6423de", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f98f564c27cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f98f564c27cc", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_befeb2ba707c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "befeb2ba707c", "function_name": "count_digits_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a356d66f5b81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "a356d66f5b81", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0cca59d8cea0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "0cca59d8cea0", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c5774525eb88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c5774525eb88", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_df3e93b849b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "df3e93b849b3", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d065fab5e527", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut index = 0 ; while index < arr1 . len ()  { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - index \ninvariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "d065fab5e527", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6269b9f91ab1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6269b9f91ab1", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5b4d4afa6dde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { for k in 1 .. lst . len ()  { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ninvariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { for k in 1 .. lst . len () invariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] , { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_sorted_iter_1_current.rs", "verified": true, "metadata": {"original_id": "5b4d4afa6dde", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_86698098f817", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "86698098f817", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_39c433ef84d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "39c433ef84d5", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8f26ff6b2328", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f26ff6b2328", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c9dce987a094", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c9dce987a094", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f3d4824ffd91", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "f3d4824ffd91", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2bb8ba1e41e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_477_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2bb8ba1e41e5", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_314920209f24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_iter_1_current.rs", "verified": true, "metadata": {"original_id": "314920209f24", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_008c4f9269bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if (c == ' ') || (c == ',') || (c == '.') { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i \ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i , { let c = str1 [i] ; if (c == ' ') || (c == ',') || (c == '.') { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "008c4f9269bc", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2d7c9dd4ee5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2d7c9dd4ee5e", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_131504e65e79", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "131504e65e79", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8256f1cd1471", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8256f1cd1471", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2318d895fdb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/060-sum_to_n_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2318d895fdb8", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_exec_attr_8a9f2ac676ab", "task": "task_a", "input_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum =>\n\n{\n    x + y\n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v =>  {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n        {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n\n   }\n   test_for_loop(10);\n   proof!{\n\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32>\n     -> z: Ghost<u32>\n\n {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n     {\n    proof!{\n\n    }\n    {\n        proof!{}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n     {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "target_text": "requires x < 100,\n  *old(y) < 100, x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32\nensures true)]\nfn test_for_loop(n: u32) -> Vec<u32>, sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32, *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32\ninvariant v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n", "full_verified_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/exec_attr.rs", "verified": true, "metadata": {"original_id": "verus_exec_attr_8a9f2ac676ab", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_strings_a9ecfdea6bcc", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n\n    let val = x.get_char(0);\n\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n\n{\n\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n\n    let b = a.as_str().substring_ascii(2, 3);\n\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "target_text": "requires s@ =~= \"Hello\"@", "full_verified_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/strings.rs", "verified": true, "metadata": {"original_id": "verus_strings_a9ecfdea6bcc", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4a328d542dff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/modn_impl.rs", "verified": true, "metadata": {"original_id": "4a328d542dff", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_73b4e757c2f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "target_text": "ensures result == is_valid_digit (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "73b4e757c2f1", "function_name": "is_valid_digit_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verified-ironkv_set_lib_ext_v_5235a371a694", "task": "task_a", "input_text": "\nuse vstd::prelude::*;\nuse vstd::seq_lib::*;\nuse vstd::set_lib::*;\n\nverus! {\n/// This fold uses a fixed zero rather than accumulating results in that\n/// argument. This means proofs don't need to generalize over the accumulator,\n/// unlike the Set::fold currently in Verus.\npub open spec fn set_fold<A, B>(s: Set<A>, zero: B, f: spec_fn(B, A) -> B) -> B\n    recommends s.finite()\n    {\n    if s.finite() {\n        if s.len() == 0 {\n            zero\n        } else {\n            let a = s.choose();\n            f(set_fold(s.remove(a), zero, f), a)\n        }\n    } else {\n        zero\n    }\n}\n\npub open spec fn flatten_sets<A>(sets: Set<Set<A>>) -> Set<A>\n{\n    // extra parens are for rust-analyzer\n    Set::new(|a: A| (exists |s: Set<A>| sets.contains(s) && s.contains(a)))\n}\n\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n\n{\n}\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}\n\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}\n\npub proof fn lemma_flatten_sets_union_auto<A>()\n\n{\n    }\n\npub proof fn set_map_union<A, B>(s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B)\n\n{\n    assert_sets_equal!((s1 + s2).map(f) == s1.map(f) + s2.map(f), y => {\n        if s1.map(f).contains(y) {\n            let x = choose |x| s1.contains(x) && f(x) == y;\n\n        } else if s2.map(f).contains(y) {\n            let x = choose |x| s2.contains(x) && f(x) == y;\n\n        }\n    });\n}\n\npub proof fn set_map_union_auto<A, B>()\n\n{\n    }\n\npub proof fn seq_map_values_concat<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B)\n\n{\n    assert_seqs_equal!((s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), i => {\n        if i < s1.len() {\n\n        } else {\n\n        }\n    });\n}\n\npub proof fn seq_map_values_concat_auto<A, B>()\n\n{\n    }\n\npub open spec fn flatten_set_seq<A>(sets: Seq<Set<A>>) -> Set<A>\n{\n    sets.fold_left(Set::<A>::empty(), |s1: Set<A>, s2: Set<A>| s1.union(s2))\n}\n\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n\n    {\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        else {\n\n            }\n        }\n        else {\n\n            }\n        }\n    }\n}\n\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n\n{\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n\n            }\n        }\n    });\n}\n\npub proof fn lemma_set_map_insert<A, B>(s: Set<A>, f: spec_fn(A) -> B, x: A)\n\n{\n    assert_sets_equal!(s.insert(x).map(f) == s.map(f).insert(f(x)), y => {\n        if y == f(x) {\n             // OBSERVE\n            //\n        } else {\n            if s.insert(x).map(f).contains(y) {\n                let x0 = choose |x0| s.contains(x0) && y == f(x0);\n\n            } else {\n                if s.map(f).insert(f(x)).contains(y) {\n                    let x0 = choose |x0| s.contains(x0) && y == f(x0);\n\n                }\n            }\n        }\n    });\n}\n\n// TODO(verus): This consequence should somehow be broadcast from map_values/map\npub proof fn lemma_seq_map_equiv<A, B>(f: spec_fn(A) -> B, g: spec_fn(int, A) -> B)\n\n{\n    }\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n\n        }\n    }\n    assert_sets_equal!(left, right);\n}\n\npub proof fn lemma_to_set_union_auto<A>()\n\n{\n    }\n\nspec fn map_fold<A, B>(s: Set<A>, f: spec_fn(A) -> B) -> Set<B>\n    recommends s.finite()\n{\n    set_fold(s, Set::empty(), |s1: Set<B>, a: A| s1.insert(f(a)))\n}\n\nproof fn map_fold_ok<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n    {\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_ok(s.remove(a), f);\n        return;\n    }\n}\n\nproof fn map_fold_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n    {\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_finite(s.remove(a), f);\n        return;\n    }\n}\n\npub proof fn map_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n{\n    map_fold_ok(s, f);\n    map_fold_finite(s, f);\n}\n\npub proof fn map_set_finite_auto<A, B>()\n\n{\n    }\n\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    }\n\npub proof fn lemma_map_values_singleton_auto<A, B>()\n\n{\n}\n\npub proof fn lemma_map_set_singleton_auto<A, B>()\n\n{\n    }\n\npub proof fn lemma_map_seq_singleton_auto<A, B>()\n\n{\n}\n\npub proof fn flatten_sets_singleton_auto<A>()\n\n{\n}\n\n// TODO(Tej): We strongly suspect there is a trigger loop in these auto\n// lemmas somewhere, but it's not easy to see from the profiler yet.\n\n}\n", "target_text": "requires forall |i: int, a: A| #[trigger] g(i, a) == f(a), s.finite(), s.finite(), s.finite()\nensures (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets))), flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s), flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)), forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)), (s1 + s2).map(f) == s1.map(f) + s2.map(f), forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f), (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x)), s.push(x).to_set() == s.to_set().insert(x), s.insert(x).map(f) == s.map(f).insert(f(x)), forall |s: Seq<A>| s.map_values(f) == s.map(g), (s+t).to_set() == s.to_set() + t.to_set(), forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set(), map_fold(s, f) =~= s.map(f), map_fold(s, f).finite(), s.map(f).finite(), forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()), forall |x: A| #[trigger] seq![x].to_set() == set![x], forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)], forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)], forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)], forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x, (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len(), map_fold(s, f) =~= s.map(f)\n    decreases s.len(), map_fold(s, f).finite()\n    decreases s.len()\ndecreases s.len(), sets.len(), s.len(), s.len()", "full_verified_code": "\nuse vstd::prelude::*;\nuse vstd::seq_lib::*;\nuse vstd::set_lib::*;\n\nverus! {\n/// This fold uses a fixed zero rather than accumulating results in that\n/// argument. This means proofs don't need to generalize over the accumulator,\n/// unlike the Set::fold currently in Verus.\npub open spec fn set_fold<A, B>(s: Set<A>, zero: B, f: spec_fn(B, A) -> B) -> B\n    recommends s.finite()\n    decreases s.len()\n{\n    if s.finite() {\n        if s.len() == 0 {\n            zero\n        } else {\n            let a = s.choose();\n            f(set_fold(s.remove(a), zero, f), a)\n        }\n    } else {\n        zero\n    }\n}\n\npub open spec fn flatten_sets<A>(sets: Set<Set<A>>) -> Set<A>\n{\n    // extra parens are for rust-analyzer\n    Set::new(|a: A| (exists |s: Set<A>| sets.contains(s) && s.contains(a)))\n}\n\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    ensures\n        (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}\n\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}\n\npub proof fn lemma_flatten_sets_union_auto<A>()\n    ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)) by {\n        lemma_flatten_sets_union(sets1, sets2);\n    }\n}\n\npub proof fn set_map_union<A, B>(s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B)\n    ensures (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert_sets_equal!((s1 + s2).map(f) == s1.map(f) + s2.map(f), y => {\n        if s1.map(f).contains(y) {\n            let x = choose |x| s1.contains(x) && f(x) == y;\n            assert((s1 + s2).contains(x));\n        } else if s2.map(f).contains(y) {\n            let x = choose |x| s2.contains(x) && f(x) == y;\n            assert((s1 + s2).contains(x));\n        }\n    });\n}\n\npub proof fn set_map_union_auto<A, B>()\n    ensures forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}\n\npub proof fn seq_map_values_concat<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B)\n    ensures (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert_seqs_equal!((s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), i => {\n        if i < s1.len() {\n            assert((s1+s2)[i] == s1[i]);\n        } else {\n            assert((s1+s2)[i] == s2[i - s1.len()]);\n        }\n    });\n}\n\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}\n\npub open spec fn flatten_set_seq<A>(sets: Seq<Set<A>>) -> Set<A>\n{\n    sets.fold_left(Set::<A>::empty(), |s1: Set<A>, s2: Set<A>| s1.union(s2))\n}\n\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures\n        (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}\n\n\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n    ensures s.push(x).to_set() == s.to_set().insert(x)\n{\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n            assert(s.push(x)[s.len() as int] == x);\n            assert(s.push(x).contains(x))\n        } else {\n            if s.to_set().insert(x).contains(elem) {\n                assert(s.to_set().contains(elem));\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n                assert(s.push(x)[i] == elem);\n            }\n        }\n    });\n}\n\npub proof fn lemma_set_map_insert<A, B>(s: Set<A>, f: spec_fn(A) -> B, x: A)\n    ensures s.insert(x).map(f) == s.map(f).insert(f(x))\n{\n    assert_sets_equal!(s.insert(x).map(f) == s.map(f).insert(f(x)), y => {\n        if y == f(x) {\n            assert(s.insert(x).contains(x)); // OBSERVE\n            // assert(s.map(f).insert(f(x)).contains(f(x)));\n        } else {\n            if s.insert(x).map(f).contains(y) {\n                let x0 = choose |x0| s.contains(x0) && y == f(x0);\n                assert(s.map(f).contains(y));\n            } else {\n                if s.map(f).insert(f(x)).contains(y) {\n                    let x0 = choose |x0| s.contains(x0) && y == f(x0);\n                    assert(s.map(f).contains(y));\n                    assert(s.insert(x).contains(x0));\n                }\n            }\n        }\n    });\n}\n\n// TODO(verus): This consequence should somehow be broadcast from map_values/map\npub proof fn lemma_seq_map_equiv<A, B>(f: spec_fn(A) -> B, g: spec_fn(int, A) -> B)\nrequires\n    forall |i: int, a: A| #[trigger] g(i, a) == f(a)\nensures\n    forall |s: Seq<A>| s.map_values(f) == s.map(g)\n{\n    assert forall |s: Seq<A>| s.map_values(f) == s.map(g) by {\n        assert_seqs_equal!(s.map_values(f), s.map(g));\n    }\n}\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}\n\n\npub proof fn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}\n\nspec fn map_fold<A, B>(s: Set<A>, f: spec_fn(A) -> B) -> Set<B>\n    recommends s.finite()\n{\n    set_fold(s, Set::empty(), |s1: Set<B>, a: A| s1.insert(f(a)))\n}\n\nproof fn map_fold_ok<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n    requires s.finite()\n    ensures map_fold(s, f) =~= s.map(f)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_ok(s.remove(a), f);\n        return;\n    }\n}\n\nproof fn map_fold_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n    requires s.finite()\n    ensures map_fold(s, f).finite()\n    decreases s.len()\n{\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_finite(s.remove(a), f);\n        return;\n    }\n}\n\npub proof fn map_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\nrequires\n    s.finite(),\nensures\n    s.map(f).finite(),\n{\n    map_fold_ok(s, f);\n    map_fold_finite(s, f);\n}\n\npub proof fn map_set_finite_auto<A, B>()\nensures\n    forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()),\n{\n    assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by {\n        map_finite(s, f);\n    }\n}\n\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}\n\npub proof fn lemma_map_values_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}\n\npub proof fn lemma_map_set_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)],\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}\n\npub proof fn lemma_map_seq_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}\n\n\npub proof fn flatten_sets_singleton_auto<A>()\nensures\n    forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x,\n{\n}\n\n// TODO(Tej): We strongly suspect there is a trigger loop in these auto\n// lemmas somewhere, but it's not easy to see from the profiler yet.\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-ironkv/ironsht/src/verus_extra/set_lib_ext_v.rs", "verified": true, "metadata": {"original_id": "verified-ironkv_set_lib_ext_v_5235a371a694", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a239dbf1c5f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32) requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_7/verina_advanced_7_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a239dbf1c5f7", "function_name": "binary_to_decimal", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bae2c7702c04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "bae2c7702c04", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b85d5c2c824e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b85d5c2c824e", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0459c1a200ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0459c1a200ec", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_050586e58c13", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { 0 }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "050586e58c13", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_675cd954685d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "675cd954685d", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_54831fba50a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] \ndecreases a . len () - i , b . len () - j \ninvariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "54831fba50a1", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a64d84288315", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {     return false ; } i = i + 1 ; }   return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "a64d84288315", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2da8c3330c3c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2da8c3330c3c", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_eacdf445eec3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "eacdf445eec3", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fe0933fa19b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/057-monotonic_impl.rs", "verified": true, "metadata": {"original_id": "fe0933fa19b0", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0a6ed5b553c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)   { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index\ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "0a6ed5b553c3", "function_name": "find_first_occurrence", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4d9cde7f473c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4d9cde7f473c", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_65c867af533c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires find_majority_element_precond (lst @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_11/verina_advanced_11_iter_0_original.rs", "verified": true, "metadata": {"original_id": "65c867af533c", "function_name": "find_majority_element", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a17cd7dcaa30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a17cd7dcaa30", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_da09a0a8af91", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/max_index_iter_2_current.rs", "verified": true, "metadata": {"original_id": "da09a0a8af91", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d03fd30fde88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_min.rs", "verified": true, "metadata": {"original_id": "d03fd30fde88", "function_name": "min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b39f2ab4789c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b39f2ab4789c", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6a1924bcbe6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "6a1924bcbe6f", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ec65c331810f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "ec65c331810f", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3df3a1cef5df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "3df3a1cef5df", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_db8eba61e4e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_iter_2_current.rs", "verified": true, "metadata": {"original_id": "db8eba61e4e5", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_157ebe39e327", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut idx = 1 ; while idx < lists . len ()  { if lists [idx] . len () < min_length { min_length = lists [idx] . len () ; } idx += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - idx\ninvariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_length <= lists [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut idx = 1 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_length <= lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_length { min_length = lists [idx] . len () ; } idx += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "157ebe39e327", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_68528a612e39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "68528a612e39", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8859c72c44f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max \ndecreases a . len () - idx\ninvariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/035-max-element_impl.rs", "verified": true, "metadata": {"original_id": "8859c72c44f1", "function_name": "max_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f9e413e3d8a7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f9e413e3d8a7", "function_name": "sum_powers_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4e6d0475eead", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "4e6d0475eead", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2aae472d4d7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires solution_precond (nums @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_74/verina_advanced_74.rs", "verified": true, "metadata": {"original_id": "2aae472d4d7b", "function_name": "solution", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_72a77d0be868", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_canyon_search/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "72a77d0be868", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fe5feb0b3a26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "fe5feb0b3a26", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e94174c8246b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e94174c8246b", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c1eec920f16e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c1eec920f16e", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_51851ecb2982", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "ensures if let Some (idx) = index\ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_807_iter_4_current.rs", "verified": true, "metadata": {"original_id": "51851ecb2982", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_950e363ff8ac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res1o_impl.rs", "verified": true, "metadata": {"original_id": "950e363ff8ac", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_01647fd9aa11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_iter_2_current.rs", "verified": true, "metadata": {"original_id": "01647fd9aa11", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_28f246cc2622", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let double_n = 2 * N ; sum . set (0 , double_n) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 , ensures sum [0] == 2 * N , { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "28f246cc2622", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_vostd_seq_extra_344700480285", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n\n{\n\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n\n{\n    if (forall_seq(s.push(v), f)) {\n        }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n\n{\n    if (s.push(v).all(f)) {\n        }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n\n{\n\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n\n{\n\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n\n    {\n    if s2.len() == 0 {\n\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n\n        }\n        if (s1 + s2).all(f) {\n\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n\n{\n}\n\n} // verus!\n", "target_text": "requires 0 <= idx < s.len(), s.len() > 0, new_elem != needle, s.len() > 0,\n        s.last() != needle, forall_seq(s, f),\n        0 <= i < s.len(), 0 <= i < s.len(),\n        #[trigger] s.all(f), s.len() > 0, s.len() > 0, source1.is_prefix_of(child),\n        source2.is_prefix_of(child)\nensures res == Seq::<T>::new(len, f), res == s.update(idx, x), res == s1.add(s2), s =~= seq![s[0]].add(s.drop_first()), seq![hd].add(s) =~= s.reverse().push(hd).reverse(), seq![hd].add(s).drop_first() =~= s, seq![hd].add(s)[0] == hd, #[trigger] s.push(needle).contains(needle), #[trigger] s.push(new_elem).contains(needle) == s.contains(needle), #[trigger] s.drop_last().contains(needle) == s.contains(needle), f(i, s[i]), f(#[trigger] (s[i])), forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f), #[trigger] s.push(v).all(f) <==> s.all(f) && f(v), forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ), s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()), s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f), source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1), s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\ndecreases s2.len(),\n// Induction proof on the length of s2", "full_verified_code": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n    ensures\n        res == Seq::<T>::new(len, f),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n    requires\n        0 <= idx < s.len(),\n    ensures\n        res == s.update(idx, x),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n    ensures\n        res == s1.add(s2),\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n    requires\n        s.len() > 0,\n    ensures\n        s =~= seq![s[0]].add(s.drop_first()),\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s) =~= s.reverse().push(hd).reverse(),\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s).drop_first() =~= s,\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s)[0] == hd,\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n    ensures\n        #[trigger] s.push(needle).contains(needle),\n{\n    assert(s.push(needle).last() == needle);\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n    requires\n        new_elem != needle,\n    ensures\n        #[trigger] s.push(new_elem).contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n        assert(0 <= i < s.push(new_elem).len() && s.push(new_elem)[i] == needle);\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n    requires\n        s.len() > 0,\n        s.last() != needle,\n    ensures\n        #[trigger] s.drop_last().contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        assert(0 <= i < s.drop_last().len() && s.drop_last()[i] == needle);\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n    requires\n        forall_seq(s, f),\n        0 <= i < s.len(),\n    ensures\n        f(i, s[i]),\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n    requires\n        0 <= i < s.len(),\n        #[trigger] s.all(f),\n    ensures\n        f(#[trigger] (s[i])),\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n    ensures\n        forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f),\n{\n    if (forall_seq(s.push(v), f)) {\n        assert forall|i| 0 <= i < s.len() implies f(i, s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n    ensures\n        #[trigger] s.push(v).all(f) <==> s.all(f) && f(v),\n{\n    if (s.push(v).all(f)) {\n        assert forall|i| 0 <= i < s.len() implies f(s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n    ensures\n        s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\n\n{\n    if s2.len() == 0 {\n        assert(s1 + s2 == s1);\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n            assert((s1 + s2).all(f));\n        }\n        if (s1 + s2).all(f) {\n            assert((s1 + s2).drop_last() == s1 + s2.drop_last());\n            assert(s2 == s2.drop_last().push(s2.last()));\n            assert((s1 + s2).last() == s2.last());\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n    requires\n        source1.is_prefix_of(child),\n        source2.is_prefix_of(child),\n    ensures\n        source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/seq_extra.rs", "verified": true, "metadata": {"original_id": "vostd_seq_extra_344700480285", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b2f06b5278a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - i\ninvariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b2f06b5278a0", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7551765cf41c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7551765cf41c", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_overflow_8c4772399c7c", "task": "task_a", "input_text": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n     {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n     {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "target_text": "ensures match result, match result", "full_verified_code": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/overflow.rs", "verified": true, "metadata": {"original_id": "verus_overflow_8c4772399c7c", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_023f08f3b9d9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "023f08f3b9d9", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b87b20df173c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len ()  { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - idx\ninvariant 0 <= idx <= list . len () , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 0 <= idx <= list . len () , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "b87b20df173c", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_fifo_7d613aff30a4", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// port of single-producer single-consumer queue from LinearDafny\n// https://github.com/vmware-labs/verified-betrfs/tree/concurrency-experiments/concurrency/spsc-queue\n\n// ANCHOR:full\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// ANCHOR: enum_state\n#[is_variant]\npub enum ProducerState {\n    Idle(nat),  // local copy of tail\n    Producing(nat),\n}\n\n#[is_variant]\npub enum ConsumerState {\n    Idle(nat),  // local copy of head\n    Consuming(nat),\n}\n// ANCHOR_END: enum_state\n\n// ANCHOR: fields\ntokenized_state_machine!{FifoQueue<T> {\n    fields {\n        // IDs of the cells used in the ring buffer.\n        // These are fixed throughout the protocol.\n\n        #[sharding(constant)]\n        pub backing_cells: Seq<CellId>,\n\n        // All the stored permissions\n\n        #[sharding(storage_map)]\n        pub storage: Map<nat, cell::PointsTo<T>>,\n\n        // Represents the shared `head` field\n\n        #[sharding(variable)]\n        pub head: nat,\n\n        // Represents the shared `tail` field\n\n        #[sharding(variable)]\n        pub tail: nat,\n\n        // Represents the local state of the single-producer\n\n        #[sharding(variable)]\n        pub producer: ProducerState,\n\n        // Represents the local state of the single-consumer\n\n        #[sharding(variable)]\n        pub consumer: ConsumerState,\n    }\n    // ANCHOR_END: fields\n\n    pub open spec fn len(&self) -> nat {\n        self.backing_cells.len()\n    }\n\n    // ANCHOR: inc_wrap\n    pub open spec fn inc_wrap(i: nat, len: nat) -> nat {\n        if i + 1 == len { 0 } else { i + 1 }\n    }\n    // ANCHOR_END: inc_wrap\n\n    // Make sure the producer state and the consumer state aren't inconsistent.\n\n    #[invariant]\n    pub fn not_overlapping(&self) -> bool {\n        match (self.producer, self.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n                && Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                true\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n            }\n        }\n    }\n\n    // `head` and `tail` are in-bounds\n    // shared `head` and `tail` fields agree with the ProducerState and ConsumerState\n\n    #[invariant]\n    pub fn in_bounds(&self) -> bool {\n        0 <= self.head && self.head < self.len() &&\n        0 <= self.tail && self.tail < self.len()\n        && match self.producer {\n            ProducerState::Producing(tail) => {\n                self.tail == tail\n            }\n            ProducerState::Idle(tail) => {\n                self.tail == tail\n            }\n        }\n        && match self.consumer {\n            ConsumerState::Consuming(head) => {\n                self.head == head\n            }\n            ConsumerState::Idle(head) => {\n                self.head == head\n            }\n        }\n    }\n\n    // Indicates whether we expect the cell at index `i` to be full based on\n    // the values of the `head` and `tail`.\n\n    pub open spec fn in_active_range(&self, i: nat) -> bool {\n        // Note that self.head = self.tail means empty range\n        0 <= i && i < self.len() && (\n            if self.head <= self.tail {\n                self.head <= i && i < self.tail\n            } else {\n                i >= self.head || i < self.tail\n            }\n        )\n    }\n\n    // Indicates whether we expect a cell to be checked out or not,\n    // based on the producer/consumer state.\n\n    pub open spec fn is_checked_out(&self, i: nat) -> bool {\n        self.producer === ProducerState::Producing(i)\n        || self.consumer === ConsumerState::Consuming(i)\n    }\n\n    // Predicate to determine that the state at cell index `i`\n    // is correct. For each index, there are three possibilities:\n    //\n    //  1. No cell permission is stored\n    //  2. Permission is stored; permission indicates a full cell\n    //  3. Permission is stored; permission indicates an empty cell\n    //\n    // Which of these 3 possibilities we should be in depends on the\n    // producer/consumer/head/tail state.\n\n    pub open spec fn valid_storage_at_idx(&self, i: nat) -> bool {\n        if self.is_checked_out(i) {\n            // No cell permission is stored\n            !self.storage.dom().contains(i)\n        } else {\n            // Permission is stored\n            self.storage.dom().contains(i)\n\n            // Permission must be for the correct cell:\n            && self.storage.index(i).id() === self.backing_cells.index(i as int)\n\n            && if self.in_active_range(i) {\n                // The cell is full\n                self.storage.index(i).is_init()\n            } else {\n                // The cell is empty\n                self.storage.index(i).is_uninit()\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn valid_storage_all(&self) -> bool {\n        forall|i: nat| 0 <= i && i < self.len() ==>\n            self.valid_storage_at_idx(i)\n    }\n\n    init!{\n        initialize(backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n            // Upon initialization, the user needs to deposit _all_ the relevant\n            // cell permissions to start with. Each permission should indicate\n            // an empty cell.\n\n            require(\n                (forall|i: nat| 0 <= i && i < backing_cells.len() ==>\n                    #[trigger] storage.dom().contains(i)\n                    && storage.index(i).id() === backing_cells.index(i as int)\n                    && storage.index(i).is_uninit())\n            );\n            require(backing_cells.len() > 0);\n\n            init backing_cells = backing_cells;\n            init storage = storage;\n            init head = 0;\n            init tail = 0;\n            init producer = ProducerState::Idle(0);\n            init consumer = ConsumerState::Idle(0);\n        }\n    }\n\n    // ANCHOR: transition_produce_start\n    transition!{\n        produce_start() {\n            // In order to begin, we have to be in ProducerState::Idle.\n            require(pre.producer.is_Idle());\n\n            // We'll be comparing the producer's _local_ copy of the tail\n            // with the _shared_ version of the head.\n            let tail = pre.producer.get_Idle_0();\n            let head = pre.head;\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // We have to check that the buffer isn't full to proceed.\n            require(next_tail != head);\n\n            // Update the producer's local state to be in the `Producing` state.\n            update producer = ProducerState::Producing(tail);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n            // This creates a proof obligation for the transition system to prove that\n            // there is actually a permission stored at this index.\n            withdraw storage -= [tail => let perm] by {\n\n            };\n\n            // The transition needs to guarantee to the client that the\n            // permission they are checking out:\n            //  (i) is for the cell at index `tail` (the IDs match)\n            //  (ii) the permission indicates that the cell is empty\n\n            };\n        }\n    }\n    // ANCHOR_END: transition_produce_start\n\n    // ANCHOR: transition_produce_end\n    transition!{\n        // This transition is parameterized by the value of the permission\n        // being inserted. Since the permission is being deposited\n        // (coming from \"outside\" the system) we can't compute it as a\n        // function of the current state, unlike how we did it for the\n        // `produce_start` transition).\n        produce_end(perm: cell::PointsTo<T>) {\n            // In order to complete the produce step,\n            // we have to be in ProducerState::Producing.\n            require(pre.producer.is_Producing());\n            let tail = pre.producer.get_Producing_0();\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // This time, we don't need to compare the `head` and `tail` - we already\n            // check that, and anyway, we don't have access to the `head` field\n            // for this transition. (This transition is supposed to occur while\n            // modifying the `tail` field, so we can't do both.)\n\n            // However, we _do_ need to check that the permission token being\n            // checked in satisfies its requirements. It has to be associated\n            // with the correct cell, and it has to be full.\n\n            require(perm.id() === pre.backing_cells.index(tail as int)\n              && perm.is_init());\n\n            // Perform our updates. Update the tail to the computed value,\n            // both the shared version and the producer's local copy.\n            // Also, move back to the Idle state.\n            update producer = ProducerState::Idle(next_tail);\n            update tail = next_tail;\n\n            // Check the permission back into the storage map.\n            deposit storage += [tail => perm] by {  };\n        }\n    }\n    // ANCHOR_END: transition_produce_end\n\n    transition!{\n        consume_start() {\n            // In order to begin, we have to be in ConsumerState::Idle.\n            require(pre.consumer.is_Idle());\n\n            // We'll be comparing the consumer's _local_ copy of the head\n            // with the _shared_ version of the tail.\n            let head = pre.consumer.get_Idle_0();\n            let tail = pre.tail;\n\n            // We have to check that the buffer isn't empty to proceed.\n            require(head != tail);\n\n            // Update the consumer's local state to be in the `Consuming` state.\n            update consumer = ConsumerState::Consuming(head);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n\n            birds_eye let perm = pre.storage.index(head);\n            withdraw storage -= [head => perm] by {\n\n            };\n\n            };\n\n            };\n        }\n    }\n\n    transition!{\n        consume_end(perm: cell::PointsTo<T>) {\n            require(pre.consumer.is_Consuming());\n            let head = pre.consumer.get_Consuming_0();\n\n            let next_head = Self::inc_wrap(head, pre.backing_cells.len());\n\n            update consumer = ConsumerState::Idle(next_head);\n            update head = next_head;\n\n            require(perm.id() === pre.backing_cells.index(head as int)\n              && perm.is_uninit());\n            deposit storage += [head => perm] by {  };\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n        }\n\n    //// Invariant proofs\n\n    #[inductive(produce_start)]\n    fn produce_start_inductive(pre: Self, post: Self) {\n        let tail = pre.producer.get_Idle_0();\n\n        match (post.producer, post.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n\n            }\n        }\n\n    }\n\n    #[inductive(produce_end)]\n    fn produce_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        else {\n\n            }*/\n        }\n    }\n\n    #[inductive(consume_start)]\n    fn consume_start_inductive(pre: Self, post: Self) {\n        }\n\n    #[inductive(consume_end)]\n    fn consume_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        let head = pre.consumer.get_Consuming_0();\n\n        match (pre.producer, pre.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n\n            }\n        };\n\n        }\n}}\n\n// ANCHOR: impl_queue_struct\nstruct_with_invariants!{\n    struct Queue<T> {\n        buffer: Vec<PCell<T>>,\n        head: AtomicU64<_, FifoQueue::head<T>, _>,\n        tail: AtomicU64<_, FifoQueue::tail<T>, _>,\n\n        instance: Tracked<FifoQueue::Instance<T>>,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            // The Cell IDs in the instance protocol match the cell IDs in the actual vector:\n            &&& self.instance@.backing_cells().len() == self.buffer@.len()\n            &&& forall|i: int| 0 <= i && i < self.buffer@.len() as int ==>\n                self.instance@.backing_cells().index(i) ===\n                    self.buffer@.index(i).id()\n        }\n\n         {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n\n         {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: impl_queue_struct\n\n// ANCHOR: impl_producer_struct\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n    producer: Tracked<FifoQueue::producer<T>>,\n}\n\nimpl<T> Producer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.producer@.instance_id() == (*self.queue).instance@.id()\n            && self.producer@.value() == ProducerState::Idle(self.tail as nat)\n            && (self.tail as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_producer_struct\n\n// ANCHOR: impl_consumer_struct\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n    consumer: Tracked<FifoQueue::consumer<T>>,\n}\n\nimpl<T> Consumer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.consumer@.instance_id() === (*self.queue).instance@.id()\n            && self.consumer@.value() === ConsumerState::Idle(self.head as nat)\n            && (self.head as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_consumer_struct\n\n// ANCHOR: impl_new_queue\npub fn new_queue<T>(len: usize) -> (pc: (Producer<T>, Consumer<T>))\n\n{\n    // Initialize the vector to store the cells\n    let mut backing_cells_vec = Vec::<PCell<T>>::new();\n    // Initialize map for the permissions to the cells\n    // (keyed by the indices into the vector)\n    let tracked mut perms = Map::<nat, cell::PointsTo<T>>::tracked_empty();\n    while backing_cells_vec.len() < len\n\n    {\n        let ghost i = backing_cells_vec.len();\n        let (cell, cell_perm) = PCell::empty();\n        backing_cells_vec.push(cell);\n\n    }\n    // Vector for ids\n\n    let ghost mut backing_cells_ids = Seq::<CellId>::new(\n        backing_cells_vec@.len(),\n        |i: int| backing_cells_vec@.index(i).id(),\n    );\n    // Initialize an instance of the FIFO queue\n    let tracked (\n        Tracked(instance),\n        Tracked(head_token),\n        Tracked(tail_token),\n        Tracked(producer_token),\n        Tracked(consumer_token),\n    ) = FifoQueue::Instance::initialize(backing_cells_ids, perms, perms);\n    // Initialize atomics\n    let tracked_inst: Tracked<FifoQueue::Instance<T>> = Tracked(instance.clone());\n    let head_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(head_token));\n    let tail_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(tail_token));\n    // Initialize the queue\n    let queue = Queue::<T> {\n        instance: Tracked(instance),\n        head: head_atomic,\n        tail: tail_atomic,\n        buffer: backing_cells_vec,\n    };\n    // Share the queue between the producer and consumer\n    let queue_arc = Arc::new(queue);\n    let prod = Producer::<T> {\n        queue: queue_arc.clone(),\n        tail: 0,\n        producer: Tracked(producer_token),\n    };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0, consumer: Tracked(consumer_token) };\n    (prod, cons)\n}\n// ANCHOR_END: impl_new_queue\n\n// ANCHOR: impl_producer\nimpl<T> Producer<T> {\n    fn enqueue(&mut self, t: T)\n\n    {\n        // Loop: if the queue is full, then block until it is not.\n        loop\n\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len {\n                0\n            } else {\n                self.tail + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            // Get the current `head` value from the shared atomic.\n            let head =\n                atomic_with_ghost!(&queue.head => load();\n                returning head;\n                ghost head_token => {\n                    // If `head != next_tail`, then we proceed with the operation.\n                    // We check here, ghostily, in the `open_atomic_invariant` block if that's the case.\n                    // If so, we proceed with the `produce_start` transition\n                    // and obtain the cell permission.\n                    cell_perm = if head != next_tail as u64 {\n                        let tracked cp = queue.instance.borrow().produce_start(&head_token, self.producer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            // Here's where we \"actually\" do the `head != next_tail` check:\n            if head != next_tail as u64 {\n                // Unwrap the cell_perm from the option.\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n\n                        proof_from_false()\n                    },\n                };\n                // Write the element t into the buffer, updating the cell\n                // from uninitialized to initialized (to the value t).\n                queue.buffer[self.tail].put(Tracked(&mut cell_perm), t);\n                // Store the updated tail to the shared `tail` atomic,\n                // while performing the `produce_end` transition.\n                atomic_with_ghost!(&queue.tail => store(next_tail as u64); ghost tail_token => {\n                    queue.instance.borrow().produce_end(cell_perm,\n                        cell_perm, &mut tail_token, self.producer.borrow_mut());\n                });\n                self.tail = next_tail;\n                return ;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl_producer\n\n// ANCHOR: impl_consumer\nimpl<T> Consumer<T> {\n    fn dequeue(&mut self) -> (t: T)\n\n    {\n        loop\n\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n\n            let next_head = if self.head + 1 == len {\n                0\n            } else {\n                self.head + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            let tail =\n                atomic_with_ghost!(&queue.tail => load();\n                returning tail;\n                ghost tail_token => {\n                    cell_perm = if self.head as u64 != tail {\n                        let tracked (_, Tracked(cp)) = queue.instance.borrow().consume_start(&tail_token, self.consumer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            if self.head as u64 != tail {\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n\n                        proof_from_false()\n                    },\n                };\n                let t = queue.buffer[self.head].take(Tracked(&mut cell_perm));\n                atomic_with_ghost!(&queue.head => store(next_head as u64); ghost head_token => {\n                    queue.instance.borrow().consume_end(cell_perm,\n                        cell_perm, &mut head_token, self.consumer.borrow_mut());\n                });\n                self.head = next_head;\n                return t;\n            }\n        }\n    }\n}\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n\n    // Simple test:\n\n    producer.enqueue(5);\n    producer.enqueue(6);\n    producer.enqueue(7);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    // Multi-threaded test:\n\n    let producer = producer;\n    let _join_handle = vstd::thread::spawn(\n        move ||\n            {\n                let mut producer = producer;\n                let mut i = 0;\n                while i < 100\n\n                {\n                    producer.enqueue(i);\n                    i = i + 1;\n                }\n            },\n    );\n    let mut i = 0;\n    while i < 100\n\n    {\n        let x = consumer.dequeue();\n        print_u64(x);\n        i = i + 1;\n    }\n}\n\n} // verus!\n// ANCHOR_END: impl_consumer\n// ANCHOR_END: full\n", "target_text": "requires len > 0, old(self).wf(), old(self).wf()\nensures pc.0.wf(),\n        pc.1.wf(), self.wf(), self.wf()\ninvariant on head with (instance) is (v: u64, g: FifoQueue::head<T>), on tail with (instance) is (v: u64, g: FifoQueue::tail<T>), forall|j: nat|\n                #![trigger( perms.dom().contains(j) )]\n                #![trigger( backing_cells_vec@.index(j as int) )]\n                #![trigger( perms.index(j) )]\n                0 <= j && j < backing_cells_vec.len() as int ==> perms.dom().contains(j)\n                    && backing_cells_vec@.index(j as int).id() === perms.index(j).id()\n                    && perms.index(j).is_uninit(), self.wf(), self.wf(), producer.wf(), consumer.wf()", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// port of single-producer single-consumer queue from LinearDafny\n// https://github.com/vmware-labs/verified-betrfs/tree/concurrency-experiments/concurrency/spsc-queue\n\n// ANCHOR:full\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// ANCHOR: enum_state\n#[is_variant]\npub enum ProducerState {\n    Idle(nat),  // local copy of tail\n    Producing(nat),\n}\n\n#[is_variant]\npub enum ConsumerState {\n    Idle(nat),  // local copy of head\n    Consuming(nat),\n}\n// ANCHOR_END: enum_state\n\n// ANCHOR: fields\ntokenized_state_machine!{FifoQueue<T> {\n    fields {\n        // IDs of the cells used in the ring buffer.\n        // These are fixed throughout the protocol.\n\n        #[sharding(constant)]\n        pub backing_cells: Seq<CellId>,\n\n        // All the stored permissions\n\n        #[sharding(storage_map)]\n        pub storage: Map<nat, cell::PointsTo<T>>,\n\n        // Represents the shared `head` field\n\n        #[sharding(variable)]\n        pub head: nat,\n\n        // Represents the shared `tail` field\n\n        #[sharding(variable)]\n        pub tail: nat,\n\n        // Represents the local state of the single-producer\n\n        #[sharding(variable)]\n        pub producer: ProducerState,\n\n        // Represents the local state of the single-consumer\n\n        #[sharding(variable)]\n        pub consumer: ConsumerState,\n    }\n    // ANCHOR_END: fields\n\n    pub open spec fn len(&self) -> nat {\n        self.backing_cells.len()\n    }\n\n    // ANCHOR: inc_wrap\n    pub open spec fn inc_wrap(i: nat, len: nat) -> nat {\n        if i + 1 == len { 0 } else { i + 1 }\n    }\n    // ANCHOR_END: inc_wrap\n\n    // Make sure the producer state and the consumer state aren't inconsistent.\n\n    #[invariant]\n    pub fn not_overlapping(&self) -> bool {\n        match (self.producer, self.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n                && Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                true\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n            }\n        }\n    }\n\n    // `head` and `tail` are in-bounds\n    // shared `head` and `tail` fields agree with the ProducerState and ConsumerState\n\n    #[invariant]\n    pub fn in_bounds(&self) -> bool {\n        0 <= self.head && self.head < self.len() &&\n        0 <= self.tail && self.tail < self.len()\n        && match self.producer {\n            ProducerState::Producing(tail) => {\n                self.tail == tail\n            }\n            ProducerState::Idle(tail) => {\n                self.tail == tail\n            }\n        }\n        && match self.consumer {\n            ConsumerState::Consuming(head) => {\n                self.head == head\n            }\n            ConsumerState::Idle(head) => {\n                self.head == head\n            }\n        }\n    }\n\n    // Indicates whether we expect the cell at index `i` to be full based on\n    // the values of the `head` and `tail`.\n\n    pub open spec fn in_active_range(&self, i: nat) -> bool {\n        // Note that self.head = self.tail means empty range\n        0 <= i && i < self.len() && (\n            if self.head <= self.tail {\n                self.head <= i && i < self.tail\n            } else {\n                i >= self.head || i < self.tail\n            }\n        )\n    }\n\n    // Indicates whether we expect a cell to be checked out or not,\n    // based on the producer/consumer state.\n\n    pub open spec fn is_checked_out(&self, i: nat) -> bool {\n        self.producer === ProducerState::Producing(i)\n        || self.consumer === ConsumerState::Consuming(i)\n    }\n\n    // Predicate to determine that the state at cell index `i`\n    // is correct. For each index, there are three possibilities:\n    //\n    //  1. No cell permission is stored\n    //  2. Permission is stored; permission indicates a full cell\n    //  3. Permission is stored; permission indicates an empty cell\n    //\n    // Which of these 3 possibilities we should be in depends on the\n    // producer/consumer/head/tail state.\n\n    pub open spec fn valid_storage_at_idx(&self, i: nat) -> bool {\n        if self.is_checked_out(i) {\n            // No cell permission is stored\n            !self.storage.dom().contains(i)\n        } else {\n            // Permission is stored\n            self.storage.dom().contains(i)\n\n            // Permission must be for the correct cell:\n            && self.storage.index(i).id() === self.backing_cells.index(i as int)\n\n            && if self.in_active_range(i) {\n                // The cell is full\n                self.storage.index(i).is_init()\n            } else {\n                // The cell is empty\n                self.storage.index(i).is_uninit()\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn valid_storage_all(&self) -> bool {\n        forall|i: nat| 0 <= i && i < self.len() ==>\n            self.valid_storage_at_idx(i)\n    }\n\n    init!{\n        initialize(backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n            // Upon initialization, the user needs to deposit _all_ the relevant\n            // cell permissions to start with. Each permission should indicate\n            // an empty cell.\n\n            require(\n                (forall|i: nat| 0 <= i && i < backing_cells.len() ==>\n                    #[trigger] storage.dom().contains(i)\n                    && storage.index(i).id() === backing_cells.index(i as int)\n                    && storage.index(i).is_uninit())\n            );\n            require(backing_cells.len() > 0);\n\n            init backing_cells = backing_cells;\n            init storage = storage;\n            init head = 0;\n            init tail = 0;\n            init producer = ProducerState::Idle(0);\n            init consumer = ConsumerState::Idle(0);\n        }\n    }\n\n    // ANCHOR: transition_produce_start\n    transition!{\n        produce_start() {\n            // In order to begin, we have to be in ProducerState::Idle.\n            require(pre.producer.is_Idle());\n\n            // We'll be comparing the producer's _local_ copy of the tail\n            // with the _shared_ version of the head.\n            let tail = pre.producer.get_Idle_0();\n            let head = pre.head;\n\n            assert(0 <= tail && tail < pre.backing_cells.len());\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // We have to check that the buffer isn't full to proceed.\n            require(next_tail != head);\n\n            // Update the producer's local state to be in the `Producing` state.\n            update producer = ProducerState::Producing(tail);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n            // This creates a proof obligation for the transition system to prove that\n            // there is actually a permission stored at this index.\n            withdraw storage -= [tail => let perm] by {\n                assert(pre.valid_storage_at_idx(tail));\n            };\n\n            // The transition needs to guarantee to the client that the\n            // permission they are checking out:\n            //  (i) is for the cell at index `tail` (the IDs match)\n            //  (ii) the permission indicates that the cell is empty\n            assert(\n                perm.id() === pre.backing_cells.index(tail as int)\n                && perm.is_uninit()\n            ) by {\n                assert(!pre.in_active_range(tail));\n                assert(pre.valid_storage_at_idx(tail));\n            };\n        }\n    }\n    // ANCHOR_END: transition_produce_start\n\n    // ANCHOR: transition_produce_end\n    transition!{\n        // This transition is parameterized by the value of the permission\n        // being inserted. Since the permission is being deposited\n        // (coming from \"outside\" the system) we can't compute it as a\n        // function of the current state, unlike how we did it for the\n        // `produce_start` transition).\n        produce_end(perm: cell::PointsTo<T>) {\n            // In order to complete the produce step,\n            // we have to be in ProducerState::Producing.\n            require(pre.producer.is_Producing());\n            let tail = pre.producer.get_Producing_0();\n\n            assert(0 <= tail && tail < pre.backing_cells.len());\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // This time, we don't need to compare the `head` and `tail` - we already\n            // check that, and anyway, we don't have access to the `head` field\n            // for this transition. (This transition is supposed to occur while\n            // modifying the `tail` field, so we can't do both.)\n\n            // However, we _do_ need to check that the permission token being\n            // checked in satisfies its requirements. It has to be associated\n            // with the correct cell, and it has to be full.\n\n            require(perm.id() === pre.backing_cells.index(tail as int)\n              && perm.is_init());\n\n            // Perform our updates. Update the tail to the computed value,\n            // both the shared version and the producer's local copy.\n            // Also, move back to the Idle state.\n            update producer = ProducerState::Idle(next_tail);\n            update tail = next_tail;\n\n            // Check the permission back into the storage map.\n            deposit storage += [tail => perm] by { assert(pre.valid_storage_at_idx(tail)); };\n        }\n    }\n    // ANCHOR_END: transition_produce_end\n\n    transition!{\n        consume_start() {\n            // In order to begin, we have to be in ConsumerState::Idle.\n            require(pre.consumer.is_Idle());\n\n            // We'll be comparing the consumer's _local_ copy of the head\n            // with the _shared_ version of the tail.\n            let head = pre.consumer.get_Idle_0();\n            let tail = pre.tail;\n\n            assert(0 <= head && head < pre.backing_cells.len());\n\n            // We have to check that the buffer isn't empty to proceed.\n            require(head != tail);\n\n            // Update the consumer's local state to be in the `Consuming` state.\n            update consumer = ConsumerState::Consuming(head);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n\n            birds_eye let perm = pre.storage.index(head);\n            withdraw storage -= [head => perm] by {\n                assert(pre.valid_storage_at_idx(head));\n            };\n\n            assert(perm.id() === pre.backing_cells.index(head as int)) by {\n                assert(pre.valid_storage_at_idx(head));\n            };\n            assert(perm.is_init()) by {\n                assert(pre.in_active_range(head));\n                assert(pre.valid_storage_at_idx(head));\n            };\n        }\n    }\n\n    transition!{\n        consume_end(perm: cell::PointsTo<T>) {\n            require(pre.consumer.is_Consuming());\n            let head = pre.consumer.get_Consuming_0();\n\n            assert(0 <= head && head < pre.backing_cells.len());\n            let next_head = Self::inc_wrap(head, pre.backing_cells.len());\n\n            update consumer = ConsumerState::Idle(next_head);\n            update head = next_head;\n\n            require(perm.id() === pre.backing_cells.index(head as int)\n              && perm.is_uninit());\n            deposit storage += [head => perm] by { assert(pre.valid_storage_at_idx(head)); };\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n        assert forall|i: nat|\n            0 <= i && i < post.len() implies post.valid_storage_at_idx(i)\n        by {\n            assert(post.storage.dom().contains(i));\n            /*\n            assert(\n                post.storage.index(i).id() ===\n                post.backing_cells.index(i)\n            );\n            assert(if post.in_active_range(i) {\n                post.storage.index(i).value.is_Some()\n            } else {\n                post.storage.index(i).value.is_None()\n            });*/\n        }\n    }\n\n    //// Invariant proofs\n\n    #[inductive(produce_start)]\n    fn produce_start_inductive(pre: Self, post: Self) {\n        let tail = pre.producer.get_Idle_0();\n        assert(!pre.in_active_range(tail));\n        match (post.producer, post.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                assert(Self::inc_wrap(tail, post.len()) != head);\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                assert(head != tail);\n                assert(Self::inc_wrap(tail, post.len()) != head);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                assert(head != tail);\n            }\n        }\n        assert(forall|i| pre.valid_storage_at_idx(i) ==> post.valid_storage_at_idx(i));\n    }\n\n    #[inductive(produce_end)]\n    fn produce_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies\n            post.valid_storage_at_idx(i)\n        by {\n            /*if post.is_checked_out(i) {\n                assert(!post.storage.dom().contains(i));\n            } else {\n                assert(post.storage.dom().contains(i));\n                assert(\n                    post.storage.index(i).id() ===\n                    post.backing_cells.index(i)\n                );\n                assert(if post.in_active_range(i) {\n                    post.storage.index(i).value.is_Some()\n                } else {\n                    post.storage.index(i).value.is_None()\n                });\n            }*/\n        }\n    }\n\n    #[inductive(consume_start)]\n    fn consume_start_inductive(pre: Self, post: Self) {\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies post.valid_storage_at_idx(i)\n        by { }\n    }\n\n    #[inductive(consume_end)]\n    fn consume_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        let head = pre.consumer.get_Consuming_0();\n        assert(post.storage.dom().contains(head));\n        assert(\n                post.storage.index(head).id() ===\n                post.backing_cells.index(head as int)\n            );\n        assert(if post.in_active_range(head) {\n                post.storage.index(head).is_init()\n            } else {\n                post.storage.index(head).is_uninit()\n            });\n\n        match (pre.producer, pre.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                assert(pre.head != pre.tail);\n            }\n        };\n\n        assert(pre.head != pre.tail);\n        assert(!post.is_checked_out(head));\n        assert(post.valid_storage_at_idx(head));\n\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies post.valid_storage_at_idx(i)\n        by { }\n    }\n}}\n\n// ANCHOR: impl_queue_struct\nstruct_with_invariants!{\n    struct Queue<T> {\n        buffer: Vec<PCell<T>>,\n        head: AtomicU64<_, FifoQueue::head<T>, _>,\n        tail: AtomicU64<_, FifoQueue::tail<T>, _>,\n\n        instance: Tracked<FifoQueue::Instance<T>>,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            // The Cell IDs in the instance protocol match the cell IDs in the actual vector:\n            &&& self.instance@.backing_cells().len() == self.buffer@.len()\n            &&& forall|i: int| 0 <= i && i < self.buffer@.len() as int ==>\n                self.instance@.backing_cells().index(i) ===\n                    self.buffer@.index(i).id()\n        }\n\n        invariant on head with (instance) is (v: u64, g: FifoQueue::head<T>) {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n\n        invariant on tail with (instance) is (v: u64, g: FifoQueue::tail<T>) {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: impl_queue_struct\n\n// ANCHOR: impl_producer_struct\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n    producer: Tracked<FifoQueue::producer<T>>,\n}\n\nimpl<T> Producer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.producer@.instance_id() == (*self.queue).instance@.id()\n            && self.producer@.value() == ProducerState::Idle(self.tail as nat)\n            && (self.tail as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_producer_struct\n\n// ANCHOR: impl_consumer_struct\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n    consumer: Tracked<FifoQueue::consumer<T>>,\n}\n\nimpl<T> Consumer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.consumer@.instance_id() === (*self.queue).instance@.id()\n            && self.consumer@.value() === ConsumerState::Idle(self.head as nat)\n            && (self.head as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_consumer_struct\n\n// ANCHOR: impl_new_queue\npub fn new_queue<T>(len: usize) -> (pc: (Producer<T>, Consumer<T>))\n    requires\n        len > 0,\n    ensures\n        pc.0.wf(),\n        pc.1.wf(),\n{\n    // Initialize the vector to store the cells\n    let mut backing_cells_vec = Vec::<PCell<T>>::new();\n    // Initialize map for the permissions to the cells\n    // (keyed by the indices into the vector)\n    let tracked mut perms = Map::<nat, cell::PointsTo<T>>::tracked_empty();\n    while backing_cells_vec.len() < len\n        invariant\n            forall|j: nat|\n                #![trigger( perms.dom().contains(j) )]\n                #![trigger( backing_cells_vec@.index(j as int) )]\n                #![trigger( perms.index(j) )]\n                0 <= j && j < backing_cells_vec.len() as int ==> perms.dom().contains(j)\n                    && backing_cells_vec@.index(j as int).id() === perms.index(j).id()\n                    && perms.index(j).is_uninit(),\n    {\n        let ghost i = backing_cells_vec.len();\n        let (cell, cell_perm) = PCell::empty();\n        backing_cells_vec.push(cell);\n        proof {\n            perms.tracked_insert(i as nat, cell_perm.get());\n        }\n        assert(perms.dom().contains(i as nat));\n        assert(backing_cells_vec@.index(i as int).id() === perms.index(i as nat).id());\n        assert(perms.index(i as nat).is_uninit());\n    }\n    // Vector for ids\n\n    let ghost mut backing_cells_ids = Seq::<CellId>::new(\n        backing_cells_vec@.len(),\n        |i: int| backing_cells_vec@.index(i).id(),\n    );\n    // Initialize an instance of the FIFO queue\n    let tracked (\n        Tracked(instance),\n        Tracked(head_token),\n        Tracked(tail_token),\n        Tracked(producer_token),\n        Tracked(consumer_token),\n    ) = FifoQueue::Instance::initialize(backing_cells_ids, perms, perms);\n    // Initialize atomics\n    let tracked_inst: Tracked<FifoQueue::Instance<T>> = Tracked(instance.clone());\n    let head_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(head_token));\n    let tail_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(tail_token));\n    // Initialize the queue\n    let queue = Queue::<T> {\n        instance: Tracked(instance),\n        head: head_atomic,\n        tail: tail_atomic,\n        buffer: backing_cells_vec,\n    };\n    // Share the queue between the producer and consumer\n    let queue_arc = Arc::new(queue);\n    let prod = Producer::<T> {\n        queue: queue_arc.clone(),\n        tail: 0,\n        producer: Tracked(producer_token),\n    };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0, consumer: Tracked(consumer_token) };\n    (prod, cons)\n}\n// ANCHOR_END: impl_new_queue\n\n// ANCHOR: impl_producer\nimpl<T> Producer<T> {\n    fn enqueue(&mut self, t: T)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n    {\n        // Loop: if the queue is full, then block until it is not.\n        loop\n            invariant\n                self.wf(),\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n            assert(0 <= self.tail && self.tail < len);\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len {\n                0\n            } else {\n                self.tail + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            // Get the current `head` value from the shared atomic.\n            let head =\n                atomic_with_ghost!(&queue.head => load();\n                returning head;\n                ghost head_token => {\n                    // If `head != next_tail`, then we proceed with the operation.\n                    // We check here, ghostily, in the `open_atomic_invariant` block if that's the case.\n                    // If so, we proceed with the `produce_start` transition\n                    // and obtain the cell permission.\n                    cell_perm = if head != next_tail as u64 {\n                        let tracked cp = queue.instance.borrow().produce_start(&head_token, self.producer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            // Here's where we \"actually\" do the `head != next_tail` check:\n            if head != next_tail as u64 {\n                // Unwrap the cell_perm from the option.\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n                        assert(false);\n                        proof_from_false()\n                    },\n                };\n                // Write the element t into the buffer, updating the cell\n                // from uninitialized to initialized (to the value t).\n                queue.buffer[self.tail].put(Tracked(&mut cell_perm), t);\n                // Store the updated tail to the shared `tail` atomic,\n                // while performing the `produce_end` transition.\n                atomic_with_ghost!(&queue.tail => store(next_tail as u64); ghost tail_token => {\n                    queue.instance.borrow().produce_end(cell_perm,\n                        cell_perm, &mut tail_token, self.producer.borrow_mut());\n                });\n                self.tail = next_tail;\n                return ;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl_producer\n\n// ANCHOR: impl_consumer\nimpl<T> Consumer<T> {\n    fn dequeue(&mut self) -> (t: T)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n            assert(0 <= self.head && self.head < len);\n            let next_head = if self.head + 1 == len {\n                0\n            } else {\n                self.head + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            let tail =\n                atomic_with_ghost!(&queue.tail => load();\n                returning tail;\n                ghost tail_token => {\n                    cell_perm = if self.head as u64 != tail {\n                        let tracked (_, Tracked(cp)) = queue.instance.borrow().consume_start(&tail_token, self.consumer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            if self.head as u64 != tail {\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n                        assert(false);\n                        proof_from_false()\n                    },\n                };\n                let t = queue.buffer[self.head].take(Tracked(&mut cell_perm));\n                atomic_with_ghost!(&queue.head => store(next_head as u64); ghost head_token => {\n                    queue.instance.borrow().consume_end(cell_perm,\n                        cell_perm, &mut head_token, self.consumer.borrow_mut());\n                });\n                self.head = next_head;\n                return t;\n            }\n        }\n    }\n}\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n\n    // Simple test:\n\n    producer.enqueue(5);\n    producer.enqueue(6);\n    producer.enqueue(7);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    // Multi-threaded test:\n\n    let producer = producer;\n    let _join_handle = vstd::thread::spawn(\n        move ||\n            {\n                let mut producer = producer;\n                let mut i = 0;\n                while i < 100\n                    invariant\n                        producer.wf(),\n                {\n                    producer.enqueue(i);\n                    i = i + 1;\n                }\n            },\n    );\n    let mut i = 0;\n    while i < 100\n        invariant\n            consumer.wf(),\n    {\n        let x = consumer.dequeue();\n        print_u64(x);\n        i = i + 1;\n    }\n}\n\n} // verus!\n// ANCHOR_END: impl_consumer\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/fifo.rs", "verified": true, "metadata": {"original_id": "verus_fifo_7d613aff30a4", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7c9959dba619", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] , decreases arr . len () - idx , { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7c9959dba619", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_45948c0dcced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "45948c0dcced", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6ec50bf7bdb9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6ec50bf7bdb9", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3ab42e75f852", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list @ . len () - i , n - j \ninvariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "3ab42e75f852", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_269518014d5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n \ndecreases fuel ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_28/verina_basic_28.rs", "verified": true, "metadata": {"original_id": "269518014d5f", "function_name": "is_prime_check", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f2a35c61be7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires first_duplicate_precond (lst @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_12/verina_advanced_12_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f2a35c61be7a", "function_name": "first_duplicate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5086ae4db97e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "5086ae4db97e", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_54cdc60873f4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "target_text": "requires start <= chars . len ()\nensures result @ == digit_to_letters (c)\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "54cdc60873f4", "function_name": "go", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ef181f52950f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires isSublist_precond (sub @ , main @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_21/verina_basic_21.rs", "verified": true, "metadata": {"original_id": "ef181f52950f", "function_name": "isSublist", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0255fb7432b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "ensures result == odd (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0255fb7432b6", "function_name": "odd_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c1dd8816a528", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c1dd8816a528", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_51e5c6e21309", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith)   { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n  { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires p > 0 , p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) , r == modp_rec (n as nat , p as nat) \ndecreases n , n - i \ninvariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "51e5c6e21309", "function_name": "modp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1639d516bb20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool)  { if n <= 1 {  return false ; } let mut i = 2u64 ; while i < n  { if n % i == 0 {    return false ; } i = i + 1 ; }     return true ; }\n\n} // verus!", "target_text": "ensures result == prime (n as nat)\ndecreases n - i\ninvariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyPrograms_tmp_tmp74_f9k_c_prime-database/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1639d516bb20", "function_name": "test_primeness", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8f3fd5a0a3d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "8f3fd5a0a3d4", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_vostd_function_properties_ac5ffca188ef", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n    // Prove that g is injective on codomain\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n\n    {\n    if s.is_empty() {\n\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n\n{\n}\n\n} // verus!\n", "target_text": "requires injective_on(f, domain), bijective_on(f, domain, codomain), injective(f), inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain), injective_on(f, dom),\n        s.finite(),\n        s <= dom, bijective_on(f, domain, codomain),\n        domain.finite(), bijective_on(f, domain, codomain),\n        s <= domain\nensures left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)), inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain), injective_on(f, dom), bijective_on(f, domain, codomain), bijective_on(g, codomain, domain), bijective_on(g, codomain, domain), bijective_on(g, codomain, domain), s.len() == s.map(f).len(),\n        s.map(f).finite(), codomain.finite(),\n        domain.len() == codomain.len(), bijective_on(f, s, s.map(f)), s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len()\ndecreases s.len()", "full_verified_code": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/function_properties.rs", "verified": true, "metadata": {"original_id": "vostd_function_properties_ac5ffca188ef", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_16a922d07ab2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "16a922d07ab2", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_fa3fc34cebcd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa3fc34cebcd", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_11e4c10a27d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "11e4c10a27d3", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_72be5eeacf95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z' { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "72be5eeacf95", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1cb00516fc41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "1cb00516fc41", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_60174e37a666", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "60174e37a666", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f9304443414a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f9304443414a", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cea8626b15a4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >)  { let len = v . len () ; let mut i = 0 ; while i < len / 2  { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] \ndecreases len / 2 - i \ninvariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/reverse_impl.rs", "verified": true, "metadata": {"original_id": "cea8626b15a4", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f038eb73e65a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool)  { let mut result = true ; for i in 0 .. v . len ()  { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "target_text": "ensures b == positive (v @)\ninvariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f038eb73e65a", "function_name": "mpositive4", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cee4533fa4fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cee4533fa4fe", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bd72405ce164", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = N ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum [0] = N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "bd72405ce164", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_74438889dde4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32)   { let mut i = 0 ; while i < a . len ()  { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] <= N \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i , { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/condn_impl.rs", "verified": true, "metadata": {"original_id": "74438889dde4", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e472af234805", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "e472af234805", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d059178c6f16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len ()  { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - idx \ninvariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "d059178c6f16", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cb347e9a3400", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cb347e9a3400", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_69bc9f5f3eee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { for idx in 1 .. arr . len ()  { if arr [idx - 1] > arr [idx] { return false ; } } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ninvariant forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { for idx in 1 .. arr . len () invariant forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , { if arr [idx - 1] > arr [idx] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "69bc9f5f3eee", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cd60df574312", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "cd60df574312", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7966dba4ed0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires bound <= 100 , r <= 10 , n <= 100 \ndecreases bound", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32) requires bound <= 100 , r <= 10 , n <= 100 , decreases bound { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_65/verina_basic_65_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7966dba4ed0c", "function_name": "bounded_loop", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f56724e263b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "f56724e263b0", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c598d24e772a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ndecreases a . len () - i\ninvariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_only_one_distinct_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c598d24e772a", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_52e2f9691e2a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "52e2f9691e2a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2f49a95aeca4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f49a95aeca4", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_dfd8fc138793", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "requires old (a) . len () > 0 \nensures result == odd (n as int), a @ . len () == old (a) @ . len () \ndecreases right - left\ninvariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "dfd8fc138793", "function_name": "partition_odd_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fbc23ba4a7da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/023-strlen_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fbc23ba4a7da", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_08fa248ef5f5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | 0 <= i < a . len () && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "08fa248ef5f5", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2f121e2a452e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "2f121e2a452e", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d5076568e671", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {   let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "d5076568e671", "function_name": "element_wise_division", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7b5f7e94f536", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7b5f7e94f536", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
