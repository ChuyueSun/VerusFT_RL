{"id": "task_a_verus_requires_ensures_edit_115a081c222b", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n", "target_text": "requires -64 <= x1,\n        x1 < 64, -16 <= x1,\n        x1 < 16, -16 <= x1,\n        x1 < 16\nensures x8 == 8 * x1", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n/*\n// ANCHOR: init\nfn octuple(x1: i8) -> i8 {\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: init\n\nfn main() {\n}\n\n// ANCHOR: pre1\nfn octuple(x1: i8) -> i8\n    requires\n        -64 <= x1,\n        x1 < 64,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre1\n\nfn main() {\n}\n\n// ANCHOR: pre2\nfn octuple(x1: i8) -> i8\n    requires\n        -16 <= x1,\n        x1 < 16,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: pre2\n\nfn main() {\n}\n\n// ANCHOR: pre3\nfn main() {\n    let n = octuple(20);\n}\n// ANCHOR_END: pre3\n\n// ANCHOR: pre4\nfn main() {\n    let n = octuple(10);\n}\n// ANCHOR_END: pre4\n*/\n\n// ANCHOR: post1\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n}\n// ANCHOR_END: post1\n\n// ANCHOR: post2\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1,\n        x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n// ANCHOR_END: post2\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/requires_ensures_edit.rs", "verified": true, "metadata": {"original_id": "verus_requires_ensures_edit_115a081c222b", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c8ff6c1d68b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_95/verina_basic_95_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c8ff6c1d68b7", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_211b69bf344d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/053-add.rs", "verified": true, "metadata": {"original_id": "211b69bf344d", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ccc4e7907856", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ccc4e7907856", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_295fb6b7020c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize)   { let mut i = c ; while i < f  { let mut min_idx = i ; let mut j = i + 1 ; while j < f  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires c <= f , f <= old (a) . len () \nensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) \ndecreases f - i, f - j\ninvariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "295fb6b7020c", "function_name": "sel_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c665d8bd494e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c665d8bd494e", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_56e6b68b28eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "56e6b68b28eb", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9f02ff96afb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9f02ff96afb8", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_bitvector_garbage_collection_ea9da15b3907", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nenum Color {\n    White,  // 11\n    Gray,  // 10\n    Black,  // 01\n    Undefined,  // 00\n}\n\nspec fn color_view(high: bool, low: bool) -> Color {\n    if high {\n        if low {\n            Color::White\n        } else {\n            Color::Gray\n        }\n    } else {\n        if low {\n            Color::Black\n        } else {\n            Color::Undefined\n        }\n    }\n}\n\nspec fn bucket_view(bucket: u32) -> Seq<Color> {\n    Seq::new(\n        16,\n        |i: int|\n            color_view(\n                get_bit!(bucket, add(mul(i as u32, 2), 1)),\n                get_bit!(bucket, mul(i as u32, 2)),\n            ),\n    )\n}\n\n#[verifier::bit_vector]\nproof fn set_two_bit_proof(\n    bv: u32,\n    target: u32,\n    mask: u32,\n    result: u32,\n    low_loc: u32,\n    high: bool,\n    low: bool,\n)\n     {\n            if low {\n                3u32\n            } else {\n                2u32\n            }\n        } else {\n            if low {\n                1u32\n            } else {\n                0u32\n            }\n        }) << low_loc,\n        mask == !(3u32 << low_loc),\n        result == (bv & mask) | target,\n\n{\n}\n\nfn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)\n\n{\n    let target: u32 = (if high {\n        if low {\n            3u32\n        } else {\n            2u32\n        }\n    } else {\n        if low {\n            1u32\n        } else {\n            0u32\n        }\n    }) << low_loc;\n    let mask: u32 = !(3u32 << low_loc);\n    let result: u32 = (bv & mask) | target;\n\n    result\n}\n\nfn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:\n    u32)\n\n{\n    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);\n\n    new_bucket\n}\n\n#[verifier::bit_vector]\nproof fn get_color_proof(bv: u32, index: u32, v: u32)\n\n{\n}\n\nfn get_color(bv: u32, index: u32) -> (c: Color)\n\n{\n    let v: u32 = 3u32 & (bv >> index * 2);\n\n    let c = if v == 0 {\n        Color::Undefined\n    } else if v == 1 {\n        Color::Black\n    } else if v == 2 {\n        Color::Gray\n    } else {\n        Color::White\n    };\n    c\n}\n\n} // verus!\n", "target_text": "requires low_loc < 31,\n        target == (if high, low_loc < 31, i < 16,\n        bucket_view(bucket) =~= ghost_bucket, v == 3u32 & (bv >> mul(index, 2)), index < 15\nensures get_bit!(result, low_loc) == low,\n        get_bit!(result, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)\n                == get_bit!(bv, loc2), get_bit!(ret, low_loc) == low,\n        get_bit!(ret, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)\n                == get_bit!(bv, loc2), bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)), v < 4u32,\n        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)), c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index)))", "full_verified_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\n#[allow(unused_macros)]\nmacro_rules! get_bit_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u32 & ($a >> $b)) == 1\n    }};\n}\n\n#[allow(unused_macros)]\nmacro_rules! get_bit {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit_macro!($($a)*))\n    }\n}\nfn main() {}\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nenum Color {\n    White,  // 11\n    Gray,  // 10\n    Black,  // 01\n    Undefined,  // 00\n}\n\nspec fn color_view(high: bool, low: bool) -> Color {\n    if high {\n        if low {\n            Color::White\n        } else {\n            Color::Gray\n        }\n    } else {\n        if low {\n            Color::Black\n        } else {\n            Color::Undefined\n        }\n    }\n}\n\nspec fn bucket_view(bucket: u32) -> Seq<Color> {\n    Seq::new(\n        16,\n        |i: int|\n            color_view(\n                get_bit!(bucket, add(mul(i as u32, 2), 1)),\n                get_bit!(bucket, mul(i as u32, 2)),\n            ),\n    )\n}\n\n#[verifier::bit_vector]\nproof fn set_two_bit_proof(\n    bv: u32,\n    target: u32,\n    mask: u32,\n    result: u32,\n    low_loc: u32,\n    high: bool,\n    low: bool,\n)\n    requires\n        low_loc < 31,\n        target == (if high {\n            if low {\n                3u32\n            } else {\n                2u32\n            }\n        } else {\n            if low {\n                1u32\n            } else {\n                0u32\n            }\n        }) << low_loc,\n        mask == !(3u32 << low_loc),\n        result == (bv & mask) | target,\n    ensures\n        get_bit!(result, low_loc) == low,\n        get_bit!(result, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(result, loc2)\n                == get_bit!(bv, loc2),\n{\n}\n\nfn set_two_bit_exec(bv: u32, low_loc: u32, high: bool, low: bool) -> (ret: u32)\n    requires\n        low_loc < 31,\n    ensures\n        get_bit!(ret, low_loc) == low,\n        get_bit!(ret, add(low_loc, 1)) == high,\n        forall|loc2: u32|\n            #![auto]\n            loc2 < 32 && loc2 != low_loc && loc2 != add(low_loc, 1) ==> get_bit!(ret, loc2)\n                == get_bit!(bv, loc2),\n{\n    let target: u32 = (if high {\n        if low {\n            3u32\n        } else {\n            2u32\n        }\n    } else {\n        if low {\n            1u32\n        } else {\n            0u32\n        }\n    }) << low_loc;\n    let mask: u32 = !(3u32 << low_loc);\n    let result: u32 = (bv & mask) | target;\n    proof {\n        set_two_bit_proof(bv, target, mask, result, low_loc, high, low);\n    }\n    result\n}\n\nfn set_color(bucket: u32, high: bool, low: bool, i: u32, ghost_bucket: Seq<Color>) -> (new_bucket:\n    u32)\n    requires\n        i < 16,\n        bucket_view(bucket) =~= ghost_bucket,\n    ensures\n        bucket_view(new_bucket) =~= ghost_bucket.update(i as int, color_view(high, low)),\n{\n    let new_bucket = set_two_bit_exec(bucket, 2 * i, high, low);\n    assert(color_view(high, low) == color_view(\n        get_bit!(new_bucket, add(mul(2, i), 1)),\n        get_bit!(new_bucket, mul(2, i)),\n    ));\n    new_bucket\n}\n\n#[verifier::bit_vector]\nproof fn get_color_proof(bv: u32, index: u32, v: u32)\n    requires\n        v == 3u32 & (bv >> mul(index, 2)),\n    ensures\n        v < 4u32,\n        v == 3 ==> get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 2 ==> !get_bit!(bv, mul(index, 2)) && get_bit!(bv, add(mul(index, 2), 1)),\n        v == 1 ==> get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n        v == 0 ==> !get_bit!(bv, mul(index, 2)) && !get_bit!(bv, add(mul(index, 2), 1)),\n{\n}\n\nfn get_color(bv: u32, index: u32) -> (c: Color)\n    requires\n        index < 15,\n    ensures\n        c == color_view(get_bit!(bv, add(mul(2, index), 1)), get_bit!(bv, mul(2, index))),\n{\n    let v: u32 = 3u32 & (bv >> index * 2);\n    proof {\n        get_color_proof(bv, index, v);\n    }\n    let c = if v == 0 {\n        Color::Undefined\n    } else if v == 1 {\n        Color::Black\n    } else if v == 2 {\n        Color::Gray\n    } else {\n        Color::White\n    };\n    c\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/bitvector_garbage_collection.rs", "verified": true, "metadata": {"original_id": "verus_bitvector_garbage_collection_ea9da15b3907", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b05d90ede66", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool)   { let result = n % 11 == 0 ; if result {  } else { proof {  } } } result }\n\n} // verus!", "target_text": "requires is_divisible_by_11_precond (n as int)\nensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_impl.rs", "verified": true, "metadata": {"original_id": "3b05d90ede66", "function_name": "is_divisible_by_11", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_20eb1e1bf536", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x , forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "20eb1e1bf536", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_33208ea28c6c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 4 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s32if_impl.rs", "verified": true, "metadata": {"original_id": "33208ea28c6c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_06b165328a0d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "06b165328a0d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0f778607c179", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires prev_nums . len () == lengths . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize) requires prev_nums . len () == lengths . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_32/verina_advanced_32.rs", "verified": true, "metadata": {"original_id": "0f778607c179", "function_name": "find_length_ending_at_curr", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ace45313dc15", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ace45313dc15", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b81a4eb4686c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b81a4eb4686c", "function_name": "secondSmallestAux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d4e198b885bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "d4e198b885bc", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_abc483f4c846", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "abc483f4c846", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_50af5f75473c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "50af5f75473c", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e9647ec26668", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires smallest_missing_precond (l @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize) requires smallest_missing_precond (l @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_73/verina_advanced_73_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e9647ec26668", "function_name": "smallest_missing", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_484f0a6325c6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len ()  { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - idx\ninvariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/smallest_list_length_iter_2_current.rs", "verified": true, "metadata": {"original_id": "484f0a6325c6", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_053c3d43c29f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s5if_impl.rs", "verified": true, "metadata": {"original_id": "053c3d43c29f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_60ea05f202d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "60ea05f202d3", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8854013dacc5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8854013dacc5", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_basic_lock1_e15090f9d5e6", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n\n    {\n        loop\n\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n\n        });\n    }\n}\n\n}\n\nfn main() { }\n", "target_text": "requires self.wf(), self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\nensures lock.wf(), points_to@.id() == self.cell.id(), points_to@.is_init()\ninvariant self.wf()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic::*;\nuse vstd::invariant::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::atomic;\nuse vstd::modes::*;\n\nverus!{\n\nstruct LockInv { }\nimpl<T> InvariantPredicate<(AtomicCellId, CellId), (atomic::PermissionBool, Option<cell::PointsTo<T>>)> for LockInv {\n    open spec fn inv(\n        cell_ids: (AtomicCellId, CellId),\n        ghost_stuff: (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n    ) -> bool {\n        ghost_stuff.0.id() == cell_ids.0\n        && match ghost_stuff.1 {\n            None => {\n                // When there's no PointsTo, the lock must be taken, thus\n                // the boolean value is 'true'.\n                ghost_stuff.0.value() == true\n            }\n            Some(points_to) => {\n                points_to.id() == cell_ids.1\n                  && points_to.is_init()\n                  && ghost_stuff.0.value() == false\n            }\n        }\n    }\n}\n\nstruct Lock<T> {\n    pub atomic: PAtomicBool,\n    pub cell: PCell<T>,\n    pub inv: Tracked<AtomicInvariant<\n        (AtomicCellId, CellId),\n        (atomic::PermissionBool, Option<cell::PointsTo<T>>),\n        LockInv\n    >>,\n}\n\nimpl<T> Lock<T> {\n    spec fn wf(self) -> bool {\n        self.inv@.constant() == (self.atomic.id(), self.cell.id())\n    }\n\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (atomic, Tracked(atomic_perm)) = PAtomicBool::new(false);\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let tracked inv = AtomicInvariant::new(\n            (atomic.id(), cell.id()),\n            (atomic_perm, Some(cell_perm)),\n            1337);\n        Lock { atomic, cell, inv: Tracked(inv) }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked points_to_opt = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n                let tracked (mut atomic_permission, mut points_to_inv) = ghost_stuff;\n                res = self.atomic.compare_exchange(Tracked(&mut atomic_permission), false, true);\n                proof {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                    ghost_stuff = (atomic_permission, points_to_inv);\n                }\n            });\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        open_atomic_invariant!(self.inv.borrow() => ghost_stuff => {\n            let tracked (mut atomic_permission, _) = ghost_stuff;\n            self.atomic.store(Tracked(&mut atomic_permission), false);\n            proof {\n                ghost_stuff = (atomic_permission, Some(points_to.get()));\n            }\n        });\n    }\n}\n\n}\n\nfn main() { }\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/basic_lock1.rs", "verified": true, "metadata": {"original_id": "verus_basic_lock1_e15090f9d5e6", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_daffedf95bce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_36/verina_basic_36_iter_2_current.rs", "verified": true, "metadata": {"original_id": "daffedf95bce", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e6e7ef5c8f6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e6e7ef5c8f6f", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_237c6bb75325", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 [i] == old_char { new_char } else { str1 [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let ch = if str1 [idx] == old_char { new_char } else { str1 [idx] } ; result . push (ch) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 [i] == old_char { new_char } else { str1 [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - idx , { let ch = if str1 [idx] == old_char { new_char } else { str1 [idx] } ; result . push (ch) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "237c6bb75325", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4562143ddd22", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/choose_odd.rs", "verified": true, "metadata": {"original_id": "4562143ddd22", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c56c15f61812", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "c56c15f61812", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_956382ec37b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "956382ec37b4", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8a5f9362ac8c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8a5f9362ac8c", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e930e6c3c5af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len ()  { let c = str [i] ; let flipped = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - i\ninvariant i <= str . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len () invariant i <= str . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) , decreases str . len () - i { let c = str [i] ; let flipped = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/027-flip_case_impl.rs", "verified": true, "metadata": {"original_id": "e930e6c3c5af", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_broadcast_proof_a0c86e101dd0", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n\n    {\n      admit();\n    }\n\n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n\n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n\n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n\n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n\n    {\n      //\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n\n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n\n    }\n  }\n\n} // verus!", "target_text": "requires a % c == 0,\n            b % c == 0, p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v), p.aligned(), v.aligned(), p.modulo == v.modulo, p.aligned(), v.aligned(), p.modulo == v.modulo, p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v), p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v), p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v)\nensures (a + b) % c == 0, p2.aligned(), (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo), (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo), p2.aligned(), p2.aligned(), p2.aligned()", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/broadcast_proof.rs", "verified": true, "metadata": {"original_id": "verus_broadcast_proof_a0c86e101dd0", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_26c2133f771a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires unique_product_precond (arr)\nensures true", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_20/verina_basic_20_iter_0_original.rs", "verified": true, "metadata": {"original_id": "26c2133f771a", "function_name": "unique_product", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_54583889d45b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires arr . len () >= 0 \nensures num >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32) requires arr . len () >= 0 , ensures num >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_countnonzero_iter_0_original.rs", "verified": true, "metadata": {"original_id": "54583889d45b", "function_name": "nonzero", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d4e8ebf49cb4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)   { let mut result : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } result . push (row) ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] \ninvariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == a [k] . len () , forall | k : int | # ! [trigger result [k] , a [k] , b [k]] 0 <= k < i ==> forall | j : int | 0 <= j < result [k] . len () ==> result [k] [j] == a [k] [j] + b [k] [j] , i < a . len () , row . len () == j , forall | l : int | 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut result : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == a [k] . len () , forall | k : int | # ! [trigger result [k] , a [k] , b [k]] 0 <= k < i ==> forall | j : int | 0 <= j < result [k] . len () ==> result [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } result . push (row) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "d4e8ebf49cb4", "function_name": "index_wise_addition", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9b24a8b0a518", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/unverified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "9b24a8b0a518", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f1a30c1853ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_13/verina_advanced_13_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f1a30c1853ba", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fee542870c4e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] <= N \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condn_impl.rs", "verified": true, "metadata": {"original_id": "fee542870c4e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_db82da583b3b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >)   { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { '0' } else { '1' }) { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1')\nensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i]\ndecreases a . len () - i\ninvariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/string_xor_impl.rs", "verified": true, "metadata": {"original_id": "db82da583b3b", "function_name": "xor_strings", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3fa3f6e6b06f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i\ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "3fa3f6e6b06f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f0909d07afd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_8/verina_basic_8_impl.rs", "verified": true, "metadata": {"original_id": "0f0909d07afd", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3882746a5dd8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str . len ()  { let c = str [idx] ; let flipped_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_c) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - idx \ninvariant idx <= str . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == flip_case_spec (str [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str . len () invariant idx <= str . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == flip_case_spec (str [i]) , decreases str . len () - idx , { let c = str [idx] ; let flipped_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_c) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/027-flip_case_impl.rs", "verified": true, "metadata": {"original_id": "3882746a5dd8", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3fd1866c621d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3fd1866c621d", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_set_from_vec_53ebf03fd67e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n\n    {\n        self.vt.push(v);\n\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n\n    {\n        for i in iter: 0..self.vt.len()\n\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n\n}\n\n} // verus!\n", "target_text": "ensures s@ =~= Set::<u64>::empty(), self@ =~= old(self)@.insert(v), contained == self@.contains(v)\ninvariant forall|j: nat| j < i ==> self.vt[j as int] != v", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\nstruct VecSet {\n    vt: Vec<u64>,\n}\n\nimpl VecSet {\n    pub closed spec fn view(&self) -> Set<u64> {\n        self.vt@.to_set()\n    }\n\n    pub fn new() -> (s: Self)\n        ensures\n            s@ =~= Set::<u64>::empty(),\n    {\n        VecSet { vt: Vec::new() }\n    }\n\n    pub fn insert(&mut self, v: u64)\n        ensures\n            self@ =~= old(self)@.insert(v),\n    {\n        self.vt.push(v);\n        proof {\n            broadcast use vstd::seq_lib::group_seq_properties;\n        }\n        assert(self.vt@ =~= old(self).vt@ + seq![v]);\n    }\n\n    pub fn contains(&self, v: u64) -> (contained: bool)\n        ensures\n            contained == self@.contains(v),\n    {\n        for i in iter: 0..self.vt.len()\n            invariant\n                forall|j: nat| j < i ==> self.vt[j as int] != v,\n        {\n            if self.vt[i] == v {\n                return true;\n            }\n        }\n        false\n    }\n}\n\nfn main() {\n    let mut vs: VecSet = VecSet::new();\n    assert(vs@ =~= set![]);\n    vs.insert(3);\n    vs.insert(5);\n    let contains2 = vs.contains(2);\n    assert(!contains2);\n    assert(vs@ =~= set![3, 5]);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/set_from_vec.rs", "verified": true, "metadata": {"original_id": "verus_set_from_vec_53ebf03fd67e", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_88d56e281c39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires bound <= 100 , r <= 10 , n <= 100 \ndecreases bound", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32) requires bound <= 100 , r <= 10 , n <= 100 , decreases bound { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_65/verina_basic_65_iter_0_original.rs", "verified": true, "metadata": {"original_id": "88d56e281c39", "function_name": "bounded_loop", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6b434fd69cc8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires isSublist_precond (sub @ , main @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_21/verina_basic_21_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6b434fd69cc8", "function_name": "isSublist", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9931d6d97d55", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires match_precond (s @ , p @)\nensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?')\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?')", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_73/verina_basic_73_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9931d6d97d55", "function_name": "match_fn", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1e85f9564809", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_is_even/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1e85f9564809", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f96e5d130a2d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/res1o_impl.rs", "verified": true, "metadata": {"original_id": "f96e5d130a2d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_16300e4e7930", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 5 * N ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s5if_impl.rs", "verified": true, "metadata": {"original_id": "16300e4e7930", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_36f349e67135", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires trap_rain_water_precond (height @)\nensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_77/verina_advanced_77_iter_0_original.rs", "verified": true, "metadata": {"original_id": "36f349e67135", "function_name": "trap_rain_water", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b895621bab5a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "b895621bab5a", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bc7ae17467e2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires has_common_element_precond (a @ , b @) \nensures has_common_element_postcond (a @ , b @ , result) \ndecreases a . len () - i, b . len () - j\ninvariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_9/verina_basic_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "bc7ae17467e2", "function_name": "has_common_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_385ba17c20ec", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >)  { arbitrary () }\n\n} // verus!", "target_text": "ensures result . deep_view () == s\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "385ba17c20ec", "function_name": "seq_to_vec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_16ead3a93054", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "16ead3a93054", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_even_cell_0d341f961f74", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::invariant::*;\nuse vstd::cell::*;\n\nverus!{\n\nghost struct EvenCell { }\n\nimpl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n        points_to.id() == cell_id\n          && (match points_to.mem_contents() {\n              MemContents::Uninit => false,\n              MemContents::Init(x) => x % 2 == 0,\n          })\n    }\n}\n\nfn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)\n\n{\n    open_local_invariant!(inv => points_to => {\n\n        let x = cell.take(Tracked(&mut points_to));\n\n        // Add 2 (wrap around if necessary)\n        let x_plus_2 = if x == 254 { 0 } else { x + 2 };\n\n        cell.put(Tracked(&mut points_to), x_plus_2);\n\n    });\n}\n\nfn main() {\n    let (cell, Tracked(points_to)) = PCell::new(4);\n\n    let tracked inv = LocalInvariant::new(\n        cell.id(),\n        points_to,\n        1337 /* arbitrary namespace */);\n\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n}\n\n}\n", "target_text": "requires inv.constant() == cell.id()", "full_verified_code": "use vstd::prelude::*;\nuse vstd::invariant::*;\nuse vstd::cell::*;\n\nverus!{\n\nghost struct EvenCell { }\n\nimpl InvariantPredicate<CellId, PointsTo<u8>> for EvenCell {\n    open spec fn inv(cell_id: CellId, points_to: PointsTo<u8>) -> bool {\n        points_to.id() == cell_id\n          && (match points_to.mem_contents() {\n              MemContents::Uninit => false,\n              MemContents::Init(x) => x % 2 == 0,\n          })\n    }\n}\n\nfn add_2(cell: &PCell<u8>, Tracked(inv): Tracked<&LocalInvariant<CellId, PointsTo<u8>, EvenCell>>)\n    requires inv.constant() == cell.id(),\n{\n    open_local_invariant!(inv => points_to => {\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n\n        let x = cell.take(Tracked(&mut points_to));\n        assert(x % 2 == 0);\n\n        // Add 2 (wrap around if necessary)\n        let x_plus_2 = if x == 254 { 0 } else { x + 2 };\n\n        cell.put(Tracked(&mut points_to), x_plus_2);\n\n        assert(points_to.is_init());\n        assert(points_to.value() % 2 == 0);\n    });\n}\n\nfn main() {\n    let (cell, Tracked(points_to)) = PCell::new(4);\n\n    let tracked inv = LocalInvariant::new(\n        cell.id(),\n        points_to,\n        1337 /* arbitrary namespace */);\n\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n    add_2(&cell, Tracked(&inv));\n}\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/even_cell.rs", "verified": true, "metadata": {"original_id": "verus_even_cell_0d341f961f74", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e067973e9642", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "e067973e9642", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_99075a360b25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ndecreases arr . len () - i , arr1 . len () - i \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "99075a360b25", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a8949747f667", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882\nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a8949747f667", "function_name": "Triple1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1fd4df22bd7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1fd4df22bd7a", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d5bc24f83307", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d5bc24f83307", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e7d7258d1ace", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { for i in 0 .. l . len ()  { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ninvariant forall | j : int | 0 <= j < i ==> l [j] < t ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/052-below-threshold_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e7d7258d1ace", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_000452c4f641", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == is_even (n), result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "000452c4f641", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ceaf04c10a8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ceaf04c10a8e", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_60d316298945", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right  { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } }  0 }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases right - left \ninvariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "60d316298945", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e40d4c1272ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32)   { x + 15 }\n\n} // verus!", "target_text": "requires 10 <= x <= 1000\nensures 25 <= y", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32) requires 10 <= x <= 1000 ensures 25 <= y { x + 15 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e40d4c1272ba", "function_name": "MyMethod", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f46c513abc42", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool)   { let mut i = 0 ; while i < s . len ()  { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires s . len () == p . len () \nensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?'\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_match/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f46c513abc42", "function_name": "match_strings", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_39e37c7acd6a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/cal_div_iter_1_current.rs", "verified": true, "metadata": {"original_id": "39e37c7acd6a", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_08c05060e9a9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires shortest_beautiful_substring_precond (s @ , k as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_71/verina_advanced_71.rs", "verified": true, "metadata": {"original_id": "08c05060e9a9", "function_name": "shortest_beautiful_substring", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_48c0504e309d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop  { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases high - low\ninvariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "48c0504e309d", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d49a9b14cf15", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d49a9b14cf15", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f9fd013b136f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "f9fd013b136f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bbc941e4aa4d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx \ninvariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "bbc941e4aa4d", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e8c9dc06390f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len ()  { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ninvariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e8c9dc06390f", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3561a6ec4545", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32)   { let mut i = 0 ; while i != N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "3561a6ec4545", "function_name": "up_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_93b7609eb1e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93b7609eb1e3", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab8f51c2cb7e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "ab8f51c2cb7e", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_bd22240abf5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_11/verina_basic_11_impl.rs", "verified": true, "metadata": {"original_id": "bd22240abf5e", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_750e0222ff80", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "750e0222ff80", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e1811ca67dd1", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires if_power_of_four_precond (n as nat)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e1811ca67dd1", "function_name": "if_power_of_four", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f0757364b3b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_454_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f0757364b3b9", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_60a6a9345f96", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for idx in 0 .. arr . len ()  { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for idx in 0 .. arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "60a6a9345f96", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_17cf6cd3a3c8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/havoc_inline_post_impl.rs", "verified": true, "metadata": {"original_id": "17cf6cd3a3c8", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0c10f306fe6d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_21723d6ef86c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >)   { let mut i = 0 ; while i < s . len ()  { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 \nensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_double_array_elements/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "21723d6ef86c", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1470080d8f21", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1470080d8f21", "function_name": "bubbleSort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_796187d91ebe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "796187d91ebe", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e12f2512cf25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "e12f2512cf25", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4e3daaaa2b28", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "4e3daaaa2b28", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b375d0077dd0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "b375d0077dd0", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_99ac91a8e131", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "99ac91a8e131", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3d2be12da2e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >)   { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i = i + 1 ; } b }\n\n} // verus!", "target_text": "requires a . len () <= 100 \nensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] \ndecreases a . len () - i \ninvariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i = i + 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "3d2be12da2e3", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7ae15ff834b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7ae15ff834b5", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7cb7ca7ad1de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 [i] == old_char { new_char } else { str1 [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let char_to_add = if str1 [idx] == old_char { new_char } else { str1 [idx] } ; result . push (char_to_add) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 [i] == old_char { new_char } else { str1 [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - idx , { let char_to_add = if str1 [idx] == old_char { new_char } else { str1 [idx] } ; result . push (char_to_add) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "7cb7ca7ad1de", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_vostd_array_ptr_6a87e02b8f48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr;\nuse vstd::set;\nuse vstd::set_lib;\n\nuse core::marker::PhantomData;\n\nverus! {\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ArrayPtr<V, const N: usize> {\n    pub addr: usize,\n    pub index: usize,\n    pub _type: PhantomData<[V; N]>,\n}\n\n#[verifier::external_body]\n#[verifier::accept_recursive_types(V)]\npub tracked struct PointsToArray<V, const N: usize> {\n    phantom: core::marker::PhantomData<[V; N]>,\n    no_copy: NoCopy,\n}\n\npub ghost struct PointsToArrayData<V, const N: usize> {\n    pub ptr: *mut [V; N],\n    pub value: [raw_ptr::MemContents<V>; N],\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub uninterp spec fn mem_contents_unwrap<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> (res: raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub uninterp spec fn mem_contents_wrap<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n) -> (res: [raw_ptr::MemContents<V>; N]);\n\npub axiom fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n\n     {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    uninterp spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(self) -> *mut [V; N] {\n        self@.ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self@.value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\nbroadcast use {\n    raw_ptr::group_raw_ptr_axioms,\n    set_lib::group_set_lib_default,\n    set::group_set_axioms,\n};\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub exec fn addr(&self) -> usize\n        returns\n            self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n\n    {\n        Self { addr, index: 0, _type: PhantomData }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub exec fn add(self, off: usize) -> Self\n\n    {\n        Self { addr: self.addr, index: (self.index + off) as usize, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn is_pptr(self, ptr: ArrayPtr<V, N>) -> bool {\n        ptr.addr == self.addr()\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V: Sized, const N: usize>()\n\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n\n        let ptr = ArrayPtr { addr: p as usize, index: 0, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V)\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), self.index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: V) where\n        V: Copy,\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), self.index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n\n    {\n\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n\n} // verus!\n", "target_text": "requires res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr), res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr), res == mem_contents_wrap(data), layout::size_of::<[V; N]>() > 0, old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N, old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N, old(perm).ptr() == ptr,\n        old(perm).is_init_all(), perm.ptr() == ptr,\n        perm.is_init(index as int), perm.ptr() == ptr,\n        perm.is_init_all(), self.index + off\n                <= N  // C standard style: don't exceed one-past the end of the array\n            , self.wf(), old(self).wf(), layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0, layout::size_of::<[V; N]>() > 0, layout::size_of::<[V; N]>() > 0, perm.wf(),\n            perm.is_pptr(self),\n            perm.is_uninit_all(), old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit(self.index as int),\n            self.index < N, old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(self.index as int),\n            self.index < N, old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init_all(), perm.wf(),\n            perm.is_pptr(self),\n            perm.is_init_all(), old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(index as int),\n            index < N, perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N, perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(), old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N, old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N, perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N\nensures res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n;\n\npub axiom fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n;\n\npub axiom fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n;\n\nimpl<V, const N: usize> PointsToArrayData<V, N>, data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value), res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value), self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i], self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int, self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int, self@.ptr@.addr != 0, perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind, perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind, perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind, res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind, forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind, res.addr == addr,\n            res.index == 0, self.addr() != 0, self.wf(),\n            self.addr() == old(self).addr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i], self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(), self.addr() != other.addr(), res@.ptr == pt@.ptr,\n            res@.value == mem_contents_wrap(pt@.opt_value), res@.ptr == self@.ptr,\n            res@.opt_value == mem_contents_unwrap(self@.value), res === *self, layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind, res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            res.1@.is_uninit_all(), res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft), perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[self.index as int] == raw_ptr::MemContents::Init(value), perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[self.index as int].value(), perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit_all(),\n            res@ == old(perm).value(), res@ == perm.value(), perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(), res == perm.opt_value()[index as int].value(), forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(), perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n        opens_invariants none\n        no_unwind, perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value), res == perm.opt_value()[index as int].value(), perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind, perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value)", "full_verified_code": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr;\nuse vstd::set;\nuse vstd::set_lib;\n\nuse core::marker::PhantomData;\n\nverus! {\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ArrayPtr<V, const N: usize> {\n    pub addr: usize,\n    pub index: usize,\n    pub _type: PhantomData<[V; N]>,\n}\n\n#[verifier::external_body]\n#[verifier::accept_recursive_types(V)]\npub tracked struct PointsToArray<V, const N: usize> {\n    phantom: core::marker::PhantomData<[V; N]>,\n    no_copy: NoCopy,\n}\n\npub ghost struct PointsToArrayData<V, const N: usize> {\n    pub ptr: *mut [V; N],\n    pub value: [raw_ptr::MemContents<V>; N],\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub uninterp spec fn mem_contents_unwrap<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> (res: raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub uninterp spec fn mem_contents_wrap<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n) -> (res: [raw_ptr::MemContents<V>; N]);\n\npub axiom fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n;\n\npub axiom fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n;\n\npub axiom fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n;\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    uninterp spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(self) -> *mut [V; N] {\n        self@.ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self@.value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\nbroadcast use {\n    raw_ptr::group_raw_ptr_axioms,\n    set_lib::group_set_lib_default,\n    set::group_set_axioms,\n};\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub exec fn addr(&self) -> usize\n        returns\n            self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n            res.index == 0,\n    {\n        Self { addr, index: 0, _type: PhantomData }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub exec fn add(self, off: usize) -> Self\n        requires\n            self.index + off\n                <= N  // C standard style: don't exceed one-past the end of the array\n            ,\n    {\n        Self { addr: self.addr, index: (self.index + off) as usize, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn is_pptr(self, ptr: ArrayPtr<V, N>) -> bool {\n        ptr.addr == self.addr()\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.addr() == old(self).addr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res@.ptr == pt@.ptr,\n            res@.value == mem_contents_wrap(pt@.opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res@.ptr == self@.ptr,\n            res@.opt_value == mem_contents_unwrap(self@.value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V: Sized, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm@.value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, index: 0, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.is_pptr(res.0),\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.is_pptr(p));\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(points_to@.value, perm_ptr.opt_value());\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_uninit(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[self.index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(self.index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), self.index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: V) where\n        V: Copy,\n\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(self.index as int),\n            self.index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit(self.index as int),\n            forall|i: int|\n                0 <= i < N && i != self.index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[self.index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(self.index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), self.index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(self),\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n        opens_invariants none\n        no_unwind\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).is_pptr(*self),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.is_pptr(*self),\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/array_ptr.rs", "verified": true, "metadata": {"original_id": "vostd_array_ptr_6a87e02b8f48", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f4ddff6adae6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f4ddff6adae6", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8fce4613ffdc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code.rs", "verified": true, "metadata": {"original_id": "8fce4613ffdc", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6ee92261d8b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires missing_number_precond (nums @)\nensures missing_number_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize) requires missing_number_precond (nums @) ensures missing_number_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_54/verina_advanced_54_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6ee92261d8b9", "function_name": "missing_number", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_10a8c35799bc", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn size_to_chunks (sz : int) -> int { (sz + const_persistence_chunk_size () - 1) / const_persistence_chunk_size () }\n# [doc = \" We model the persistent memory as getting flushed in chunks,\"] # [doc = \" where each chunk has `const_persistence_chunk_size()` bytes. We refer\"] # [doc = \" to chunk number `c` as the set of addresses `addr` such that\"] # [doc = \" `addr / const_persistence_chunk_size() == c`.\"] pub open spec fn const_persistence_chunk_size () -> int { 8 }\npub exec fn persistence_chunk_size () -> (out : usize)  { 8 }\npub exec fn size_to_chunks_exec (sz : usize) -> (res : usize)  { let whole_chunks = sz / persistence_chunk_size () ; let overflowed_chunk = (sz - whole_chunks * persistence_chunk_size () + persistence_chunk_size () - 1) / persistence_chunk_size () ; whole_chunks + overflowed_chunk }\n\n} // verus!", "target_text": "ensures out == const_persistence_chunk_size (), res == size_to_chunks (sz as int)\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn size_to_chunks (sz : int) -> int { (sz + const_persistence_chunk_size () - 1) / const_persistence_chunk_size () }\n# [doc = \" We model the persistent memory as getting flushed in chunks,\"] # [doc = \" where each chunk has `const_persistence_chunk_size()` bytes. We refer\"] # [doc = \" to chunk number `c` as the set of addresses `addr` such that\"] # [doc = \" `addr / const_persistence_chunk_size() == c`.\"] pub open spec fn const_persistence_chunk_size () -> int { 8 }\npub exec fn persistence_chunk_size () -> (out : usize) ensures out == const_persistence_chunk_size () { 8 }\npub exec fn size_to_chunks_exec (sz : usize) -> (res : usize) ensures res == size_to_chunks (sz as int) { let whole_chunks = sz / persistence_chunk_size () ; let overflowed_chunk = (sz - whole_chunks * persistence_chunk_size () + persistence_chunk_size () - 1) / persistence_chunk_size () ; whole_chunks + overflowed_chunk }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "10a8c35799bc", "function_name": "size_to_chunks_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e7c2be2a4e20", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32)   { let mut i : usize = 0 ; while i < nums . len ()  { if nums [i] == target {   return i as i32 ; } i = i + 1 ; }   return - 1 ; }\n\n} // verus!", "target_text": "requires nums @ . len () < 0x8000_0000 \nensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target \ndecreases nums @ . len () - i\ninvariant i <= nums @ . len () , forall | j : int | 0 <= j < i as int ==> # [trigger] nums @ [j] != target , nums @ . len () < 0x8000_0000 ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i : usize = 0 ; while i < nums . len () invariant i <= nums @ . len () , forall | j : int | 0 <= j < i as int ==> # [trigger] nums @ [j] != target , nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i = i + 1 ; } assert (i == nums @ . len ()) ; assert (forall | j : int | 0 <= j < nums @ . len () as int ==> # [trigger] nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/linearsearch_impl.rs", "verified": true, "metadata": {"original_id": "e7c2be2a4e20", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_65c6543d615c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { if x . checked_add (y) . is_some () { Some (x + y) } else { None } }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { if x . checked_add (y) . is_some () { Some (x + y) } else { None } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/053-add_impl.rs", "verified": true, "metadata": {"original_id": "65c6543d615c", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f6ef943b7e3b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "f6ef943b7e3b", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_vostd_page_prop_233cd10cc37d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\n// Copied from aster_common\n// TODO: Check if it's correct\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// Whether the page has a mapping.\n    ///\n    /// If it is `false`. The page doesn't have a mapping, but may contain\n    /// metadata that is marked by the user.\n    pub has_map: bool,\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 4, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    #[vstd::contrib::auto_spec]\n    pub fn new(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { has_map: true, flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub fn new_absent() -> Self {\n        Self {\n            has_map: false,\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn N() -> (res: usize) {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn value(&self) -> (res: u8) {\n        match self {\n            CachePolicy::Uncacheable => 0u8,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn empty() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    #[deprecated(note = \"Use `bits()` instead. It is now aligned with asterinas.\")]\n    pub const fn value(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn bits(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub fn from_bits(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn R() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn W() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn X() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RW() -> Self {\n        Self { bits: Self::R().bits() | Self::W().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RX() -> Self {\n        Self { bits: Self::R().bits() | Self::X().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RWX() -> Self {\n        Self { bits: Self::R().bits() | Self::W().bits() | Self::X().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn ACCESSED() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn DIRTY() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn AVAIL1() -> Self {\n        Self { bits: 0b01000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn AVAIL2() -> Self {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn empty() -> (res: Self) {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    #[deprecated(note = \"Use `bits()` instead. It is now aligned with asterinas.\")]\n    pub const fn value(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn bits(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub fn from_bits(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn USER() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn GLOBAL() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn SHARED() -> Self {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "target_text": "requires #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n        a.has_map == b.has_map, a == b, #[trigger] a.bits == #[trigger] b.bits, a == b, #[trigger] a.bits == #[trigger] b.bits, a == b\nensures a == b, #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags, a == b, #[trigger] a.bits == #[trigger] b.bits, a == b, #[trigger] a.bits == #[trigger] b.bits", "full_verified_code": "use vstd::prelude::*;\n\n// Copied from aster_common\n// TODO: Check if it's correct\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// Whether the page has a mapping.\n    ///\n    /// If it is `false`. The page doesn't have a mapping, but may contain\n    /// metadata that is marked by the user.\n    pub has_map: bool,\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 4, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n    requires\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n        a.has_map == b.has_map,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    #[vstd::contrib::auto_spec]\n    pub fn new(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { has_map: true, flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[vstd::contrib::auto_spec]\n    pub fn new_absent() -> Self {\n        Self {\n            has_map: false,\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn N() -> (res: usize) {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn value(&self) -> (res: u8) {\n        match self {\n            CachePolicy::Uncacheable => 0u8,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn empty() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    #[deprecated(note = \"Use `bits()` instead. It is now aligned with asterinas.\")]\n    pub const fn value(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn bits(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub fn from_bits(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn R() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn W() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn X() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RW() -> Self {\n        Self { bits: Self::R().bits() | Self::W().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RX() -> Self {\n        Self { bits: Self::R().bits() | Self::X().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn RWX() -> Self {\n        Self { bits: Self::R().bits() | Self::W().bits() | Self::X().bits() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn ACCESSED() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn DIRTY() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn AVAIL1() -> Self {\n        Self { bits: 0b01000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn AVAIL2() -> Self {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn empty() -> (res: Self) {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    #[deprecated(note = \"Use `bits()` instead. It is now aligned with asterinas.\")]\n    pub const fn value(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn bits(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub fn from_bits(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn USER() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn GLOBAL() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[vstd::contrib::auto_spec]\n    pub const fn SHARED() -> Self {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/lock-protocol-rcu/src/mm/page_prop.rs", "verified": true, "metadata": {"original_id": "vostd_page_prop_233cd10cc37d", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_625132ba4285", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subseq_length_precond (xs @) \nensures longest_increasing_subseq_length_postcond (xs @ , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_31/verina_advanced_31_iter_0_original.rs", "verified": true, "metadata": {"original_id": "625132ba4285", "function_name": "longest_increasing_subseq_length", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_593d233aa9c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_82/verina_basic_82_impl.rs", "verified": true, "metadata": {"original_id": "593d233aa9c0", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_faa7453635c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "faa7453635c0", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0672d3828446", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0672d3828446", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ecc9e7abe87a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ecc9e7abe87a", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_18be5efd162d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >)   { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 {   } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 {    } else {   } } }) ; }  }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64)  { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >)  { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; }  result }\n\n} // verus!", "target_text": "requires intersperse_quantified (numbers , delimiter , interspersed) \nensures interspersed == intersperse_spec (numbers , delimiter) , numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , result @ == intersperse_spec (numbers @ , delimiter) , interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () \ndecreases numbers . len () , numbers . len () , numbers . len () , numbers . len () - i \ninvariant 0 <= i <= numbers . len () , result . len () == if i == 0", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) decreases numbers . len () , { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) requires intersperse_quantified (numbers , delimiter , interspersed) , ensures interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 { assert (interspersed . len () == 1) ; assert (interspersed [even (0)] == numbers [0]) ; } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 { assert (is [i] == numbers . last ()) ; assert (interspersed [even (i / 2)] == numbers [i / 2]) ; assert (i / 2 == numbers . len () - 1) ; } else { assert (is [i] == delimiter) ; assert (interspersed [odd ((i - 1) / 2)] == delimiter) ; } } }) ; } assert (interspersed =~= intersperse_spec (numbers , delimiter)) ; }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64) ensures numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () , { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >) ensures result @ == intersperse_spec (numbers @ , delimiter) , { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , result . len () == if i == 0 { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , decreases numbers . len () - i , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; } proof { assert (intersperse_quantified (numbers @ , delimiter , result @)) ; intersperse_quantified_is_spec (numbers @ , delimiter , result @) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/005-intersperse_impl.rs", "verified": true, "metadata": {"original_id": "18be5efd162d", "function_name": "intersperse", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_849aa2fc577e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "849aa2fc577e", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7d2efeadcd9b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >)   { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high  { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] \nensures match result\ndecreases high - low \ninvariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >) requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] , ensures match result { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high invariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target , decreases high - low , { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "7d2efeadcd9b", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4ec85337b928", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "4ec85337b928", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_563efd003869", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "563efd003869", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_376bfc725936", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "376bfc725936", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1bd681d68fd4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; }   copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr @ . len () - i\ninvariant copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , i <= arr @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , i <= arr @ . len () , decreases arr @ . len () - i { copied . push (arr [i]) ; i += 1 ; } assert (i == arr @ . len ()) ; assert (copied @ . len () == i) ; copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "1bd681d68fd4", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3b778de10e68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/binary_search_recursive_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3b778de10e68", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7498bef44049", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7498bef44049", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e00903eee137", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs2_impl.rs", "verified": true, "metadata": {"original_id": "e00903eee137", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_305fa8a021b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "305fa8a021b2", "function_name": "canyon_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c8304568ff0a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c8304568ff0a", "function_name": "three_distinct", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_67cc1bda9f73", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "67cc1bda9f73", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5233aa61aedf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "5233aa61aedf", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ff04b0112799", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/063-fibfib.rs", "verified": true, "metadata": {"original_id": "ff04b0112799", "function_name": "fibfib", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_71383fe86069", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "71383fe86069", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1de965d92f4c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_44/verina_advanced_44_impl.rs", "verified": true, "metadata": {"original_id": "1de965d92f4c", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d6dd387a2651", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_414_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d6dd387a2651", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_71a03d38b1e0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "71a03d38b1e0", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4825620ab073", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_26/verina_basic_26_impl.rs", "verified": true, "metadata": {"original_id": "4825620ab073", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_be8112c0bae7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  {    new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list . len () - i , n - j \ninvariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "be8112c0bae7", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a6a52f027f84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "a6a52f027f84", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0c638a9dec4c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "0c638a9dec4c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_075cea08b9f9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/indp5_impl.rs", "verified": true, "metadata": {"original_id": "075cea08b9f9", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8f1cfbd6e6d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "8f1cfbd6e6d0", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4f692090db47", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len ()  { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len ()  { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "target_text": "ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , already_added == (exists | m : int | 0 <= m < k && result [m] == elem) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len () invariant found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len () invariant already_added == (exists | m : int | 0 <= m < k && result [m] == elem) , { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "4f692090db47", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7fcaead1c7e4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32)   { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "requires d > 0, count_sum_divisible_by_precond (n as nat , d as nat)\nensures result == is_sum_divisible_by (x as nat , d as nat), result == sum_of_digits (x as nat), result == count_sum_divisible_by_spec (n as nat , d as nat)\ndecreases n, x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7fcaead1c7e4", "function_name": "count_sum_divisible_by", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_fc693be58c56", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "fc693be58c56", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9212fd224c2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "9212fd224c2c", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1ba91f828296", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < i ==> ! arr2 @ . contains (arr1 [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < i ==> ! arr2 @ . contains (arr1 [k]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_414_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1ba91f828296", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_818ebf1d24b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "818ebf1d24b5", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_afb7e111b28a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases a . len () - i\ninvariant i <= a . len () , result . len () == if i <= pos", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "afb7e111b28a", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_31657bd999e2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "31657bd999e2", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c5833f44f944", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len ()  { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - index \ninvariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len () invariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - index , { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "c5833f44f944", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e5c0ef0e2c64", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e5c0ef0e2c64", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_be15ff386505", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start_idx <= lst . len () \ndecreases lst . len () - start_idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_73/verina_advanced_73_iter_0_original.rs", "verified": true, "metadata": {"original_id": "be15ff386505", "function_name": "search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_26e1f13fe374", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "ensures if let Some (idx) = index\ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "26e1f13fe374", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_19a0ce8547b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "19a0ce8547b0", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_844487d1e52b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len ()\nensures result <= nums . len (), result <= nums . len () decreases nums . len () - idx\ndecreases nums . len () - idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "844487d1e52b", "function_name": "longest_increasing_streak_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0d8506f9fa25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "0d8506f9fa25", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e1a65ee5559e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e1a65ee5559e", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_350cc2d5a451", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "350cc2d5a451", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_interior_mutability_bb35c8760b0b", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "target_text": "requires cell_is_valid(cell)\nensures res == result_of_computation(), res == result_of_computation()\ninvariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation()", "full_verified_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{cell::*, prelude::*};\n\n//// InvCell\n\nverus! {\n\n// ANCHOR: inv_cell_example\nspec fn result_of_computation() -> u64 {\n    2\n}\n\nfn expensive_computation() -> (res: u64)\n    ensures\n        res == result_of_computation(),\n{\n    1 + 1\n}\n\nspec fn cell_is_valid(cell: &InvCell<Option<u64>>) -> bool {\n    forall|v|\n        (cell.inv(v) <==> match v {\n            Option::Some(i) => i == result_of_computation(),\n            Option::None => true,\n        })\n}\n\n// Memoize the call to `expensive_computation()`.\n// The argument here is an InvCell wrapping an Option<u64>,\n// which is initially None, but then it is set to the correct\n// answer once it's computed.\n//\n// The precondition here, given in the definition of `cell_is_valid` above,\n// says that the InvCell has an invariant that the interior contents is either\n// `None` or `Some(i)` where `i` is the desired value.\nfn memoized_computation(cell: &InvCell<Option<u64>>) -> (res: u64)\n    requires\n        cell_is_valid(cell),\n    ensures\n        res == result_of_computation(),\n{\n    let c = cell.get();\n    match c {\n        Option::Some(i) => {\n            // The value has already been computed; return the cached value\n            i\n        },\n        Option::None => {\n            // The value hasn't been computed yet. Compute it here\n            let i = expensive_computation();\n            // Store it for later\n            cell.replace(Option::Some(i));\n            // And return it now\n            i\n        },\n    }\n}\n// ANCHOR_END: inv_cell_example\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/interior_mutability.rs", "verified": true, "metadata": {"original_id": "verus_interior_mutability_bb35c8760b0b", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6edf0fc34933", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i , second . len () - j \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "6edf0fc34933", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ae3c421c5cf4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires first_duplicate_precond (lst @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_12/verina_advanced_12_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ae3c421c5cf4", "function_name": "first_duplicate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fa22a39ad343", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx\ninvariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "fa22a39ad343", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bb646573475a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "bb646573475a", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a7ead548f143", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_test_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a7ead548f143", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b03a820eadf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 \nensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_32/verina_advanced_32_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b03a820eadf", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ec45183af665", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i \ninvariant i <= arr . len () , result . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "ec45183af665", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7294e23a4b17", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_68/verina_basic_68_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7294e23a4b17", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_63d73406a881", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { return false ; }\n\n} // verus!", "target_text": "requires is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_22/verina_advanced_22.rs", "verified": true, "metadata": {"original_id": "63d73406a881", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1623ebcdb64b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m\nensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/WIP/WIP__mcontained_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1623ebcdb64b", "function_name": "mcontained", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_counting_to_2_e8be9817663d", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        // ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n        // ANCHOR_END: inv\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        // ANCHOR: inv_proof\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n        // ANCHOR_END: inv_proof\n    }\n);\n\n// ANCHOR: global_struct\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the  {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: global_struct\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n}\n\n} // verus!\n// ANCHOR_END: full\n", "target_text": "ensures new_token@.instance_id() == instance.id() && new_token@.value() == true, new_token@.instance_id() == instance.id() && new_token@.value() == true\ninvariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter)", "full_verified_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        // ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n        // ANCHOR_END: inv\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        // ANCHOR: inv_proof\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n        // ANCHOR_END: inv_proof\n    }\n);\n\n// ANCHOR: global_struct\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: global_struct\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/counting_to_2.rs", "verified": true, "metadata": {"original_id": "verus_counting_to_2_e8be9817663d", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6c56620d6a39", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int)   { let remainder = addr % alignment ; if remainder != 0 {  }   } } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize)   { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64_to_usize (v : & CheckedU64 , alignment : usize) -> (result : CheckedU64)   {  if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment_usize (v . unwrap () , alignment) as u64) } }\n\n} // verus!", "target_text": "requires 0 < alignment , 0 < alignment , 0 < alignment \nensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment), result == space_needed_for_alignment (addr as int , alignment as int), v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) \ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64_to_usize (v : & CheckedU64 , alignment : usize) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment_usize (v . unwrap () , alignment) as u64) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "6c56620d6a39", "function_name": "align_checked_u64_to_usize", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_63261adfa282", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "63261adfa282", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_78aa65f17712", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let result = N * (N + 2) ; sum . set (0 , result) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= 46340 , N * (N + 2) <= MAX \nensures sum [0] == N * (N + 2) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= 46340 , N * (N + 2) <= MAX , ensures sum [0] == N * (N + 2) , { let result = N * (N + 2) ; sum . set (0 , result) ; assert (sum [0] == result) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ss1_impl.rs", "verified": true, "metadata": {"original_id": "78aa65f17712", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_173a2be6bfc3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : u32)   { let mut i = 0 ; while i < N  { let value = if N % 2 == 0 { 0i32 } else { 1i32 } ; a . set (i as usize , value) ;  i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] % 2 == N % 2 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] % 2 == N % 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : u32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] % 2 == N % 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] % 2 == N % 2 , decreases N - i , { let value = if N % 2 == 0 { 0i32 } else { 1i32 } ; a . set (i as usize , value) ; assert (a [i as int] % 2 == N % 2) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condm_impl.rs", "verified": true, "metadata": {"original_id": "173a2be6bfc3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_736617973405", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s1if_impl.rs", "verified": true, "metadata": {"original_id": "736617973405", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_766002711d69", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32)   { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res \ndecreases a . len () - idx \ninvariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_max_iter_2_current.rs", "verified": true, "metadata": {"original_id": "766002711d69", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a27b7749fb54", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)   { let result = arr [k - 1] ;  result }\n\n} // verus!", "target_text": "requires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a27b7749fb54", "function_name": "kth_element", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f3d4eec1b1ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >)   { let mut i = 0 ; while i < a . len ()  { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "requires find_first_odd_precond (a)\nensures find_first_odd_postcond (a , result)\ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_49/verina_basic_49_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f3d4eec1b1ad", "function_name": "find_first_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e27e4fb4974f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/abs_impl.rs", "verified": true, "metadata": {"original_id": "e27e4fb4974f", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fa9d0a6c75ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut idx = 0 ; while idx < text . len ()  { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) \ndecreases text . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa9d0a6c75ee", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9c48f8f505a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "9c48f8f505a0", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_660690dd0133", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_18/verina_advanced_18.rs", "verified": true, "metadata": {"original_id": "660690dd0133", "function_name": "sum_powers_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_33fd6d051667", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires unique_sorted_precond (arr @)\nensures unique_sorted_postcond (arr @ , result @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @) ensures unique_sorted_postcond (arr @ , result @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_81/verina_advanced_81_iter_0_original.rs", "verified": true, "metadata": {"original_id": "33fd6d051667", "function_name": "unique_sorted", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c93368c267b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "c93368c267b1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_21c6aeb89368", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize)  { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , canyon_search_precond (a @ , b @) \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize) requires canyon_search_precond (a @ , b @) , { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "21c6aeb89368", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e0cc80966e4b", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\npub open spec fn optional_value_view (ov : Option :: < Vec :: < u8 > >) -> Option :: < Seq :: < u8 > > { match ov { Some (v) => Some (v @) , None => None , } }\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >)  { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len ()  { out . push (v [i]) ; i = i + 1 ; }  out }\npub fn clone_optional_value (ov : & Option :: < Vec :: < u8 > >) -> (res : Option :: < Vec :: < u8 > >)  { match ov . as_ref () { Some (v) => Some (clone_vec_u8 (v)) , None => None , } }\n\n} // verus!", "target_text": "ensures out @ == v @, optional_value_view (* ov) == optional_value_view (res)\ndecreases v . len () - i \ninvariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\npub open spec fn optional_value_view (ov : Option :: < Vec :: < u8 > >) -> Option :: < Seq :: < u8 > > { match ov { Some (v) => Some (v @) , None => None , } }\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_optional_value (ov : & Option :: < Vec :: < u8 > >) -> (res : Option :: < Vec :: < u8 > >) ensures optional_value_view (* ov) == optional_value_view (res) { match ov . as_ref () { Some (v) => Some (clone_vec_u8 (v)) , None => None , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "e0cc80966e4b", "function_name": "clone_optional_value", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_934b8a5b050b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires bound <= 100 , r <= 10 , n <= 100 \ndecreases bound", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32) requires bound <= 100 , r <= 10 , n <= 100 , decreases bound { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_65/verina_basic_65.rs", "verified": true, "metadata": {"original_id": "934b8a5b050b", "function_name": "bounded_loop", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7103b723a5f6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7103b723a5f6", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_power_of_2_773462c2aac5", "task": "task_a", "input_text": "// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n\n    {\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    {\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n\n    {\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n\n    {\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n\n    {\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n\n    {\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n\n    {\n    if e == 0 {\n        //\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n\n        //\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        //\n        //\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        //         // we get this from above recursive call\n        //\n\n        // need the above nonlinear fact to make this pass\n\n        }\n\n        //\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n\n            //\n            //\n        }\n\n        }\n        //\n\n    }\n}\n\n} // verus!\nfn main() {}\n", "target_text": "requires e > 0,\n        e <= 32, e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1, e > 3, e > 0, e > 0, e >= 0, e > 0, x < y, e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat), pow2(0) == 1,\n                bv << 0 == bv * 1, (bv == bv as nat), e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat), e > 0, (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat), bv << ((e - 1) as u32) < 0x8000_0000, e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat)\nensures bv << e == (bv << sub(e, 1)) << 1u32, (bv << e) == mul(2, bv << sub(e, 1)), pow2(0) == 1, pow2(e) == pow2((e - 3) as nat) * 8, (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1, (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)), pow2(e) * pow2(e) == pow2(2 * e), pow2(e) > pow2((e - 1) as nat), z * x <= z * y, (bv << e) as nat == (bv as nat) * pow2(e as nat), bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e, (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e, (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e, pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e, pow2(e) > pow2((e - 1) as nat),\n    decreases e, (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e\ndecreases e, (e), e, e, e, e, e", "full_verified_code": "// Some of the lemmas are ported from the following:\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power2.dfy\n// https://github.com/dafny-lang/libraries/blob/master/src/NonlinearArithmetic/Power.dfy\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n    ensures\n        bv << e == (bv << sub(e, 1)) << 1u32,\n    decreases e,\n{\n    // REVIEW:                 ^^^^^^^^^^ expected `u32`, found struct `verus_builtin::int`\n    // get this error when updated to new syntax. Type casting (i.e. `(e - 1u32) as u32`) does not make this error disappear\n}\n\n#[verifier::bit_vector]\nproof fn left_shift_by_one_is_mul2(bv: u32, e: u32)\n    requires\n        e > 0,\n        e <= 32,\n        bv << e == (bv << sub(e, 1)) << 1,\n    ensures\n        (bv << e) == mul(2, bv << sub(e, 1)),\n{\n}\n\nspec fn pow2(e: nat) -> nat\n    decreases (e),\n{\n    if e == 0 {\n        1\n    } else {\n        2 * pow2((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_0()\n    ensures\n        pow2(0) == 1,\n{\n}\n\nproof fn lemma_pow2_unfold3(e: nat)\n    requires\n        e > 3,\n    ensures\n        pow2(e) == pow2((e - 3) as nat) * 8,\n{\n    reveal_with_fuel(pow2, 3);\n}\n\n// (2^e - 1) / 2 = 2^(e - 1) - 1\nproof fn lemma_pow2_make_div(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(e) - 1) / 2 == pow2((e - 1) as nat) - 1,\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_make_div((e - 1) as nat)\n    }\n}\n\nproof fn lemma_pow2_2e(e: nat)\n    requires\n        e > 0,\n    ensures\n        (pow2(2 * e)) == 4 * pow2(2 * ((e - 1) as nat)),\n    decreases e,\n{\n    reveal_with_fuel(pow2, 3);\n    if e == 1 {\n        assert(pow2(2) == 4);\n    } else {\n        lemma_pow2_2e((e - 1) as nat)\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_pow2_two_e(e: nat)\n    requires\n        e >= 0,\n    ensures\n        pow2(e) * pow2(e) == pow2(2 * e),\n    decreases e,\n{\n    if e != 0 {\n        lemma_pow2_two_e((e - 1) as nat);\n        lemma_pow2_2e(e);\n    }\n}\n\nproof fn lemma_pow2_increase(e: nat)\n    requires\n        e > 0,\n    ensures\n        pow2(e) > pow2((e - 1) as nat),\n    decreases e,\n{\n    if e == 1 {\n    } else {\n        lemma_pow2_increase((e - 1) as nat);\n    }\n}\n\n#[verifier::nonlinear]\nproof fn lemma_mul_upper_bound(x: nat, y: nat, z: nat)\n    requires\n        x < y,\n    ensures\n        z * x <= z * y,\n{\n}\n\nproof fn left_shift_is_pow2(bv: u32, e: u32)\n    requires\n        e <= 32,\n        (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n    ensures\n        (bv << e) as nat == (bv as nat) * pow2(e as nat),\n    decreases e,\n{\n    if e == 0 {\n        // assert(bv << 0 == bv * 1u32) by(bit_vector);\n        // REVIEW:           ^^^^^^^^^\n        //        error: cannot use bit-vector arithmetic on type Int(Int)\n        assume(bv << 0 == bv * 1);\n        assert((bv << 0) as nat == (bv as nat) * pow2(0)) by (nonlinear_arith)\n            requires\n                pow2(0) == 1,\n                bv << 0 == bv * 1,\n        {}\n    } else {\n        lemma_pow2_increase(e as nat);\n        // assert(pow2((e-1) as nat) < pow2(e as nat));\n        lemma_mul_upper_bound(pow2((e - 1) as nat), pow2(e as nat), bv as nat);\n        // assert((bv as nat) * pow2( (e-1) as nat) <= (bv as nat) * pow2(e as nat));\n        // assert((bv as nat) * pow2( (e-1) as nat) < (0x1_0000_0000 as nat));\n        left_shift_is_pow2(bv, (e - 1) as u32);\n        // assert( (bv << (e-1) as u32) as nat == (bv as nat) * pow2((e-1) as nat));        // we get this from above recursive call\n        // assert(bv == bv as nat);\n        assert((bv as nat) * pow2((e - 1) as nat) == bv * pow2((e - 1) as nat)) by (nonlinear_arith)\n            requires\n                (bv == bv as nat),\n        {}// assert((bv << (e-1) as u32) as nat == bv* pow2((e-1) as nat));\n        // need the above nonlinear fact to make this pass\n\n        assert(pow2(e as nat) == 2 * pow2((e - 1) as nat)) by {\n            reveal_with_fuel(pow2, 1);\n        }\n        assert((bv as nat) * pow2(e as nat) == (bv as nat) * 2 * pow2((e - 1) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n        {}\n        assert((2 * (bv << ((e - 1) as u32))) as nat == 2 * ((bv << ((e - 1) as u32)) as nat))\n            by (nonlinear_arith)\n            requires\n                e > 0,\n        {}\n        left_shift_by_one(bv, e);\n        // assert( (bv << e) == (bv << ((e-1) as u32)) << 1);\n        left_shift_by_one_is_mul2(bv, e);\n        // cannot get the `ensures` clause from this lemma directly\n        // since the `ensures` includes `uclip 32` the the RHS, when normal assertions doesn't\n        assert(bv << ((e - 1) as u32) < 0x8000_0000) by (nonlinear_arith)\n            requires\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv as nat) * pow2(e as nat) < (0x1_0000_0000 as nat),\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            // assert( (bv as nat) * pow2((e-1) as nat) * 2 == (bv as nat) * pow2(e as nat));\n            // assert( (bv as nat) * pow2((e-1) as nat) < 0x8000_0000);\n            // assert(bv * pow2((e-1) as nat) < 0x8000_0000);\n        }\n        assert(2 * (bv << ((e - 1) as u32)) < 0x1_0000_0000) by (nonlinear_arith)\n            requires\n                bv << ((e - 1) as u32) < 0x8000_0000,\n        {}\n        // assert( (bv << e)  == 2 * (bv << ((e-1) as u32)));\n\n        assert((bv << e) as nat == (bv as nat) * pow2(e as nat)) by (nonlinear_arith)\n            requires\n                e > 0,\n                (bv << ((e - 1) as u32)) as nat == bv * pow2((e - 1) as nat),\n                (bv << e) as nat == 2 * (bv << ((e - 1) as u32)) as nat,\n                pow2(e as nat) == 2 * pow2((e - 1) as nat),\n        {\n            assert((bv << e) as nat == 2 * ((bv << ((e - 1) as u32)) as nat));\n            assert(2 * ((bv << ((e - 1) as u32)) as nat) == (bv as nat) * 2 * pow2((e - 1) as nat));\n            assert((bv as nat) * 2 * pow2((e - 1) as nat) == (bv as nat) * pow2(e as nat));\n        }\n        // assert((bv << e) as nat == (bv as nat) * pow2(e as nat));\n\n    }\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/power_of_2.rs", "verified": true, "metadata": {"original_id": "verus_power_of_2_773462c2aac5", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_9d3446f3b2ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "9d3446f3b2ea", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4aa245ba1d0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)   { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index\ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_733_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4aa245ba1d0b", "function_name": "find_first_occurrence", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e4f1bab20d97", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "e4f1bab20d97", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e2985cfa789b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , N <= MAX / 4 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 4 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s32if_impl.rs", "verified": true, "metadata": {"original_id": "e2985cfa789b", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b1c64b65abfb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_even_list/verus_code.rs", "verified": true, "metadata": {"original_id": "b1c64b65abfb", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d0aa4e94a847", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_414_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d0aa4e94a847", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_generics_2a21efd9e4a5", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n\n}\n\nproof fn test_g2(u: u8) {\n\n}\n\n} // verus!\n", "target_text": "requires f(a, c)\nensures f(r, a), f(r, id_u64(i))", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/generics.rs", "verified": true, "metadata": {"original_id": "verus_generics_2a21efd9e4a5", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6a023c766fb2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "6a023c766fb2", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1262351705d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 0 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum [0] = 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1262351705d4", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_lib_examples_85b5449808d7", "task": "task_a", "input_text": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n\n    {\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n\n    {\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n\n    {\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n\n    {\n    if s1.is_empty() {\n\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n\n    v.set(2, 21);\n\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires x == y, x =~= y, x == y, s1.finite(), s1.finite(), s1.finite(), s1.finite()\nensures s1.intersect(s2).len() <= s1.len(), s1.intersect(s2).len() <= s1.len(), s1.intersect(s2).len() <= s1.len(), s1.intersect(s2).len() <= s1.len(), s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(), s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len()\ndecreases s1.len(), s1.len(), the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 -, s1.len(), s1.len()", "full_verified_code": "#![allow(unused_imports)]\nuse vstd::{map::*, prelude::*, seq::*, set::*};\n\nverus! {\n\n// ANCHOR: macro\nproof fn test_seq1() {\n    let s: Seq<int> = seq![0, 10, 20, 30, 40];\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set1() {\n    let s: Set<int> = set![0, 10, 20, 30, 40];\n    assert(s.finite());\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n}\n\nproof fn test_map1() {\n    let m: Map<int, int> = map![0 => 0, 10 => 100, 20 => 200, 30 => 300, 40 => 400];\n    assert(m.dom().contains(20));\n    assert(m.dom().contains(30));\n    assert(!m.dom().contains(60));\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n}\n\n// ANCHOR_END: macro\n#[verusfmt::skip]\nmod m0 {\nuse vstd::{seq::*, prelude::*};\n\n// ANCHOR: new0\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n// ANCHOR_END: new0\n}\n\n// ANCHOR: new\nproof fn test_seq2() {\n    let s: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s.len() == 5);\n    assert(s[2] == 20);\n    assert(s[3] == 30);\n}\n\nproof fn test_set2() {\n    let s: Set<int> = Set::new(|i: int| 0 <= i <= 40 && i % 10 == 0);\n    assert(s.contains(20));\n    assert(s.contains(30));\n    assert(!s.contains(60));\n\n    let s_infinite: Set<int> = Set::new(|i: int| i % 10 == 0);\n    assert(s_infinite.contains(20));\n    assert(s_infinite.contains(30));\n    assert(!s_infinite.contains(35));\n}\n\nproof fn test_map2() {\n    let m: Map<int, int> = Map::new(|i: int| 0 <= i <= 40 && i % 10 == 0, |i: int| 10 * i);\n    assert(m[20] == 200);\n    assert(m[30] == 300);\n\n    let m_infinite: Map<int, int> = Map::new(|i: int| i % 10 == 0, |i: int| 10 * i);\n    assert(m_infinite[20] == 200);\n    assert(m_infinite[30] == 300);\n    assert(m_infinite[90] == 900);\n}\n// ANCHOR_END: new\n\n/*\n// ANCHOR: test_eq_fail\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq_fail() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq(s1, s2); // FAILS, even though s1 equals s2\n    check_eq(s1, s3); // FAILS, even though s1 equals s3\n}\n// ANCHOR_END: test_eq_fail\n*/\n\n// ANCHOR: test_eq\nproof fn check_eq_extensionally(x: Seq<int>, y: Seq<int>)\n    requires\n        x =~= y,\n{\n}\n\nproof fn test_eq() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    check_eq_extensionally(s1, s2); // succeeds\n    check_eq_extensionally(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq\n\n// ANCHOR: test_eq2\nproof fn check_eq(x: Seq<int>, y: Seq<int>)\n    requires\n        x == y,\n{\n}\n\nproof fn test_eq2() {\n    let s1: Seq<int> = seq![0, 10, 20, 30, 40];\n    let s2: Seq<int> = seq![0, 10] + seq![20] + seq![30, 40];\n    let s3: Seq<int> = Seq::new(5, |i: int| 10 * i);\n    assert(s1 =~= s2);\n    assert(s1 =~= s3);\n    check_eq(s1, s2); // succeeds\n    check_eq(s1, s3); // succeeds\n}\n// ANCHOR_END: test_eq2\n\n/*\n// ANCHOR: lemma_len_intersect_fail\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n\n    } else {\n        let a = s1.choose();\n\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect_fail\n\n// ANCHOR: lemma_len_intersect_sketch\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        // s1 is the empty set.\n        // Therefore, s1.intersect(s2) is also empty.\n        // So both s1.len() and s1.intersect(s2).len() are 0,\n        // and 0 <= 0.\n    } else {\n        // s1 is not empty, so it has at least one element.\n        // Let a be an element from s1.\n        // Let s1' be the set s1 with the element a removed (i.e. s1' == s1 - {a}).\n        // Removing an element decreases the cardinality by 1, so s1'.len() == s1.len() - 1.\n        // By induction, s1'.intersect(s2).len() <= s1'.len(), so:\n        //   (s1 - {a}).intersect(s2).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1'.len()\n        //   (s1.intersect(s2) - {a}).len() <= s1.len() - 1\n        // case a in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len() - 1\n        // case a not in s1.intersect(s2):\n        //   (s1.intersect(s2) - {a}).len() == s1.intersect(s2).len()\n        // In either case:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1\n        // Putting all the inequalities together:\n        //   s1.intersect(s2).len() <= (s1.intersect(s2) - {a}).len() + 1 <= (s1.len() - 1) + 1\n        // So:\n        //   s1.intersect(s2).len() <= (s1.len() - 1) + 1\n        //   s1.intersect(s2).len() <= s1.len()\n    }\n}\n// ANCHOR_END: lemma_len_intersect_sketch\n\n// ANCHOR: lemma_len_intersect\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases\n        s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2) =~= s1);\n    } else {\n        let a = s1.choose();\n        assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        lemma_len_intersect(s1.remove(a), s2);\n    }\n}\n// ANCHOR_END: lemma_len_intersect\n*/\n\n// ANCHOR: lemma_len_intersect_commented\npub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)\n    requires\n        s1.finite(),\n    ensures\n        s1.intersect(s2).len() <= s1.len(),\n    decreases s1.len(),\n{\n    if s1.is_empty() {\n        assert(s1.intersect(s2).len() == 0) by {\n            assert(s1.intersect(s2) =~= s1);\n        }\n    } else {\n        let a = s1.choose();\n        lemma_len_intersect(s1.remove(a), s2);\n        // by induction: s1.remove(a).intersect(s2).len() <= s1.remove(a).len()\n        assert(s1.intersect(s2).remove(a).len() <= s1.remove(a).len()) by {\n            assert(s1.intersect(s2).remove(a) =~= s1.remove(a).intersect(s2));\n        }\n        // simplifying \".remove(a).len()\" yields s1.intersect(s2).len() <= s1.len())\n\n    }\n}\n// ANCHOR_END: lemma_len_intersect_commented\n\n// ANCHOR: test_vec1\nfn test_vec1() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v.len() == 5);\n    assert(v[2] == 20);\n    assert(v[3] == 30);\n    v.set(2, 21);\n    assert(v[2] == 21);\n    assert(v[3] == 30);\n}\n// ANCHOR_END: test_vec1\n\n// ANCHOR: test_vec2\nspec fn has_five_sorted_numbers(s: Seq<u32>) -> bool {\n    s.len() == 5 && s[0] <= s[1] <= s[2] <= s[3] <= s[4]\n}\n\nfn test_vec2() {\n    let mut v: Vec<u32> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    v.set(2, 21);\n    assert(v@ =~= seq![0, 10, 21, 30, 40]);\n    assert(v@ =~= seq![0, 10] + seq![21] + seq![30, 40]);\n    assert(v@[2] == 21);\n    assert(v@[3] == 30);\n    assert(v@.subrange(2, 4) =~= seq![21, 30]);\n    assert(has_five_sorted_numbers(v@));\n}\n// ANCHOR_END: test_vec2\n\n// ANCHOR: ret_spec_fn\nspec fn adder(x: int) -> spec_fn(int) -> int {\n    |y: int| x + y\n}\n\nproof fn test_adder() {\n    let f = adder(10);\n    assert(f(20) == 30);\n    assert(f(60) == 70);\n}\n// ANCHOR_END: ret_spec_fn\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/lib_examples.rs", "verified": true, "metadata": {"original_id": "verus_lib_examples_85b5449808d7", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6f431219a479", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len ()  { if a [i] > result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , result . len () > 0 , result [result . len () - 1] == a [i - 1] || (exists | k : int | 0 <= k < i - 1 && result [result . len () - 1] == a [k] && forall | j : int | k < j < i ==> a [j] == a [k]) , forall | x : int , y : int | 0 <= x < y < result . len () ==> result [x] < result [y] , forall | j : int | # ! [trigger result [j]] 0 <= j < result . len () ==> exists | k : int | 0 <= k < i && result [j] == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () > 0 , result [result . len () - 1] == a [i - 1] || (exists | k : int | 0 <= k < i - 1 && result [result . len () - 1] == a [k] && forall | j : int | k < j < i ==> a [j] == a [k]) , forall | x : int , y : int | 0 <= x < y < result . len () ==> result [x] < result [y] , forall | j : int | # ! [trigger result [j]] 0 <= j < result . len () ==> exists | k : int | 0 <= k < i && result [j] == a [k] , decreases a . len () - i { if a [i] > result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/unique_better_impl.rs", "verified": true, "metadata": {"original_id": "6f431219a479", "function_name": "unique_better", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dc28565fd671", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "ensures result == sum_of_digits (x as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "dc28565fd671", "function_name": "sum_of_digits_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_counting_to_n_732137aafefb", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!{\n    X {\n        fields {\n            #[sharding(constant)]\n            pub num_threads: nat,\n\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(count)]\n            pub unstamped_tickets: nat,\n\n            #[sharding(count)]\n            pub stamped_tickets: nat,\n        }\n// ANCHOR_END: fields\n\n// ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n// ANCHOR_END: inv\n\n// ANCHOR: init\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n// ANCHOR_END: init\n\n// ANCHOR: tr_inc\n        transition!{\n            tr_inc() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= 1);\n                //    update unstampted_tickets = pre.unstamped_tickets - 1\n                // (In any `remove` statement, the `>=` condition is always implicit.)\n                remove unstamped_tickets -= (1);\n\n                // Equivalent to:\n                //    update stamped_tickets = pre.stamped_tickets + 1\n                add stamped_tickets += (1);\n\n                // These still use ordinary 'update' syntax, because `pre.counter`\n                // uses the `variable` sharding strategy.\n\n                update counter = pre.counter + 1;\n            }\n        }\n// ANCHOR_END: tr_inc\n\n// ANCHOR: finalize\n        property!{\n            finalize() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= pre.num_threads);\n                have stamped_tickets >= (pre.num_threads);\n\n            }\n        }\n// ANCHOR_END: finalize\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct Global {\n        pub atomic: AtomicU32<_, X::counter, _>,\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n         {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n\n        predicate {\n            self.instance@.num_threads() < 0x100000000\n        }\n    }\n}\n\nfn do_count(num_threads: u32) {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(unstamped_tokens),\n        Tracked(stamped_tokens),\n    ) = X::Instance::initialize(num_threads as nat);\n    // Initialize the counter\n    let tracked_instance = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: tracked_instance };\n    let global_arc = Arc::new(global);\n\n    // ANCHOR: loop_spawn\n    // Spawn threads\n    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n    let mut i = 0;\n    while i < num_threads\n\n    {\n        let tracked unstamped_token;\n\n        let global_arc = global_arc.clone();\n        let join_handle = spawn(\n            (move || -> (new_token: Tracked<X::stamped_tickets>)\n\n                {\n                    let tracked unstamped_token = unstamped_token;\n                    let globals = &*global_arc;\n                    let tracked stamped_token;\n                    let _ =\n                        atomic_with_ghost!(\n                            &global_arc.atomic => fetch_add(1);\n                            update prev -> next;\n                            returning ret;\n                            ghost c => {\n                                stamped_token =\n                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);\n                            }\n                        );\n                    Tracked(stamped_token)\n                }),\n        );\n        join_handles.push(join_handle);\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_spawn\n    // ANCHOR: loop_join\n    // Join threads\n\n    let mut i = 0;\n    while i < num_threads\n\n    {\n        let join_handle = join_handles.pop().unwrap();\n        match join_handle.join() {\n            Result::Ok(token) => {\n\n            },\n            _ => {\n                return ;\n            },\n        };\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_join\n\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &stamped_tokens);\n        }\n    );\n\n}\n\nfn main() {\n    do_count(20);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "target_text": "ensures new_token@.instance_id() == instance.id(),\n                    new_token@.count() == 1\ninvariant on atomic with (instance) is (v: u32, g: X::counter), 0 <= i,\n            i <= num_threads,\n            unstamped_tokens.count() + i == num_threads,\n            unstamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() == i as int,\n            forall|j: int, ret|\n                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>\n                    ret@.instance_id() == instance.id()\n                    && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance, 0 <= i,\n            i <= num_threads,\n            stamped_tokens.count() == i,\n            stamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() as int + i as int == num_threads,\n            forall|j: int, ret|\n                0 <= j && j < join_handles@.len() ==>\n                    #[trigger] join_handles@.index(j).predicate(ret) ==>\n                        ret@.instance_id() == instance.id()\n                        && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_state_machines_macros::tokenized_state_machine;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::thread::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!{\n    X {\n        fields {\n            #[sharding(constant)]\n            pub num_threads: nat,\n\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(count)]\n            pub unstamped_tickets: nat,\n\n            #[sharding(count)]\n            pub stamped_tickets: nat,\n        }\n// ANCHOR_END: fields\n\n// ANCHOR: inv\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == self.stamped_tickets\n            && self.stamped_tickets + self.unstamped_tickets == self.num_threads\n        }\n// ANCHOR_END: inv\n\n// ANCHOR: init\n        init!{\n            initialize(num_threads: nat) {\n                init num_threads = num_threads;\n                init counter = 0;\n                init unstamped_tickets = num_threads;\n                init stamped_tickets = 0;\n            }\n        }\n// ANCHOR_END: init\n\n// ANCHOR: tr_inc\n        transition!{\n            tr_inc() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= 1);\n                //    update unstampted_tickets = pre.unstamped_tickets - 1\n                // (In any `remove` statement, the `>=` condition is always implicit.)\n                remove unstamped_tickets -= (1);\n\n                // Equivalent to:\n                //    update stamped_tickets = pre.stamped_tickets + 1\n                add stamped_tickets += (1);\n\n                // These still use ordinary 'update' syntax, because `pre.counter`\n                // uses the `variable` sharding strategy.\n                assert(pre.counter < pre.num_threads);\n                update counter = pre.counter + 1;\n            }\n        }\n// ANCHOR_END: tr_inc\n\n// ANCHOR: finalize\n        property!{\n            finalize() {\n                // Equivalent to:\n                //    require(pre.unstamped_tickets >= pre.num_threads);\n                have stamped_tickets >= (pre.num_threads);\n\n                assert(pre.counter == pre.num_threads);\n            }\n        }\n// ANCHOR_END: finalize\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, num_threads: nat) { }\n\n        #[inductive(tr_inc)]\n        fn tr_inc_preserves(pre: Self, post: Self) {\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct Global {\n        pub atomic: AtomicU32<_, X::counter, _>,\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n\n        predicate {\n            self.instance@.num_threads() < 0x100000000\n        }\n    }\n}\n\nfn do_count(num_threads: u32) {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(unstamped_tokens),\n        Tracked(stamped_tokens),\n    ) = X::Instance::initialize(num_threads as nat);\n    // Initialize the counter\n    let tracked_instance = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tracked_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: tracked_instance };\n    let global_arc = Arc::new(global);\n\n    // ANCHOR: loop_spawn\n    // Spawn threads\n    let mut join_handles: Vec<JoinHandle<Tracked<X::stamped_tickets>>> = Vec::new();\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            unstamped_tokens.count() + i == num_threads,\n            unstamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() == i as int,\n            forall|j: int, ret|\n                0 <= j && j < i ==> join_handles@.index(j).predicate(ret) ==>\n                    ret@.instance_id() == instance.id()\n                    && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let tracked unstamped_token;\n        proof {\n            unstamped_token = unstamped_tokens.split(1 as nat);\n        }\n        let global_arc = global_arc.clone();\n        let join_handle = spawn(\n            (move || -> (new_token: Tracked<X::stamped_tickets>)\n                ensures\n                    new_token@.instance_id() == instance.id(),\n                    new_token@.count() == 1,\n                {\n                    let tracked unstamped_token = unstamped_token;\n                    let globals = &*global_arc;\n                    let tracked stamped_token;\n                    let _ =\n                        atomic_with_ghost!(\n                            &global_arc.atomic => fetch_add(1);\n                            update prev -> next;\n                            returning ret;\n                            ghost c => {\n                                stamped_token =\n                                    global_arc.instance.borrow().tr_inc(&mut c, unstamped_token);\n                            }\n                        );\n                    Tracked(stamped_token)\n                }),\n        );\n        join_handles.push(join_handle);\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_spawn\n    // ANCHOR: loop_join\n    // Join threads\n\n    let mut i = 0;\n    while i < num_threads\n        invariant\n            0 <= i,\n            i <= num_threads,\n            stamped_tokens.count() == i,\n            stamped_tokens.instance_id() == instance.id(),\n            join_handles@.len() as int + i as int == num_threads,\n            forall|j: int, ret|\n                0 <= j && j < join_handles@.len() ==>\n                    #[trigger] join_handles@.index(j).predicate(ret) ==>\n                        ret@.instance_id() == instance.id()\n                        && ret@.count() == 1,\n            (*global_arc).wf(),\n            (*global_arc).instance@ === instance,\n    {\n        let join_handle = join_handles.pop().unwrap();\n        match join_handle.join() {\n            Result::Ok(token) => {\n                proof {\n                    stamped_tokens.join(token.get());\n                }\n            },\n            _ => {\n                return ;\n            },\n        };\n        i = i + 1;\n    }\n    // ANCHOR_END: loop_join\n\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &stamped_tokens);\n        }\n    );\n    assert(x == num_threads);\n}\n\nfn main() {\n    do_count(20);\n}\n\n} // verus!\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/counting_to_n.rs", "verified": true, "metadata": {"original_id": "verus_counting_to_n_732137aafefb", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4d4cf83ddbc8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { b [i as usize] = N + 2 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 \ndecreases N - i \ninvariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N + 2 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N + 2 <= MAX , decreases N - i , { b [i as usize] = N + 2 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/sina4_impl.rs", "verified": true, "metadata": {"original_id": "4d4cf83ddbc8", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verified-memory-allocator_pigeonhole_e1059c4ea54a", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\nuse vstd::prelude::*;\nuse vstd::set_lib::*;\nuse vstd::assert_by_contradiction;\n\nverus!{\n\n// TODO: This belongs in set_lib\nproof fn singleton_set_unique_elt<T>(s: Set<T>, a:T, b:T)\n\n{\n    assert_by_contradiction!(a == b, {\n        let empty = s.remove(a);\n\n    });\n}\n\nproof fn set_mismatch(s1:Set<nat>, s2:Set<nat>, missing:nat)\n\n    {\n    if s1.len() == 1 {\n        let elt = s2.choose();\n\n        singleton_set_unique_elt(s1, elt, missing);\n\n    } else {\n        let elt = s2.choose();\n\n        let s1_smaller = s1.remove(elt);\n        set_mismatch(s1_smaller, s2.remove(elt), missing);\n    }\n}\n\n/* TODO: These next two should be derived from the set_int_range and lemma_int_range in\n *       set_lib.rs, but it's surprisingly painful to do so */\n\n/// Creates a finite set of nats in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains nats in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n\n    {\n    if lo == hi {\n\n    } else {\n        lemma_nat_range(lo, (hi - 1) as nat);\n\n    }\n}\n\nproof fn nat_set_size(s:Set<nat>, bound:nat)\n\n{\n    let nats = set_nat_range(0, bound);\n    lemma_nat_range(0, bound);\n\n}\n\npub proof fn pigeonhole_missing_idx_implies_double_helper(\n    m: Map<nat, nat>,\n    missing: nat,\n    len: nat,\n    prev_vals: Set<nat>,\n    k: nat,\n) -> (dup2: nat)\n\n    {\n    if prev_vals.contains(m[k]) {\n        let dup1 = choose |j| 0 <= j < k && m[j] == m[k];\n        dup1\n    } else {\n        if k < len - 1 {\n            pigeonhole_missing_idx_implies_double_helper(m, missing, len, prev_vals.insert(m[k]), k + 1)\n        } else {\n            let new_prev_vals = prev_vals.insert(m[k]);\n            else {\n\n                }\n            };\n            nat_set_size(m.dom(), len);\n            set_mismatch(m.dom(), new_prev_vals, missing);\n            1\n        }\n    }\n}\n\npub proof fn pigeonhole_missing_idx_implies_double(\n    m: Map<nat, nat>,\n    missing: nat,\n    len: nat,\n) -> (r: (nat, nat))\n\n    { let (i, j) = r;\n        i != j\n          && m.dom().contains(i)\n          && m.dom().contains(j)\n          && m[i] == m[j]\n    })\n{\n\n        if len == 1 {\n\n        }\n    };\n    let dup2 = pigeonhole_missing_idx_implies_double_helper(m, missing, len, Set::empty(), 0);\n    let dup1 = choose |dup1| #![auto] dup1 != dup2 && m.dom().contains(dup1) && 0 <= dup1 < len && m[dup1] == m[dup2];\n    (dup1, dup2)\n}\n\npub proof fn pigeonhole_too_many_elements_implies_double(\n    m: Map<nat, nat>,\n    len: nat,\n) -> (r: (nat, nat))\n\n    { let (i, j) = r;\n        i != j\n          && m.dom().contains(i)\n          && m.dom().contains(j)\n          && m[i] == m[j]\n    })\n{\n    pigeonhole_missing_idx_implies_double(m, len, len + 1)\n}\n\n}\n", "target_text": "requires s.finite(),\n        s.len() == 1,\n        s.contains(a),\n        s.contains(b), s1.finite(),\n        s2.finite(),\n        s1.len() == s2.len(),\n        forall |elt| s2.contains(elt) ==> s1.contains(elt),\n        s1.contains(missing),\n        !s2.contains(missing), lo <= hi, forall |i: nat| (0 <= i < bound <==> s.contains(i)), len >= 2,\n        forall |i: nat| (0 <= i < len <==> m.dom().contains(i)),\n        forall |i: nat| (#[trigger] m.dom().contains(i) ==> (\n            0 <= m[i] < len && m[i] != missing\n        )),\n        0 <= missing < len,\n        0 <= k < len,\n        prev_vals.finite(),\n        prev_vals.len() == k,\n        //forall |j| 0 <= j < k ==> #[trigger] prev_vals.contains(m[j]),\n        forall |elt| #[trigger] prev_vals.contains(elt) ==> exists |j| 0 <= j < k && m[j] == elt, forall |i: nat| (0 <= i < len <==> m.dom().contains(i)),\n        forall |i: nat| (#[trigger] m.dom().contains(i) ==> (\n            0 <= m[i] < len && m[i] != missing\n        )),\n        0 <= missing < len, forall |i: nat| (0 <= i < len + 1 <==> m.dom().contains(i)),\n        forall |i: nat| #[trigger] m.dom().contains(i) ==> 0 <= m[i] < len\nensures a == b, false, set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo, s.finite(),\n        s.len() == bound, m.dom().contains(dup2),\n        exists |dup1| #![auto] dup1 != dup2 && m.dom().contains(dup1) && 0 <= dup1 < len && m[dup1] == m[dup2], (, (, false,\n    decreases s1.len(), set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases\n        hi - lo, m.dom().contains(dup2),\n        exists |dup1| #![auto] dup1 != dup2 && m.dom().contains(dup1) && 0 <= dup1 < len && m[dup1] == m[dup2],\n    decreases len - k\ndecreases s1.len(), hi - lo, len - k", "full_verified_code": "#![allow(unused_imports)]\n\nuse vstd::prelude::*;\nuse vstd::set_lib::*;\nuse vstd::assert_by_contradiction;\n\nverus!{\n\n// TODO: This belongs in set_lib\nproof fn singleton_set_unique_elt<T>(s: Set<T>, a:T, b:T)\n    requires\n        s.finite(),\n        s.len() == 1,\n        s.contains(a),\n        s.contains(b),\n    ensures\n        a == b,\n{\n    assert_by_contradiction!(a == b, {\n        let empty = s.remove(a);\n        assert(empty.len() == 0);\n        assert(empty.contains(b));\n    });\n}\n\nproof fn set_mismatch(s1:Set<nat>, s2:Set<nat>, missing:nat)\n    requires\n        s1.finite(),\n        s2.finite(),\n        s1.len() == s2.len(),\n        forall |elt| s2.contains(elt) ==> s1.contains(elt),\n        s1.contains(missing),\n        !s2.contains(missing),\n    ensures\n        false,\n    decreases s1.len(),\n{\n    if s1.len() == 1 {\n        let elt = s2.choose();\n        assert(s2.contains(elt));\n        assert(s1.contains(elt));\n        singleton_set_unique_elt(s1, elt, missing);\n        assert(elt == missing);\n        assert(false);\n    } else {\n        let elt = s2.choose();\n        assert(s2.contains(elt));\n        assert(s1.contains(elt));\n        let s1_smaller = s1.remove(elt);\n        set_mismatch(s1_smaller, s2.remove(elt), missing);\n    }\n}\n\n/* TODO: These next two should be derived from the set_int_range and lemma_int_range in \n *       set_lib.rs, but it's surprisingly painful to do so */\n\n/// Creates a finite set of nats in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains nats in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n    requires\n        lo <= hi,\n    ensures\n        set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases\n        hi - lo,\n{\n    if lo == hi {\n        assert(set_nat_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_nat_range(lo, (hi - 1) as nat);\n        assert(set_nat_range(lo, (hi - 1) as nat).insert((hi - 1) as nat) =~= set_nat_range(lo, hi));\n    }\n}\n\n\nproof fn nat_set_size(s:Set<nat>, bound:nat)\n    requires\n        forall |i: nat| (0 <= i < bound <==> s.contains(i)),\n    ensures\n        s.finite(),\n        s.len() == bound,\n{\n    let nats = set_nat_range(0, bound);\n    lemma_nat_range(0, bound);\n    assert(s =~= nats);\n}\n\n        \n\npub proof fn pigeonhole_missing_idx_implies_double_helper(\n    m: Map<nat, nat>,\n    missing: nat,\n    len: nat,\n    prev_vals: Set<nat>,\n    k: nat,\n) -> (dup2: nat)\n    requires\n        len >= 2,\n        forall |i: nat| (0 <= i < len <==> m.dom().contains(i)),\n        forall |i: nat| (#[trigger] m.dom().contains(i) ==> (\n            0 <= m[i] < len && m[i] != missing\n        )),\n        0 <= missing < len,\n        0 <= k < len,\n        prev_vals.finite(),\n        prev_vals.len() == k,\n        //forall |j| 0 <= j < k ==> #[trigger] prev_vals.contains(m[j]),\n        forall |elt| #[trigger] prev_vals.contains(elt) ==> exists |j| 0 <= j < k && m[j] == elt,\n    ensures \n        m.dom().contains(dup2),\n        exists |dup1| #![auto] dup1 != dup2 && m.dom().contains(dup1) && 0 <= dup1 < len && m[dup1] == m[dup2],\n    decreases len - k,\n{\n    if prev_vals.contains(m[k]) {\n        let dup1 = choose |j| 0 <= j < k && m[j] == m[k];\n        dup1\n    } else {\n        if k < len - 1 {\n            pigeonhole_missing_idx_implies_double_helper(m, missing, len, prev_vals.insert(m[k]), k + 1)\n        } else {\n            assert forall |elt| prev_vals.contains(elt) implies 0 <= elt < len && elt != missing by {\n                let j = choose |j| 0 <= j < k && m[j] == elt;\n                assert(m.dom().contains(j));\n            }\n            let new_prev_vals = prev_vals.insert(m[k]);\n            assert forall |elt| new_prev_vals.contains(elt) implies 0 <= elt < len && elt != missing by {\n                if prev_vals.contains(elt) {\n                } else {\n                    assert(elt == m[k]);\n                    assert(m.dom().contains(k));\n                }\n            };\n            nat_set_size(m.dom(), len);\n            set_mismatch(m.dom(), new_prev_vals, missing);\n            1\n        }\n    }\n}\n\npub proof fn pigeonhole_missing_idx_implies_double(\n    m: Map<nat, nat>,\n    missing: nat,\n    len: nat,\n) -> (r: (nat, nat))\n    requires\n        forall |i: nat| (0 <= i < len <==> m.dom().contains(i)),\n        forall |i: nat| (#[trigger] m.dom().contains(i) ==> (\n            0 <= m[i] < len && m[i] != missing\n        )),\n        0 <= missing < len,\n    ensures ({ let (i, j) = r;\n        i != j\n          && m.dom().contains(i)\n          && m.dom().contains(j)\n          && m[i] == m[j]\n    })\n{\n    assert(len >= 2) by {\n        assert(len >= 1);\n        if len == 1 {\n            assert(m.dom().contains(0));\n            assert(m[0] != missing);\n        }\n    };\n    let dup2 = pigeonhole_missing_idx_implies_double_helper(m, missing, len, Set::empty(), 0);\n    let dup1 = choose |dup1| #![auto] dup1 != dup2 && m.dom().contains(dup1) && 0 <= dup1 < len && m[dup1] == m[dup2];\n    (dup1, dup2)\n}\n\npub proof fn pigeonhole_too_many_elements_implies_double(\n    m: Map<nat, nat>,\n    len: nat,\n) -> (r: (nat, nat))\n    requires\n        forall |i: nat| (0 <= i < len + 1 <==> m.dom().contains(i)),\n        forall |i: nat| #[trigger] m.dom().contains(i) ==> 0 <= m[i] < len,\n    ensures ({ let (i, j) = r;\n        i != j\n          && m.dom().contains(i)\n          && m.dom().contains(j)\n          && m[i] == m[j]\n    })\n{\n    pigeonhole_missing_idx_implies_double(m, len, len + 1)\n}\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-memory-allocator/verus-mimalloc/pigeonhole.rs", "verified": true, "metadata": {"original_id": "verified-memory-allocator_pigeonhole_e1059c4ea54a", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2f94412bc462", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { return false ; }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2f94412bc462", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a32ba9ac906c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires concat_precond (a , b) , a . len () + b . len () <= MAX \nensures concat_postcond (a , b , & result) \ndecreases a . len () - i , b . len () - j \ninvariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_83/verina_basic_83_impl.rs", "verified": true, "metadata": {"original_id": "a32ba9ac906c", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_04911af74c2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "04911af74c2c", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b5aa71a17161", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_avg/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b5aa71a17161", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2b6913fa918f", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >)  { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len ()  { out . push (v [i]) ; i = i + 1 ; }  out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >)  { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "target_text": "ensures out @ == v @, match ov\ndecreases v . len () - i \ninvariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_option_vec_u8 (ov : Option < & Vec < u8 > >) -> (res : Option < Vec < u8 > >) ensures match ov { Some (e1) => res . is_some () && e1 @ == res -> 0 @ , None => res is None , } { match ov { Some (e1) => Some (clone_vec_u8 (e1)) , None => None , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "2b6913fa918f", "function_name": "clone_option_vec_u8", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3661409307fb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_impl.rs", "verified": true, "metadata": {"original_id": "3661409307fb", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ec0669710e30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "target_text": "requires exists | i : int | 0 <= i < a . len () && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ec0669710e30", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_recommends_25251cfab7d9", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    {\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n\n{\n\n}\n\nfn main() {\n\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "target_text": "requires seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\ndecreases s.len()", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{pervasive::*, seq::*, seq_lib::*};\n\nverus! {\n\nspec fn max_int(x: int, y: int) -> int {\n    if x > y {\n        x\n    } else {\n        y\n    }\n}\n\n// To enable recommends checking, use: spec(checked) instead of spec\nspec fn seq_max_int(s: Seq<int>) -> int\n    recommends\n        s.len()\n            > 0,  // without this, spec(checked) generates a recommends warning below\n\n    decreases s.len(),\n{\n    let m = s[s.len() - 1];\n    if s.len() <= 1 {\n        m\n    } else {\n        max_int(m, seq_max_int(s.drop_last()))\n    }\n}\n\nproof fn test(s: Seq<int>)\n    requires\n        seq_max_int(s)\n            >= 0,  // without this, the assertion fails and there's a recommends note\n{\n    assert(seq_max_int(s) >= 0);\n}\n\nfn main() {\n    proof {\n        let s = seq![10, 20, 30, 25];\n        reveal_with_fuel(seq_max_int, 4);\n        assert(seq_max_int(s) == 30);\n    }\n}\n\n// Usage of `spec_affirm`\nspec fn some_predicate(a: nat) -> bool\n    recommends\n        a < 100,\n{\n    if (a >= 50) {\n        let _ = spec_affirm(50 <= a && a < 100);\n        a >= 75\n    } else {\n        let _ = spec_affirm(a < 40);  // spec(checked) would raise a recommends note here\n        a < 25\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recommends.rs", "verified": true, "metadata": {"original_id": "verus_recommends_25251cfab7d9", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f02c619e0da2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f02c619e0da2", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1b50a9b9acdd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "1b50a9b9acdd", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7459e298200f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_13/verina_advanced_13_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7459e298200f", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4ba28f7ce860", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int)   { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ;    }\nfn count_true (arr : & Vec < bool >) -> (count : u64)  { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len ()  { if arr [i] { count = count + 1 ; } i = i + 1 ;  }  count }\n\n} // verus!", "target_text": "requires 0 < i <= seq . len ()\nensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1], 0 <= count <= arr . len () , count_boolean (arr @) == count \ndecreases seq . len () , arr . len () - i \ninvariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) decreases seq . len () , { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int) requires 0 < i <= seq . len () ensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1] { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ; assert (prefix_i == prefix_i_minus_1 . push (seq [i - 1])) ; assert (prefix_i . drop_last () == prefix_i_minus_1) ; assert (prefix_i . last () == seq [i - 1]) ; }\nfn count_true (arr : & Vec < bool >) -> (count : u64) ensures 0 <= count <= arr . len () , count_boolean (arr @) == count , { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len () invariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count , decreases arr . len () - i , { if arr [i] { count = count + 1 ; } i = i + 1 ; proof { lemma_count_boolean_extend (arr @ , i as int) ; } } assert (arr @ . take (arr . len () as int) == arr @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_105_impl.rs", "verified": true, "metadata": {"original_id": "4ba28f7ce860", "function_name": "count_true", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_16383c330ae4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool)  { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len ()  { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) , happy <==> happy_spec (s @) \ndecreases s . len () - j\ninvariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16383c330ae4", "function_name": "is_happy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2ff77b5119f3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "2ff77b5119f3", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_619cdc245f26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/replace_impl.rs", "verified": true, "metadata": {"original_id": "619cdc245f26", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8c31501366df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx\ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "8c31501366df", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_89779cf87d1f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/023-strlen_impl.rs", "verified": true, "metadata": {"original_id": "89779cf87d1f", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2854d96a6911", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 9 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 9 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2854d96a6911", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e062fcdb9291", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e062fcdb9291", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bc7008844e9a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "bc7008844e9a", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7bd15a9f2d14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)\ndecreases nums . len () - i\ninvariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_43/verina_advanced_43_impl.rs", "verified": true, "metadata": {"original_id": "7bd15a9f2d14", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dca03ef7f26c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dca03ef7f26c", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_46af5580e5a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)   { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] \ninvariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/index_wise_addition_iter_2_current.rs", "verified": true, "metadata": {"original_id": "46af5580e5a0", "function_name": "index_wise_addition", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_75c75f5ef6d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)   { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index\ndecreases arr . len () - index\ninvariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "75c75f5ef6d8", "function_name": "find_first_occurrence", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d885bab00260", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith)   { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n  { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires p > 0 , p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) , r == modp_rec (n as nat , p as nat) \ndecreases n , n - i \ninvariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d885bab00260", "function_name": "modp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_30f6aa5835fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "30f6aa5835fd", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0d3788ae0506", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >)  { return None ; }\n\n} // verus!", "target_text": "requires two_sum_precond (nums @ , target)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >) requires two_sum_precond (nums @ , target) { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_79/verina_advanced_79.rs", "verified": true, "metadata": {"original_id": "0d3788ae0506", "function_name": "two_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_842bd239fd93", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] % 2 == 0 {  return true ; }  i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ndecreases arr . len () - i \ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , decreases arr . len () - i , { if arr [i] % 2 == 0 { assert (is_even (arr [i as int])) ; return true ; } assert (! is_even (arr [i as int])) ; i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "842bd239fd93", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e21ff055c8d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e21ff055c8d8", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4b4010ca0b85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool)   { let first_len = seq [0] . len () ; for k in 1 .. seq . len ()  { if seq [k] . len () != first_len {      return false ; } }   true }\n\n} // verus!", "target_text": "requires seq . len () > 0 \nensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) \ninvariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [0] . len () == first_len) ; assert (seq [k as int] . len () != first_len) ; assert (0 <= 0 < seq . len () && 0 <= k < seq . len ()) ; assert (seq [0] . len () != seq [k as int] . len ()) ; assert (! (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ())) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; assert (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == first_len && seq [j] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "4b4010ca0b85", "function_name": "all_sequence_equal_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_280df798a05c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2u32 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "280df798a05c", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_aef9dfb8e0b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut i = a . len () - 1 ; loop  { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; }  0 }\n\n} // verus!", "target_text": "requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases i\ninvariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "aef9dfb8e0b7", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9bcb64058fda", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9bcb64058fda", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f5572a91edf7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/unverified/cal_div_impl.rs", "verified": true, "metadata": {"original_id": "f5572a91edf7", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dd33a6f40e1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_iter_3_current.rs", "verified": true, "metadata": {"original_id": "dd33a6f40e1a", "function_name": "secondSmallestAux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d6b3b5732277", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "d6b3b5732277", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6e6e83b824e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) && ! contains (& result , arr1 [i]) { result . push (arr1 [i]) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key, forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if contains (arr2 , arr1 [i]) && ! contains (& result , arr1 [i]) { result . push (arr1 [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "6e6e83b824e8", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_db7eacd5dc40", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/023-strlen_impl.rs", "verified": true, "metadata": {"original_id": "db7eacd5dc40", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_85a3f84a1454", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_ilog (x : u32 , base : u32) -> (ret : u32)   { x . ilog (base) }\n\n} // verus!", "target_text": "requires x > 0 , base > 1 \nensures ret == log (base as int , x as int) ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_ilog (x : u32 , base : u32) -> (ret : u32) requires x > 0 , base > 1 , ensures ret == log (base as int , x as int) , { x . ilog (base) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/not_finished_proof/076-is_simple_power_iter_3_current.rs", "verified": true, "metadata": {"original_id": "85a3f84a1454", "function_name": "ex_ilog", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a21112f0fe29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires concat_precond (a , b) , a . len () + b . len () <= MAX \nensures concat_postcond (a , b , & result) \ndecreases a . len () - i , b . len () - j \ninvariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_83/verina_basic_83_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a21112f0fe29", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_28778e12784d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms1_impl.rs", "verified": true, "metadata": {"original_id": "28778e12784d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3a52176b7e06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { for i in 0 .. a . len ()  { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ninvariant forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3a52176b7e06", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1dc4f0ba4ad5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_82/verina_basic_82_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1dc4f0ba4ad5", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_766276bb3784", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] != element { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] == element", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "766276bb3784", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_87ff0947783d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "87ff0947783d", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3fb35852a0d6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires square_root_precond (n as nat) , n <= 100 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32) requires square_root_precond (n as nat) , n <= 100 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_65/verina_basic_65.rs", "verified": true, "metadata": {"original_id": "3fb35852a0d6", "function_name": "square_root", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_bitmap_d13ecbc0afdf", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n\n        ;\n        self.bits.set(seq_index, bv_new);\n\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "target_text": "requires bv_new == set_bit64!(bv_old, index, bit),\n        index < 64, bv_new == bv1 | bv2, bv_new == u1 | u2, index < self@.len(), index < old(self)@.len(), self@.len() == bm@.len()\nensures get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)), forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)), u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)), bit == self@[index as int], self@ == old(self)@.update(index as int, bit), self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i])\ninvariant i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k])", "full_verified_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq_lib::*};\n\nmacro_rules! get_bit64_macro {\n    ($a:expr, $b:expr) => {{\n        (0x1u64 & ($a >> $b)) == 1\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `get_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! get_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(get_bit64_macro!($($a)*))\n    }\n}\n\nmacro_rules! set_bit64_macro {\n    ($a:expr,$b:expr, $c:expr) => {{\n        if $c {\n            $a | 1u64 << $b\n        } else {\n            $a & (!(1u64 << $b))\n        }\n    }};\n}\n\n// since this wraps with `verus_proof_macro_exprs`, should use the above `set_bit64_macro` if it is going to be executable.\n#[allow(unused_macros)]\nmacro_rules! set_bit64 {\n    ($($a:tt)*) => {\n        verus_proof_macro_exprs!(set_bit64_macro!($($a)*))\n    }\n}\n\nverus! {\n\nspec fn u64_view(u: u64) -> Seq<bool> {\n    Seq::new(64, |i: int| get_bit64!(u, i as u64))\n}\n\n#[verifier::bit_vector]\nproof fn set_bit64_proof(bv_new: u64, bv_old: u64, index: u64, bit: bool)\n    requires\n        bv_new == set_bit64!(bv_old, index, bit),\n        index < 64,\n    ensures\n        get_bit64!(bv_new, index) == bit,\n        forall|loc2: u64|\n            (loc2 < 64 && loc2 != index) ==> (get_bit64!(bv_new, loc2) == get_bit64!(bv_old, loc2)),\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or_64_proof(bv1: u64, bv2: u64, bv_new: u64)\n    requires\n        bv_new == bv1 | bv2,\n    ensures\n        forall|i: u64|\n            (i < 64) ==> get_bit64!(bv_new, i) == (get_bit64!(bv1, i) || get_bit64!(bv2, i)),\n{\n}\n\nproof fn bit_or_64_view_proof(u1: u64, u2: u64, bv_new: u64)\n    requires\n        bv_new == u1 | u2,\n    ensures\n        u64_view(bv_new) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i)),\n{\n    bit_or_64_proof(u1, u2, bv_new);\n}\n\nspec fn or_u64_relation(u1: u64, u2: u64, or_int: u64) -> bool {\n    u64_view(or_int) =~= Seq::new(64, |i: int| u64_view(u1).index(i) || u64_view(u2).index(i))\n}\n\npub struct BitMap {\n    bits: Vec<u64>,\n}\n\nimpl BitMap {\n    spec fn view(&self) -> Seq<bool> {\n        let width = self.bits@.len() * 64;\n        Seq::new(width, |i: int| u64_view(self.bits@[i / 64])[i % 64])\n    }\n\n    fn from(v: Vec<u64>) -> BitMap {\n        BitMap { bits: v }\n    }\n\n    fn get_bit(&self, index: u32) -> (bit: bool)\n        requires\n            index < self@.len(),\n        ensures\n            bit == self@[index as int],\n    {\n        // REVIEW: at this moment, usize is assumed to be 32 or 64.\n        // Therefore, if `index` is u64, verification fails due to the possibility of truncation\n        // when we begin to consider `usize` smaller than 32, this might fail again.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bucket: u64 = self.bits[seq_index];\n        get_bit64_macro!(bucket, bit_index as u64)\n    }\n\n    fn set_bit(&mut self, index: u32, bit: bool)\n        requires\n            index < old(self)@.len(),\n        ensures\n            self@ == old(self)@.update(index as int, bit),\n    {\n        // REVEIW: Same problem here with above regarding `usize`.\n        let seq_index: usize = (index / 64) as usize;\n        let bit_index: u32 = index % 64;\n        let bv_old: u64 = self.bits[seq_index];\n        let bv_new: u64 = set_bit64_macro!(bv_old, bit_index as u64, bit);\n        proof {\n            set_bit64_proof(bv_new, bv_old, bit_index as u64, bit);\n        }\n        ;\n        self.bits.set(seq_index, bv_new);\n        proof {\n            assert_seqs_equal!(\n                self.view(),\n                old(self).view().update(index as int, bit)\n            );\n        }\n        ;\n    }\n\n    // bitwise-OR for bitmap\n    fn or(&self, bm: &BitMap) -> (ret: BitMap)\n        requires\n            self@.len() == bm@.len(),\n        ensures\n            self@.len() == ret@.len(),\n            forall|i: int| 0 <= i < ret@.len() ==> ret@[i] == (self@[i] || bm@[i]),\n    {\n        let n: usize = self.bits.len();\n        let mut i: usize = 0;\n        let mut res_bits: Vec<u64> = Vec::new();\n        let mut result = BitMap { bits: res_bits };\n        while i < n\n            invariant\n                i <= n,\n                n == self.bits@.len(),\n                n == bm.bits@.len(),\n                i == result.bits.len(),\n                forall|k: int|\n                    0 <= k < i ==> or_u64_relation(self.bits@[k], bm.bits@[k], result.bits@[k]),\n                forall|k: int| 0 <= k < i * 64 ==> result@[k] == (self@[k] || bm@[k]),\n        {\n            res_bits = result.bits;\n            let u1: u64 = self.bits[i];\n            let u2: u64 = bm.bits[i];\n            let or_int: u64 = u1 | u2;\n            proof {\n                bit_or_64_view_proof(u1, u2, or_int);\n            }\n            res_bits.push(or_int);\n            result = BitMap { bits: res_bits };\n            i = i + 1;\n        }\n        result\n    }\n}\n\n} // verus!\n#[verifier::external]\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/bitmap.rs", "verified": true, "metadata": {"original_id": "verus_bitmap_d13ecbc0afdf", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cabbb977ab37", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j\ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "cabbb977ab37", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7d2690f28726", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms4_impl.rs", "verified": true, "metadata": {"original_id": "7d2690f28726", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6b228108a01b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6b228108a01b", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_assorted_demo_1dbd8b1d4e00", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nfn main() {\n    let x = 3;\n    let y = 4;\n\n}\n\n#[derive(Eq, PartialEq, Structural)]\nstruct Train {\n    cars: u64,\n}\n\nfn main2() {\n    let t = Train { cars: 10 };\n    let q = Train { cars: 10 };\n\n}\n\nspec fn mul(a: u64, b: u64) -> u64 {\n    verus_builtin::mul(a, b)\n}\n\nspec fn divides(v: u64, d: u64) -> bool {\n    exists|k: u64| mul(d, k) == v\n}\n\n#[verifier::external]\nfn gcd_external(a: u64, b: u64) -> u64 {\n    let mut i = a;\n    while i >= 1 {\n        if a % i == 0 && b % i == 0 {\n            break ;\n        }\n        i -= 1;\n    }\n    i\n}\n\n#[verifier::external_body]\nfn gcd(a: u64, b: u64) -> (result: u64)\n\n{\n    gcd_external(a, b)\n}\n\nfn main3() {\n    let x = 42;\n    let y = 182;\n    let z = gcd(x, y);\n\n    // TODO\n}\n\n} // verus!\n", "target_text": "requires a >= 0,\n        b >= 0\nensures divides(a, result),\n        divides(b, result)", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nfn main() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n#[derive(Eq, PartialEq, Structural)]\nstruct Train {\n    cars: u64,\n}\n\nfn main2() {\n    let t = Train { cars: 10 };\n    let q = Train { cars: 10 };\n    assert(t == q);\n}\n\nspec fn mul(a: u64, b: u64) -> u64 {\n    verus_builtin::mul(a, b)\n}\n\nspec fn divides(v: u64, d: u64) -> bool {\n    exists|k: u64| mul(d, k) == v\n}\n\n#[verifier::external]\nfn gcd_external(a: u64, b: u64) -> u64 {\n    let mut i = a;\n    while i >= 1 {\n        if a % i == 0 && b % i == 0 {\n            break ;\n        }\n        i -= 1;\n    }\n    i\n}\n\n#[verifier::external_body]\nfn gcd(a: u64, b: u64) -> (result: u64)\n    requires\n        a >= 0,\n        b >= 0,\n    ensures\n        divides(a, result),\n        divides(b, result),\n{\n    gcd_external(a, b)\n}\n\nfn main3() {\n    let x = 42;\n    let y = 182;\n    let z = gcd(x, y);\n    assert(divides(x, z));\n    assert(divides(y, z));\n    // TODO assert(x % z == 0);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/assorted_demo.rs", "verified": true, "metadata": {"original_id": "verus_assorted_demo_1dbd8b1d4e00", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_59dad8f24bf2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires set_to_seq_precond (s @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >) requires set_to_seq_precond (s @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_89/verina_basic_89_iter_0_original.rs", "verified": true, "metadata": {"original_id": "59dad8f24bf2", "function_name": "set_to_seq", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5cb4af354fe7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "5cb4af354fe7", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fcf5cbfc20af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {    return false ; } i = i + 1 ; }   true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "fcf5cbfc20af", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8714d34e0d77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "8714d34e0d77", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c64127304c51", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32)   { 0 }\n\n} // verus!", "target_text": "requires 0 < x < y \nensures z >= 0 && z <= y && z != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c64127304c51", "function_name": "m1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d917e3667e09", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - idx\ninvariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d917e3667e09", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a69f60f76982", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a69f60f76982", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5a13781737ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] \ndecreases a . len () - i\ninvariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "5a13781737ff", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_81e2371004ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "81e2371004ee", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_50409ef99fb0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_55/verina_basic_55_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "50409ef99fb0", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_datatypes_1d964de00785", "task": "task_a", "input_text": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    {\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n\n    {\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n\n}\n\n} // verus!\n", "target_text": "requires len(list) <= 0xffffffffffffffff, start + length <= 0xffff_ffff\nensures r == len(list), len::<u32>(&r) == length, n == len(list),\n        decreases len(iter), len::<u32>(&r) == length,\n    decreases length\ndecreases list, len(iter), length\ninvariant len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list)", "full_verified_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/datatypes.rs", "verified": true, "metadata": {"original_id": "verus_datatypes_1d964de00785", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_17101b6af3eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_103/verina_basic_103_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "17101b6af3eb", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fdff90987a6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len ()  { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fdff90987a6f", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cdfcdd2992a6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32)   { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "requires d > 0, count_sum_divisible_by_precond (n as nat , d as nat)\nensures result == is_sum_divisible_by (x as nat , d as nat), result == sum_of_digits (x as nat), result == count_sum_divisible_by_spec (n as nat , d as nat)\ndecreases n, x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cdfcdd2992a6", "function_name": "count_sum_divisible_by", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_9a38628dfd06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut i = 1 ; while i < lists . len ()  { if lists [i] . len () < min_length { min_length = lists [i] . len () ; } i += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - i\ninvariant 1 <= i <= lists . len () , exists | j : int | # ! [auto] 0 <= j < i && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < i ==> min_length <= lists [j] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut i = 1 ; while i < lists . len () invariant 1 <= i <= lists . len () , exists | j : int | # ! [auto] 0 <= j < i && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < i ==> min_length <= lists [j] . len () , decreases lists . len () - i { if lists [i] . len () < min_length { min_length = lists [i] . len () ; } i += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/smallest_list_length_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9a38628dfd06", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5a105fbd6d3c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)   { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] \ninvariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/index_wise_addition_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5a105fbd6d3c", "function_name": "index_wise_addition", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ca25f043cf9a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ca25f043cf9a", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b8721ee3399f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32)   { let mut i = N ; while i > 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b8721ee3399f", "function_name": "down_while_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d166998ea3fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn square_nums (nums : & Vec < i32 >) -> (squared : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < nums . len ()  {   let squared_val = nums [i] * nums [i] ; result . push (squared_val) ;   i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) \nensures nums . len () == squared . len () , forall | k : int | 0 <= k < nums . len () ==> (# [trigger] squared [k] == nums [k] * nums [k]) \ndecreases nums . len () - i \ninvariant i <= nums . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == nums [k] * nums [k] , forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn square_nums (nums : & Vec < i32 >) -> (squared : Vec < i32 >) requires forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) , ensures nums . len () == squared . len () , forall | k : int | 0 <= k < nums . len () ==> (# [trigger] squared [k] == nums [k] * nums [k]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < nums . len () invariant i <= nums . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == nums [k] * nums [k] , forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) , decreases nums . len () - i , { assert (0 <= i < nums . len ()) ; assert (0 <= nums [i as int] * nums [i as int] < MAX) ; let squared_val = nums [i] * nums [i] ; result . push (squared_val) ; assert (result . len () == i + 1) ; assert (result [i as int] == nums [i as int] * nums [i as int]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_8_impl.rs", "verified": true, "metadata": {"original_id": "d166998ea3fd", "function_name": "square_nums", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_82ccc346b8b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_impl.rs", "verified": true, "metadata": {"original_id": "82ccc346b8b1", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b9ac506e9e48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "b9ac506e9e48", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_31d46c40b195", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) \nensures result == is_digit_spec (c) , all_digits_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "31d46c40b195", "function_name": "all_digits", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7d6eb70aa064", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "7d6eb70aa064", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_197460015e86", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if arr [index] != element { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> arr [i] == element ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> arr [i] == element , decreases arr . len () - index { if arr [index] != element { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "197460015e86", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3d019cd3391a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "3d019cd3391a", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_503cbef31bfa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "503cbef31bfa", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5a080927b1e0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "5a080927b1e0", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab94299eda92", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ab94299eda92", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a7e6797bc86a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a7e6797bc86a", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ba5d668f31cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - idx\ninvariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "ba5d668f31cf", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ce751345aff0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ninvariant forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "ce751345aff0", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_62a8cc71df06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "62a8cc71df06", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_990bbedc39eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "990bbedc39eb", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_99f8cb03a0d2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "99f8cb03a0d2", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_modes_48bf1a515123", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n     // succeeds\n     // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n         // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n         // succeeds\n         // FAILS\n\n         // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n         // succeeds\n         // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n\n          // succeeds\n          // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n\n            lemma_min(100, 200);\n        }\n         // succeeds\n         // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n         // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n         // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n      // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n     // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n     // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "ensures m == min3(x as int, y as int, z as int), min(x,y) <= x && min(x,y) <= y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/modes.rs", "verified": true, "metadata": {"original_id": "verus_modes_48bf1a515123", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f086a67575eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f086a67575eb", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4ed022cb7ba8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "4ed022cb7ba8", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1b206db906d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "1b206db906d0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8ee1810c4c9f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) { let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len ()  { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "target_text": "ensures (\ndecreases arr @ . len () - i\ninvariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) ensures ({ let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len () invariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () , decreases arr @ . len () - i { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/136-largest_smallest_integers_impl.rs", "verified": true, "metadata": {"original_id": "8ee1810c4c9f", "function_name": "largest_smallest_integers", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6711671e2eaa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires arr . len () >= 0 \nensures num >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32) requires arr . len () >= 0 , ensures num >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_countnonzero.rs", "verified": true, "metadata": {"original_id": "6711671e2eaa", "function_name": "nonzero", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_31dbc32b0792", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_iter_1_current.rs", "verified": true, "metadata": {"original_id": "31dbc32b0792", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_267d2b8fb8c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop  { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases high - low\ninvariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "267d2b8fb8c2", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7e6d422f0e93", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7e6d422f0e93", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a0d27fd3adb2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "a0d27fd3adb2", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6c777e6bc825", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut pos = 0 ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { pos = i ; break ; } i += 1 ; } while i < a . len ()  { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i, a . len () - i\ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/last_position_impl.rs", "verified": true, "metadata": {"original_id": "6c777e6bc825", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_452c4b73a53b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "452c4b73a53b", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7e499364facb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  {   let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "7e499364facb", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7a7642bc0144", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j\ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "7a7642bc0144", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e18070090d7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos  { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i , p - j , (l - at_pos) - k \ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i , { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j , { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos invariant k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases (l - at_pos) - k , { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_64/verina_basic_64_impl.rs", "verified": true, "metadata": {"original_id": "e18070090d7b", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3815f6d0de6e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "3815f6d0de6e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_671064e1a0ef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "671064e1a0ef", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6d6abc8ecfff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j \ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j , { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "6d6abc8ecfff", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_26d9db836f76", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_55/verina_basic_55_iter_1_current.rs", "verified": true, "metadata": {"original_id": "26d9db836f76", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9dc8ed2f674a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires c <= n , n == a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool) requires c <= n , n == a . len () , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9dc8ed2f674a", "function_name": "fillK", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c515cba66359", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for j in 0 .. text . len ()  { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c515cba66359", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_c1a7cddc6283", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c1a7cddc6283", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_674054c9accf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires old (v) . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code.rs", "verified": true, "metadata": {"original_id": "674054c9accf", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_af0c6c2421cd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_impl.rs", "verified": true, "metadata": {"original_id": "af0c6c2421cd", "function_name": "max_array_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2d94ab73a521", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant result @ == a @ . subrange (0 , i as int) { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2d94ab73a521", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_94777ccebe24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires prev_nums . len () == lengths . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize) requires prev_nums . len () == lengths . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_32/verina_advanced_32_iter_0_original.rs", "verified": true, "metadata": {"original_id": "94777ccebe24", "function_name": "find_length_ending_at_curr", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_49b80751079c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { for i in 0 .. l . len ()  { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ninvariant forall | j : int | 0 <= j < i ==> l [j] < t ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/052-below-threshold_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "49b80751079c", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_vecdeque_test_3d17853271e4", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n\n    v2.push_back(5);\n\n    v2.push_back(7);\n\n    v2.insert(1, 6);\n\n    v1.append(&mut v2);\n\n    v1.remove(2);\n\n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n\n    {\n\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "target_text": "invariant i == it.pos,\n            it.elements == seq![10u32, 11u32]", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse std::collections::VecDeque;\nuse vstd::pervasive::runtime_assert;\n#[allow(unused_imports)]\nuse vstd::std_specs::vecdeque::*;\nuse vstd::prelude::*;\n\nverus! {\n\nfn vec_deque_test()\n{\n    let mut v1: VecDeque<u32> = VecDeque::<u32>::new();\n    let mut v2: VecDeque<u32> = VecDeque::<u32>::new();\n    v1.push_back(3);\n    v1.push_back(4);\n    let front = v1.pop_front();\n    runtime_assert(front.is_some());\n    runtime_assert(front.unwrap() == 3);\n    assert(v1@ == seq![4u32]);\n\n    v2.push_back(5);\n    assert(v2.len() == 1);\n    v2.push_back(7);\n    assert(v2@.len() == 2);\n    v2.insert(1, 6);\n    assert(v2@ == seq![5u32, 6u32, 7u32]);\n\n    v1.append(&mut v2);\n    assert(v2@.len() == 0);\n    assert(v1@.len() == 4);\n    assert(v1@ == seq![4u32, 5u32, 6u32, 7u32]);\n    v1.remove(2);\n    assert(v1@ == seq![4u32, 5u32, 7u32]);\n    \n    let mut x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 4);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 5);\n    x = v1.pop_front();\n    runtime_assert(x.is_some());\n    runtime_assert(x.unwrap() == 7);\n    x = v1.pop_front();\n    runtime_assert(x.is_none());\n\n    v1.push_back(10);\n    v1.push_back(11);\n    assert(v1@ == seq![10u32, 11u32]);\n\n    let mut i: usize = 0;\n    for x in it: v1.iter()\n        invariant\n            i == it.pos,\n            it.elements == seq![10u32, 11u32],\n    {\n        assert(x > 9);\n        assert(x < 12);\n        i = i + 1;\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/std_test/vecdeque_test.rs", "verified": true, "metadata": {"original_id": "verus_vecdeque_test_3d17853271e4", "function_name": "", "has_requires": false, "has_ensures": false, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8620ff43a009", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "8620ff43a009", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_010f11f6971e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "010f11f6971e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ed29a7fd0a81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z' { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "ed29a7fd0a81", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0314439c145f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "0314439c145f", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_307b699e2cfc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs5_impl.rs", "verified": true, "metadata": {"original_id": "307b699e2cfc", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e9bb4ef1edad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e9bb4ef1edad", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_23c7990adbdb", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64)   {  arr [i] }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) \nensures ret == i + 2 , ret == arr @ [i as int] ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/trigger_impl.rs", "verified": true, "metadata": {"original_id": "23c7990adbdb", "function_name": "get_element_check_property", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9ffef5e1c6ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9ffef5e1c6ff", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fe45d7bb9bcc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "fe45d7bb9bcc", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_18d0b3583f5d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s12if_impl.rs", "verified": true, "metadata": {"original_id": "18d0b3583f5d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c70743850c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs5_impl.rs", "verified": true, "metadata": {"original_id": "7c70743850c0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dd7ca91f442d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs4_impl.rs", "verified": true, "metadata": {"original_id": "dd7ca91f442d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7b8fc5bc2115", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { let mut i : usize = 0 ; while i < list1 . len ()  { let mut j : usize = 0 ; while j < list2 . len ()  { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) \ndecreases list1 . len () - i, list2 . len () - j\ninvariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { let mut i : usize = 0 ; while i < list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , decreases list1 . len () - i { let mut j : usize = 0 ; while j < list2 . len () invariant i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , decreases list2 . len () - j { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_431_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7b8fc5bc2115", "function_name": "has_common_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9dba26c5f332", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32)   { let mut i = N ; while i > 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9dba26c5f332", "function_name": "down_while_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c52c4e10370a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut k : usize = 0 ; while k <= p  { let mut l : usize = p + 1 ; while l < arr . len ()  { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - k, arr . len () - l\ninvariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c52c4e10370a", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4cd5bcf81648", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_prime_precond (n as nat) , n <= 0xFFFF ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool) requires is_prime_precond (n as nat) , n <= 0xFFFF , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_28/verina_basic_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4cd5bcf81648", "function_name": "is_prime", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bfb56c71098d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == circle { return i ; } i = i + 1 ; } a . len () }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () \ndecreases a . len () - i\ninvariant 0 <= i <= a . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () decreases a . len () - i { if a [i] == circle { return i ; } i = i + 1 ; } a . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "bfb56c71098d", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_22db67d09ce2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_44/verina_advanced_44_iter_2_current.rs", "verified": true, "metadata": {"original_id": "22db67d09ce2", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_bst_map_type_invariant_62d3bbe5efb1", "task": "task_a", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n\n        {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n\n        {\n        if key == self.key {\n            self.value = value;\n\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n\n    {\n\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n\n        {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n\n        {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n\n    {\n\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n         {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n         { Some(&self.as_map()[key]) } else { None }),\n        {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n\n            Self::get_from_optional(&self.left, key)\n        } else {\n\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    tree_map.delete(17);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "requires old(node).is_some() ==> old(node).unwrap().well_formed(), old(self).well_formed(), old(node).is_some() ==> old(node).unwrap().well_formed(), old(node).is_some(),\n            old(node).unwrap().well_formed(), node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node, self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key)\nensures s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value), self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem, self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node)\ndecreases node_opt, self, self, *old(node), *old(self), *old(node), *old(node), node, self", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\n// ANCHOR: well_formed_with_attr\nimpl<V> TreeMap<V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed_with_attr\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<u64, V>::empty()\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\n// ANCHOR: insert\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n// ANCHOR_END: insert\n\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\n// ANCHOR: delete\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        ensures\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n// ANCHOR_END: delete\n\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\n// ANCHOR: get\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: example_use\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: example_use\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map_type_invariant.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_type_invariant_62d3bbe5efb1", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_82193e2a0593", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "82193e2a0593", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e3ea3ba5f840", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e3ea3ba5f840", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c401fe1ab01f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "c401fe1ab01f", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_890c0a971069", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "890c0a971069", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ed503af431ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "ed503af431ee", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_419b0e2e73f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "419b0e2e73f0", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b197612d2de2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b197612d2de2", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0e8596649a9d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "0e8596649a9d", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6288996593a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool)  { if s . len () < 3 { return false ; } let mut j = 1 ; while j < s . len () - 1  { if ! three_distinct (s , j) { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) , happy <==> happy_spec (s @) \ndecreases s . len () - j \ninvariant 1 <= j <= s . len () , forall | i : int | 0 < i < j && i + 1 < s . len () ==> three_distinct_spec (s @ , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j = 1 ; while j < s . len () - 1 invariant 1 <= j <= s . len () , forall | i : int | 0 < i < j && i + 1 < s . len () ==> three_distinct_spec (s @ , i) , decreases s . len () - j , { if ! three_distinct (s , j) { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "6288996593a1", "function_name": "is_happy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_96ccb9a459e0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { let mut i = 0 ; while i < chords . len ()  { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } { let mut j = i + 1 ; while j < chords . len ()  { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)\ndecreases chords . len () - i, chords . len () - j\ninvariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==>, 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { let mut i = 0 ; while i < chords . len () invariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - i { let mut j = i + 1 ; while j < chords . len () invariant 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - j { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_13/verina_advanced_13_iter_3_current.rs", "verified": true, "metadata": {"original_id": "96ccb9a459e0", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f6c55e5b2b96", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_22/verina_advanced_22.rs", "verified": true, "metadata": {"original_id": "f6c55e5b2b96", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_5b15e39211d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] \ndecreases a . len () - i , b . len () - j \ninvariant i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "5b15e39211d0", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8a9e0ab031c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs3_impl.rs", "verified": true, "metadata": {"original_id": "8a9e0ab031c0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4809c259dae3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/havoc_inline_post_impl.rs", "verified": true, "metadata": {"original_id": "4809c259dae3", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6fb8f0bcc1c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { for k in 1 .. lst . len ()  { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ninvariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { for k in 1 .. lst . len () invariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] , { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "6fb8f0bcc1c7", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verismo_subseq_500b64c32e59", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier(inline)]\npub open spec fn sub_element<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>, k: int) -> bool {\n    &&& (0 <= #[trigger] idx[k] < s.len())\n    &&& (subs[k] === s[idx[k]])\n}\n\npub open spec fn is_subseq_via_index<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>) -> bool {\n    &&& (forall|k: int| (0 <= k < idx.len()) ==> sub_element(subs, s, idx, k))\n    &&& subs.len() == idx.len()\n    &&& subs.len() <= s.len()\n}\n\npub proof fn proof_empty_is_subs<T>(s: Seq<T>)\n\n{\n}\n\npub proof fn proof_subs_remove<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs0.remove(i);\n    let subs_idx1 = subs_idx0.remove(i);\n    else {\n\n        }\n    }\n\n}\n\npub proof fn proof_subs_push<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs.push(s[i]);\n    let subs_idx1 = subs_idx.push(i);\n\n    else {\n\n        }\n    }\n\n}\n\npub proof fn lemma_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: Seq<int>,\n    removed_idx: Seq<int>,\n    i: int,\n)  //-> (ret: (Seq<T>, Seq<T>, Seq<int>, Seq<int>))\n\n{\n    let keep0 = keep;\n    let keep_idx0 = keep_idx;\n    let (removed0, removed_idx0) = (removed, removed_idx);\n\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n}\n\npub proof fn proof_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: &mut Seq<int>,\n    removed_idx: &mut Seq<int>,\n    i: int,\n)\n\n{\n    let (keep0, keep_idx0) = (keep, *keep_idx);\n    let (removed0, removed_idx0) = (removed, *removed_idx);\n\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n    *keep_idx = keep_idx1;\n    *removed_idx = removed_idx1;\n}\n\n} // verus!\n", "target_text": "requires is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < subs_idx.len(), is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < s.len(),\n        subs.len() < s.len(), is_subseq_via_index(keep, s, keep_idx),\n        is_subseq_via_index(removed, s, removed_idx),\n        0 <= i < keep_idx.len(),\n        keep.len() + removed.len() == s.len(), is_subseq_via_index(keep, s, *old(keep_idx)),\n        is_subseq_via_index(removed, s, *old(removed_idx)),\n        0 <= i < old(keep_idx).len(),\n        keep.len() + removed.len() == s.len()\nensures is_subseq_via_index(Seq::empty(), s, Seq::empty()), is_subseq_via_index(subs.remove(i), s, subs_idx.remove(i)),\n        subs.remove(i).len() == subs.len() - 1, is_subseq_via_index(subs.push(s[i]), s, subs_idx.push(i)),\n        subs.push(s[i]).len() == subs.len() + 1,\n        subs_idx.push(i).len() == subs_idx.len() + 1, is_subseq_via_index(keep.remove(i), s, keep_idx.remove(i)),\n        is_subseq_via_index(\n            removed.push(s[keep_idx[i]]),\n            s,\n            removed_idx.push(keep_idx[i]),\n        ),\n//ret === (keep.remove(i), removed.push(s[keep_idx[i]]), keep_idx.remove(i), removed_idx.push(keep_idx[i])), is_subseq_via_index(keep.remove(i), s, *keep_idx),\n        is_subseq_via_index(removed.push(s[old(keep_idx)[i]]), s, *removed_idx),\n        *keep_idx === (old(keep_idx).remove(i)),\n        *removed_idx === old(removed_idx).push(old(keep_idx)[i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier(inline)]\npub open spec fn sub_element<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>, k: int) -> bool {\n    &&& (0 <= #[trigger] idx[k] < s.len())\n    &&& (subs[k] === s[idx[k]])\n}\n\npub open spec fn is_subseq_via_index<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>) -> bool {\n    &&& (forall|k: int| (0 <= k < idx.len()) ==> sub_element(subs, s, idx, k))\n    &&& subs.len() == idx.len()\n    &&& subs.len() <= s.len()\n}\n\npub proof fn proof_empty_is_subs<T>(s: Seq<T>)\n    ensures\n        is_subseq_via_index(Seq::empty(), s, Seq::empty()),\n{\n}\n\npub proof fn proof_subs_remove<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < subs_idx.len(),\n    ensures\n        is_subseq_via_index(subs.remove(i), s, subs_idx.remove(i)),\n        subs.remove(i).len() == subs.len() - 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs0.remove(i);\n    let subs_idx1 = subs_idx0.remove(i);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() - 1);\n        assert(0 <= k < subs_idx0.len());\n        assert(0 <= k < subs0.len());\n        assert(0 <= k < subs1.len());\n        if k < i {\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(subs_idx0[k + 1] == subs_idx1[k]);\n            assert(subs0[k + 1] === subs1[k]);\n            assert(sub_element(subs0, s, subs_idx0, k + 1));\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n}\n\npub proof fn proof_subs_push<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < s.len(),\n        subs.len() < s.len(),\n    ensures\n        is_subseq_via_index(subs.push(s[i]), s, subs_idx.push(i)),\n        subs.push(s[i]).len() == subs.len() + 1,\n        subs_idx.push(i).len() == subs_idx.len() + 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs.push(s[i]);\n    let subs_idx1 = subs_idx.push(i);\n    assert(subs_idx1.len() == subs_idx0.len() + 1);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() + 1);\n        if (0 <= k < subs_idx0.len()) {\n            assert(0 <= k < subs0.len());\n            assert(0 <= k < subs1.len());\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(k == subs_idx0.len());\n            assert(i == subs_idx1[k]);\n            assert(s[i] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n    assert(is_subseq_via_index(subs1, s, subs_idx1));\n}\n\npub proof fn lemma_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: Seq<int>,\n    removed_idx: Seq<int>,\n    i: int,\n)  //-> (ret: (Seq<T>, Seq<T>, Seq<int>, Seq<int>))\n    requires\n        is_subseq_via_index(keep, s, keep_idx),\n        is_subseq_via_index(removed, s, removed_idx),\n        0 <= i < keep_idx.len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, keep_idx.remove(i)),\n        is_subseq_via_index(\n            removed.push(s[keep_idx[i]]),\n            s,\n            removed_idx.push(keep_idx[i]),\n        ),\n//ret === (keep.remove(i), removed.push(s[keep_idx[i]]), keep_idx.remove(i), removed_idx.push(keep_idx[i])),\n\n{\n    let keep0 = keep;\n    let keep_idx0 = keep_idx;\n    let (removed0, removed_idx0) = (removed, removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n}\n\npub proof fn proof_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: &mut Seq<int>,\n    removed_idx: &mut Seq<int>,\n    i: int,\n)\n    requires\n        is_subseq_via_index(keep, s, *old(keep_idx)),\n        is_subseq_via_index(removed, s, *old(removed_idx)),\n        0 <= i < old(keep_idx).len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, *keep_idx),\n        is_subseq_via_index(removed.push(s[old(keep_idx)[i]]), s, *removed_idx),\n        *keep_idx === (old(keep_idx).remove(i)),\n        *removed_idx === old(removed_idx).push(old(keep_idx)[i]),\n{\n    let (keep0, keep_idx0) = (keep, *keep_idx);\n    let (removed0, removed_idx0) = (removed, *removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n    *keep_idx = keep_idx1;\n    *removed_idx = removed_idx1;\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verismo/source/verismo/src/tspec/seqlib/subseq.rs", "verified": true, "metadata": {"original_id": "verismo_subseq_500b64c32e59", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7ce97dcccc6c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7ce97dcccc6c", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_21130a95411e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m\nensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/WIP/WIP__mcontained_iter_0_original.rs", "verified": true, "metadata": {"original_id": "21130a95411e", "function_name": "mcontained", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cba32b42d8d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cba32b42d8d3", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0060035f6dab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0060035f6dab", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_733f0ff599ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos  { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len ()  { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases pos - i , a . len () - j \ninvariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "733f0ff599ae", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_983543276d23", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_103/verina_basic_103_iter_1_current.rs", "verified": true, "metadata": {"original_id": "983543276d23", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_513018466523", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_82/verina_basic_82_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "513018466523", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_invariants_effffa8a5a18", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\n// ANCHOR: fib_spec\nspec fn fib(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib((n - 2) as nat) + fib((n - 1) as nat)\n    }\n}\n// ANCHOR_END: fib_spec\n\n// ANCHOR: fib_is_mono\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n\n    {\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fib_is_monotonic(i, (j - 1) as nat);\n        lemma_fib_is_monotonic(i, (j - 2) as nat);\n    }\n}\n// ANCHOR_END: fib_is_mono\n\n/*\n// ANCHOR: fib_impl_no_proof\nfn fib_impl(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n    {\n        i = i + 1;\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_impl_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_no_proof\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n\n{\n}\n// ANCHOR_END: fib_mono_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_skeleton\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        assume(false);\n    }\n\n}\n// ANCHOR_END: fib_mono_skeleton\n*/\n\n// ANCHOR: fib_final\nfn fib_impl(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_final\n\n// ANCHOR: fib_checked\nfn fib_checked(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.unwrap()\n}\n// ANCHOR_END: fib_checked\n\n// ANCHOR: fib_checked_no_precondition\nfn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)\n     {\n            Some(x) => x == fib(n as nat),\n            None => fib(n as nat) > u64::MAX,\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.to_option()\n}\n// ANCHOR_END: fib_checked_no_precondition\n\n// ANCHOR: bank_spec\nspec fn always_non_negative(s: Seq<i64>) -> bool\n{\n    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0\n}\n\nspec fn sum(s: Seq<i64>) -> int\n    {\n    if s.len() == 0 {\n        0\n    } else {\n        sum(s.drop_last()) + s.last()\n    }\n}\n// ANCHOR_END: bank_spec\n\n/*\n// ANCHOR: bank_no_proof\nfn non_negative(operations: &[i64]) -> (r: bool)\n\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n    {\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_no_proof\n*/\n\n// ANCHOR: bank_final\nfn non_negative(operations: &[i64]) -> (r: bool)\n\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n\n    {\n\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_final\n\nfn main() {\n}\n\n} // verus!\n\n", "target_text": "requires i <= j, fib(n as nat) <= u64::MAX, i <= j, i <= j, fib(n as nat) <= u64::MAX, fib(n as nat) <= u64::MAX\nensures fib(i) <= fib(j), result == fib(n as nat), fib(i) <= fib(j), fib(i) <= fib(j), result == fib(n as nat), result == fib(n as nat), match result, r == always_non_negative(operations@), r == always_non_negative(operations@), fib(i) <= fib(j),\n    decreases j - i\ndecreases n, j - i, n - i, n - i, n - i, s.len()\ninvariant 0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur == fib(i as nat),\n            prev == fib((i - 1) as nat), 0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat), 0 < i <= n,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat), s == sum(operations@.take(i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\n// ANCHOR: fib_spec\nspec fn fib(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fib((n - 2) as nat) + fib((n - 1) as nat)\n    }\n}\n// ANCHOR_END: fib_spec\n\n// ANCHOR: fib_is_mono\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fib_is_monotonic(i, (j - 1) as nat);\n        lemma_fib_is_monotonic(i, (j - 2) as nat);\n    }\n}\n// ANCHOR_END: fib_is_mono\n\n/*\n// ANCHOR: fib_impl_no_proof\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n    {\n        i = i + 1;\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_impl_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_no_proof\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n}\n// ANCHOR_END: fib_mono_no_proof\n*/\n\n/*\n// ANCHOR: fib_mono_skeleton\nproof fn lemma_fib_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fib(i) <= fib(j),\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        assume(false);\n    }\n\n}\n// ANCHOR_END: fib_mono_skeleton\n*/\n\n// ANCHOR: fib_final\nfn fib_impl(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur == fib(i as nat),\n            prev == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        proof {\n            lemma_fib_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n// ANCHOR_END: fib_final\n\n// ANCHOR: fib_checked\nfn fib_checked(n: u64) -> (result: u64)\n    requires\n        fib(n as nat) <= u64::MAX\n    ensures\n        result == fib(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fib(n as nat) <= u64::MAX,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.unwrap()\n}\n// ANCHOR_END: fib_checked\n\n// ANCHOR: fib_checked_no_precondition\nfn fib_checked_no_precondition(n: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(x) => x == fib(n as nat),\n            None => fib(n as nat) > u64::MAX,\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    let mut prev: CheckedU64 = CheckedU64::new(0);\n    let mut cur: CheckedU64 = CheckedU64::new(1);\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            cur@ == fib(i as nat),\n            prev@ == fib((i - 1) as nat),\n        decreases n - i,\n    {\n        i = i + 1;\n        let new_cur = cur.add_checked(&prev);\n        prev = cur;\n        cur = new_cur;\n    }\n    cur.to_option()\n}\n// ANCHOR_END: fib_checked_no_precondition\n\n// ANCHOR: bank_spec\nspec fn always_non_negative(s: Seq<i64>) -> bool\n{\n    forall|i: int| 0 <= i <= s.len() ==> sum(#[trigger] s.take(i)) >= 0    \n}\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        sum(s.drop_last()) + s.last()\n    }\n}\n// ANCHOR_END: bank_spec\n\n/*\n// ANCHOR: bank_no_proof\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n    {\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_no_proof\n*/\n\n// ANCHOR: bank_final\nfn non_negative(operations: &[i64]) -> (r: bool)\n    ensures\n        r == always_non_negative(operations@),\n{\n    let mut s = 0i128;\n    for i in 0usize..operations.len()\n        invariant\n            s == sum(operations@.take(i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operations@.take(j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,\n    {\n        assert(operations@.take(i as int) =~= operations@.take(\n            (i + 1) as int,\n        ).drop_last());\n        s = s + operations[i] as i128;\n        if s < 0 {\n            return false;\n        }\n    }\n    true\n}\n// ANCHOR_END: bank_final\n\n\nfn main() {\n}\n\n} // verus!\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/invariants.rs", "verified": true, "metadata": {"original_id": "verus_invariants_effffa8a5a18", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_rc_5dc2d964df07", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerRc<S> {\n    pub rc_cell: PCell<u64>,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: cell::PointsTo<u64>,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n        &&& self.rc_perm@.pcell == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerRc<S> {\n    spec fn wf(self, cell: PCell<u64>) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyRc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerRc<S>>,\n\n        pub rc_cell: Ghost< PCell<u64> >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyRc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);\n        let inner_rc = InnerRc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n\n            assume(count < 100000000);\n\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n\n    fn dispose(self)\n\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n\n                // we still have to write back to the `inner_rc` to restore the invariant\n                // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            }\n\n        });\n\n        if count < 2 {\n            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyRc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyRc::new(Sequence::Nil);\n    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "target_text": "requires self.wf(), self.wf(), self.wf()\nensures rc.wf(),\n            rc@ == s, *s == self@, s.wf() && s@ == self@\ninvariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>), // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof", "full_verified_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerRc<S> {\n    pub rc_cell: PCell<u64>,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerRc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: cell::PointsTo<u64>,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PCell<u64>) -> bool {\n        &&& self.rc_perm@.pcell == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerRc<S> {\n    spec fn wf(self, cell: PCell<u64>) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyRc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerRc<S>>,\n\n        pub rc_cell: Ghost< PCell<u64> >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyRc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(1);\n        let inner_rc = InnerRc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = LocalInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyRc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n        let tracked new_reader;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            let count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n\n            assume(count < 100000000);\n\n            let count = count + 1;\n            inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n            proof {\n                new_reader = self.inst.borrow().do_clone(\n                    reader.element(),\n                    &mut rc_token,\n                    &reader);\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n        MyRc {\n            inst: Tracked(self.inst.borrow().clone()),\n            inv: Tracked(self.inv.borrow().clone()),\n            reader: Tracked(new_reader),\n            ptr: self.ptr,\n            rc_cell: Ghost(self.rc_cell@),\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyRc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n\n        open_local_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.take(Tracked(&mut rc_perm));\n            if count >= 2 {\n                let count = count - 1;\n                inner_rc_ref.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inst.dec_basic(\n                        reader.element(),\n                        &mut rc_token,\n                        reader);\n                }\n            } else {\n                let tracked mut inner_rc_perm = inst.dec_to_zero(\n                    reader.element(),\n                    &mut rc_token,\n                    reader);\n\n                let inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n\n                // we still have to write back to the `inner_rc` to restore the invariant\n                // even though inner_rc has been moved onto the stack here.\n                // so this will probably get optimized out\n                let count = count - 1;\n                inner_rc.rc_cell.put(Tracked(&mut rc_perm), count);\n\n                proof {\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                }\n            }\n\n            proof { g = GhostStuff { rc_perm, rc_token }; }\n        });\n\n        if count < 2 {\n            ptr.free(Tracked(inner_rc_perm_opt.tracked_unwrap()));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyRc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyRc::new(Sequence::Nil);\n    let a5 = MyRc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyRc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyRc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/rc.rs", "verified": true, "metadata": {"original_id": "verus_rc_5dc2d964df07", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_657e7c8ca61d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "657e7c8ca61d", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_57b6f7edc3e1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "57b6f7edc3e1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_501c3075c253", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "501c3075c253", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d196e324da0e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d196e324da0e", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3b57b39f41dc", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type CKey = SHTKey ;\n# [derive (Eq , PartialEq , Hash)] pub struct SHTKey { pub ukey : u64 , }\npub type AbstractKey = SHTKey ;\npub open spec fn valid_key (key : AbstractKey) -> bool { true }\npub fn is_key_valid (key : & CKey) -> (b : bool)  { true }\n\n} // verus!", "target_text": "ensures b == valid_key (* key)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type CKey = SHTKey ;\n# [derive (Eq , PartialEq , Hash)] pub struct SHTKey { pub ukey : u64 , }\npub type AbstractKey = SHTKey ;\npub open spec fn valid_key (key : AbstractKey) -> bool { true }\npub fn is_key_valid (key : & CKey) -> (b : bool) ensures b == valid_key (* key) { true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "3b57b39f41dc", "function_name": "is_key_valid", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_600f6b9b3f47", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "600f6b9b3f47", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_09be92538d29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)   { let mut i = 0 ; while i < nums . len ()  { let mut j = i + 1 ; while j < nums . len ()  { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN \nensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target \ndecreases nums . len () - i, nums . len () - j\ninvariant 0 <= i <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , 0 <= i < nums . len () , i + 1 <= j <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , forall | jj : int | (i as int) < jj < j ==> nums [i as int] + nums [jj] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , decreases nums . len () - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () , i + 1 <= j <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , forall | jj : int | (i as int) < jj < j ==> nums [i as int] + nums [jj] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "09be92538d29", "function_name": "pairs_sum_to_zero", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_be582711e490", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for idx in 0 .. arr . len ()  { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for idx in 0 .. arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_808_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "be582711e490", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_92c02d14d870", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_97/verina_basic_97_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "92c02d14d870", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6f3047680232", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nfn task_code (sequence : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires task_code_precond (sequence @ . map (| i , x | x as int))\nensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int)))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_75/verina_advanced_75_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6f3047680232", "function_name": "task_code", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b4ae1e7fa402", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b4ae1e7fa402", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_33a22d864556", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "33a22d864556", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_48b9bb559061", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_streak_precond (nums @)\nensures longest_increasing_streak_postcond (nums @ , result as nat)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize) requires longest_increasing_streak_precond (nums @) ensures longest_increasing_streak_postcond (nums @ , result as nat) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_30/verina_advanced_30.rs", "verified": true, "metadata": {"original_id": "48b9bb559061", "function_name": "longest_increasing_streak", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c99829d20b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7c99829d20b4", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_721602857b80", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "721602857b80", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a424a7fdc86c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a424a7fdc86c", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bd8af3d608ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { for i in 0 .. a . len ()  { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ninvariant forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_impl.rs", "verified": true, "metadata": {"original_id": "bd8af3d608ec", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_dba398f0c0c8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "dba398f0c0c8", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b005945d294e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b005945d294e", "function_name": "M", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_26c8c558218f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { for k in 1 .. lst . len ()  { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ninvariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { for k in 1 .. lst . len () invariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] , { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_sorted_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "26c8c558218f", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_286ab52cb934", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_82/verina_basic_82_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "286ab52cb934", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_70d2271b1232", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "70d2271b1232", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d7a8db92880e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len ()  { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len ()  { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "target_text": "ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , already_added == (exists | m : int | 0 <= m < k && result [m] == elem) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len () invariant found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len () invariant already_added == (exists | m : int | 0 <= m < k && result [m] == elem) , { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d7a8db92880e", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9696f70fcf24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m \ndecreases a . len () - idx \ninvariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9696f70fcf24", "function_name": "MaxA", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_05bad4e9f97a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "05bad4e9f97a", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d74774ff10c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires unique_sorted_precond (arr @)\nensures unique_sorted_postcond (arr @ , result @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @) ensures unique_sorted_postcond (arr @ , result @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_81/verina_advanced_81.rs", "verified": true, "metadata": {"original_id": "d74774ff10c7", "function_name": "unique_sorted", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1dc0aa7a92d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "1dc0aa7a92d8", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_c90f146f58cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires replace_with_colon_precond (s @)\nensures result == is_space_comma_dot_spec (c), replace_with_colon_postcond (s @ , result @)\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "c90f146f58cf", "function_name": "replace_with_colon", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f2f1427ef78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize))   { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len ()  { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len ()  { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "target_text": "requires numbers . len () >= 2 \nensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) \ndecreases seq . len () , numbers . len () - i , numbers . len () - i \ninvariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_755_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0f2f1427ef78", "function_name": "second_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_50c3eee18ee4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "50c3eee18ee4", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_496a3de62c67", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "496a3de62c67", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9a4fb523e65a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_streak_precond (nums @)\nensures longest_increasing_streak_postcond (nums @ , result as nat)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize) requires longest_increasing_streak_precond (nums @) ensures longest_increasing_streak_postcond (nums @ , result as nat) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9a4fb523e65a", "function_name": "longest_increasing_streak", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b2e94e72aba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "target_text": "ensures result as nat == spec_nat_abs_diff (x , y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3b2e94e72aba", "function_name": "nat_abs_diff", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ddfeb024ca26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >)   { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , append_precond (a @ , b) \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , append_postcond (a @ , b , result @) , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ddfeb024ca26", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verified-ironkv_args_t_f2429d08994c", "task": "task_a", "input_text": "#![verus::trusted]\n\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::seq_lib::*;\n\nverus! {\n\npub type AbstractArg = Seq<u8>;\npub type AbstractArgs = Seq<AbstractArg>;\n\npub type Arg = Vec<u8>;\npub type Args = Vec<Arg>;\n\n/// Clone a Vec<u8>.\n///\n/// Implemented as a loop, so might not be as efficient as the\n/// `std::vec::Vec::clone` method.\n// TODO: implemented to avoid depending on (and waiting for) Vec::clone,\n// which is made complicated by how it should treat its generic type\n// parameter. Here the elements are u8 which are easy to deal with.\npub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\n\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n\n    out\n}\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\n\n{\n    clone_vec_u8(arg)\n}\n\npub open spec fn abstractify_args(args: Args) -> AbstractArgs\n{\n    args@.map(|i, arg: Arg| arg@)\n}\n\n}\n", "target_text": "ensures out@ == v@, out@ == arg@\ndecreases v.len() - i\ninvariant i <= v.len(),\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j]", "full_verified_code": "#![verus::trusted]\n\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::seq_lib::*;\n\n\nverus! {\n\npub type AbstractArg = Seq<u8>;\npub type AbstractArgs = Seq<AbstractArg>;\n\npub type Arg = Vec<u8>;\npub type Args = Vec<Arg>;\n\n/// Clone a Vec<u8>.\n///\n/// Implemented as a loop, so might not be as efficient as the\n/// `std::vec::Vec::clone` method.\n// TODO: implemented to avoid depending on (and waiting for) Vec::clone,\n// which is made complicated by how it should treat its generic type\n// parameter. Here the elements are u8 which are easy to deal with.\npub fn clone_vec_u8(v: &Vec<u8>) -> (out: Vec<u8>)\nensures\n    out@ == v@\n{\n    let mut out: Arg = Vec::with_capacity(v.len());\n    let mut i = 0;\n    while i < v.len()\n        invariant\n            i <= v.len(),\n            i == out.len(),\n            forall |j| #![auto] 0 <= j < i  ==> out@[j] == v@[j],\n        decreases\n            v.len() - i,\n    {\n        out.push(v[i]);\n        i = i + 1;\n    }\n    proof {\n        assert_seqs_equal!(out@, v@);\n    }\n    out\n}\n\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\nensures\n    out@ == arg@\n{\n    clone_vec_u8(arg)\n}\n\npub open spec fn abstractify_args(args: Args) -> AbstractArgs\n{\n    args@.map(|i, arg: Arg| arg@)\n}\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-ironkv/ironsht/src/args_t.rs", "verified": true, "metadata": {"original_id": "verified-ironkv_args_t_f2429d08994c", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f4639301b0fc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f4639301b0fc", "function_name": "bubbleSorta", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8f052db50046", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f052db50046", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_801acf261259", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - i \ninvariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/max_array_impl.rs", "verified": true, "metadata": {"original_id": "801acf261259", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3d27422846e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_8/verina_basic_8_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3d27422846e8", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_447b7cfcaff6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem  { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len ()  { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i , a . len () - i \ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i , { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i , { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/last_position_iter_4_current.rs", "verified": true, "metadata": {"original_id": "447b7cfcaff6", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e813472caced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subseq_length_precond (xs @) \nensures longest_increasing_subseq_length_postcond (xs @ , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_31/verina_advanced_31_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e813472caced", "function_name": "longest_increasing_subseq_length", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b437235fabc6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_82/verina_basic_82_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b437235fabc6", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0300cd0e441a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >)  { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "0300cd0e441a", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f39ac4f002ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len ()  { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ninvariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f39ac4f002ec", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_20597967dd20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { new_char } else { str1 [i] }) , { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "20597967dd20", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_06785d20d5f6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let result = 4 * N ; sum . set (0 , result) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 4 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 4 , ensures sum [0] == 4 * N , { let result = 4 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "06785d20d5f6", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fc6dad00b632", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >)  { x . checked_pow (exp) }\n\n} // verus!", "target_text": "ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >) ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX , { x . checked_pow (exp) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/not_finished_proof/076-is_simple_power_iter_3_current.rs", "verified": true, "metadata": {"original_id": "fc6dad00b632", "function_name": "ex_checked_pow", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_15b839565212", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_current.rs", "verified": true, "metadata": {"original_id": "15b839565212", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c6508c551eb5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >)   { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len ()  { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "target_text": "requires find_smallest_precond (s @) \nensures find_smallest_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_2/verina_basic_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c6508c551eb5", "function_name": "find_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_805e9284b8ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s1lif_impl.rs", "verified": true, "metadata": {"original_id": "805e9284b8ad", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_350655feed65", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool)   { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len ()  { if chars [i] != first_char { return false ; } i += 1 ; }  true }\n\n} // verus!", "target_text": "requires all_characters_same_precond (chars)\nensures all_characters_same_postcond (chars , result)\ndecreases chars . len () - i\ninvariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_38/verina_basic_38_impl.rs", "verified": true, "metadata": {"original_id": "350655feed65", "function_name": "all_characters_same", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8fb08dfff757", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "8fb08dfff757", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f31764314b8f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires nums . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32) requires nums . len () > 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_1/verina_advanced_1.rs", "verified": true, "metadata": {"original_id": "f31764314b8f", "function_name": "find_single_number", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b8409b9c1086", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "b8409b9c1086", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1c0dbd75131f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/conda_impl.rs", "verified": true, "metadata": {"original_id": "1c0dbd75131f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9ad0eb7ec4b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_72/verina_basic_72_impl.rs", "verified": true, "metadata": {"original_id": "9ad0eb7ec4b8", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b843b3e80d44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i])\ndecreases str1 . len () - index \ninvariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b843b3e80d44", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ef35a5194918", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "ef35a5194918", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5a32ea0f8529", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "5a32ea0f8529", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_19d2bfa444aa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1\nensures result >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "19d2bfa444aa", "function_name": "max_coverage_after_removing_one", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0200e16b05a5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >)  { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >)  { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures char_vec @ == number_to_char (n as nat) , single_digit_number_to_char (n as nat) == output , string_seq @ == string_sequence (n as nat) , char_vec @ == number_to_char (n as nat) , decreases n, string_seq @ == string_sequence (n as nat) , decreases n\ndecreases n , n , n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) decreases n , { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >) ensures string_seq @ == string_sequence (n as nat) , decreases n { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_impl.rs", "verified": true, "metadata": {"original_id": "0200e16b05a5", "function_name": "string_sequence_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_cdf3a797b9d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32)   { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "requires d > 0, count_sum_divisible_by_precond (n as nat , d as nat)\nensures result == is_sum_divisible_by (x as nat , d as nat), result == sum_of_digits (x as nat), result == count_sum_divisible_by_spec (n as nat , d as nat)\ndecreases n, x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "cdf3a797b9d5", "function_name": "count_sum_divisible_by", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_07c1ede4547c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_prime_precond (n as nat) , n <= 0xFFFF ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool) requires is_prime_precond (n as nat) , n <= 0xFFFF , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_28/verina_basic_28.rs", "verified": true, "metadata": {"original_id": "07c1ede4547c", "function_name": "is_prime", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_83078a54d5c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "83078a54d5c7", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_593f4fd3afb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_1_current.rs", "verified": true, "metadata": {"original_id": "593f4fd3afb8", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c2201c84e8ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_18/verina_advanced_18.rs", "verified": true, "metadata": {"original_id": "c2201c84e8ee", "function_name": "count_digits_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b1cdb1d7cb54", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 5 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s42if_impl.rs", "verified": true, "metadata": {"original_id": "b1cdb1d7cb54", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_616dd2fa2ddb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "616dd2fa2ddb", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_78bd1f99700b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "78bd1f99700b", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5374dcbb7d23", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_55/verina_basic_55_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5374dcbb7d23", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b76aef20e088", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "b76aef20e088", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4a4dc9705230", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool)  { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len ()  { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) \ndecreases arr . len () - j\ninvariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len () invariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] , decreases arr . len () - j { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_760_impl.rs", "verified": true, "metadata": {"original_id": "4a4dc9705230", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1490a368946a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1490a368946a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_33b2294d8aac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "33b2294d8aac", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ec8162a547bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ec8162a547bb", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_arc_c4e33fa9630e", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{atomic::*, pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerArc<S> {\n    pub rc_cell: PAtomicU64,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: PermissionU64,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n        &&& self.rc_perm@.patomic == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm@.value as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerArc<S> {\n    spec fn wf(self, cell: PAtomicU64) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyArc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerArc<S>>,\n\n        pub rc_cell: Ghost< PAtomicU64 >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyArc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n\n    {\n        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);\n        let inner_rc = InnerArc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n\n    {\n        loop\n\n        {\n            let tracked inst = self.inst.borrow();\n            let tracked reader = self.reader.borrow();\n            let tracked perm = inst.reader_guard(reader.element(), &reader);\n            let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n            let count: u64;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));\n\n            });\n            assume(count < 100000000);\n            let tracked mut new_reader = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);\n\n            });\n            if res.is_ok() {\n                return MyArc {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    inv: Tracked(self.inv.borrow().clone()),\n                    reader: Tracked(new_reader.tracked_unwrap()),\n                    ptr: self.ptr,\n                    rc_cell: Ghost(self.rc_cell@),\n                };\n            }\n        }\n    }\n\n    fn dispose(self)\n\n    {\n        let MyArc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_atomic_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n\n        });\n        if count == 1 {\n            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();\n            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n            ptr.free(Tracked(inner_rc_perm));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyArc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyArc::new(Sequence::Nil);\n    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "target_text": "requires self.wf(), self.wf(), self.wf()\nensures rc.wf(),\n            rc@ == s, *s == self@, s.wf() && s@ == self@\ninvariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>), self.wf()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::{atomic::*, pervasive::*, *};\nuse vstd::shared::*;\n\nverus! {\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<Perm> {\n    fields {\n        #[sharding(variable)]\n        pub counter: nat,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm>,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm| self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage(&self) -> bool {\n        self.counter == 0 ==> self.storage is None\n    }\n\n    #[invariant]\n    pub fn counter_agrees_storage_rev(&self) -> bool {\n        self.storage is None ==> self.counter == 0\n    }\n\n    #[invariant]\n    pub fn counter_agrees_reader_count(&self) -> bool {\n        self.storage is Some ==>\n            self.reader.count(self.storage->0) == self.counter\n    }\n\n    init!{\n        initialize_empty() {\n            init counter = 0;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self) { }\n\n    transition!{\n        do_deposit(x: Perm) {\n            require(pre.counter == 0);\n            update counter = 1;\n            deposit storage += Some(x);\n            add reader += {x};\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm) { }\n\n    property!{\n        reader_guard(x: Perm) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        do_clone(x: Perm) {\n            have reader >= {x};\n            add reader += {x};\n            update counter = pre.counter + 1;\n        }\n    }\n\n    #[inductive(do_clone)]\n    fn do_clone_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n        assert(pre.counter > 0);\n    }\n\n    transition!{\n        dec_basic(x: Perm) {\n            require(pre.counter >= 2);\n            remove reader -= {x};\n            update counter = (pre.counter - 1) as nat;\n        }\n    }\n\n    transition!{\n        dec_to_zero(x: Perm) {\n            remove reader -= {x};\n            require(pre.counter < 2);\n            assert(pre.counter == 1);\n            update counter = 0;\n            withdraw storage -= Some(x);\n        }\n    }\n\n    #[inductive(dec_basic)]\n    fn dec_basic_inductive(pre: Self, post: Self, x: Perm) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n    }\n\n    #[inductive(dec_to_zero)]\n    fn dec_to_zero_inductive(pre: Self, post: Self, x: Perm) { }\n});\n\npub struct InnerArc<S> {\n    pub rc_cell: PAtomicU64,\n    pub s: S,\n}\n\npub type MemPerms<S> = simple_pptr::PointsTo<InnerArc<S>>;\n\npub tracked struct GhostStuff<S> {\n    pub tracked rc_perm: PermissionU64,\n    pub tracked rc_token: RefCounter::counter<MemPerms<S>>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub open spec fn wf(self, inst: RefCounter::Instance<MemPerms<S>>, cell: PAtomicU64) -> bool {\n        &&& self.rc_perm@.patomic == cell.id()\n        &&& self.rc_token.instance_id() == inst.id()\n        &&& self.rc_perm@.value as nat == self.rc_token.value()\n    }\n}\n\nimpl<S> InnerArc<S> {\n    spec fn wf(self, cell: PAtomicU64) -> bool {\n        self.rc_cell == cell\n    }\n}\n\nstruct_with_invariants!{\n    struct MyArc<S> {\n        pub inst: Tracked< RefCounter::Instance<MemPerms<S>> >,\n        pub inv: Tracked< Shared<AtomicInvariant<_, GhostStuff<S>, _>> >,\n        pub reader: Tracked< RefCounter::reader<MemPerms<S>> >,\n\n        pub ptr: PPtr<InnerArc<S>>,\n\n        pub rc_cell: Ghost< PAtomicU64 >,\n    }\n\n    spec fn wf(self) -> bool {\n        predicate {\n            &&& self.reader@.element().pptr() == self.ptr\n            &&& self.reader@.element().pptr() == self.ptr\n\n            &&& self.reader@.instance_id() == self.inst@.id()\n            &&& self.reader@.element().is_init()\n            &&& self.reader@.element().value().rc_cell == self.rc_cell\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell@)\n        }\n    }\n}\n\nimpl<S> MyArc<S> {\n    spec fn view(self) -> S {\n        self.reader@.element().value().s\n    }\n\n    fn new(s: S) -> (rc: Self)\n        ensures\n            rc.wf(),\n            rc@ == s,\n    {\n        let (rc_cell, Tracked(rc_perm)) = PAtomicU64::new(1);\n        let inner_rc = InnerArc::<S> { rc_cell, s };\n        let (ptr, Tracked(ptr_perm)) = PPtr::new(inner_rc);\n        let tracked (Tracked(inst), Tracked(mut rc_token), _) =\n            RefCounter::Instance::initialize_empty(Option::None);\n        let tracked reader = inst.do_deposit(\n            ptr_perm,\n            &mut rc_token,\n            ptr_perm,\n        );\n        let tracked g = GhostStuff::<S> { rc_perm, rc_token };\n        let tr_inst = Tracked(inst);\n        let gh_cell = Ghost(rc_cell);\n        let tracked inv = AtomicInvariant::new((tr_inst, gh_cell), g, 0);\n        let tracked inv = Shared::new(inv);\n        MyArc { inst: tr_inst, inv: Tracked(inv), reader: Tracked(reader), ptr, rc_cell: gh_cell }\n    }\n\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self@,\n    {\n        let tracked inst = self.inst.borrow();\n        let tracked reader = self.reader.borrow();\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        &self.ptr.borrow(Tracked(perm)).s\n    }\n\n    fn clone(&self) -> (s: Self)\n        requires\n            self.wf(),\n        ensures\n            s.wf() && s@ == self@,\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked inst = self.inst.borrow();\n            let tracked reader = self.reader.borrow();\n            let tracked perm = inst.reader_guard(reader.element(), &reader);\n            let inner_rc_ref = self.ptr.borrow(Tracked(perm));\n            let count: u64;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                count = inner_rc_ref.rc_cell.load(Tracked(&rc_perm));\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            assume(count < 100000000);\n            let tracked mut new_reader = None;\n            let res;\n            open_atomic_invariant!(self.inv.borrow().borrow() => g => {\n                let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n                res = inner_rc_ref.rc_cell.compare_exchange_weak(Tracked(&mut rc_perm), count, count + 1);\n\n                proof {\n                    if res.is_ok() {\n                        new_reader = Some(self.inst.borrow().do_clone(\n                            reader.element(),\n                            &mut rc_token,\n                            &reader));\n                    }\n                }\n\n                proof { g = GhostStuff { rc_perm, rc_token }; }\n            });\n            if res.is_ok() {\n                return MyArc {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    inv: Tracked(self.inv.borrow().clone()),\n                    reader: Tracked(new_reader.tracked_unwrap()),\n                    ptr: self.ptr,\n                    rc_cell: Ghost(self.rc_cell@),\n                };\n            }\n        }\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let MyArc {\n            inst: Tracked(inst),\n            inv: Tracked(inv),\n            reader: Tracked(reader),\n            ptr,\n            rc_cell: _,\n        } = self;\n        let tracked perm = inst.reader_guard(reader.element(), &reader);\n        let inner_rc_ref = &ptr.borrow(Tracked(perm));\n        let count;\n        let tracked mut inner_rc_perm_opt = None;\n        open_atomic_invariant!(inv.borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, rc_token: mut rc_token } = g;\n\n            count = inner_rc_ref.rc_cell.fetch_sub_wrapping(Tracked(&mut rc_perm), 1);\n\n            proof {\n                if rc_token.value() < 2 {\n                    let tracked inner_rc_perm = inst.dec_to_zero(\n                        reader.element(), &mut rc_token, reader);\n                    inner_rc_perm_opt = Some(inner_rc_perm);\n                } else {\n                    inst.dec_basic(reader.element(), &mut rc_token, reader);\n                }\n\n                g = GhostStuff { rc_perm, rc_token };\n            }\n        });\n        if count == 1 {\n            let tracked mut inner_rc_perm = inner_rc_perm_opt.tracked_unwrap();\n            let _inner_rc = ptr.take(Tracked(&mut inner_rc_perm));\n            ptr.free(Tracked(inner_rc_perm));\n        }\n    }\n}\n\nenum Sequence<V> {\n    Nil,\n    Cons(V, MyArc<Sequence<V>>),\n}\n\nfn main() {\n    let nil = MyArc::new(Sequence::Nil);\n    let a5 = MyArc::new(Sequence::Cons(5, nil.clone()));\n    let a7 = MyArc::new(Sequence::Cons(7, nil.clone()));\n    let a67 = MyArc::new(Sequence::Cons(6, a7.clone()));\n}\n\n} // verus!\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/arc.rs", "verified": true, "metadata": {"original_id": "verus_arc_c4e33fa9630e", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_21f1901eedf6", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "21f1901eedf6", "function_name": "helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_81ce8fdfe6ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool)  { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "target_text": "requires m > 0 \ndecreases fuel", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool) requires m > 0 , decreases fuel { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_23/verina_advanced_23_impl.rs", "verified": true, "metadata": {"original_id": "81ce8fdfe6ea", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_886b277fdc81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "886b277fdc81", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2533c1fbb6be", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/max_index_impl.rs", "verified": true, "metadata": {"original_id": "2533c1fbb6be", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5f30ac57404f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >)   { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , append_precond (a @ , b) \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , append_postcond (a @ , b , result @) , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_72/verina_basic_72_impl.rs", "verified": true, "metadata": {"original_id": "5f30ac57404f", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d5eae418e192", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "target_text": "ensures result @ == digit_to_letters (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "d5eae418e192", "function_name": "digit_to_letters_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_319b1f974ff8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ninvariant forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "319b1f974ff8", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9ccece2856d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositivertl (v : & [i32]) -> (b : bool)  { let mut i = v . len () ; while i > 0  { i = i - 1 ;  if v [i] < 0 { return false ; } }   true }\n\n} // verus!", "target_text": "ensures b == positive (v @)\ndecreases i\ninvariant 0 <= i <= v . len () , forall | u : int | i <= u < v . len () ==> v [u] >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositivertl (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut i = v . len () ; while i > 0 invariant 0 <= i <= v . len () , forall | u : int | i <= u < v . len () ==> v [u] >= 0 decreases i { i = i - 1 ; assert (0 <= i < v . len ()) ; if v [i] < 0 { return false ; } } assert (i == 0) ; assert (forall | u : int | 0 <= u < v . len () ==> v [u] >= 0) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9ccece2856d0", "function_name": "mpositivertl", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_352fd7cf6f7e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop  { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases high - low\ninvariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "352fd7cf6f7e", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7dda11249db6", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >)  { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len ()  { out . push (v [i]) ; i = i + 1 ; }  out }\n\n} // verus!", "target_text": "ensures out @ == v @\ndecreases v . len () - i \ninvariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "7dda11249db6", "function_name": "clone_vec_u8", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bbccb96fcb28", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "bbccb96fcb28", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b944c8fc8f8d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant 0 <= idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "b944c8fc8f8d", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_eec342cc46a7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ndecreases arr . len () - i, list1 . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases list1 . len () - i { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "eec342cc46a7", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_987ed838376e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_precond (xs @) , xs . len () <= 100", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32) requires max_subarray_sum_precond (xs @) , xs . len () <= 100 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_45/verina_advanced_45_iter_0_original.rs", "verified": true, "metadata": {"original_id": "987ed838376e", "function_name": "max_subarray_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_28fc4eedcec5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)   { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)   {  c [j] - c [i] }\n\n} // verus!", "target_text": "requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c), a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 \nensures sum (a , i , j) == c [j] - c [i], r == sum (seq_to_int (a @) , i as int , j as int), sum (a , i , j) == c [j] - c [i] decreases j - i\ndecreases j - i, j - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "28fc4eedcec5", "function_name": "query_fast", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bf8315113c9e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { let mut i = 0 ; while i < chords . len ()  { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } { let mut j = i + 1 ; while j < chords . len ()  { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)\ndecreases chords . len () - i, chords . len () - j\ninvariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==>, 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { let mut i = 0 ; while i < chords . len () invariant 0 <= i <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - i { let mut j = i + 1 ; while j < chords . len () invariant 0 <= i < chords . len () , i + 1 <= j <= chords . len () , forall | k : int | 0 <= k < chords . len () ==> (chords [k] . len () == 2 && chords [k] [0] >= 1 && chords [k] [0] <= 2 * n && chords [k] [1] >= 1 && chords [k] [1] <= 2 * n) , forall | k1 : int , k2 : int | 0 <= k1 < i && 0 <= k2 < chords . len () && k1 != k2 ==> { let chord1 = # [trigger] chords @ [k1] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } , forall | k2 : int | i + 1 <= k2 < j ==> { let chord1 = chords @ [i as int] ; let chord2 = # [trigger] chords @ [k2] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; ! ((a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)) } decreases chords . len () - j { let chord1 = & chords [i] ; let chord2 = & chords [j] ; let (a1 , b1) = if chord1 [0] <= chord1 [1] { (chord1 [0] , chord1 [1]) } else { (chord1 [1] , chord1 [0]) } ; let (a2 , b2) = if chord2 [0] <= chord2 [1] { (chord2 [0] , chord2 [1]) } else { (chord2 [1] , chord2 [0]) } ; if (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1) { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_13/verina_advanced_13_impl.rs", "verified": true, "metadata": {"original_id": "bf8315113c9e", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_02efcf4bf828", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N <= MAX / 3 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N <= MAX / 3 , ensures sum [0] <= 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms4_impl.rs", "verified": true, "metadata": {"original_id": "02efcf4bf828", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5c6350a13060", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "5c6350a13060", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1d34d2db58fa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "1d34d2db58fa", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2012ed93d37e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2012ed93d37e", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ba3c6ff39b39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "ensures result == odd (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ba3c6ff39b39", "function_name": "odd_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b1d23e5299d9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize)  { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i]  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int]\ndecreases a . len () - i\ninvariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b1d23e5299d9", "function_name": "longest_prefix", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b7a531061c0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - j", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > decreases nums . len () - j { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b7a531061c0c", "function_name": "two_sum_inner", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4d13c74ee1ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { x + x + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4d13c74ee1ab", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_59468cd5d2ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "59468cd5d2ca", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a8d68914180d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_43/verina_basic_43_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a8d68914180d", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_991bbe1d1168", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i < list . len ()  { result . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list . len () - i , n - j \ninvariant n <= i <= list . len () , result @ == list @ . subrange (n as int , i as int) , 0 <= j <= n , n < list . len () , result @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut result = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , result @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { result . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list . len () , result @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "991bbe1d1168", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fd74f839e512", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/last_position_impl.rs", "verified": true, "metadata": {"original_id": "fd74f839e512", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4952c72576de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "4952c72576de", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a439577991c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "a439577991c0", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c7975defa497", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  {  new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases (k - 1) - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "c7975defa497", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_09b8575cf5f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "09b8575cf5f0", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_44206d99f5b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/abs_impl.rs", "verified": true, "metadata": {"original_id": "44206d99f5b2", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2db51a094234", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len ()  { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - idx\ninvariant idx <= arr . len () , copied @ . len () == idx , forall | i : int | (0 <= i < idx) ==> arr [i] == copied [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len () invariant idx <= arr . len () , copied @ . len () == idx , forall | i : int | (0 <= i < idx) ==> arr [i] == copied [i] , decreases arr . len () - idx { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_307_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2db51a094234", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dd30f6578fb1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_95/verina_basic_95_impl.rs", "verified": true, "metadata": {"original_id": "dd30f6578fb1", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_09cab6dc4c8a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "09cab6dc4c8a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4cf057d56b69", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool)  { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len ()  { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) \ndecreases arr . len () - j\ninvariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len () invariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] , decreases arr . len () - j { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_760_iter_3_current.rs", "verified": true, "metadata": {"original_id": "4cf057d56b69", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_28bd706e54b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "28bd706e54b6", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e868300a90c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs4_impl.rs", "verified": true, "metadata": {"original_id": "0e868300a90c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3069463d1a00", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/max_index_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3069463d1a00", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verified-ironkv_choose_v_3ee670872889", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n/// Equivalent to `choose |i:int| low <= i < high && p(i)` except it guarantees to pick the smallest\n/// such value `i` where `p(i)` is true.\npub proof fn choose_smallest(low: int, high: int, p: spec_fn(int)->bool) -> (res:int)\n\n  {\n  if p(low) {\n    low\n  } else {\n    choose_smallest(low + 1, high, p)\n  }\n}\n\n} // verus!\n", "target_text": "requires exists |i:int| #![trigger(p(i))] low <= i < high && p(i)\nensures low <= res < high,\n    p(res),\n    forall |i:int| #![trigger(p(i))] low <= i < res ==> !p(i), low <= res < high,\n    p(res),\n    forall |i:int| #![trigger(p(i))] low <= i < res ==> !p(i),\n  decreases\n    high - low\ndecreases high - low", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n/// Equivalent to `choose |i:int| low <= i < high && p(i)` except it guarantees to pick the smallest\n/// such value `i` where `p(i)` is true.\npub proof fn choose_smallest(low: int, high: int, p: spec_fn(int)->bool) -> (res:int)\n  requires\n    exists |i:int| #![trigger(p(i))] low <= i < high && p(i),\n  ensures\n    low <= res < high,\n    p(res),\n    forall |i:int| #![trigger(p(i))] low <= i < res ==> !p(i),\n  decreases\n    high - low,\n{\n  if p(low) {\n    low\n  } else {\n    choose_smallest(low + 1, high, p)\n  }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-ironkv/ironsht/src/verus_extra/choose_v.rs", "verified": true, "metadata": {"original_id": "verified-ironkv_choose_v_3ee670872889", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_5fc68d9033cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { let idx = n as int - 1 - j ; 0 <= idx < list @ . len () } , { i = i - 1 ;   result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { let idx = n as int - 1 - k ; 0 <= idx < list @ . len () } , forall | k : int | n as int <= k < result @ . len () ==> # [trigger] result @ [k] == list @ [k] , {  result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i , list . len () - j \ninvariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , forall | j : int | 0 <= j < result @ . len () ==> # [trigger] result @ [j] == list @ [n as int - 1 - j] &&, n <= j <= list . len () , n < list @ . len () , result @ . len () == (n + (j - n)) as int , forall | k : int | 0 <= k < n as int ==> # [trigger] result @ [k] == list @ [n as int - 1 - k] &&", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , forall | j : int | 0 <= j < result @ . len () ==> # [trigger] result @ [j] == list @ [n as int - 1 - j] && { let idx = n as int - 1 - j ; 0 <= idx < list @ . len () } , decreases i , { i = i - 1 ; assert (i < n) ; assert (i < list . len ()) ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list . len () , n < list @ . len () , result @ . len () == (n + (j - n)) as int , forall | k : int | 0 <= k < n as int ==> # [trigger] result @ [k] == list @ [n as int - 1 - k] && { let idx = n as int - 1 - k ; 0 <= idx < list @ . len () } , forall | k : int | n as int <= k < result @ . len () ==> # [trigger] result @ [k] == list @ [k] , decreases list . len () - j , { assert (j < list . len ()) ; result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "5fc68d9033cc", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6d850a3d511d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6d850a3d511d", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f8bd52141f24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx\ninvariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f8bd52141f24", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cda0fddb188b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant c @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cda0fddb188b", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_counting_1e723cea7838", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!{ CountingPermissions<T> {\n    fields {\n        #[sharding(storage_option)]\n        pub stored: Option<T>,\n\n        #[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,\n\n        #[sharding(multiset)]\n        pub read_ref: Multiset<T>,\n    }\n\n    init!{\n        new() {\n            init stored = None;\n            init main_counter = None;\n            init read_ref = Multiset::empty();\n        }\n    }\n\n    transition!{\n        writeable_to_readable(t: T) {\n            require pre.main_counter.is_none();\n            update main_counter = Some((0, t));\n            deposit stored += Some(t);\n        }\n    }\n\n    transition!{\n        readable_to_writeable() {\n            require let Some((count, t)) = pre.main_counter;\n            require count == 0;\n            update main_counter = None;\n            withdraw stored -= Some(t);\n        }\n    }\n\n    transition!{\n        new_ref() {\n            require let Some((count, t)) = pre.main_counter;\n            update main_counter = Some((count + 1, t));\n            add read_ref += { t };\n        }\n    }\n\n    transition!{\n        delete_ref(t1: T) {\n            remove read_ref -= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n            update main_counter = Some(((count - 1) as nat, t1));\n        }\n    }\n\n    property!{\n        compare_refs(t1: T, t2: T) {\n            have read_ref >= { t1 };\n            have read_ref >= { t2 };\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        compare_ref_and_counter(t1: T) {\n            have read_ref >= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        read_ref_guards(t: T) {\n            have read_ref >= { t };\n            guard stored >= Some(t);\n        }\n    }\n\n    property!{\n        counter_guards() {\n            require let Some((count, t)) = pre.main_counter;\n            guard stored >= Some(t);\n        }\n    }\n\n    #[invariant]\n    pub spec fn main_inv(&self) -> bool {\n        match self.stored {\n            None => {\n                &&& self.main_counter.is_none()\n                &&& self.read_ref =~= Multiset::empty()\n            }\n            Some(t) => {\n                match self.main_counter {\n                    Some((count, t1)) => {\n                        &&& t == t1\n                        &&& self.read_ref.count(t) == count\n                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)\n                    }\n                    None => false,\n                }\n            }\n        }\n    }\n\n    #[inductive(new)]\n    fn new_inductive(post: Self) { }\n\n    #[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }\n\n    #[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) { }\n\n    #[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) { }\n\n    #[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }\n}}\n\nverus!{\n\ntracked struct Instance<T> {\n    tracked instance: CountingPermissions::Instance<T>,\n}\n\ntracked struct MainCounter<T> {\n    tracked token: CountingPermissions::main_counter<T>,\n}\n\ntracked struct ReadRef<T> {\n    tracked token: CountingPermissions::read_ref<T>\n}\n\nimpl<T> MainCounter<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> Option<(nat, T)> {\n        self.token.value()\n    }\n}\n\nimpl<T> ReadRef<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> T {\n        self.token.element()\n    }\n}\n\nimpl<T> Instance<T> {\n    pub closed spec fn id(self) -> InstanceId {\n      self.instance.id()\n    }\n\n    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))\n\n    {\n        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =\n            CountingPermissions::Instance::new(None);\n        (Instance { instance: inst }, MainCounter { token: c })\n    }\n\n    proof fn writeable_to_readable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked t: T\n    )\n\n    {\n        self.instance.writeable_to_readable(t, t, &mut counter.token);\n    }\n\n    proof fn readable_to_writeable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked t: T)\n         {\n                None => false,\n                Some((count, _)) => count == 0,\n            }\n\n    {\n        self.instance.readable_to_writeable(&mut counter.token)\n    }\n\n    proof fn new_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked read_ref: ReadRef<T>)\n\n         {\n                None => false,\n                Some((count, t)) =>\n                    counter.value() == Some((count + 1, t))\n                      && read_ref.value() == t\n            },\n    {\n        ReadRef { token: self.instance.new_ref(&mut counter.token) }\n    }\n\n    proof fn delete_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked read_ref: ReadRef<T>,\n    )\n\n         {\n                None => false,\n                Some((count, t)) =>\n                    count >= 1\n                      && counter.value() == Some(((count - 1) as nat, t))\n            },\n    {\n        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)\n    }\n\n    proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,\n    ) -> (tracked borrowed_t: &'a T)\n\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n\n}\n\nfn main() { }\n", "target_text": "requires old(counter).instance_id() == self.id(),\n            old(counter).value() === None, old(counter).instance_id() == self.id(),\n            match old(counter).value(), old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(), old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(),\n            read_ref.instance_id() == self.id(), read_ref.instance_id() == self.id()\nensures res.1.instance_id() == res.0.id(),\n            res.1.value() === None, counter.instance_id() == self.id(),\n            counter.value() === Some((0, t)), counter.instance_id() == self.id(),\n            counter.value() === None,\n            t == old(counter).value().unwrap().1, counter.instance_id() == self.id(),\n            match old(counter).value(), counter.instance_id() == self.id(),\n            match old(counter).value(), borrowed_t == read_ref.value()", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse vstd::prelude::*;\nuse vstd::multiset::*;\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine!{ CountingPermissions<T> {\n    fields {\n        #[sharding(storage_option)]\n        pub stored: Option<T>,\n\n        #[sharding(variable)]\n        pub main_counter: Option<(nat, T)>,\n\n        #[sharding(multiset)]\n        pub read_ref: Multiset<T>,\n    }\n\n    init!{\n        new() {\n            init stored = None;\n            init main_counter = None;\n            init read_ref = Multiset::empty();\n        }\n    }\n\n    transition!{\n        writeable_to_readable(t: T) {\n            require pre.main_counter.is_none();\n            update main_counter = Some((0, t));\n            deposit stored += Some(t);\n        }\n    }\n\n    transition!{\n        readable_to_writeable() {\n            require let Some((count, t)) = pre.main_counter;\n            require count == 0;\n            update main_counter = None;\n            withdraw stored -= Some(t);\n        }\n    }\n\n    transition!{\n        new_ref() {\n            require let Some((count, t)) = pre.main_counter;\n            update main_counter = Some((count + 1, t));\n            add read_ref += { t };\n        }\n    }\n\n    transition!{\n        delete_ref(t1: T) {\n            remove read_ref -= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n            update main_counter = Some(((count - 1) as nat, t1));\n        }\n    }\n\n    property!{\n        compare_refs(t1: T, t2: T) {\n            have read_ref >= { t1 };\n            have read_ref >= { t2 };\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        compare_ref_and_counter(t1: T) {\n            have read_ref >= { t1 };\n            require let Some((count, t2)) = pre.main_counter;\n            assert count >= 1;\n            assert t1 == t2;\n        }\n    }\n\n    property!{\n        read_ref_guards(t: T) {\n            have read_ref >= { t };\n            guard stored >= Some(t);\n        }\n    }\n\n    property!{\n        counter_guards() {\n            require let Some((count, t)) = pre.main_counter;\n            guard stored >= Some(t);\n        }\n    }\n\n    #[invariant]\n    pub spec fn main_inv(&self) -> bool {\n        match self.stored {\n            None => {\n                &&& self.main_counter.is_none()\n                &&& self.read_ref =~= Multiset::empty()\n            }\n            Some(t) => {\n                match self.main_counter {\n                    Some((count, t1)) => {\n                        &&& t == t1\n                        &&& self.read_ref.count(t) == count\n                        &&& (forall |t0: T| t0 != t ==> self.read_ref.count(t0) == 0)\n                    }\n                    None => false,\n                }\n            }\n        }\n    }\n\n    #[inductive(new)]\n    fn new_inductive(post: Self) { }\n   \n    #[inductive(writeable_to_readable)]\n    fn writeable_to_readable_inductive(pre: Self, post: Self, t: T) { }\n   \n    #[inductive(readable_to_writeable)]\n    fn readable_to_writeable_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(new_ref)]\n    fn new_ref_inductive(pre: Self, post: Self) { }\n   \n    #[inductive(delete_ref)]\n    fn delete_ref_inductive(pre: Self, post: Self, t1: T) { }\n}}\n\nverus!{\n\ntracked struct Instance<T> {\n    tracked instance: CountingPermissions::Instance<T>,\n}\n\ntracked struct MainCounter<T> {\n    tracked token: CountingPermissions::main_counter<T>,\n}\n\ntracked struct ReadRef<T> {\n    tracked token: CountingPermissions::read_ref<T>\n}\n\nimpl<T> MainCounter<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> Option<(nat, T)> {\n        self.token.value()\n    }\n}\n\nimpl<T> ReadRef<T> {\n    pub closed spec fn instance_id(self) -> InstanceId {\n        self.token.instance_id()\n    }\n\n    pub closed spec fn value(self) -> T {\n        self.token.element()\n    }\n}\n\nimpl<T> Instance<T> {\n    pub closed spec fn id(self) -> InstanceId {\n      self.instance.id()\n    }\n\n    proof fn new() -> (tracked res: (Instance<T>, MainCounter<T>))\n        ensures\n            res.1.instance_id() == res.0.id(),\n            res.1.value() === None\n    {\n        let tracked (Tracked(inst), Tracked(c), Tracked(_r)) =\n            CountingPermissions::Instance::new(None);\n        (Instance { instance: inst }, MainCounter { token: c })\n    }\n\n    proof fn writeable_to_readable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked t: T\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value() === None,\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === Some((0, t)),\n    {\n        self.instance.writeable_to_readable(t, t, &mut counter.token);\n    }\n\n    proof fn readable_to_writeable(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked t: T)\n        requires\n            old(counter).instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, _)) => count == 0,\n            }\n        ensures\n            counter.instance_id() == self.id(),\n            counter.value() === None,\n            t == old(counter).value().unwrap().1,\n    {\n        self.instance.readable_to_writeable(&mut counter.token)\n    }\n\n    proof fn new_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n    ) -> (tracked read_ref: ReadRef<T>)\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some()\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    counter.value() == Some((count + 1, t))\n                      && read_ref.value() == t\n            },\n    {\n        ReadRef { token: self.instance.new_ref(&mut counter.token) }\n    }\n\n    proof fn delete_ref(\n        tracked &self,\n        tracked counter: &mut MainCounter<T>,\n        tracked read_ref: ReadRef<T>,\n    )\n        requires\n            old(counter).instance_id() == self.id(),\n            old(counter).value().is_some(),\n            read_ref.instance_id() == self.id(),\n        ensures\n            counter.instance_id() == self.id(),\n            match old(counter).value() {\n                None => false,\n                Some((count, t)) =>\n                    count >= 1\n                      && counter.value() == Some(((count - 1) as nat, t))\n            },\n    {\n        self.instance.delete_ref(read_ref.token.element(), &mut counter.token, read_ref.token)\n    }\n\n    proof fn read_ref_guards<'a>(\n        tracked &self,\n        tracked read_ref: &'a ReadRef<T>,\n    ) -> (tracked borrowed_t: &'a T)\n        requires\n            read_ref.instance_id() == self.id(),\n        ensures\n            borrowed_t == read_ref.value()\n    {\n        self.instance.read_ref_guards(read_ref.value(), &read_ref.token)\n    }\n}\n\n}\n\nfn main() { }\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/counting.rs", "verified": true, "metadata": {"original_id": "verus_counting_1e723cea7838", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9544cdceed4d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires nums . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32) requires nums . len () > 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_1/verina_advanced_1_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9544cdceed4d", "function_name": "find_single_number", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_37a4db675187", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) \nensures result == is_digit_spec (c) , all_digits_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_iter_2_current.rs", "verified": true, "metadata": {"original_id": "37a4db675187", "function_name": "all_digits", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8052b9924d79", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8052b9924d79", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8c612d506a69", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - j", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > decreases nums . len () - j { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_79/verina_advanced_79.rs", "verified": true, "metadata": {"original_id": "8c612d506a69", "function_name": "two_sum_inner", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_02cd29f80fc9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "ensures result == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "02cd29f80fc9", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ade21030e0c6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "ade21030e0c6", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_90d51220e05f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)   { let mut k = 2 ; while k < n  { if n % k == 0 {   return true ; } k = k + 1 ; }   return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) \ndecreases n - k\ninvariant 2 <= k <= n , forall | j : int | 2 <= j < k ==> ! is_divisible (n as int , j) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut k = 2 ; while k < n invariant 2 <= k <= n , forall | j : int | 2 <= j < k ==> ! is_divisible (n as int , j) , decreases n - k { if n % k == 0 { assert (is_divisible (n as int , k as int)) ; assert (2 <= k < n) ; return true ; } k = k + 1 ; } assert (k == n) ; assert (forall | j : int | 2 <= j < n ==> ! is_divisible (n as int , j)) ; return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "90d51220e05f", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_15bebac3d3c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { return false ; }\n\n} // verus!", "target_text": "requires is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "15bebac3d3c7", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f08edbdadb07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms2_impl.rs", "verified": true, "metadata": {"original_id": "f08edbdadb07", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7a561411b753", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms3_impl.rs", "verified": true, "metadata": {"original_id": "7a561411b753", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b8405f4335c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 3 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s22if_impl.rs", "verified": true, "metadata": {"original_id": "b8405f4335c0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c11e063363e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c11e063363e5", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_09865cc00b29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_477_impl.rs", "verified": true, "metadata": {"original_id": "09865cc00b29", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6c4e2454c325", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6c4e2454c325", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c6e3f127e2e7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_8/verina_basic_8_impl.rs", "verified": true, "metadata": {"original_id": "c6e3f127e2e7", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_069b27323236", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/choose_odd_iter_3_current.rs", "verified": true, "metadata": {"original_id": "069b27323236", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_55bb3c0dfb79", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >)  { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "55bb3c0dfb79", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_527f09fa648c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_251_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "527f09fa648c", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_adts_7172b41de434", "task": "task_a", "input_text": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n     {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n     {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires v matches Vehicle2::Train(true)\nensures res == if o is Some, res == if r is Ok", "full_verified_code": "use verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n#[derive(Structural, PartialEq, Eq)]\nstruct Car<P> {\n    four_doors: bool,\n    passengers: P,\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle {\n    Car(Car<u64>),\n    Train(bool),\n}\n\nfn test_struct_1(p: u64) {\n    let c1 = Car { four_doors: true, passengers: p };\n    assert(c1.passengers == p);\n    assert((Car { passengers: p, four_doors: true }).passengers == p);\n}\n\nfn test_structural_eq(passengers: u64) {\n    let c1 = Car { passengers, four_doors: true };\n    let c2 = Car { passengers, four_doors: false };\n    let c3 = Car { passengers, four_doors: true };\n    assert(c1 == c3);\n    assert(c1 != c2);\n    let t = Vehicle::Train(true);\n    let ca = Vehicle::Car(c1);\n    assert(t != ca);\n}\n\n#[derive(Structural, PartialEq, Eq)]\nenum Vehicle2<T> {\n    Car(Car<T>),\n    Train(bool),\n}\n\nfn test_is_variant_1(v: Vehicle2<u64>) {\n    match v {\n        Vehicle2::Car(_) => assert(v is Car),\n        Vehicle2::Train(_) => assert(v is Train),\n    };\n}\n\nfn test_is_variant_2(v: Vehicle2<u64>)\n    requires v matches Vehicle2::Train(true)\n{\n}\n\nfn test_option(o: Option<u64>) -> (res: u64)\n    ensures\n        res == if o is Some {\n            o->0\n        } else {\n            0\n        },\n{\n    match o {\n        Option::Some(v) => v,\n        Option::None => 0,\n    }\n}\n\nfn test_result<E>(r: Result<u64, E>) -> (res: u64)\n    ensures\n        res == if r is Ok {\n            r->Ok_0\n        } else {\n            0\n        },\n{\n    match r {\n        Result::Ok(v) => v,\n        Result::Err(_) => 0,\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/adts.rs", "verified": true, "metadata": {"original_id": "verus_adts_7172b41de434", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b272abf7a481", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "b272abf7a481", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5d77e5301987", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5d77e5301987", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cc0c928fbc2f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires c <= n , n == a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool) requires c <= n , n == a . len () , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "cc0c928fbc2f", "function_name": "fillK", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e5e53c32a53f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e5e53c32a53f", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c6e3b769730", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires shortest_beautiful_substring_precond (s @ , k as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_71/verina_advanced_71_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7c6e3b769730", "function_name": "shortest_beautiful_substring", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8d2b7ee294a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "requires d > 0\nensures result == sum_of_digits (x as nat), result == is_sum_divisible_by (x as nat , d as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "8d2b7ee294a3", "function_name": "is_sum_divisible_by_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1eb6f2899eb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "1eb6f2899eb8", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9c00390f6d99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9c00390f6d99", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4be2c39f8aa2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "4be2c39f8aa2", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e31100fab272", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e31100fab272", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ab9a64c09140", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "ab9a64c09140", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4d4bbc1406b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "4d4bbc1406b0", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8543c41ecc1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_min_iter_0_original.rs", "verified": true, "metadata": {"original_id": "8543c41ecc1a", "function_name": "min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e436006d696", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >)  { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { ch } else { str1 [i] }) , { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_230_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0e436006d696", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_16ff0c84e53e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "16ff0c84e53e", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a1ca01cbe16a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a1ca01cbe16a", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3ab45420c105", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] pub fn copy_from_slice (bytes : & [u8]) -> (out : Vec < u8 >)  { let mut buffer = vec ! [0 ; bytes . len ()] ; let buffer_slice = buffer . as_mut_slice () ; buffer_slice . copy_from_slice (bytes) ; buffer }\n\n} // verus!", "target_text": "ensures out @ == bytes @\ninvariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] pub fn copy_from_slice (bytes : & [u8]) -> (out : Vec < u8 >) ensures out @ == bytes @ { let mut buffer = vec ! [0 ; bytes . len ()] ; let buffer_slice = buffer . as_mut_slice () ; buffer_slice . copy_from_slice (bytes) ; buffer }\n\n} // verus!", "source": "vericoding_ast", "source_file": "multilog_inlined.rs", "verified": true, "metadata": {"original_id": "3ab45420c105", "function_name": "copy_from_slice", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7501af37a05e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "7501af37a05e", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4230f034f4f9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut i = a . len () - 1 ; loop  { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; }  0 }\n\n} // verus!", "target_text": "requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases i\ninvariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "4230f034f4f9", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e04ffe04067f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e04ffe04067f", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_38cb1d1d32e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  { if p >= arr . len () { return true ; } let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () { return true ; } let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "38cb1d1d32e8", "function_name": "barrier", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ff6ad118b623", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 . len () - idx\ninvariant 0 <= idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant 0 <= idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "ff6ad118b623", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_proposal-rw2022_7d76b33c938f", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n\n    {\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires i <= j, fibo_fits_u64(n as nat)\nensures fibo(i) <= fibo(j), result == fibo(n as nat), fibo(i) <= fibo(j),\n    decreases j - i\ndecreases n, j - i\ninvariant 0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat)", "full_verified_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/proposal-rw2022.rs", "verified": true, "metadata": {"original_id": "verus_proposal-rw2022_7d76b33c938f", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_const_4a3b8978107b", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n\n{\n    1\n}\n\nexec const E: u64\n\n{\n\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires x < 0xff\nensures C == 7, u == f(), ret == x + ONE,  // use \"ONE\" in spec code, E == 2, USIZE_BYTES as nat == layout::size_of::<usize>()", "full_verified_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/const.rs", "verified": true, "metadata": {"original_id": "verus_const_4a3b8978107b", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5dc6a29ccaa0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "5dc6a29ccaa0", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7287334c84d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7287334c84d4", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_876b26085621", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_better_iter_0_original.rs", "verified": true, "metadata": {"original_id": "876b26085621", "function_name": "unique_better", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ad2bee13c5b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "ensures result == sum_of_digits (x as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ad2bee13c5b3", "function_name": "sum_of_digits_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0f4160e689c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len ()  { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ninvariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0f4160e689c7", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_bb0489574c48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >)   { let mut i = 0 ; while i < a . len ()  { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "requires find_first_odd_precond (a)\nensures find_first_odd_postcond (a , result)\ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_49/verina_basic_49_impl.rs", "verified": true, "metadata": {"original_id": "bb0489574c48", "function_name": "find_first_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1bc64135516d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ninvariant forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1bc64135516d", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_282f6aca56ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s1if_impl.rs", "verified": true, "metadata": {"original_id": "282f6aca56ab", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9c4b95c26686", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9c4b95c26686", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1f93987007c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1f93987007c2", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a1c61a5b9f0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1)  { for j in (p + 1) .. arr . len ()  { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "target_text": "ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ninvariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1) invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , { for j in (p + 1) .. arr . len () invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "a1c61a5b9f0b", "function_name": "barrier", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0901af1693d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_0_original.rs", "verified": true, "metadata": {"original_id": "0901af1693d5", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_54aa4f8494bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { let mut i = 0 ; while i < lst . len () - 1  { if lst [i] > lst [i + 1] { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ndecreases lst . len () - 1 - i\ninvariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "54aa4f8494bb", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7e11715b30a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { let mut idx = 0 ; while idx < l . len ()  { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ndecreases l . len () - idx\ninvariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { let mut idx = 0 ; while idx < l . len () invariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t , decreases l . len () - idx { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/052-below-threshold_impl.rs", "verified": true, "metadata": {"original_id": "7e11715b30a0", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_661b222f9a34", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "661b222f9a34", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8f02b90892eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z' { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f02b90892eb", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_ref_cell_2d1e7719c23e", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::multiset::*;\nuse vstd::pervasive::*;\nuse vstd::prelude::*;\nuse vstd::shared::*;\n\nverus! {\n\n//////////////////////////////////////////////////////////////////////////////\npub enum BorrowFlag {\n    MutBorrow,\n    ReadBorrow(nat),  // 0 if there are no borrows\n}\n\ntype Perm<S> = cell::PointsTo<S>;\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<S> {\n    fields {\n        #[sharding(constant)]\n        pub pcell_loc: CellId,\n\n        #[sharding(variable)]\n        pub flag: BorrowFlag,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm<S>>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm<S>>,\n\n        #[sharding(bool)]\n        pub writer: bool,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn flag_inv(&self) -> bool {\n        match self.flag {\n            BorrowFlag::MutBorrow => {\n                self.writer && self.reader == Multiset::<Perm<S>>::empty()\n                  && self.storage is None\n            }\n            BorrowFlag::ReadBorrow(n) => {\n                !self.writer\n                  && self.storage is Some\n                  && self.reader.count(self.storage->0) == n\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn storage_inv(&self) -> bool {\n        match self.storage {\n            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),\n            None => true,\n        }\n    }\n\n    init!{\n        initialize_empty(loc: CellId) {\n            init pcell_loc = loc;\n            init flag = BorrowFlag::MutBorrow;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n            init writer = true;\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self, loc: CellId) { }\n\n    transition!{\n        do_deposit(x: Perm<S>) {\n            require(x@.pcell == pre.pcell_loc && x.is_init());\n            remove writer -= true;\n\n            update flag = BorrowFlag::ReadBorrow(0);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }\n\n    transition!{\n        do_withdraw() {\n            require(pre.flag == BorrowFlag::ReadBorrow(0));\n            update flag = BorrowFlag::MutBorrow;\n\n            add writer += true;\n\n            withdraw storage -= Some(let x);\n\n        }\n    }\n\n    #[inductive(do_withdraw)]\n    fn do_withdraw_inductive(pre: Self, post: Self) {\n        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());\n    }\n\n    property!{\n        reader_guard(x: Perm<S>) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        new_reader() {\n            require let BorrowFlag::ReadBorrow(n) = pre.flag;\n            update flag = BorrowFlag::ReadBorrow(n + 1);\n\n            birds_eye let x = pre.storage->0;\n            add reader += { x };\n\n        }\n    }\n\n    #[inductive(new_reader)]\n    fn new_reader_inductive(pre: Self, post: Self) { }\n\n    transition!{\n        drop_reader(x: Perm<S>) {\n            remove reader -= { x };\n            assert let BorrowFlag::ReadBorrow(n) = pre.flag;\n            assert n >= 1;\n            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);\n        }\n    }\n\n    #[inductive(drop_reader)]\n    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {\n\n    }\n});\n\npub tracked struct GhostStuff<S> {\n    tracked rc_perm: cell::PointsTo<isize>,\n    tracked flag_token: RefCounter::flag<S>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {\n        &&& self.rc_perm@.pcell == rc_cell.id()\n        &&& self.flag_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as int == match self.flag_token.value() {\n            BorrowFlag::MutBorrow => 1,\n            BorrowFlag::ReadBorrow(n) => -n,\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct RefCell<S> {\n        // 0: no reference taken\n        // 1: mut reference taken\n        // -n: n non-mut references taken\n        rc_cell: PCell<isize>,\n        value_cell: PCell<S>,\n\n        inst: Tracked< RefCounter::Instance<S> >,\n        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        predicate {\n            &&& self.inst@.pcell_loc() == self.value_cell.id()\n        }\n\n        {\n            v.wf(inst@, rc_cell)\n        }\n    }\n}\n\npub struct Ref<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    reader: Tracked<RefCounter::reader<S>>,\n}\n\nimpl<'a, S> Ref<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n            && self.reader@.instance_id() == self.ref_cell.inst@.id()\n            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()\n            && self.reader@.element().is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.reader@.element().value()\n    }\n}\n\npub struct RefMut<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    writer: Tracked<RefCounter::writer<S>>,\n    perm: Tracked<Perm<S>>,\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n          && self.writer@.instance_id() == self.ref_cell.inst@.id()\n          && self.perm@@.pcell == self.ref_cell.value_cell.id()\n          && self.perm@.is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.perm@.value()\n    }\n}\n\nimpl<S> RefCell<S> {\n    fn new(s: S) -> (ref_cell: Self)\n\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);\n        let (value_cell, Tracked(value_perm)) = PCell::new(s);\n        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<\n            S,\n        >::initialize_empty(value_cell.id(), None);\n\n        let tracked_inst = Tracked(inst);\n        let tracked inv = LocalInvariant::new(\n            (tracked_inst, rc_cell),\n            GhostStuff { rc_perm, flag_token: flag },\n            0,\n        );\n        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }\n    }\n\n    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)\n\n         {\n                Some(read_ref) => read_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc <= 0 && cur_rc > isize::MIN {\n                let new_rc = cur_rc - 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (_, Tracked(reader_token)) =\n                    self.inst.borrow().new_reader(&mut flag_token);\n                return_value = Some(Ref {\n                    ref_cell: self,\n                    reader: Tracked(reader_token),\n                });\n            } else {\n                return_value = None;\n            }\n\n        });\n        return_value\n    }\n\n    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)\n\n         {\n                Some(write_ref) => write_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc == 0 {\n                let new_rc = 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (Tracked(perm), Tracked(writer_token)) =\n                    self.inst.borrow().do_withdraw(&mut flag_token);\n                return_value = Some(RefMut {\n                    ref_cell: self,\n                    writer: Tracked(writer_token),\n                    perm: Tracked(perm),\n                });\n            } else {\n                return_value = None;\n            }\n\n        });\n        return_value\n    }\n}\n\nimpl<'a, S> Ref<'a, S> {\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n\n    {\n        self.ref_cell.value_cell.borrow(\n            Tracked(\n                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),\n            ),\n        )\n    }\n\n    fn dispose(self)\n\n    {\n        let Ref { ref_cell, reader: Tracked(reader) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));\n            let new_rc = cur_rc + 1;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n        });\n    }\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    fn replace(&mut self, in_s: S) -> (out_s: S)\n\n    {\n        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)\n    }\n\n    fn dispose(self)\n\n    {\n        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let new_rc = 0;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n        });\n    }\n}\n\nfn main() {\n    let rf = RefCell::new(5);\n    let read_ref1 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let read_ref2 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let x = *read_ref1.borrow();\n    let y = *read_ref2.borrow();\n    print_u64(x);\n    print_u64(y);\n    read_ref1.dispose();\n    read_ref2.dispose();\n    let mut write_ref = match rf.try_borrow_mut() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let t = write_ref.replace(20);\n    print_u64(t);\n    write_ref.dispose();\n    let read_ref3 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let z = *read_ref3.borrow();\n    print_u64(z);\n    read_ref3.dispose();\n}\n\n} // verus!\n", "target_text": "requires self.wf(), self.wf(), self.wf(), self.wf(), old(self).wf(), self.wf()\nensures ref_cell.wf(), match opt_ref, match opt_ref_mut, *s == self.value(), self.wf(),\n            out_s == old(self).value(),\n            in_s == self.value()\ninvariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)", "full_verified_code": "#![allow(unused_imports)]\n\n// ANCHOR: full\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::multiset::*;\nuse vstd::pervasive::*;\nuse vstd::prelude::*;\nuse vstd::shared::*;\n\nverus! {\n\n//////////////////////////////////////////////////////////////////////////////\npub enum BorrowFlag {\n    MutBorrow,\n    ReadBorrow(nat),  // 0 if there are no borrows\n}\n\ntype Perm<S> = cell::PointsTo<S>;\n\n// ANCHOR: fields\ntokenized_state_machine!(RefCounter<S> {\n    fields {\n        #[sharding(constant)]\n        pub pcell_loc: CellId,\n\n        #[sharding(variable)]\n        pub flag: BorrowFlag,\n\n        #[sharding(storage_option)]\n        pub storage: Option<Perm<S>>,\n\n        #[sharding(multiset)]\n        pub reader: Multiset<Perm<S>>,\n\n        #[sharding(bool)]\n        pub writer: bool,\n    }\n// ANCHOR_END: fields\n\n    #[invariant]\n    pub fn reader_agrees_storage(&self) -> bool {\n        forall |t: Perm<S>| #[trigger] self.reader.count(t) > 0 ==>\n            self.storage == Option::Some(t)\n    }\n\n    #[invariant]\n    pub fn flag_inv(&self) -> bool {\n        match self.flag {\n            BorrowFlag::MutBorrow => {\n                self.writer && self.reader == Multiset::<Perm<S>>::empty()\n                  && self.storage is None\n            }\n            BorrowFlag::ReadBorrow(n) => {\n                !self.writer\n                  && self.storage is Some\n                  && self.reader.count(self.storage->0) == n\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn storage_inv(&self) -> bool {\n        match self.storage {\n            Some(x) => x@.pcell == self.pcell_loc && x.is_init(),\n            None => true,\n        }\n    }\n\n    init!{\n        initialize_empty(loc: CellId) {\n            init pcell_loc = loc;\n            init flag = BorrowFlag::MutBorrow;\n            init storage = Option::None;\n            init reader = Multiset::empty();\n            init writer = true;\n        }\n    }\n\n    #[inductive(initialize_empty)]\n    fn initialize_empty_inductive(post: Self, loc: CellId) { }\n\n    transition!{\n        do_deposit(x: Perm<S>) {\n            require(x@.pcell == pre.pcell_loc && x.is_init());\n            remove writer -= true;\n            assert(pre.flag == BorrowFlag::MutBorrow);\n            update flag = BorrowFlag::ReadBorrow(0);\n\n            deposit storage += Some(x);\n        }\n    }\n\n    #[inductive(do_deposit)]\n    fn do_deposit_inductive(pre: Self, post: Self, x: Perm<S>) { }\n\n    transition!{\n        do_withdraw() {\n            require(pre.flag == BorrowFlag::ReadBorrow(0));\n            update flag = BorrowFlag::MutBorrow;\n\n            add writer += true;\n\n            withdraw storage -= Some(let x);\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(do_withdraw)]\n    fn do_withdraw_inductive(pre: Self, post: Self) {\n        assert_multisets_equal!(post.reader, Multiset::<Perm<S>>::empty());\n    }\n\n    property!{\n        reader_guard(x: Perm<S>) {\n            have reader >= {x};\n            guard storage >= Some(x);\n        }\n    }\n\n    transition!{\n        new_reader() {\n            require let BorrowFlag::ReadBorrow(n) = pre.flag;\n            update flag = BorrowFlag::ReadBorrow(n + 1);\n\n            birds_eye let x = pre.storage->0;\n            add reader += { x };\n            assert(x@.pcell == pre.pcell_loc && x.is_init());\n        }\n    }\n\n    #[inductive(new_reader)]\n    fn new_reader_inductive(pre: Self, post: Self) { }\n\n    transition!{\n        drop_reader(x: Perm<S>) {\n            remove reader -= { x };\n            assert let BorrowFlag::ReadBorrow(n) = pre.flag;\n            assert n >= 1;\n            update flag = BorrowFlag::ReadBorrow((n - 1) as nat);\n        }\n    }\n\n    #[inductive(drop_reader)]\n    fn drop_reader_inductive(pre: Self, post: Self, x: Perm<S>) {\n        assert(pre.reader.count(x) > 0);\n        assert(pre.storage == Option::Some(x));\n        assert(pre.storage is Some);\n    }\n});\n\npub tracked struct GhostStuff<S> {\n    tracked rc_perm: cell::PointsTo<isize>,\n    tracked flag_token: RefCounter::flag<S>,\n}\n\nimpl<S> GhostStuff<S> {\n    pub closed spec fn wf(self, inst: RefCounter::Instance<S>, rc_cell: PCell<isize>) -> bool {\n        &&& self.rc_perm@.pcell == rc_cell.id()\n        &&& self.flag_token.instance_id() == inst.id()\n        &&& self.rc_perm.is_init()\n        &&& self.rc_perm.value() as int == match self.flag_token.value() {\n            BorrowFlag::MutBorrow => 1,\n            BorrowFlag::ReadBorrow(n) => -n,\n        }\n    }\n}\n\nstruct_with_invariants!{\n    pub struct RefCell<S> {\n        // 0: no reference taken\n        // 1: mut reference taken\n        // -n: n non-mut references taken\n        rc_cell: PCell<isize>,\n        value_cell: PCell<S>,\n\n        inst: Tracked< RefCounter::Instance<S> >,\n        inv: Tracked< Shared<LocalInvariant<_, GhostStuff<S>, _>> >,\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        predicate {\n            &&& self.inst@.pcell_loc() == self.value_cell.id()\n        }\n\n        invariant on inv with (inst, rc_cell)\n            specifically (self.inv@@)\n            is (v: GhostStuff<S>)\n        {\n            v.wf(inst@, rc_cell)\n        }\n    }\n}\n\npub struct Ref<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    reader: Tracked<RefCounter::reader<S>>,\n}\n\nimpl<'a, S> Ref<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n            && self.reader@.instance_id() == self.ref_cell.inst@.id()\n            && self.reader@.element()@.pcell == self.ref_cell.value_cell.id()\n            && self.reader@.element().is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.reader@.element().value()\n    }\n}\n\npub struct RefMut<'a, S> {\n    ref_cell: &'a RefCell<S>,\n    writer: Tracked<RefCounter::writer<S>>,\n    perm: Tracked<Perm<S>>,\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    pub closed spec fn wf(&self) -> bool {\n        self.ref_cell.wf()\n          && self.writer@.instance_id() == self.ref_cell.inst@.id()\n          && self.perm@@.pcell == self.ref_cell.value_cell.id()\n          && self.perm@.is_init()\n    }\n\n    pub closed spec fn value(&self) -> S {\n        self.perm@.value()\n    }\n}\n\nimpl<S> RefCell<S> {\n    fn new(s: S) -> (ref_cell: Self)\n        ensures\n            ref_cell.wf(),\n    {\n        let (rc_cell, Tracked(rc_perm)) = PCell::new(0);\n        let (value_cell, Tracked(value_perm)) = PCell::new(s);\n        let tracked (Tracked(inst), Tracked(flag), _, Tracked(writer)) = RefCounter::Instance::<\n            S,\n        >::initialize_empty(value_cell.id(), None);\n        proof {\n            inst.do_deposit(value_perm, &mut flag, value_perm, writer.tracked_unwrap());\n        }\n        let tracked_inst = Tracked(inst);\n        let tracked inv = LocalInvariant::new(\n            (tracked_inst, rc_cell),\n            GhostStuff { rc_perm, flag_token: flag },\n            0,\n        );\n        RefCell::<S> { rc_cell, value_cell, inst: tracked_inst, inv: Tracked(Shared::new(inv)) }\n    }\n\n    fn try_borrow<'a>(&'a self) -> (opt_ref: Option<Ref<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref {\n                Some(read_ref) => read_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc <= 0 && cur_rc > isize::MIN {\n                let new_rc = cur_rc - 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (_, Tracked(reader_token)) =\n                    self.inst.borrow().new_reader(&mut flag_token);\n                return_value = Some(Ref {\n                    ref_cell: self,\n                    reader: Tracked(reader_token),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n\n    fn try_borrow_mut<'a>(&'a self) -> (opt_ref_mut: Option<RefMut<'a, S>>)\n        requires\n            self.wf(),\n        ensures\n            match opt_ref_mut {\n                Some(write_ref) => write_ref.wf(),\n                None => true,\n            },\n    {\n        let return_value;\n        open_local_invariant!(self.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            let cur_rc = *self.rc_cell.borrow(Tracked(&rc_perm));\n\n            if cur_rc == 0 {\n                let new_rc = 1;\n                self.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n                let tracked (Tracked(perm), Tracked(writer_token)) =\n                    self.inst.borrow().do_withdraw(&mut flag_token);\n                return_value = Some(RefMut {\n                    ref_cell: self,\n                    writer: Tracked(writer_token),\n                    perm: Tracked(perm),\n                });\n            } else {\n                return_value = None;\n            }\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n        return_value\n    }\n}\n\nimpl<'a, S> Ref<'a, S> {\n    fn borrow<'b>(&'b self) -> (s: &'b S)\n        requires\n            self.wf(),\n        ensures\n            *s == self.value(),\n    {\n        self.ref_cell.value_cell.borrow(\n            Tracked(\n                self.ref_cell.inst.borrow().reader_guard(self.reader@.element(), self.reader.borrow()),\n            ),\n        )\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let Ref { ref_cell, reader: Tracked(reader) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().drop_reader(reader.element(), &mut flag_token, reader);\n            }\n\n            let cur_rc = *ref_cell.rc_cell.borrow(Tracked(&rc_perm));\n            let new_rc = cur_rc + 1;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nimpl<'a, S> RefMut<'a, S> {\n    fn replace(&mut self, in_s: S) -> (out_s: S)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            out_s == old(self).value(),\n            in_s == self.value(),\n    {\n        self.ref_cell.value_cell.replace(Tracked(self.perm.borrow_mut()), in_s)\n    }\n\n    fn dispose(self)\n        requires\n            self.wf(),\n    {\n        let RefMut { ref_cell, writer: Tracked(writer), perm: Tracked(perm) } = self;\n        open_local_invariant!(ref_cell.inv.borrow().borrow() => g => {\n            let tracked GhostStuff { rc_perm: mut rc_perm, flag_token: mut flag_token } = g;\n\n            proof {\n                ref_cell.inst.borrow().do_deposit(perm, &mut flag_token, perm, writer);\n            }\n\n            let new_rc = 0;\n            ref_cell.rc_cell.write(Tracked(&mut rc_perm), new_rc);\n\n            proof { g = GhostStuff { rc_perm, flag_token }; }\n        });\n    }\n}\n\nfn main() {\n    let rf = RefCell::new(5);\n    let read_ref1 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let read_ref2 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let x = *read_ref1.borrow();\n    let y = *read_ref2.borrow();\n    print_u64(x);\n    print_u64(y);\n    read_ref1.dispose();\n    read_ref2.dispose();\n    let mut write_ref = match rf.try_borrow_mut() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let t = write_ref.replace(20);\n    print_u64(t);\n    write_ref.dispose();\n    let read_ref3 = match rf.try_borrow() {\n        Some(x) => x,\n        None => {\n            return ;\n        },\n    };\n    let z = *read_ref3.borrow();\n    print_u64(z);\n    read_ref3.dispose();\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/ref_cell.rs", "verified": true, "metadata": {"original_id": "verus_ref_cell_2d1e7719c23e", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_36d1bb095bb5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "36d1bb095bb5", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_69f96a3bf115", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len ()  { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - idx\ninvariant idx <= arr . len () , copied @ . len () == idx , forall | i : int | (0 <= i < idx) ==> arr [i] == copied [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len () invariant idx <= arr . len () , copied @ . len () == idx , forall | i : int | (0 <= i < idx) ==> arr [i] == copied [i] , decreases arr . len () - idx { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "69f96a3bf115", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_760590b3d061", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/brs2_impl.rs", "verified": true, "metadata": {"original_id": "760590b3d061", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f50c9ffb1ee3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > decreases nums . len () - i { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f50c9ffb1ee3", "function_name": "two_sum_outer", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b218a05d3c88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b218a05d3c88", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_65b358753fce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "65b358753fce", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a52ae0d25094", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires square_root_precond (n as nat) , n <= 100 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32) requires square_root_precond (n as nat) , n <= 100 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_65/verina_basic_65_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a52ae0d25094", "function_name": "square_root", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2ce9c2fbf0a7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "2ce9c2fbf0a7", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6c57323acece", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64)   { return 0 ; }\n\n} // verus!", "target_text": "requires 0 <= k <= n \nensures result as nat == comb (n as nat , k as nat) \ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_CombNK/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6c57323acece", "function_name": "comb_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c8dd4b36aa98", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "c8dd4b36aa98", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_88a5b1553ff6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ndecreases numbers . len () - i\ninvariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "88a5b1553ff6", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_41ff95777d45", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)   { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)   {  c [j] - c [i] }\n\n} // verus!", "target_text": "requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c), a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 \nensures sum (a , i , j) == c [j] - c [i], r == sum (seq_to_int (a @) , i as int , j as int), sum (a , i , j) == c [j] - c [i] decreases j - i\ndecreases j - i, j - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "41ff95777d45", "function_name": "query_fast", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_595fab833fb5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "595fab833fb5", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2b478bfb2995", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | 0 <= i < a . len () && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_linear_search2/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2b478bfb2995", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b812c4a3edf5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_impl.rs", "verified": true, "metadata": {"original_id": "b812c4a3edf5", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_067a2aec34a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right  { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()\ndecreases right - left\ninvariant left <= right <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_24/verina_advanced_24_iter_2_current.rs", "verified": true, "metadata": {"original_id": "067a2aec34a1", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5e9cc255e917", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)   { let mut i = 0 ; while i < nums . len () - 1  { let mut j = i + 1 ; while j < nums . len ()  { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN \nensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target \ndecreases nums . len () - 1 - i, nums . len () - j\ninvariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "5e9cc255e917", "function_name": "pairs_sum_to_zero", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_17dbe9409d72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "17dbe9409d72", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eaf2a2271d61", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { return 0 ; }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_24/verina_advanced_24_iter_0_original.rs", "verified": true, "metadata": {"original_id": "eaf2a2271d61", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_77c304f26af7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { let mut i = 0 ; while i < lst . len () - 1  { if lst [i] > lst [i + 1] { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ndecreases lst . len () - 1 - i\ninvariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_sorted_iter_2_current.rs", "verified": true, "metadata": {"original_id": "77c304f26af7", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_76d66feff36e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s42if_impl.rs", "verified": true, "metadata": {"original_id": "76d66feff36e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_536fcaaf9536", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: layout ;\nuse vstd :: raw_ptr :: MemContents ;\nuse vstd :: simple_pptr :: { self , PPtr } ;\nuse vstd :: arithmetic :: logarithm :: * ;\nuse vstd :: arithmetic :: power :: * ;\nuse vstd :: arithmetic :: power2 :: * ;\nuse vstd :: bits :: * ;\nuse vstd :: layout :: is_power_2 ;\nuse vstd :: relations :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: atomic :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [inline (always)] pub exec fn layout_for_array_is_valid < V : Sized , const N : usize > ()  { }\n\n} // verus!", "target_text": "ensures layout :: valid_layout (layout :: size_of :: < [V ; N] > () as usize , layout :: align_of :: < [V ; N] > () as usize ,) , layout :: size_of :: < [V ; N] > () as usize as nat == layout :: size_of :: < [V ; N] > () , layout :: align_of :: < [V ; N] > () as usize as nat == layout :: align_of :: < [V ; N] > () , opens_invariants none no_unwind", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: layout ;\nuse vstd :: raw_ptr :: MemContents ;\nuse vstd :: simple_pptr :: { self , PPtr } ;\nuse vstd :: arithmetic :: logarithm :: * ;\nuse vstd :: arithmetic :: power :: * ;\nuse vstd :: arithmetic :: power2 :: * ;\nuse vstd :: bits :: * ;\nuse vstd :: layout :: is_power_2 ;\nuse vstd :: relations :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: atomic :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [inline (always)] pub exec fn layout_for_array_is_valid < V : Sized , const N : usize > () ensures layout :: valid_layout (layout :: size_of :: < [V ; N] > () as usize , layout :: align_of :: < [V ; N] > () as usize ,) , layout :: size_of :: < [V ; N] > () as usize as nat == layout :: size_of :: < [V ; N] > () , layout :: align_of :: < [V ; N] > () as usize as nat == layout :: align_of :: < [V ; N] > () , opens_invariants none no_unwind { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "vstd_extra_inlined.rs", "verified": true, "metadata": {"original_id": "536fcaaf9536", "function_name": "layout_for_array_is_valid", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7fda24ebcce6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7fda24ebcce6", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d29ad2b3aa22", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool)  { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c), str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_732_iter_3_current.rs", "verified": true, "metadata": {"original_id": "d29ad2b3aa22", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d4630a170c04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires has_close_elements_precond (numbers @ , threshold) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool) requires has_close_elements_precond (numbers @ , threshold) , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "d4630a170c04", "function_name": "has_close_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_057da121d61c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases j\ninvariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/reverse_impl.rs", "verified": true, "metadata": {"original_id": "057da121d61c", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d388d86d804c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs1_impl.rs", "verified": true, "metadata": {"original_id": "d388d86d804c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c0f0e20133b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "7c0f0e20133b", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_74e74503ed04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "74e74503ed04", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cb6172ad4867", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb6172ad4867", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c36490f8ed2a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    result . push (arr1 [i] * arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] * arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] * arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] * arr2 [i as int] <= MAX) ; result . push (arr1 [i] * arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_445_impl.rs", "verified": true, "metadata": {"original_id": "c36490f8ed2a", "function_name": "element_wise_multiplication", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verified-memory-allocator_bitmap_78a931c15aa7", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\nuse vstd::raw_ptr::*;\nuse vstd::*;\nuse vstd::set_lib::*;\n\nverus!{\n\n/*\n\ntype G = crate::os_mem::MemChunk;\ntype K = int;\n\npub open spec fn entry_inv(k: K, user_idx: int, g: G) -> bool {\n    g.wf()\n      && g.os_exact_range(\n            k + user_idx * crate::arena::ARENA_BLOCK_SIZE,\n            crate::arena::ARENA_BLOCK_SIZE as int\n        )\n      && g.has_pointsto_for_all_read_write()\n}\n\npub open spec fn map_has_range(m: Map<int, G>, start: int, end: int, k: K) -> bool {\n    (forall |i| start <= i < end ==> m.dom().contains(i))\n    && (forall |i| start <= i < end ==> entry_inv(k, i, #[trigger] m.index(i)))\n}\n\n// field_idx = index into the data array (0 <= field_idx < data.len())\n// bit_idx = index of a bit within a word (0 <= bit_idx < usize::BITS)\n// user_idx = index of object from user perspective\n//      (user_idx = field_idx * usize::BITS + bit_idx)\n\nstruct_with_invariants!{\n    pub struct Bitmap {\n        data: Vec<AtomicUsize<_, Map<int, G>, _>>,\n        ghost k: K,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            self.data.len() < 0x1000000\n        }\n\n        {\n            forall |bitidx: int|\n                ! #[trigger] has_bit(v, bitidx)\n                ==> gmap.dom().contains(field_idx * usize::BITS + bitidx)\n                    && entry_inv(k,\n                        field_idx * usize::BITS + bitidx,\n                        gmap.index(field_idx * usize::BITS + bitidx))\n        }\n    }\n}\n\npub closed spec fn has_bit(v: usize, i: int) -> bool {\n    (0 <= i < usize::BITS && ((v >> (i as usize)) & 1usize) != 0)\n}\n\nimpl Bitmap {\n    pub closed spec fn len(&self) -> nat {\n        self.data@.len()\n    }\n\n    pub closed spec fn constant(&self) -> int {\n        self.k\n    }\n\n    pub fn bitmap_try_find_from_claim_across(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n        {\n            let (success, user_idx, tr_map) = res;\n            success ==> {\n                &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n            }\n        }),\n    {\n        if count == 1 {\n            return self.bitmap_try_find_from_claim(start_field_idx, count);\n        }\n\n        assume(false); loop { }\n    }\n\n    fn bitmap_try_find_from_claim(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n    {\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let mut idx = start_field_idx;\n        let mut visited = 0;\n        let bitmap_fields = self.data.len();\n        while visited < bitmap_fields\n\n        {\n            if idx >= bitmap_fields {\n                idx = 0;\n            }\n\n            let (success, user_idx, tr_map) =\n                self.bitmap_try_find_claim_field(idx, count);\n            if success {\n                return (true, user_idx, tr_map);\n            }\n\n            visited = visited + 1;\n            idx = idx + 1;\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    fn bitmap_try_find_claim_field(&self, field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n\n    {\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& usize::BITS * field_idx <= user_idx\n            &&& user_idx + count <= usize::BITS * (field_idx + 1)\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let atomic = &self.data[field_idx];\n\n        let mut map = atomic.load();\n        if map == !(0usize) {\n            return (false, 0, Tracked(Map::tracked_empty()));\n        }\n\n        assert((1usize << count) >= 1usize) by(bit_vector)\n             { }\n\n        let mask = (1usize << count) - 1;\n        let bitidx_max = usize::BITS as usize - count;\n\n        let mut bitidx = crate::bin_sizes::trailing_zeros(map) as usize;\n        let mut m = mask << bitidx;\n\n        while bitidx <= bitidx_max\n\n        {\n            let mapm = map & m;\n            if mapm == 0 {\n                let tracked mut res_map: Map<int, G>;\n\n                let newmap = map | m;\n                let res = my_atomic_with_ghost!(\n                    atomic => compare_exchange_weak(map, newmap);\n                    update old_v -> new_v;\n                    returning res;\n                    ghost gmap =>\n                {\n                    if res.is_Ok() {\n                        let range = set_int_range(\n                            usize::BITS * field_idx + bitidx,\n                            usize::BITS * field_idx + bitidx + count);\n\n                        verus_proof_expr!({\n                        });\n\n                        res_map = gmap.tracked_remove_keys(range);\n\n                        assume(bitidx + count < usize::BITS);\n\n                        let bit = bitidx;\n\n                        verus_proof_expr!({\n                        else {\n                                if bitidx0 >= usize::BITS || bitidx0 < 0 {\n\n                                } else {\n                                    let bi = bitidx0 as usize;\n\n                                    if bit > bi {\n\n                                }\n                            }\n                        }\n                        });\n                    }\n                });\n\n                match res {\n                    Result::Ok(_) => {\n                        let user_idx = usize::BITS as usize * field_idx + bitidx;\n                        return (true, user_idx, Tracked(res_map));\n                    }\n                    Result::Err(updated_map) => {\n                        map = updated_map;\n                    }\n                }\n            } else {\n                let shift = if count == 1 {\n                    1\n                } else {\n                    let tz = crate::bin_sizes::trailing_zeros(mapm) as usize;\n                    assume(tz + 1 >= bitidx);\n                    tz + 1 - bitidx\n                };\n\n                assert(((mask << bitidx) << shift) == mask << add(bitidx, shift))\n                  by(bit_vector)\n\n                    { }\n\n                bitidx = bitidx + shift;\n                m = m << shift;\n\n            }\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    //pub bitmap_try_find_claim_field_across(&self, idx: usize,\n}\n\n*/\n\n}\n", "target_text": "requires self.wf(),\n        0 <= start_field_idx < self.len(), self.wf(),\n        0 <= start_field_idx < self.data@.len(),\n        1 <= count < usize::BITS, self.wf(),\n        0 <= field_idx < self.data@.len(),\n        1 <= count < usize::BITS, count < 64usize, bitidx <= bi < add(bitidx, count) < 64usize,\n                                  new_v == old_v | m,\n                                  m == sub(1usize << count, 1) << bitidx,\n                                  old_v & m == 0usize,\n                                  1usize <= count <= (64usize), bitidx > bi,\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize), bi >= add(bitidx, count),\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize), bitidx <= 64usize,\n                        shift <= 64usize,\n                        add(bitidx, shift) <= 64usize\nensures (, (, (\ninvariant on data\n            with (k)\n            forall |field_idx: int|\n            where (0 <= field_idx < self.data@.len())\n            specifically (self.data@.index(field_idx))\n            is (v: usize, gmap: Map<int, G>), self.wf(),\n                0 <= start_field_idx < self.data@.len(),\n                1 <= count < usize::BITS,\n                visited <= bitmap_fields,\n                bitmap_fields == self.data@.len(), self.wf(),\n                atomic == self.data@.index(field_idx as int),\n                0 <= field_idx < self.data@.len(),\n                1 <= count <= usize::BITS,\n                bitidx_max == usize::BITS - count,\n                m == mask << bitidx,\n                mask == (1usize << count) - 1", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_state_machines_macros::*;\nuse vstd::prelude::*;\nuse vstd::raw_ptr::*;\nuse vstd::*;\nuse vstd::set_lib::*;\n\nverus!{\n\n/*\n\ntype G = crate::os_mem::MemChunk;\ntype K = int;\n\npub open spec fn entry_inv(k: K, user_idx: int, g: G) -> bool {\n    g.wf()\n      && g.os_exact_range(\n            k + user_idx * crate::arena::ARENA_BLOCK_SIZE,\n            crate::arena::ARENA_BLOCK_SIZE as int\n        )\n      && g.has_pointsto_for_all_read_write()\n}\n\npub open spec fn map_has_range(m: Map<int, G>, start: int, end: int, k: K) -> bool {\n    (forall |i| start <= i < end ==> m.dom().contains(i))\n    && (forall |i| start <= i < end ==> entry_inv(k, i, #[trigger] m.index(i)))\n}\n\n// field_idx = index into the data array (0 <= field_idx < data.len())\n// bit_idx = index of a bit within a word (0 <= bit_idx < usize::BITS)\n// user_idx = index of object from user perspective\n//      (user_idx = field_idx * usize::BITS + bit_idx)\n\nstruct_with_invariants!{\n    pub struct Bitmap {\n        data: Vec<AtomicUsize<_, Map<int, G>, _>>,\n        ghost k: K,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            self.data.len() < 0x1000000\n        }\n\n        invariant\n            on data\n            with (k)\n            forall |field_idx: int|\n            where (0 <= field_idx < self.data@.len())\n            specifically (self.data@.index(field_idx))\n            is (v: usize, gmap: Map<int, G>)\n        {\n            forall |bitidx: int| \n                ! #[trigger] has_bit(v, bitidx)\n                ==> gmap.dom().contains(field_idx * usize::BITS + bitidx)\n                    && entry_inv(k,\n                        field_idx * usize::BITS + bitidx,\n                        gmap.index(field_idx * usize::BITS + bitidx))\n        }\n    }\n}\n\npub closed spec fn has_bit(v: usize, i: int) -> bool {\n    (0 <= i < usize::BITS && ((v >> (i as usize)) & 1usize) != 0)\n}\n\nimpl Bitmap {\n    pub closed spec fn len(&self) -> nat {\n        self.data@.len()\n    }\n\n    pub closed spec fn constant(&self) -> int {\n        self.k\n    }\n\n    pub fn bitmap_try_find_from_claim_across(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.len(),\n        ensures ({\n            let (success, user_idx, tr_map) = res;\n            success ==> {\n                &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n            }\n        }),\n    {\n        if count == 1 {\n            return self.bitmap_try_find_from_claim(start_field_idx, count);\n        }\n\n        assume(false); loop { }\n    }\n\n    fn bitmap_try_find_from_claim(&self, start_field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= start_field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let mut idx = start_field_idx;\n        let mut visited = 0;\n        let bitmap_fields = self.data.len();\n        while visited < bitmap_fields\n            invariant\n                self.wf(),\n                0 <= start_field_idx < self.data@.len(),\n                1 <= count < usize::BITS,\n                visited <= bitmap_fields,\n                bitmap_fields == self.data@.len(),\n        {\n            if idx >= bitmap_fields {\n                idx = 0;\n            }\n\n            let (success, user_idx, tr_map) =\n                self.bitmap_try_find_claim_field(idx, count);\n            if success {\n                return (true, user_idx, tr_map);\n            }\n\n            visited = visited + 1;\n            idx = idx + 1;\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n\n    fn bitmap_try_find_claim_field(&self, field_idx: usize, count: usize)\n        -> (res: (bool, usize, Tracked<Map<int, G>>))\n    requires\n        self.wf(),\n        0 <= field_idx < self.data@.len(),\n        1 <= count < usize::BITS,\n    ensures ({\n        let (success, user_idx, tr_map) = res;\n        success ==> {\n            &&& usize::BITS * field_idx <= user_idx\n            &&& user_idx + count <= usize::BITS * (field_idx + 1)\n            &&& map_has_range(tr_map@, user_idx as int, user_idx + count, self.constant())\n        }\n    }),\n    {\n        let atomic = &self.data[field_idx];\n\n        let mut map = atomic.load();\n        if map == !(0usize) {\n            return (false, 0, Tracked(Map::tracked_empty()));\n        }\n\n        assert((1usize << count) >= 1usize) by(bit_vector)\n            requires count < 64usize { }\n\n        let mask = (1usize << count) - 1;\n        let bitidx_max = usize::BITS as usize - count;\n\n        let mut bitidx = crate::bin_sizes::trailing_zeros(map) as usize;\n        let mut m = mask << bitidx;\n\n        while bitidx <= bitidx_max\n            invariant\n                self.wf(),\n                atomic == self.data@.index(field_idx as int),\n                0 <= field_idx < self.data@.len(),\n                1 <= count <= usize::BITS,\n                bitidx_max == usize::BITS - count,\n                m == mask << bitidx,\n                mask == (1usize << count) - 1,\n        {\n            let mapm = map & m;\n            if mapm == 0 {\n                let tracked mut res_map: Map<int, G>;\n                proof { res_map = Map::tracked_empty(); }\n\n                let newmap = map | m;\n                let res = my_atomic_with_ghost!(\n                    atomic => compare_exchange_weak(map, newmap);\n                    update old_v -> new_v;\n                    returning res;\n                    ghost gmap =>\n                {\n                    if res.is_Ok() {\n                        let range = set_int_range(\n                            usize::BITS * field_idx + bitidx,\n                            usize::BITS * field_idx + bitidx + count);\n\n                        verus_proof_expr!({\n                        assert forall |i| range.contains(i) implies #[trigger] gmap.dom().contains(i)\n                        by {\n                            assume(!has_bit(old_v, i - usize::BITS * field_idx));\n                        }\n                        });\n\n                        res_map = gmap.tracked_remove_keys(range);\n\n                        assume(bitidx + count < usize::BITS);\n\n                        let bit = bitidx;\n\n                        verus_proof_expr!({\n                        assert forall |bitidx0: int| \n                            ! #[trigger] has_bit(new_v, bitidx0)\n                            implies gmap.dom().contains(field_idx * usize::BITS + bitidx0)\n                                && entry_inv(self.k,\n                                    field_idx * usize::BITS + bitidx0,\n                                    gmap.index(field_idx * usize::BITS + bitidx0))\n                        by {\n                            assert(m == sub(1usize << count,  1) << bitidx);\n                            assert(new_v == old_v | m);\n                            assert(old_v & m == 0);\n\n                            if bitidx <= bitidx0 < bitidx + count {\n                                let bi = bitidx0 as usize;\n\n                                assert(((new_v >> bi) & 1usize) != 0usize)\n                                  by(bit_vector)\n                                requires\n                                  bitidx <= bi < add(bitidx, count) < 64usize,\n                                  new_v == old_v | m,\n                                  m == sub(1usize << count, 1) << bitidx,\n                                  old_v & m == 0usize,\n                                  1usize <= count <= (64usize)\n                                { }\n\n                                assert(false);\n                            } else {\n                                if bitidx0 >= usize::BITS || bitidx0 < 0 {\n                                    assert(!has_bit(old_v, bitidx0));\n                                } else {\n                                    let bi = bitidx0 as usize;\n                                    assert(add(bitidx, count) == bitidx + count);\n\n                                    if bit > bi {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bitidx > bi,\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    } else {\n                                        assert(((new_v >> bi) & 1usize) == ((old_v >> bi) & 1usize))\n                                          by(bit_vector)\n                                        requires\n                                          bi >= add(bitidx, count),\n                                          add(bitidx, count) <= 64usize,\n                                          bitidx <= 64usize,\n                                          count <= 64usize,\n                                          new_v == old_v | (sub(1usize << count, 1) << bitidx),\n                                          1usize <= count <= (64usize)\n                                        { }\n                                    }\n                                    assert(!has_bit(old_v, bitidx0));\n                                }\n                            }\n                        }\n                        });\n                    }\n                });\n\n                match res {\n                    Result::Ok(_) => {\n                        let user_idx = usize::BITS as usize * field_idx + bitidx;\n                        return (true, user_idx, Tracked(res_map));\n                    }\n                    Result::Err(updated_map) => {\n                        map = updated_map;\n                    }\n                }\n            } else {\n                let shift = if count == 1 {\n                    1\n                } else {\n                    let tz = crate::bin_sizes::trailing_zeros(mapm) as usize;\n                    assume(tz + 1 >= bitidx);\n                    tz + 1 - bitidx\n                };\n\n                assert(((mask << bitidx) << shift) == mask << add(bitidx, shift))\n                  by(bit_vector)\n                    requires\n                        bitidx <= 64usize,\n                        shift <= 64usize,\n                        add(bitidx, shift) <= 64usize,\n                    { }\n\n                bitidx = bitidx + shift;\n                m = m << shift;\n\n            }\n        }\n\n        return (false, 0, Tracked(Map::tracked_empty()));\n    }\n        \n\n    //pub bitmap_try_find_claim_field_across(&self, idx: usize, \n}\n\n*/\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-memory-allocator/verus-mimalloc/bitmap.rs", "verified": true, "metadata": {"original_id": "verified-memory-allocator_bitmap_78a931c15aa7", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f0601ff35320", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len ()  { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - idx\ninvariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len () invariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] , decreases arr . len () - idx { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "f0601ff35320", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cfa994b93799", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)   { arr [k - 1] }\n\n} // verus!", "target_text": "requires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { arr [k - 1] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_4/verina_basic_4_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cfa994b93799", "function_name": "kth_element", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_67c91cec2fab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)   { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] \ninvariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "67c91cec2fab", "function_name": "index_wise_addition", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a3d45e5fcc06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "a3d45e5fcc06", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c7773f0b70cd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c7773f0b70cd", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_37da678db317", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x < 0 { - x } else { x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "37da678db317", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3723a04e46f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires replace_with_colon_precond (s @)\nensures result == is_space_comma_dot_spec (c), replace_with_colon_postcond (s @ , result @)\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_iter_3_current.rs", "verified": true, "metadata": {"original_id": "3723a04e46f8", "function_name": "replace_with_colon", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f3cbbcd3266d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1)  { for j in (p + 1) .. arr . len ()  { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "target_text": "ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ninvariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1) invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , { for j in (p + 1) .. arr . len () invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/barrier_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f3cbbcd3266d", "function_name": "barrier", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ed70253ccf77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len ()  { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - idx\ninvariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_product_impl.rs", "verified": true, "metadata": {"original_id": "ed70253ccf77", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d9822a02ebd6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "d9822a02ebd6", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2d5c23d76df7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/063-fibfib_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2d5c23d76df7", "function_name": "fibfib", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a9fa3ab62078", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i\ninvariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_251_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a9fa3ab62078", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fa86143af6a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut idx = 0 ; while idx < text . len ()  { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) \ndecreases text . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "fa86143af6a0", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ad0a463794bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32)   { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_min_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ad0a463794bb", "function_name": "min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9e24947c20d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9e24947c20d3", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_394f66598116", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "394f66598116", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_24ef92da2525", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_100/verina_basic_100_iter_1_current.rs", "verified": true, "metadata": {"original_id": "24ef92da2525", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b1086f776c5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start <= end , end < nums . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize) requires start <= end , end < nums . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_74/verina_advanced_74_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b1086f776c5e", "function_name": "count_distinct_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7f97edf86bb0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/brs5_impl.rs", "verified": true, "metadata": {"original_id": "7f97edf86bb0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e5ee1c425714", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == circle { return i ; } i = i + 1 ; } a . len () }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () \ndecreases a . len () - i\ninvariant 0 <= i <= a . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () decreases a . len () - i { if a [i] == circle { return i ; } i = i + 1 ; } a . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e5ee1c425714", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f9b8c0394e67", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize)  { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , canyon_search_precond (a @ , b @) \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize) requires canyon_search_precond (a @ , b @) , { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "f9b8c0394e67", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d1df77f93f4c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "d1df77f93f4c", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5b700e08b023", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,)   { }\n\n} // verus!", "target_text": "requires nums . len () == old (used) . len () \nensures used . len () == old (used) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/interprocedural/AlgorithmsRust/permutations.rs", "verified": true, "metadata": {"original_id": "5b700e08b023", "function_name": "backtrack", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2197f4f65d55", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "2197f4f65d55", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8b76be8e8121", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if ! a [left] { left = left + 1 ; } else { right = right - 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if ! a [left] { left = left + 1 ; } else { right = right - 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "8b76be8e8121", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_92d9db1ecdcf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "92d9db1ecdcf", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_12e79e5822de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "12e79e5822de", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ec3952de258a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "ec3952de258a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_197ed1dbdc14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { new_char } else { str1 [k] }) , { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char\ndecreases str1 @ . len () - index\ninvariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char { new_char } else { str1 [k] }) , decreases str1 @ . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "197ed1dbdc14", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6feb82691110", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i : usize = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len () , v [odd_index as int] % 2 == 1\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () , v [odd_index as int] % 2 == 1 { let mut i : usize = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "6feb82691110", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_da61e74b02c6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/conda_impl.rs", "verified": true, "metadata": {"original_id": "da61e74b02c6", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9785a44c8e1b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9785a44c8e1b", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b04de85a9104", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s1if_impl.rs", "verified": true, "metadata": {"original_id": "b04de85a9104", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b6c141da2625", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j as int] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j as int] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "b6c141da2625", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a9cdbe9b3296", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a9cdbe9b3296", "function_name": "canyon_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a30dffe76ad0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "a30dffe76ad0", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_652fca66e6aa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_72/verina_advanced_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "652fca66e6aa", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c431a3841f95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c431a3841f95", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1f909d4aa1a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s1if_impl.rs", "verified": true, "metadata": {"original_id": "1f909d4aa1a2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9c0a3280d2c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "9c0a3280d2c3", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b602dd885e0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b602dd885e0b", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a3a12d115e35", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "ensures result == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a3a12d115e35", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1f681c77b4c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  {    let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "1f681c77b4c7", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_384695c57c63", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "384695c57c63", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_98ed39156ac1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "98ed39156ac1", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_433c842c32ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "433c842c32ad", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_lib_633c4cf2933d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n// Spec function for use in verified functions\npub open spec fn double(x: u16) -> (z: int)\n{\n    x + x\n}\n\npub fn concrete_a(x: u16) -> u16\n\n{\n    x\n}\n\n} // verus!\n", "target_text": "requires double(x) < 100", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n\n// Spec function for use in verified functions\npub open spec fn double(x: u16) -> (z: int)\n{\n    x + x\n}\n\npub fn concrete_a(x: u16) -> u16 \n    requires double(x) < 100,\n{\n    x\n}\n\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/spec_def/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_633c4cf2933d", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_854143b8b0c9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool)  { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c), str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "854143b8b0c9", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a20861a306ed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "a20861a306ed", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_89a5767201e4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "89a5767201e4", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_chapter-2-2_fd1678b12990", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n\n    {\n        if candidate % factor == 0 {\n\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires 1 < candidate\nensures result == is_prime(candidate as nat)\ninvariant 1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat)", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-2-2.rs", "verified": true, "metadata": {"original_id": "verus_chapter-2-2_fd1678b12990", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f8ad9f1fc9c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "requires d > 0\nensures result == sum_of_digits (x as nat), result == is_sum_divisible_by (x as nat , d as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f8ad9f1fc9c0", "function_name": "is_sum_divisible_by_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ea5380f02e6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ea5380f02e6b", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8c81c80d49c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool)   { let result = n % 11 == 0 ; if result {  } else { proof {  } } } result }\n\n} // verus!", "target_text": "requires is_divisible_by_11_precond (n as int)\nensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c81c80d49c3", "function_name": "is_divisible_by_11", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_94fc95a22d1f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "94fc95a22d1f", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_64537322c29f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool)   { let mut i = 0 ; while i < s . len ()  { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires s . len () == p . len () \nensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?'\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_match/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "64537322c29f", "function_name": "match_strings", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2085e64bc1d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m\nensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/WIP/WIP__mcontained.rs", "verified": true, "metadata": {"original_id": "2085e64bc1d5", "function_name": "mcontained", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_abb7a05507d7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 2 * N }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 2 * N }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "abb7a05507d7", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7047bc6eecdd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s4if_impl.rs", "verified": true, "metadata": {"original_id": "7047bc6eecdd", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6e88154d540e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "6e88154d540e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9d319f499bb1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9d319f499bb1", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4ff063fcc6db", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases exp ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 decreases exp , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_18/verina_advanced_18.rs", "verified": true, "metadata": {"original_id": "4ff063fcc6db", "function_name": "pow_exec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f6693c7036ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx { let c = str1 [idx] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f6693c7036ba", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_381dfa033c22", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "381dfa033c22", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_eb5c9c40cf92", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive3 (v : & [i32]) -> (b : bool)  { let mut result = true ; for i in 0 .. v . len ()  { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "target_text": "ensures b == positive (v @)\ninvariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive3 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "eb5c9c40cf92", "function_name": "mpositive3", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b2b034271e9b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "ensures result == sum_of_digits (x as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b2b034271e9b", "function_name": "sum_of_digits_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a0a54f551f99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if a [left] == false { left += 1 ; } else { right -= 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int | 0 <= i < left ==> ! a [i] , forall | i : int | right <= i < a . len () ==> a [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int | 0 <= i < left ==> ! a [i] , forall | i : int | right <= i < a . len () ==> a [i] , decreases right - left { if a [left] == false { left += 1 ; } else { right -= 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "a0a54f551f99", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6591477db4b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires index <= lst . len () , lst . len () <= 100\ndecreases lst . len () - index", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_45/verina_advanced_45.rs", "verified": true, "metadata": {"original_id": "6591477db4b5", "function_name": "helper", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6f058fa97b77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_43/verina_basic_43_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6f058fa97b77", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_33cace39dc81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "requires old (a) . len () > 0 \nensures result == odd (n as int), a @ . len () == old (a) @ . len () \ndecreases right - left\ninvariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "33cace39dc81", "function_name": "partition_odd_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f2afe3e82be0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "f2afe3e82be0", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5be2fd92c629", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "5be2fd92c629", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a62effce2606", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size\ndecreases a . len (), size - i\ninvariant i <= size , result . len () == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a62effce2606", "function_name": "gaussian", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ae60841031c1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ae60841031c1", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_000123eb08c1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "000123eb08c1", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3aa4fc4de8e2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_43/verina_advanced_43.rs", "verified": true, "metadata": {"original_id": "3aa4fc4de8e2", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_65a77296bebd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_impl.rs", "verified": true, "metadata": {"original_id": "65a77296bebd", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7fa4c773d657", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { r . len () == x . len () }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { r . len () == x . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7fa4c773d657", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2879ebdad2ed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code.rs", "verified": true, "metadata": {"original_id": "2879ebdad2ed", "function_name": "bubbleSorta", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5160fd1b17b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "5160fd1b17b8", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fbe5600ab231", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "fbe5600ab231", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_201ee230cfd8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "201ee230cfd8", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_889889d50055", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64)   { return 0 ; }\n\n} // verus!", "target_text": "requires 0 <= k <= n \nensures result as nat == comb (n as nat , k as nat) \ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_CombNK/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "889889d50055", "function_name": "comb_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2d2df738f15b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "2d2df738f15b", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6efcf313c019", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6efcf313c019", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_15717b1ee6ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 0 < j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 0 < j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "15717b1ee6ba", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_88c16fc0969c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_98/verina_basic_98_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88c16fc0969c", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_06ae2221d67c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "06ae2221d67c", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_93ad0d5e060c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93ad0d5e060c", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_751387d56f1f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique.rs", "verified": true, "metadata": {"original_id": "751387d56f1f", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fc5119085bf6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () <= 1 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ninvariant forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () <= 1 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "fc5119085bf6", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_59d56b1e193a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len ()  { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - idx \ninvariant 1 <= idx <= list . len () , min >= 0 , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 1 <= idx <= list . len () , min >= 0 , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx , { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "59d56b1e193a", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f5ed356316b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "f5ed356316b3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3d2df07c3d82", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "3d2df07c3d82", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eccbfc385d6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "eccbfc385d6b", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1b00d830ea37", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code.rs", "verified": true, "metadata": {"original_id": "1b00d830ea37", "function_name": "bubbleSort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f36d321f2a42", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f36d321f2a42", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bd19d45f01bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "bd19d45f01bb", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c9556ae06624", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "c9556ae06624", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8b33e6965087", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "8b33e6965087", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b2278187cab3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)   {       }\nfn decode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let decoded = decode_char (s [i]) ; result . push (decoded) ;  i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 , 65 <= c <= 90 , forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 \nensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , r == decode_char_spec (c as int) , 65 <= r <= 90 , s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] \ndecreases s . len () - i \ninvariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b2278187cab3", "function_name": "decode_shift", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2dec5d3e11d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_binary_search/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2dec5d3e11d4", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5d7fe58e2d8d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5d7fe58e2d8d", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f4f15b2539ef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i : usize = 0 ; while i < a . len ()  {   a . set (i , N + 1) ;   i += 1 ;  } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i { assert (i < a . len ()) ; assert (N + 1 <= MAX) ; a . set (i , N + 1) ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; assert (a [i as int] == N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/sina2_impl.rs", "verified": true, "metadata": {"original_id": "f4f15b2539ef", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_064a7916adea", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_size : u64 = 32 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_log_size_offset : u64 = 24 ;\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub const header_head_offset : u64 = 8 ;\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn bytes_to_metadata (bytes : & [u8]) -> (out : PersistentHeaderMetadata)   { let head_bytes = slice_subrange (bytes , (header_head_offset - 8) as usize , (header_head_offset - 8 + 8) as usize) ; let tail_bytes = slice_subrange (bytes , (header_tail_offset - 8) as usize , (header_tail_offset - 8 + 8) as usize) ; let log_size_bytes = slice_subrange (bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset - 8 + 8) as usize) ; PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) , } }\n\n} // verus!", "target_text": "requires bytes @ . len () == header_size - 8\nensures out == spec_bytes_to_metadata (bytes @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_size : u64 = 32 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_log_size_offset : u64 = 24 ;\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub const header_head_offset : u64 = 8 ;\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn bytes_to_metadata (bytes : & [u8]) -> (out : PersistentHeaderMetadata) requires bytes @ . len () == header_size - 8 ensures out == spec_bytes_to_metadata (bytes @) { let head_bytes = slice_subrange (bytes , (header_head_offset - 8) as usize , (header_head_offset - 8 + 8) as usize) ; let tail_bytes = slice_subrange (bytes , (header_tail_offset - 8) as usize , (header_tail_offset - 8 + 8) as usize) ; let log_size_bytes = slice_subrange (bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset - 8 + 8) as usize) ; PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "pmemlog_inlined.rs", "verified": true, "metadata": {"original_id": "064a7916adea", "function_name": "bytes_to_metadata", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3f5d74d50179", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: assert_by_contradiction ;\nuse vstd :: map :: * ;\nuse vstd :: pervasive :: arbitrary ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec (checked) fn aligned (addr : nat , size : nat) -> bool { addr % size == 0 }\npub exec fn aligned_exec (addr : usize , size : usize) -> (res : bool)   { addr % size == 0 }\n\n} // verus!", "target_text": "requires size > 0\nensures res == aligned (addr as nat , size as nat)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: assert_by_contradiction ;\nuse vstd :: map :: * ;\nuse vstd :: pervasive :: arbitrary ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec (checked) fn aligned (addr : nat , size : nat) -> bool { addr % size == 0 }\npub exec fn aligned_exec (addr : usize , size : usize) -> (res : bool) requires size > 0 ensures res == aligned (addr as nat , size as nat) { addr % size == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "page_table_inlined.rs", "verified": true, "metadata": {"original_id": "3f5d74d50179", "function_name": "aligned_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9410727caeb6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l  { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i, p - j, l - k\ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_64/verina_basic_64_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9410727caeb6", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_85c81ee22263", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)\ndecreases nums . len () - i\ninvariant 0 <= i <= nums . len () , nums . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_2_current.rs", "verified": true, "metadata": {"original_id": "85c81ee22263", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f4bac1a13b76", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >)  { return None ; }\n\n} // verus!", "target_text": "requires two_sum_precond (nums @ , target)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >) requires two_sum_precond (nums @ , target) { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f4bac1a13b76", "function_name": "two_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b9cc7f1e51fc", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize)   { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "target_text": "requires align > 0 \nensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat)\ninvariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 , ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "multilog_inlined.rs", "verified": true, "metadata": {"original_id": "b9cc7f1e51fc", "function_name": "padding_needed", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_32e6dbbf5725", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ndecreases numbers . len () - i\ninvariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "32e6dbbf5725", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e049439dc7b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >)  { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e049439dc7b7", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ddc06a39fd9c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ddc06a39fd9c", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5d99f488f836", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = 4 * (N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum [0] = 4 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s32if_impl.rs", "verified": true, "metadata": {"original_id": "5d99f488f836", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2689d2a36fa2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires has_close_elements_precond (numbers @ , threshold) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool) requires has_close_elements_precond (numbers @ , threshold) , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_63/verina_basic_63.rs", "verified": true, "metadata": {"original_id": "2689d2a36fa2", "function_name": "has_close_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b9bbb37666eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize  { if i < a . len () && i < b . len () && a [i] <= N && b [i] <= N && total < 2000 { total = total + 1 ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N \ndecreases N as usize - i\ninvariant 0 <= i <= N , i <= a . len () , i <= b . len () , a . len () == N , b . len () == N , total <= 2 * (i as i32) , total >= 0 , N > 0 , N < 1000 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize invariant 0 <= i <= N , i <= a . len () , i <= b . len () , a . len () == N , b . len () == N , total <= 2 * (i as i32) , total >= 0 , N > 0 , N < 1000 , decreases N as usize - i { if i < a . len () && i < b . len () && a [i] <= N && b [i] <= N && total < 2000 { total = total + 1 ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/res1o_impl.rs", "verified": true, "metadata": {"original_id": "b9bbb37666eb", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f419a57be83c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f419a57be83c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a3a723b14381", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nfn rain (heights : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires rain_precond (heights @) \nensures rain_postcond (heights @ , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_62/verina_advanced_62_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a3a723b14381", "function_name": "rain", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_31de39224ff7", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [inline] pub exec fn extend_vec_u8_from_slice (v : & mut Vec < u8 > , s : & [u8])  { v . extend_from_slice (s) ;  }\n\n} // verus!", "target_text": "ensures v @ == old (v) @ + s @ \ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [inline] pub exec fn extend_vec_u8_from_slice (v : & mut Vec < u8 > , s : & [u8]) ensures v @ == old (v) @ + s @ , { v . extend_from_slice (s) ; assert (v @ =~= old (v) @ + s @) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "31de39224ff7", "function_name": "extend_vec_u8_from_slice", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_da2b1c082848", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_477_iter_2_current.rs", "verified": true, "metadata": {"original_id": "da2b1c082848", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_lib_bfbf64080aaf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n// Library function for use in verified and unverified functions\npub fn double(x: u16) -> (z: u32)\n\n{\n    x as u32 + x as u32\n}\n\n// Some corner cases that have been problematic for cargo-verus in the past\n\ntrait Trait: View {}\n\nimpl<T: View> Trait for Option<T> {}\n\nfn test(f:spec_fn(nat) -> nat) {\n}\n\n} // verus!\n", "target_text": "ensures z == x * 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n\n// Library function for use in verified and unverified functions\npub fn double(x: u16) -> (z: u32)\n    ensures z == x * 2,\n{\n    x as u32 + x as u32\n}\n\n// Some corner cases that have been problematic for cargo-verus in the past\n\ntrait Trait: View {}\n\nimpl<T: View> Trait for Option<T> {}\n\nfn test(f:spec_fn(nat) -> nat) {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/basic_verified_lib/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_bfbf64080aaf", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f6adbc2f87dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "f6adbc2f87dd", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2cdfaa289a78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code.rs", "verified": true, "metadata": {"original_id": "2cdfaa289a78", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cc4d8d29f131", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cc4d8d29f131", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_lib_61893cbd36ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub fn f() -> (r: u8)\n\n{\n    2 + 2\n}\n\n} // verus!\n", "target_text": "ensures r == 4", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub fn f() -> (r: u8)\n    ensures\n        r == 4,\n{\n    2 + 2\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/cargo-verus/library/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_61893cbd36ba", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e399a7691672", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e399a7691672", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_impl_basic_06b9ceb293ac", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n\n    let v = c3.template_get_v();\n\n}\n\n} // verus!\n", "target_text": "ensures result.passengers == 205 && result.the_v == v, result == self.passengers, result == self.the_v", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Car {\n    four_doors: bool,\n    passengers: u64,\n}\n\nimpl Car {\n    fn new() -> Car {\n        ensures(|result: Car| equal(result.passengers, 201));\n        Car { four_doors: false, passengers: 201 }\n    }\n\n    fn get_passengers(&self) -> u64 {\n        ensures(|result: u64| result == self.passengers);\n        self.passengers\n    }\n}\n\n#[derive(PartialEq, Eq)]\nstruct TemplateCar<V> {\n    four_doors: bool,\n    passengers: u64,\n    the_v: V,\n}\n\nimpl<V> TemplateCar<V> {\n    fn template_new(v: V) -> (result: TemplateCar<V>)\n        ensures\n            result.passengers == 205 && result.the_v == v,\n    {\n        TemplateCar::<V> { four_doors: false, passengers: 205, the_v: v }\n    }\n\n    fn template_get_passengers(&self) -> (result: u64)\n        ensures\n            result == self.passengers,\n    {\n        self.passengers\n    }\n\n    fn template_get_v(self) -> (result: V)\n        ensures\n            result == self.the_v,\n    {\n        self.the_v\n    }\n}\n\nfn main() {\n    let c = Car { four_doors: true, passengers: 3 };\n    let p = c.get_passengers();\n    assert(p < 4);\n    let c2 = Car::new();\n    let p2 = c2.get_passengers();\n    assert(p2 == 201);\n    let c3 = TemplateCar::<u64>::template_new(5);\n    let p3 = c3.template_get_passengers();\n    assert(p3 == 205);\n    let v = c3.template_get_v();\n    assert(v == 5);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/impl_basic.rs", "verified": true, "metadata": {"original_id": "verus_impl_basic_06b9ceb293ac", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f853734a797b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f853734a797b", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_243d54a45475", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs3_impl.rs", "verified": true, "metadata": {"original_id": "243d54a45475", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_896a3b8e6bc9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right  { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } }  0 }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases right - left \ninvariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "896a3b8e6bc9", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_70233d5ac46f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)   { let result = arr [k - 1] ;  result }\n\n} // verus!", "target_text": "requires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_impl.rs", "verified": true, "metadata": {"original_id": "70233d5ac46f", "function_name": "kth_element", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7b4386eda25d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize) requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7b4386eda25d", "function_name": "calculate_coverage", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a2cb813fc37f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/filter_weak_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a2cb813fc37f", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5f1e80c20f7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5f1e80c20f7b", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d3058115cf51", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len ()  { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ninvariant result . len () == 2 * i - (if i == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "d3058115cf51", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4fe371f586fa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_28/verina_advanced_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4fe371f586fa", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ae37f0326cf7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { let mut i = 0 ; while i < x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , decreases x . len () - i { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/filter_weak_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ae37f0326cf7", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a33d41e9a24e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a33d41e9a24e", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_59f4281c6230", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_current.rs", "verified": true, "metadata": {"original_id": "59f4281c6230", "function_name": "secondSmallestAux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3444706bcf80", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "3444706bcf80", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_382c27bf63f9", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32)   { let mut i = 0 ; while i < nums . len ()  { if nums [i] == target {    return i as i32 ; } i += 1 ; }  return - 1 ; }\n\n} // verus!", "target_text": "requires nums @ . len () < 0x8000_0000 \nensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target \ndecreases nums @ . len () - i\ninvariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/linearsearch_impl.rs", "verified": true, "metadata": {"original_id": "382c27bf63f9", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4ff9e20b4700", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "4ff9e20b4700", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0ad6e11dc30d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element , decreases arr . len () - i { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "0ad6e11dc30d", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3bffcefab762", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3bffcefab762", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f2d5cfd37d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "0f2d5cfd37d4", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_afbb7a929727", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { x . checked_add (y) }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_impl.rs", "verified": true, "metadata": {"original_id": "afbb7a929727", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_03e43303cb14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "03e43303cb14", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_912efa633050", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "912efa633050", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2f011f6ff8c8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2f011f6ff8c8", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6e704e06adc5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6e704e06adc5", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f05f34b110cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >)   { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high  { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] \nensures match result\ndecreases high - low \ninvariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (arr : & [i32] , target : i32) -> (result : Option < usize >) requires forall | i : int , j : int | 0 <= i && i < j && j < arr . len () ==> arr [i] <= arr [j] , ensures match result { Some (idx) => 0 <= idx < arr . len () && arr [idx as int] == target , None => forall | i : int | 0 <= i < arr . len () ==> arr [i] != target , } , { let mut low = 0 ; let mut high = arr . len () ; while low < high invariant low <= high && high <= arr . len () , forall | i : int | 0 <= i && i < low ==> arr [i] < target , forall | i : int | high <= i && i < arr . len () ==> arr [i] > target , decreases high - low , { let mid = low + (high - low) / 2 ; if arr [mid] == target { return Some (mid) ; } else if arr [mid] < target { low = mid + 1 ; } else { high = mid ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f05f34b110cb", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_140baffbaf66", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len ()  { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len ()  { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "target_text": "ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , already_added == (exists | m : int | 0 <= m < k && result [m] == elem) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len () invariant found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len () invariant already_added == (exists | m : int | 0 <= m < k && result [m] == elem) , { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "140baffbaf66", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_34c5d3dd4acd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 1 ; while idx < arr . len ()  { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - idx \ninvariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "34c5d3dd4acd", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_88a5d8cea0cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nfn encode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 \nensures r == encode_char_spec (c as int) , 65 <= r <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88a5d8cea0cb", "function_name": "encode_char", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_doubly_linked_7b8ba918de95", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\nuse vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn well_formed(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                }\n            }\n        }\n\n        /// Take a value from the end of the list. Requires the list to be non-empty.\n        pub fn pop_back(&mut self) -> (v: V)\n\n        {\n\n            // Deallocate the last node in the list and get the payload.\n            // Note self.tail.unwrap() will always succeed because of the precondition `len > 0`\n            let last_ptr = self.tail.unwrap();\n            let tracked last_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(\n                (self.ghost_state@.ptrs.len() - 1) as nat,\n            );\n            let last_node = last_ptr.into_inner(Tracked(last_pointsto));\n            let v = last_node.payload;\n\n            match last_node.prev {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n\n                },\n                Some(penultimate_ptr) => {\n\n                    // Otherwise, we need to set the 'tail' pointer to the (new) tail pointer,\n                    // i.e., the pointer that was previously the second-to-last pointer.\n                    self.tail = Some(penultimate_ptr);\n\n                    // And we need to set the 'next' pointer of the new tail node to None.\n                    let tracked mut penultimate_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 2) as nat);\n                    let mut penultimate_node = penultimate_ptr.take(Tracked(&mut penultimate_pointsto));\n                    penultimate_node.next = None;\n                    penultimate_ptr.put(Tracked(&mut penultimate_pointsto), penultimate_node);\n\n                },\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n\n            return v;\n        }\n\n        /// Insert a value to the front of the list\n        pub fn push_front(&mut self, v: V)\n\n        {\n            match self.head {\n                None => {\n                    // Special case: list is empty\n\n                    self.push_empty_case(v);\n\n                }\n                Some(old_head_ptr) => {\n\n                    // Allocate a new node to go at the front. It's 'next' field points\n                    // to the old head pointer.\n                    let (new_head_ptr, Tracked(new_head_pointsto)) = PPtr::new(\n                        Node::<V> { prev: None, next: Some(old_head_ptr), payload: v },\n                    );\n\n                    // Update the 'tail' pointer of the previous head node\n                    // This is all equivalent to `(*old_head_ptr).next = new_head_ptr;`\n                    let tracked mut old_head_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n                    let mut old_head_node = old_head_ptr.take(Tracked(&mut old_head_pointsto));\n                    old_head_node.prev = Some(new_head_ptr);\n                    old_head_ptr.put(Tracked(&mut old_head_pointsto), old_head_node);\n\n                    // Update `self.head`\n                    self.head = Some(new_head_ptr);\n\n                }\n            }\n        }\n\n        /// Take a value from the front of the list. Requires the list to be non-empty.\n        pub fn pop_front(&mut self) -> (v: V)\n\n        {\n\n            // Deallocate the first node in the list and get the payload.\n            // Note self.head.unwrap() will always succeed because of the precondition `len > 0`\n            let first_ptr = self.head.unwrap();\n            let tracked first_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n            let first_node = first_ptr.into_inner(Tracked(first_pointsto));\n            let v = first_node.payload;\n\n            match first_node.next {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n\n                }\n                Some(second_ptr) => {\n\n                    // Otherwise, we need to set the 'head' pointer to the (new) head pointer,\n                    // i.e., the pointer that was previously the second pointer.\n                    self.head = Some(second_ptr);\n\n                    // And we need to set the 'tail' pointer of the new head node to None\n                    let tracked mut second_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(1);\n                    let mut second_node = second_ptr.take(Tracked(&mut second_pointsto));\n                    second_node.prev = None;\n                    second_ptr.put(Tracked(&mut second_pointsto), second_node);\n\n                }\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n\n            return v;\n        }\n\n        /// Get a reference to the i^th value in the list\n        fn get<'a>(&'a self, i: usize) -> (v: &'a V)\n\n        {\n            // Iterate the nodes from 0 to j, starting at the head node\n            let mut j = 0;\n            let mut ptr = self.head.unwrap();\n            while j < i\n\n            {\n\n                // Get the next node from the 'next' field\n                let tracked pointsto_ref: &PointsTo<Node<V>> =\n                    self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n                let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n                let next_ptr = node_ref.next.unwrap();\n\n                j += 1;\n                ptr = next_ptr;\n            }\n\n            // Get a reference to this node's payload and return it\n            let tracked pointsto_ref: &PointsTo<Node<V>> =\n                self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n            let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n            return &node_ref.payload;\n        }\n    }\n\n    pub struct Iterator<'a, V> {\n        l: &'a DoublyLinkedList<V>,\n        cur: Option<PPtr<Node<V>>>,\n        index: Ghost<nat>,\n    }\n\n    impl<'a, V> Iterator<'a, V> {\n        pub closed spec fn list(&self) -> &'a DoublyLinkedList<V> {\n            self.l\n        }\n\n        pub closed spec fn index(&self) -> nat {\n            self.index@\n        }\n\n        pub closed spec fn valid(&self) -> bool {\n            &&& self.list().well_formed()\n            &&& self.index@ < self.list()@.len()\n            &&& self.cur.is_some() && self.cur.unwrap() =~= self.l.ghost_state@.ptrs[self.index@ as int]\n        }\n\n        pub fn new(l: &'a DoublyLinkedList<V>) -> (it: Self)\n\n        {\n            Iterator { l, cur: l.head, index: Ghost(0) }\n        }\n\n        pub fn value(&self) -> (v: &V)\n\n        {\n            let cur = self.cur.unwrap();\n\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            &node.payload\n        }\n\n        pub fn move_next(&mut self) -> (good: bool)\n\n        {\n\n            let cur = self.cur.unwrap();\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n\n            match node.next {\n                None => {\n                    self.cur = None;\n                    false\n                },\n                Some(next_ptr) => {\n                    self.cur = Some(next_ptr);\n                    true\n                },\n            }\n        }\n    }\n\n}\n\nmod main {\n    use super::doubly_linked_list::{DoublyLinkedList, Iterator};\n\n    pub fn run() {\n        let mut t = DoublyLinkedList::<u32>::new();\n        t.push_back(2);\n        t.push_back(3);\n        t.push_front(1);  // 1, 2, 3\n        let mut it = Iterator::new(&t);\n        let v1 = it.value();\n\n        let g = it.move_next();\n        let v2 = it.value();\n\n        let _ = it.move_next();\n        let v3 = it.value();\n\n        let g = it.move_next();\n\n        let x = t.pop_back();  // 3\n        let y = t.pop_front();  // 1\n        let z = t.pop_front();  // 2\n\n    }\n\n}\n\nfn main() {\n    main::run();\n}\n\n} // verus!\n", "target_text": "requires old(self).well_formed(),\n                old(self).ghost_state@.ptrs.len() == 0, old(self).well_formed(), old(self).well_formed(),\n                old(self)@.len() > 0, old(self).well_formed(), old(self).well_formed(),\n                old(self).view().len() > 0, self.well_formed(),\n                0 <= i < self@.len(), l.well_formed(),\n                l@.len() > 0, self.valid(), old(self).valid()\nensures s.well_formed(),\n                s@.len() == 0, self.well_formed(),\n                self@ =~= old(self)@.push(v), self.well_formed(),\n                self@ == old(self)@.push(v), self.well_formed(),\n                self@ == old(self)@.drop_last(),\n                v == old(self)@[old(self)@.len() as int - 1], self.well_formed(),\n                self@ == seq![v].add(old(self)@), self.well_formed(),\n                self@ == old(self)@.subrange(1, old(self)@.len() as int),\n                v == old(self)@[0], *v == self@[i as int], it.valid(),\n                it.index() == 0,\n                it.list() == l, v == self.list()@[self.index() as int], old(self).list() == self.list(),\n                good == (old(self).index() < old(self).list()@.len() - 1),\n                good ==> (self.valid() && self.index() == old(self).index() + 1)\ninvariant self.well_formed(),\n                    0 <= j <= i < self@.len(),\n                    ptr == self.ghost_state@.ptrs[j as int]", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\nuse vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn well_formed(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n            ensures\n                s.well_formed(),\n                s@.len() == 0,\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n                old(self).ghost_state@.ptrs.len() == 0,\n            ensures\n                self.well_formed(),\n                self@ =~= old(self)@.push(v),\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n            proof {\n                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);\n                self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                    (self.ghost_state@.ptrs.len() - 1) as nat,\n                    points_to,\n                );\n            }\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.push(v),\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.tail == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,\n                        {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                        });\n                    }\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    proof {\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                    }\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 1) as nat,\n                            old_tail_pointsto,\n                        );\n                    }\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                    proof {\n                        // Put the new tail's PointsTo into the map\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);\n                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)\n                            ==> self.well_formed_node(i));\n                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node(i as nat));  // trigger\n                        }\n                        assert(self@ =~= old(self)@.push(v));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the end of the list. Requires the list to be non-empty.\n        pub fn pop_back(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self)@.len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.drop_last(),\n                v == old(self)@[old(self)@.len() as int - 1],\n        {\n            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n\n            // Deallocate the last node in the list and get the payload.\n            // Note self.tail.unwrap() will always succeed because of the precondition `len > 0`\n            let last_ptr = self.tail.unwrap();\n            let tracked last_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(\n                (self.ghost_state@.ptrs.len() - 1) as nat,\n            );\n            let last_node = last_ptr.into_inner(Tracked(last_pointsto));\n            let v = last_node.payload;\n\n            match last_node.prev {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat)); // trigger\n                        });\n                    }\n                },\n                Some(penultimate_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n\n                    // Otherwise, we need to set the 'tail' pointer to the (new) tail pointer,\n                    // i.e., the pointer that was previously the second-to-last pointer.\n                    self.tail = Some(penultimate_ptr);\n\n                    // And we need to set the 'next' pointer of the new tail node to None.\n                    let tracked mut penultimate_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 2) as nat);\n                    let mut penultimate_node = penultimate_ptr.take(Tracked(&mut penultimate_pointsto));\n                    penultimate_node.next = None;\n                    penultimate_ptr.put(Tracked(&mut penultimate_pointsto), penultimate_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 2) as nat,\n                            penultimate_pointsto,\n                        );\n                    }\n                },\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.drop_last();\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                }\n                assert(forall|i: nat| i < self@.len() && old(self).well_formed_node(i) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.drop_last()[i] by {\n                    assert(old(self).well_formed_node(i as nat));  // trigger\n                }\n                assert(self@ =~= old(self)@.drop_last());\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Insert a value to the front of the list\n        pub fn push_front(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == seq![v].add(old(self)@),\n        {\n            match self.head {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.head == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0, {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        });\n                    }\n                    self.push_empty_case(v);\n                    assert(self@ =~= seq![v].add(old(self)@));\n                }\n                Some(old_head_ptr) => {\n                    proof {\n                        assert(self.ghost_state@.ptrs.len() > 0);\n                        assert(self.well_formed_node(0));\n                    }\n\n                    // Allocate a new node to go at the front. It's 'next' field points\n                    // to the old head pointer.\n                    let (new_head_ptr, Tracked(new_head_pointsto)) = PPtr::new(\n                        Node::<V> { prev: None, next: Some(old_head_ptr), payload: v },\n                    );\n\n                    // Update the 'tail' pointer of the previous head node\n                    // This is all equivalent to `(*old_head_ptr).next = new_head_ptr;`\n                    let tracked mut old_head_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n                    let mut old_head_node = old_head_ptr.take(Tracked(&mut old_head_pointsto));\n                    old_head_node.prev = Some(new_head_ptr);\n                    old_head_ptr.put(Tracked(&mut old_head_pointsto), old_head_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, old_head_pointsto);\n                    }\n\n                    // Update `self.head`\n                    self.head = Some(new_head_ptr);\n\n                    proof {\n                        // Put the new head's PointsTo into the map.\n                        // This goes in at index 0, so we have to shift all the keys up by 1.\n                        assert forall|j: nat|\n                            0 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        }\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 1 <= j && j <= old(self).view().len(),\n                                |j: nat| (j - 1) as nat,\n                            ),\n                        );\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, new_head_pointsto);\n                        self.ghost_state@.ptrs = seq![new_head_ptr].add(self.ghost_state@.ptrs);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node(0));\n                        assert(self.well_formed_node(1));\n                        assert(forall|i: nat|\n                            1 <= i && i <= old(self).ghost_state@.ptrs.len() && old(self).well_formed_node((i - 1) as nat)\n                                ==> #[trigger] self.well_formed_node(i));\n                        assert forall|i: int| 1 <= i && i <= self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i - 1] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node((i - 1) as nat));  // trigger\n                        }\n                        assert(self@ =~= seq![v].add(old(self)@));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the front of the list. Requires the list to be non-empty.\n        pub fn pop_front(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self).view().len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.subrange(1, old(self)@.len() as int),\n                v == old(self)@[0],\n        {\n            assert(self.well_formed_node(0));\n\n            // Deallocate the first node in the list and get the payload.\n            // Note self.head.unwrap() will always succeed because of the precondition `len > 0`\n            let first_ptr = self.head.unwrap();\n            let tracked first_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n            let first_node = first_ptr.into_inner(Tracked(first_pointsto));\n            let v = first_node.payload;\n\n            match first_node.next {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node(1)); // trigger\n                        });\n                    }\n                }\n                Some(second_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node(1));\n\n                    // Otherwise, we need to set the 'head' pointer to the (new) head pointer,\n                    // i.e., the pointer that was previously the second pointer.\n                    self.head = Some(second_ptr);\n\n                    // And we need to set the 'tail' pointer of the new head node to None\n                    let tracked mut second_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(1);\n                    let mut second_node = second_ptr.take(Tracked(&mut second_pointsto));\n                    second_node.prev = None;\n                    second_ptr.put(Tracked(&mut second_pointsto), second_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(1, second_pointsto);\n\n                        // Since we removed index 0, we need to shift all the keys down,\n                        // 1 -> 0, 2 -> 1, etc.\n                        assert forall|j: nat|\n                            1 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        };\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 0 <= j && j < old(self).view().len() - 1,\n                                |j: nat| (j + 1) as nat,\n                            ),\n                        );\n                    }\n                }\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.subrange(1, self.ghost_state@.ptrs.len() as int);\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node(0));\n                }\n                assert(forall|i: nat|\n                    i < self.view().len() && old(self).well_formed_node(i + 1) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.subrange(1, old(self)@.len() as int)[i] by {\n                    assert(old(self).well_formed_node(i as nat + 1));  // trigger\n                }\n                assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Get a reference to the i^th value in the list\n        fn get<'a>(&'a self, i: usize) -> (v: &'a V)\n            requires\n                self.well_formed(),\n                0 <= i < self@.len(),\n            ensures\n                *v == self@[i as int]\n        {\n            // Iterate the nodes from 0 to j, starting at the head node\n            let mut j = 0;\n            let mut ptr = self.head.unwrap();\n            while j < i\n                invariant\n                    self.well_formed(),\n                    0 <= j <= i < self@.len(),\n                    ptr == self.ghost_state@.ptrs[j as int],\n            {\n                proof {\n                    assert(self.well_formed_node(j as nat)); // trigger\n                }\n\n                // Get the next node from the 'next' field\n                let tracked pointsto_ref: &PointsTo<Node<V>> =\n                    self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n                let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n                let next_ptr = node_ref.next.unwrap();\n\n                j += 1;\n                ptr = next_ptr;\n            }\n\n            proof {\n                assert(self.well_formed_node(j as nat)); // trigger\n            }\n\n            // Get a reference to this node's payload and return it\n            let tracked pointsto_ref: &PointsTo<Node<V>> =\n                self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n            let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n            return &node_ref.payload;\n        }\n    }\n\n    pub struct Iterator<'a, V> {\n        l: &'a DoublyLinkedList<V>,\n        cur: Option<PPtr<Node<V>>>,\n        index: Ghost<nat>,\n    }\n\n    impl<'a, V> Iterator<'a, V> {\n        pub closed spec fn list(&self) -> &'a DoublyLinkedList<V> {\n            self.l\n        }\n\n        pub closed spec fn index(&self) -> nat {\n            self.index@\n        }\n\n        pub closed spec fn valid(&self) -> bool {\n            &&& self.list().well_formed()\n            &&& self.index@ < self.list()@.len()\n            &&& self.cur.is_some() && self.cur.unwrap() =~= self.l.ghost_state@.ptrs[self.index@ as int]\n        }\n\n        pub fn new(l: &'a DoublyLinkedList<V>) -> (it: Self)\n            requires\n                l.well_formed(),\n                l@.len() > 0,\n            ensures\n                it.valid(),\n                it.index() == 0,\n                it.list() == l,\n        {\n            Iterator { l, cur: l.head, index: Ghost(0) }\n        }\n\n        pub fn value(&self) -> (v: &V)\n            requires\n                self.valid(),\n            ensures\n                v == self.list()@[self.index() as int],\n        {\n            let cur = self.cur.unwrap();\n            assert(self.l.well_formed_node(self.index()));\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            &node.payload\n        }\n\n        pub fn move_next(&mut self) -> (good: bool)\n            requires\n                old(self).valid(),\n            ensures\n                old(self).list() == self.list(),\n                good == (old(self).index() < old(self).list()@.len() - 1),\n                good ==> (self.valid() && self.index() == old(self).index() + 1),\n        {\n            assert(self.l.well_formed_node(self.index()));\n            let cur = self.cur.unwrap();\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            proof {\n                self.index@ = self.index@ + 1;\n            }\n            match node.next {\n                None => {\n                    self.cur = None;\n                    false\n                },\n                Some(next_ptr) => {\n                    self.cur = Some(next_ptr);\n                    true\n                },\n            }\n        }\n    }\n\n}\n\nmod main {\n    use super::doubly_linked_list::{DoublyLinkedList, Iterator};\n\n    pub fn run() {\n        let mut t = DoublyLinkedList::<u32>::new();\n        t.push_back(2);\n        t.push_back(3);\n        t.push_front(1);  // 1, 2, 3\n        let mut it = Iterator::new(&t);\n        let v1 = it.value();\n        assert(*v1 == 1);\n        let g = it.move_next();\n        let v2 = it.value();\n        assert(*v2 == 2);\n        let _ = it.move_next();\n        let v3 = it.value();\n        assert(*v3 == 3);\n        let g = it.move_next();\n        assert(!g);\n        let x = t.pop_back();  // 3\n        let y = t.pop_front();  // 1\n        let z = t.pop_front();  // 2\n        assert(x == 3);\n        assert(y == 1);\n        assert(z == 2);\n    }\n\n}\n\nfn main() {\n    main::run();\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/doubly_linked.rs", "verified": true, "metadata": {"original_id": "verus_doubly_linked_7b8ba918de95", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b14438244fd8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "b14438244fd8", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_018f574bcab8", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> (result : bool) { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64)   {  arr [i] }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) \nensures ret == i + 2 , ret == arr @ [i as int] ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> (result : bool) { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/trigger_impl.rs", "verified": true, "metadata": {"original_id": "018f574bcab8", "function_name": "get_element_check_property", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_80ac35f4ccfb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires trap_rain_water_precond (height @)\nensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_77/verina_advanced_77_iter_0_original.rs", "verified": true, "metadata": {"original_id": "80ac35f4ccfb", "function_name": "trap_rain_water", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8035f3e58fb3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "requires old (a) . len () > 0 \nensures result == odd (n as int), a @ . len () == old (a) @ . len () \ndecreases right - left\ninvariant left <= right , right <= a @ . len () , a @ . len () == old (a) @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a @ . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "8035f3e58fb3", "function_name": "partition_odd_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0d26dfca2cb9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_251_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0d26dfca2cb9", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_93828301e6ef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires find_even_numbers_precond (arr @)\nensures result == is_even (n as int), find_even_numbers_postcond (arr @ , result @)\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "93828301e6ef", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f9a261419ecb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires c <= n , n == a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool) requires c <= n , n == a . len () , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code.rs", "verified": true, "metadata": {"original_id": "f9a261419ecb", "function_name": "fillK", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_recursion_e42edfec3663", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    {\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    {\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n\n    {\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n\n    {\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    {\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "target_text": "requires i <= j, n < 100\nensures arith_sum_int(i as int) >= 0, arith_sum_int(i as int) <= arith_sum_int(j as int), arith_sum_int(n as int) == sum, arith_sum_int(i as int) >= 0,\n    decreases i, arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j\ndecreases i, i, i, j, 100 - n\ninvariant n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursion.rs", "verified": true, "metadata": {"original_id": "verus_recursion_e42edfec3663", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7b37e24cffbf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires shortest_beautiful_substring_precond (s @ , k as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_71/verina_advanced_71_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7b37e24cffbf", "function_name": "shortest_beautiful_substring", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_chapter-2-3_79eb1884c0da", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    {\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    {\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n\n{\n    if input.len() == 0 {\n        //\n\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n\n        // show there's no other multiset that'll work.\n\n        output\n        */\n        assume(false);\n\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires multiset_from_seq(input) == output\nensures // show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output, sort_spec(view_i64(input.view()), view_i64(output.view()))\ndecreases a.len(), Boxed(Datatype(PathX, input.len(),  // TODO(utaal): when bug fixed, remove len", "full_verified_code": "// rust_verify/tests/example.rs\nuse multiset::*;\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse set::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn is_sorted(seqint: Seq<int>) -> bool {\n    // summer school definition:\n    //    forall(|idx: nat| idx < seqint.len()-1 ==> seqint.index(idx) <= seqint.index(idx+1 as int)) // TODO(utaal): the as int here is nasty. Why would index take something other than a nat?\n    //    TODO(utaal): Could not automatically infer triggers for this quantifer.  Use #[trigger] annotations to manually mark trigger terms instead.\n    // But jonh hates that summer school definition! Better to forall pairs of indices.\n    forall|i: int, j: int| 0 <= i <= j < seqint.len() ==> seqint[i] <= seqint[j]\n}\n\nspec fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n    decreases a.len(),\n{\n    //decreases(a);   // TOOD(utaal): thread 'rustc' panicked at 'internal error: unsupported type for decreases Boxed(Datatype(PathX { krate: None, segments: [\"vstd\", \"seq\", \"Seq\"] }, [TypParam(\"T\")]))', vir/src/recursion.rs:86:14\n    if a.len() == 0 {\n        0\n    } else {\n        count_in_seq(a.drop_last(), t) + if a.last() == t {\n            1nat\n        } else {\n            0\n        }\n    }\n}\n\n//fn count_in_seq<T>(a: Seq<T>, t: T) -> nat\n//{\n//    exists(|indices:Set<nat>|\n//            true\n//         && forall(|idx:nat| indices.contains(idx) ==> idx < a.len())\n//         && forall(|idx:nat| idx < a.len() && indices.contains(idx) == a.index(t))\n//         )\n//}\nspec fn multiset_matches_seq<T>(a: Seq<T>, b: Multiset<T>) -> bool {\n    forall|t: T| count_in_seq(a, t) == b.count(t)\n}\n\nspec fn multiset_from_seq<T>(input: Seq<T>) -> Multiset<T>\n    decreases input.len(),  // TODO(utaal): when bug fixed, remove len\n{\n    // show we CAN build a multiset constructively from a seq\n    if input.len() == 0 {\n        Multiset::empty()\n    } else {\n        multiset_from_seq(input.drop_last()).insert(input.last())\n    }\n}\n\nproof fn multiset_lemma<T>(input: Seq<T>, output: Multiset<T>)\n    requires\n        multiset_from_seq(input) == output,\n    ensures\n// show we did build a multiset constructively from a seq\n\n        multiset_matches_seq(input, output),\n        // show there's no other multiset that'll work.\n        forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output,\n{\n    if input.len() == 0 {\n        //assert(output == Multiset::empty());\n        assert(multiset_matches_seq(input, output));\n        assume(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);  // TODO\n    } else {\n        /*\n        let prev = multiset_from_seq(\n        let output = multiset_lemma(input.drop_last()\n        assert(multiset_matches_seq(input, output));\n        // show there's no other multiset that'll work.\n        assert(forall(|other:Multiset<T>| multiset_matches_seq(input, other) ==> equal(other, output)));\n        output\n        */\n        assume(false);\n        assert(multiset_matches_seq(input, output));\n        assert(forall|other: Multiset<T>| multiset_matches_seq(input, other) ==> other == output);\n    }\n}\n\nspec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {\n    &&& is_sorted(output)\n    &&& multiset_from_seq(output) == multiset_from_seq(input)\n}\n\nspec fn view_i64(i64seq: Seq<i64>) -> Seq<int> {\n    i64seq.map(|_index: int, i: i64| i as int)\n}\n\nfn merge_sort(input: Vec<i64>) -> (output: Vec<i64>)\n    ensures\n        sort_spec(view_i64(input.view()), view_i64(output.view())),\n{\n    assume(false);\n    input  // TODO(jonh): haven't actually implemented\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-2-3.rs", "verified": true, "metadata": {"original_id": "verus_chapter-2-3_79eb1884c0da", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_10a228758399", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ndecreases l . len () - 1 - i\ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_iter_2_current.rs", "verified": true, "metadata": {"original_id": "10a228758399", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ce07ee509f10", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s2if_impl.rs", "verified": true, "metadata": {"original_id": "ce07ee509f10", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_97bf0678094e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_precond (xs @) , xs . len () <= 100", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32) requires max_subarray_sum_precond (xs @) , xs . len () <= 100 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_45/verina_advanced_45_iter_0_original.rs", "verified": true, "metadata": {"original_id": "97bf0678094e", "function_name": "max_subarray_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_09faa3d174a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high  { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () \ndecreases high - low \ninvariant 0 <= low <= high <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "09faa3d174a3", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6c061a8c09d1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6c061a8c09d1", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ae7e0a5425d1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "requires d > 0\nensures result == sum_of_digits (x as nat), result == is_sum_divisible_by (x as nat , d as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ae7e0a5425d1", "function_name": "is_sum_divisible_by_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_bitvector_basic_69805abc9b67", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n// TODO: change this to a macro so that it can support u8, u16, u64, etc.\n//\n// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,\n// we need basic properties(communtativity, associativity, etc) for these operators.\n// We need to choose one of the below\n// 1) Make exactly the same formula using bit-vector reasoning, OR\n// 2) Make \"similar\" formula using bit-vector reasoning, and let the lemmas below do the rest.\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn bit_and32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_not32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_lshr32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_shl32_auto()\n\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_property32_auto()\n\n{\n}\n\nproof fn test9(b1: u32, b2: u32, b3: u32) {\n    bit_and32_auto();\n\n    let zero = 0u32;\n\n}\n\nproof fn test10(a: u8, b: u8) {\n    // We can write conditions about overflow in bit_vector assertion\n\n}\n\nproof fn test11(x: u32, y: u32) {\n    // XOR operation is independent of bitwidth so we don't need bit_vector solver to do this:\n\n}\n\nproof fn test_usize(x: usize, y: usize, z: usize) {\n\n}\n\nproof fn test_signed(x: i8, y: i8, z: i8, u: u8) {\n\n    // Compare signed vs unsigned\n\n}\n\nproof fn prove_associativity(a: u8, b: i8, c: u8) {\n\n}\n\n} // verus!\n#[verifier::external_body]\nfn main() {}\n", "target_text": "ensures forall|a: u32, b: u32| #[trigger] (a & b) == b & a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),\n        forall|a: u32| #[trigger] (a & a) == a,\n        forall|a: u32| #[trigger] (a & 0) == 0,\n        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a, forall|a: u32, b: u32| #[trigger] (a | b) == b | a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),\n        forall|a: u32| #[trigger] (a | a) == a,\n        forall|a: u32| #[trigger] (a | 0) == a,\n        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32, forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),\n        forall|a: u32| #[trigger] (a ^ a) == 0,\n        forall|a: u32| #[trigger] (a ^ 0) == a,\n        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a, forall|a: u32| #[trigger] !(!a) == a,\n        !0u32 == 0xffff_ffffu32, forall|a: u32| #[trigger] (a >> 0u32) == a, forall|a: u32| #[trigger] (a << 0u32) == a, // absorb\n\n        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,\n        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,\n        // distributive\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),\n        // De Morgan\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\n// TODO: change this to a macro so that it can support u8, u16, u64, etc.\n//\n// Since &, |, ^, (bitwise)!, >>, << are uninterpreted functions for integers,\n// we need basic properties(communtativity, associativity, etc) for these operators.\n// We need to choose one of the below\n// 1) Make exactly the same formula using bit-vector reasoning, OR\n// 2) Make \"similar\" formula using bit-vector reasoning, and let the lemmas below do the rest.\n\nverus! {\n\n#[verifier::bit_vector]\nproof fn bit_and32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a & b) == b & a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a & b) & c) == a & (b & c),\n        forall|a: u32| #[trigger] (a & a) == a,\n        forall|a: u32| #[trigger] (a & 0) == 0,\n        forall|a: u32| #[trigger] (a & 0xffffffffu32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_or32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a | b) == b | a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a | b) | c) == a | (b | c),\n        forall|a: u32| #[trigger] (a | a) == a,\n        forall|a: u32| #[trigger] (a | 0) == a,\n        forall|a: u32| #[trigger] (a | 0xffff_ffffu32) == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_xor32_auto()\n    ensures\n        forall|a: u32, b: u32| #[trigger] (a ^ b) == b ^ a,\n        forall|a: u32, b: u32, c: u32| #[trigger] ((a ^ b) ^ c) == a ^ (b ^ c),\n        forall|a: u32| #[trigger] (a ^ a) == 0,\n        forall|a: u32| #[trigger] (a ^ 0) == a,\n        forall|a: u32| #[trigger] (a ^ 0xffff_ffffu32) == !a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_not32_auto()\n    ensures\n        forall|a: u32| #[trigger] !(!a) == a,\n        !0u32 == 0xffff_ffffu32,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_lshr32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a >> 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_shl32_auto()\n    ensures\n        forall|a: u32| #[trigger] (a << 0u32) == a,\n{\n}\n\n#[verifier::bit_vector]\nproof fn bit_property32_auto()\n    ensures\n// absorb\n\n        forall|a: u32, b: u32| #[trigger] (a & (a | b)) == a,\n        forall|a: u32, b: u32| #[trigger] (a | (a & b)) == a,\n        // distributive\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b | c)) == (a & b) | (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a & (b ^ c)) == (a & b) ^ (a & c),\n        forall|a: u32, b: u32, c: u32| #[trigger] (a | (b & c)) == (a | b) & (a | c),\n        // De Morgan\n        forall|a: u32, b: u32| #[trigger] (!(a & b)) == !a | !b,\n        forall|a: u32, b: u32| #[trigger] (!(a | b)) == !a & !b,\n{\n}\n\nproof fn test9(b1: u32, b2: u32, b3: u32) {\n    bit_and32_auto();\n    assert(b1 & 0xff < 0x100) by (bit_vector);\n    assert(0xff & b1 < 0x100);\n    let zero = 0u32;\n    assert(zero & b3 == 0u32);\n}\n\nproof fn test10(a: u8, b: u8) {\n    // We can write conditions about overflow in bit_vector assertion\n    assert((a & b) == 0 ==> (a | b) == (a + b) && (a + b) < 256) by(bit_vector);\n}\n\nproof fn test11(x: u32, y: u32) {\n    // XOR operation is independent of bitwidth so we don't need bit_vector solver to do this:\n    assert((x as u64) ^ (y as u64) == (x ^ y) as u64);\n}\n\nproof fn test_usize(x: usize, y: usize, z: usize) {\n    assert(((x & y) & z) == (x & (y & z))) by(bit_vector);\n}\n\nproof fn test_signed(x: i8, y: i8, z: i8, u: u8) {\n    assert(!(x & y) == (!x | !y)) by(bit_vector);\n    assert((!z) == (!(z as i32))) by(bit_vector);\n    assert((z & (128u8 as i8)) != 0 <==> z < 0) by(bit_vector);\n\n    // Compare signed vs unsigned\n    assert(u > -1) by(bit_vector);\n    assert(u > 128 ==> u > x) by(bit_vector);\n}\n\nproof fn prove_associativity(a: u8, b: i8, c: u8) {\n    assert((a + b) + c == a + (b + c)) by(bit_vector);\n}\n\n} // verus!\n#[verifier::external_body]\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/bitvector_basic.rs", "verified": true, "metadata": {"original_id": "verus_bitvector_basic_69805abc9b67", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_02f55079b33b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/havoc_inline_post_impl.rs", "verified": true, "metadata": {"original_id": "02f55079b33b", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8e264f38d976", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_251_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8e264f38d976", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d0c86e33c6fb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d0c86e33c6fb", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_23d1dc2a0a62", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "23d1dc2a0a62", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b2fd06c1aa9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX\nensures longest_increasing_subsequence_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32) requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX ensures longest_increasing_subsequence_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_34/verina_advanced_34_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b2fd06c1aa9", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6394d02944f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/linear_search2_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6394d02944f0", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e4abb7af8d6a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { x . checked_add (y) }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e4abb7af8d6a", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8870850d018f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases a . len () - i\ninvariant i <= a . len () , result . len () == if i <= pos", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "8870850d018f", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4f89247f1c4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4f89247f1c4b", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8826dda7eb81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8826dda7eb81", "function_name": "M", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ac3ced4a2d61", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "ac3ced4a2d61", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_555a16920b3f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if a [left] == false { left += 1 ; } else { right -= 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if a [left] == false { left += 1 ; } else { right -= 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "555a16920b3f", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7cb9eafb17d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_477_impl.rs", "verified": true, "metadata": {"original_id": "7cb9eafb17d4", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_441e1adae415", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "441e1adae415", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a29ffa66c2b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_99/verina_basic_99_impl.rs", "verified": true, "metadata": {"original_id": "a29ffa66c2b4", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e0f871158ef8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "e0f871158ef8", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e5f3508fc988", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs4_impl.rs", "verified": true, "metadata": {"original_id": "e5f3508fc988", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_41ddcf85519d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >)   { let mut i = 0 ; while i < s . len ()  { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 \nensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_double_array_elements/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "41ddcf85519d", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_34b41bac24b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "34b41bac24b8", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2af7f984f338", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32)   { let mut i : usize = 0 ; while i < a . len ()  { a . set (i , (i + 1) as i32) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] == k + 1 \ndecreases a . len () - i \ninvariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == k + 1 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] == k + 1 , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == k + 1 , decreases a . len () - i , { a . set (i , (i + 1) as i32) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/indp1_impl.rs", "verified": true, "metadata": {"original_id": "2af7f984f338", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6d62299839a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >)  { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len ()  { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "target_text": "ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] \ninvariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >) ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] , { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len () invariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0 { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_cum_sum_impl.rs", "verified": true, "metadata": {"original_id": "6d62299839a3", "function_name": "cum_sum", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ffa6c1536e04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "ffa6c1536e04", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5abd6838fe15", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn ckeyhashmap_max_serialized_size () -> usize { 0x100000 }\npub fn ckeyhashmap_max_serialized_size_exec () -> (r : usize)  { reveal (ckeyhashmap_max_serialized_size) ; 0x100000 }\n\n} // verus!", "target_text": "ensures r == ckeyhashmap_max_serialized_size ()", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn ckeyhashmap_max_serialized_size () -> usize { 0x100000 }\npub fn ckeyhashmap_max_serialized_size_exec () -> (r : usize) ensures r == ckeyhashmap_max_serialized_size () { reveal (ckeyhashmap_max_serialized_size) ; 0x100000 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "5abd6838fe15", "function_name": "ckeyhashmap_max_serialized_size_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c8493d7faa64", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_all_occurrences (text : Seq < char > , pattern : Seq < char >) -> (result : Vec < usize >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires true\nensures true", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_all_occurrences (text : Seq < char > , pattern : Seq < char >) -> (result : Vec < usize >) requires true ensures true { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Practice_tmp_tmphnmt4ovh_Pattern Matching/verus_code.rs", "verified": true, "metadata": {"original_id": "c8493d7faa64", "function_name": "find_all_occurrences", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5e43ef69574e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - i\ninvariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "5e43ef69574e", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_14189d2ad554", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize)   { return 0 ; }\n\n} // verus!", "target_text": "requires b . len () <= a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code.rs", "verified": true, "metadata": {"original_id": "14189d2ad554", "function_name": "containsSubString", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6301b9aab878", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "6301b9aab878", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_babb4104c1c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , N + 1) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , N < 1000 , forall | k : int | 0 <= k < i ==> a [k as int] == N + 1 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , N < 1000 , forall | k : int | 0 <= k < i ==> a [k as int] == N + 1 , decreases N - i , { a . set (i as usize , N + 1) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/sina3_impl.rs", "verified": true, "metadata": {"original_id": "babb4104c1c3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_193ced81e2b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "193ced81e2b1", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_954cb6321571", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - i \ninvariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_product_impl.rs", "verified": true, "metadata": {"original_id": "954cb6321571", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e611bcbaf723", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "e611bcbaf723", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ec6952035112", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ec6952035112", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c8d7e2df4377", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s5if_impl.rs", "verified": true, "metadata": {"original_id": "c8d7e2df4377", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d9bac41f9e2e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nfn task_code (sequence : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires task_code_precond (sequence @ . map (| i , x | x as int))\nensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int)))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_75/verina_advanced_75_iter_0_original.rs", "verified": true, "metadata": {"original_id": "d9bac41f9e2e", "function_name": "task_code", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a25426d2dceb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let mut found = false ; for j in 0 .. result . len ()  { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found == exists | k : int | 0 <= k < j && result [k] == a [i as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , found == exists | k : int | 0 <= k < j && result [k] == a [i as int] , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "a25426d2dceb", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a487cda08e77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a487cda08e77", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_31fea0a0c705", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "31fea0a0c705", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5e8defeb6441", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "5e8defeb6441", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5ff2ae5ce81a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_char (s : Vec < char > , old : char , new : char) -> (result : Vec < char >)  { new } else { s [i] }) , { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { new } else { s [j] }) , { result . push (if s [i] == old { new } else { s [i] }) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "ensures result . len () == s . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if s [i] == old\ndecreases s . len () - i \ninvariant 0 <= i && i <= s . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if s [j] == old", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_char (s : Vec < char > , old : char , new : char) -> (result : Vec < char >) ensures result . len () == s . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if s [i] == old { new } else { s [i] }) , { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i && i <= s . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if s [j] == old { new } else { s [j] }) , decreases s . len () - i , { result . push (if s [i] == old { new } else { s [i] }) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/replace_chars_impl.rs", "verified": true, "metadata": {"original_id": "5ff2ae5ce81a", "function_name": "replace_char", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_faca488e1a60", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires move_zeros_to_end_precond (arr @) \nensures move_zeros_to_end_postcond (arr @ , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_35/verina_basic_35_iter_0_original.rs", "verified": true, "metadata": {"original_id": "faca488e1a60", "function_name": "move_zeros_to_end", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5518664c862b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)   { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "target_text": "requires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] \ndecreases a . len () - i , b . len () - j \ninvariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , decreases a . len () - i , { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] , decreases b . len () - j , { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "5518664c862b", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dd6a99cbceb3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64)   { return 0 ; }\n\n} // verus!", "target_text": "requires 0 <= k <= n \nensures result as nat == comb (n as nat , k as nat) \ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_CombNK/verus_code.rs", "verified": true, "metadata": {"original_id": "dd6a99cbceb3", "function_name": "comb_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_476e4fc506c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "476e4fc506c2", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab4797b84e5b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_test_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ab4797b84e5b", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_697f62ffc502", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "697f62ffc502", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4dbe18819b34", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "4dbe18819b34", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0ccc6a238222", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "0ccc6a238222", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c7b4c4028e43", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith)   { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n  { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires p > 0 , p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) , r == modp_rec (n as nat , p as nat) \ndecreases n , n - i \ninvariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "c7b4c4028e43", "function_name": "modp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab0e0d93ca25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ab0e0d93ca25", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_58d1bb28c3cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "58d1bb28c3cb", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9954dce0f34e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/replace_impl.rs", "verified": true, "metadata": {"original_id": "9954dce0f34e", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c646d6a1dc07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < a . len ()  { a . set (i , N + 1) ; i += 1 ;  } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i , { a . set (i , N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina2_impl.rs", "verified": true, "metadata": {"original_id": "c646d6a1dc07", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b643f4921c43", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b643f4921c43", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_60922faa053e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s4lif_impl.rs", "verified": true, "metadata": {"original_id": "60922faa053e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_da146288ef14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_53/verina_advanced_53.rs", "verified": true, "metadata": {"original_id": "da146288ef14", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_24679d6e00de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_97/verina_basic_97_iter_1_current.rs", "verified": true, "metadata": {"original_id": "24679d6e00de", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fce2ce40aa0d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_log_size_offset : u64 = 24 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_head_offset : u64 = 8 ;\npub const header_size : u64 = 32 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn crc_and_metadata_bytes_to_header (crc_bytes : & [u8] , header_bytes : & [u8]) -> (out : PersistentHeader)   { let head_bytes = slice_subrange (header_bytes , (header_head_offset - 8) as usize , (header_head_offset + 8 - 8) as usize) ; let tail_bytes = slice_subrange (header_bytes , (header_tail_offset - 8) as usize , (header_tail_offset + 8 - 8) as usize) ; let log_size_bytes = slice_subrange (header_bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset + 8 - 8) as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) } } }\n\n} // verus!", "target_text": "requires crc_bytes @ . len () == 8 , header_bytes @ . len () == header_size - 8\nensures out . crc == spec_u64_from_le_bytes (crc_bytes @) , out . metadata == spec_bytes_to_metadata (header_bytes @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_log_size_offset : u64 = 24 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_head_offset : u64 = 8 ;\npub const header_size : u64 = 32 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn crc_and_metadata_bytes_to_header (crc_bytes : & [u8] , header_bytes : & [u8]) -> (out : PersistentHeader) requires crc_bytes @ . len () == 8 , header_bytes @ . len () == header_size - 8 ensures out . crc == spec_u64_from_le_bytes (crc_bytes @) , out . metadata == spec_bytes_to_metadata (header_bytes @) { let head_bytes = slice_subrange (header_bytes , (header_head_offset - 8) as usize , (header_head_offset + 8 - 8) as usize) ; let tail_bytes = slice_subrange (header_bytes , (header_tail_offset - 8) as usize , (header_tail_offset + 8 - 8) as usize) ; let log_size_bytes = slice_subrange (header_bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset + 8 - 8) as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "pmemlog_inlined.rs", "verified": true, "metadata": {"original_id": "fce2ce40aa0d", "function_name": "crc_and_metadata_bytes_to_header", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_references_6ea52b24da6a", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    // These point to different stack variables, but they compare equal.\n\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n\n    modify_y(&mut y);\n\n}\n// ANCHOR_END: mut\n\n// ANCHOR:\n\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n\n}\n// ANCHOR_END:\n{\n\n    *a = *a + 1;\n\n    *a = *a + 1;\n\n}\n\nfn asserts()\n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n\n{\n    let mut i: u32 = 0;\n    while (*b > 0)\n\n    {\n        *b = *b - 1;\n        i = i + 1;\n\n    }\n\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n\n}\n// ANCHOR_END: complex\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires *old(a) < u32::MAX, *old(a) == 0, *old(b) == 10\nensures *a == 2, *a == *old(a) + 1, *b == 0\ndecreases *b\ninvariant *b == (10 - i)", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/references.rs", "verified": true, "metadata": {"original_id": "verus_references_6ea52b24da6a", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ca2f4e4d2d84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "ca2f4e4d2d84", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fd1d3b2c36b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] != element { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] == element", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "fd1d3b2c36b1", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fb4faf4a907f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32) requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_7/verina_advanced_7_iter_0_original.rs", "verified": true, "metadata": {"original_id": "fb4faf4a907f", "function_name": "binary_to_decimal", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3c315a401913", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires replace_with_colon_precond (s @)\nensures result == is_space_comma_dot_spec (c), replace_with_colon_postcond (s @ , result @)\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_36/verina_basic_36_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3c315a401913", "function_name": "replace_with_colon", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ccfb57f4fcbc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires concat_precond (a , b) , a . len () + b . len () <= MAX \nensures concat_postcond (a , b , & result) \ndecreases a . len () - i, b . len () - j\ninvariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_83/verina_basic_83_impl.rs", "verified": true, "metadata": {"original_id": "ccfb57f4fcbc", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_798a03f8287d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "798a03f8287d", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9d373b11dee8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9d373b11dee8", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d34a0ff253a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "d34a0ff253a3", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7157a8cdb4f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7157a8cdb4f1", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_26c59e126839", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "26c59e126839", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3a997f080293", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_72/verina_advanced_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3a997f080293", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b4c39b7bd616", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i\ninvariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "b4c39b7bd616", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_886aca454df9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int)   { 1int } else { 0int } , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ;    let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ;   let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ;   }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)   { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  {  if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; }  count }\n\n} // verus!", "target_text": "requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () \nensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i], 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count \ndecreases s1 . len () , s2 . len () , s3 . len () , s1 . len () - i , arr1 . len () - i\ninvariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_142_iter_4_current.rs", "verified": true, "metadata": {"original_id": "886aca454df9", "function_name": "count_identical_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e1ce156dfa20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "e1ce156dfa20", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1eb541c80733", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1eb541c80733", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f323d82b7fbf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = (6 * N) as i32 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = (6 * N) as i32 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "f323d82b7fbf", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_faef24e15316", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "faef24e15316", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_314de6cfc900", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "314de6cfc900", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_32c198187058", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "32c198187058", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_bad90820d702", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32)   {     let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut min_index = 0 ; for i in 1 .. arr . len ()  {    if arr [i] [1] < min_second { min_second = arr [i] [1] ; result_first = arr [i] [0] ; min_index = i ; } }     result_first }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 \nensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) \ninvariant arr . len () > 0 , forall | k : int | 0 <= k < arr . len () ==> arr [k] . len () >= 2 , 0 <= min_index < arr . len () , min_index < i , min_second == arr [min_index as int] [1] , result_first == arr [min_index as int] [0] , forall | j : int | 0 <= j < i ==> min_second <= arr [j] [1] , i <= arr . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 , ensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) , { assert (arr . len () > 0) ; assert (0 < arr . len ()) ; assert (arr [0] . len () >= 2) ; assert (0 < arr [0] . len () && 1 < arr [0] . len ()) ; let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut min_index = 0 ; for i in 1 .. arr . len () invariant arr . len () > 0 , forall | k : int | 0 <= k < arr . len () ==> arr [k] . len () >= 2 , 0 <= min_index < arr . len () , min_index < i , min_second == arr [min_index as int] [1] , result_first == arr [min_index as int] [0] , forall | j : int | 0 <= j < i ==> min_second <= arr [j] [1] , i <= arr . len () , { assert (i < arr . len ()) ; assert (arr [i as int] . len () >= 2) ; assert (1 < arr [i as int] . len ()) ; if arr [i] [1] < min_second { min_second = arr [i] [1] ; result_first = arr [i] [0] ; min_index = i ; } } assert (forall | j : int | 0 <= j < arr . len () ==> min_second <= arr [j] [1]) ; assert (0 <= min_index < arr . len ()) ; assert (result_first == arr [min_index as int] [0]) ; assert (min_second == arr [min_index as int] [1]) ; result_first }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_94_impl.rs", "verified": true, "metadata": {"original_id": "bad90820d702", "function_name": "min_second_value_first", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_61ad0e81a480", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)   { let mut i = 0 ; while i < numbers . len ()  { let mut j = 0 ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold\ndecreases numbers . len () - i, numbers . len () - j\ninvariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold, 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "61ad0e81a480", "function_name": "has_close_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d91aa2fbd788", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i \ninvariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len () invariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] , decreases x . len () - i , { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "d91aa2fbd788", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_af205b53d72f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_odd_at_index_odd_precond (a @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool) requires is_odd_at_index_odd_precond (a @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_44/verina_basic_44.rs", "verified": true, "metadata": {"original_id": "af205b53d72f", "function_name": "is_odd_at_index_odd", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b4d84c1f67cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "b4d84c1f67cc", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_92821a777ff7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left \ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left , { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "92821a777ff7", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a9f193cf911c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ndecreases a . len () - i\ninvariant i <= a . len () , result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result @ == a @ . subrange (0 , i as int) decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_array_append/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a9f193cf911c", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5096bc2f033a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5096bc2f033a", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7809d6963c00", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32)   { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res \ndecreases a . len () - idx \ninvariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_max_impl.rs", "verified": true, "metadata": {"original_id": "7809d6963c00", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1be5df6de237", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "1be5df6de237", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c7b057ca7fff", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_size : u64 = 32 ;\npub const header_head_offset : u64 = 8 ;\npub const header_crc_offset : u64 = 0 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub const header_tail_offset : u64 = 16 ;\npub const header_log_size_offset : u64 = 24 ;\npub open spec (checked) fn spec_bytes_to_header (header_seq : Seq < u8 >) -> PersistentHeader recommends header_seq . len () == header_size { let crc_val = spec_u64_from_le_bytes (header_seq . subrange (header_crc_offset as int , header_crc_offset + 8)) ; let metadata = spec_bytes_to_metadata (header_seq . subrange (header_head_offset as int , header_size as int)) ; PersistentHeader { crc : crc_val , metadata } }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn bytes_to_metadata (bytes : & [u8]) -> (out : PersistentHeaderMetadata)   { let head_bytes = slice_subrange (bytes , (header_head_offset - 8) as usize , (header_head_offset - 8 + 8) as usize) ; let tail_bytes = slice_subrange (bytes , (header_tail_offset - 8) as usize , (header_tail_offset - 8 + 8) as usize) ; let log_size_bytes = slice_subrange (bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset - 8 + 8) as usize) ; PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) , } }\n# [doc = \" Spec code only converts byte representations to structures and does not go the other way\"] # [doc = \" to simplify reasoning about persistent structures (although the opposite direction is\"] # [doc = \" implemented in exec code).\"] exec fn bytes_to_header (bytes : & [u8]) -> (out : PersistentHeader)   { let crc_bytes = slice_subrange (bytes , header_crc_offset as usize , (header_crc_offset + 8) as usize) ; let metadata_bytes = slice_subrange (bytes , header_head_offset as usize , header_size as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : bytes_to_metadata (metadata_bytes) , } }\n\n} // verus!", "target_text": "requires bytes @ . len () == header_size - 8, bytes @ . len () == header_size\nensures out == spec_bytes_to_metadata (bytes @), out == spec_bytes_to_header (bytes @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_size : u64 = 32 ;\npub const header_head_offset : u64 = 8 ;\npub const header_crc_offset : u64 = 0 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub const header_tail_offset : u64 = 16 ;\npub const header_log_size_offset : u64 = 24 ;\npub open spec (checked) fn spec_bytes_to_header (header_seq : Seq < u8 >) -> PersistentHeader recommends header_seq . len () == header_size { let crc_val = spec_u64_from_le_bytes (header_seq . subrange (header_crc_offset as int , header_crc_offset + 8)) ; let metadata = spec_bytes_to_metadata (header_seq . subrange (header_head_offset as int , header_size as int)) ; PersistentHeader { crc : crc_val , metadata } }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn bytes_to_metadata (bytes : & [u8]) -> (out : PersistentHeaderMetadata) requires bytes @ . len () == header_size - 8 ensures out == spec_bytes_to_metadata (bytes @) { let head_bytes = slice_subrange (bytes , (header_head_offset - 8) as usize , (header_head_offset - 8 + 8) as usize) ; let tail_bytes = slice_subrange (bytes , (header_tail_offset - 8) as usize , (header_tail_offset - 8 + 8) as usize) ; let log_size_bytes = slice_subrange (bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset - 8 + 8) as usize) ; PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) , } }\n# [doc = \" Spec code only converts byte representations to structures and does not go the other way\"] # [doc = \" to simplify reasoning about persistent structures (although the opposite direction is\"] # [doc = \" implemented in exec code).\"] exec fn bytes_to_header (bytes : & [u8]) -> (out : PersistentHeader) requires bytes @ . len () == header_size ensures out == spec_bytes_to_header (bytes @) { let crc_bytes = slice_subrange (bytes , header_crc_offset as usize , (header_crc_offset + 8) as usize) ; let metadata_bytes = slice_subrange (bytes , header_head_offset as usize , header_size as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : bytes_to_metadata (metadata_bytes) , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "pmemlog_inlined.rs", "verified": true, "metadata": {"original_id": "c7b057ca7fff", "function_name": "bytes_to_header", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2d9744ed7747", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i \ninvariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "2d9744ed7747", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4238801bac99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { return false ; }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4238801bac99", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ae34894f2210", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_624_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ae34894f2210", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_06a3047ef106", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "06a3047ef106", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e44fb6d8e56", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >)   { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len ()  { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "target_text": "requires start <= chars . len (), letter_combinations_precond (digits @)\nensures result == is_valid_digit (c), result @ == digit_to_letters (c), letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @))\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1, 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >) requires letter_combinations_precond (digits @) ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "0e44fb6d8e56", "function_name": "letter_combinations", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_95350da28a36", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "95350da28a36", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_164190bd6377", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "164190bd6377", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1a910d27683d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1a910d27683d", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a2b29ac3c956", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s3if_impl.rs", "verified": true, "metadata": {"original_id": "a2b29ac3c956", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_536d3e26ce5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_char (s : Vec < char > , old : char , new : char) -> (result : Vec < char >)  { new } else { s [i] }) , { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { new } else { s [j] }) , { result . push (if s [i] == old { new } else { s [i] }) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "ensures result . len () == s . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if s [i] == old\ndecreases s . len () - i \ninvariant 0 <= i && i <= s . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if s [j] == old", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_char (s : Vec < char > , old : char , new : char) -> (result : Vec < char >) ensures result . len () == s . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if s [i] == old { new } else { s [i] }) , { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i && i <= s . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if s [j] == old { new } else { s [j] }) , decreases s . len () - i , { result . push (if s [i] == old { new } else { s [i] }) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/replace_chars_iter_2_current.rs", "verified": true, "metadata": {"original_id": "536d3e26ce5f", "function_name": "replace_char", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_62039307513d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_251_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "62039307513d", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a12b555ab16d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires missing_number_precond (nums @)\nensures missing_number_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize) requires missing_number_precond (nums @) ensures missing_number_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_54/verina_advanced_54_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a12b555ab16d", "function_name": "missing_number", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_59f6b70ece37", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize))   { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len ()  { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len ()  { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "target_text": "requires numbers . len () >= 2 \nensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) \ndecreases seq . len () , numbers . len () - i , numbers . len () - i \ninvariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_755_impl.rs", "verified": true, "metadata": {"original_id": "59f6b70ece37", "function_name": "second_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b461e4ced2bd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z' { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b461e4ced2bd", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cf5bf1db2a75", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/brs4_impl.rs", "verified": true, "metadata": {"original_id": "cf5bf1db2a75", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ab81e8f03987", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "ab81e8f03987", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_728fed2aa103", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "728fed2aa103", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a388c46c3217", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j = j + 1 ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i , arr . len () - j \ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i , { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j , { if arr [i] >= arr [j] { return false ; } j = j + 1 ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "a388c46c3217", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_31b4723f5db5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_44/verina_advanced_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "31b4723f5db5", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_eab32db04a97", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "eab32db04a97", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_vostd_pod_e02b9add994d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nuse core::mem::MaybeUninit;\n\nverus! {\n\npub trait Pod: Copy + Sized {\n    /// Creates a new instance of Pod type that is filled with zeroes.\n    #[verifier::external_body]\n    fn new_zeroed() -> Self {\n        // SAFETY. An all-zero value of `T: Pod` is always valid.\n        unsafe { core::mem::zeroed() }\n    }\n\n    /// Creates a new instance of Pod type with uninitialized content.\n    #[verifier::external_body]\n    fn new_uninit() -> Self {\n        // SAFETY. A value of `T: Pod` can have arbitrary bits.\n        #[allow(clippy::uninit_assumed_init)]\n        unsafe { MaybeUninit::uninit().assume_init() }\n    }\n\n    /// As a slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes(&self) -> (slice: &[u8])\n\n    {\n        let ptr = self as *const Self as *const u8;\n        let len = core::mem::size_of::<Self>();\n        unsafe { core::slice::from_raw_parts(ptr, len) }\n    }\n\n    /// As a mutable slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes_mut(&mut self) -> (*mut u8, usize) {\n        let ptr = self as *mut Self as *mut u8;\n        let len = core::mem::size_of::<Self>();\n        // unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n        (ptr, len)\n    }\n}\n\n#[verifier::external]\npub fn as_bytes_mut_ex<T: Pod>(val: &mut T) -> &mut [u8] {\n    let ptr = val as *mut T as *mut u8;\n    let len = core::mem::size_of::<T>();\n    unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n}\n\npub open spec fn pod_size_spec<T: Pod>() -> usize {\n    core::mem::size_of::<T>()\n}\n\npub open spec fn pod_pnt_is_aligned<T: Pod>(pnt: *const u8) -> bool {\n    (pnt as usize) % pod_size_spec::<T>() == 0\n}\n\npub open spec fn pod_mem_space_is_aligned<T: Pod>(avail: int) -> bool {\n    avail % pod_size_spec::<T>() as int == 0\n}\n\n} // verus!\n", "target_text": "ensures slice.len() == core::mem::size_of::<Self>()", "full_verified_code": "use vstd::prelude::*;\n\nuse core::mem::MaybeUninit;\n\nverus! {\n\npub trait Pod: Copy + Sized {\n    /// Creates a new instance of Pod type that is filled with zeroes.\n    #[verifier::external_body]\n    fn new_zeroed() -> Self {\n        // SAFETY. An all-zero value of `T: Pod` is always valid.\n        unsafe { core::mem::zeroed() }\n    }\n\n    /// Creates a new instance of Pod type with uninitialized content.\n    #[verifier::external_body]\n    fn new_uninit() -> Self {\n        // SAFETY. A value of `T: Pod` can have arbitrary bits.\n        #[allow(clippy::uninit_assumed_init)]\n        unsafe { MaybeUninit::uninit().assume_init() }\n    }\n\n    /// As a slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes(&self) -> (slice: &[u8])\n        ensures\n            slice.len() == core::mem::size_of::<Self>(),\n    {\n        let ptr = self as *const Self as *const u8;\n        let len = core::mem::size_of::<Self>();\n        unsafe { core::slice::from_raw_parts(ptr, len) }\n    }\n\n    /// As a mutable slice of bytes.\n    #[verifier::external_body]\n    fn as_bytes_mut(&mut self) -> (*mut u8, usize) {\n        let ptr = self as *mut Self as *mut u8;\n        let len = core::mem::size_of::<Self>();\n        // unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n        (ptr, len)\n    }\n}\n\n#[verifier::external]\npub fn as_bytes_mut_ex<T: Pod>(val: &mut T) -> &mut [u8] {\n    let ptr = val as *mut T as *mut u8;\n    let len = core::mem::size_of::<T>();\n    unsafe { core::slice::from_raw_parts_mut(ptr, len) }\n}\n\npub open spec fn pod_size_spec<T: Pod>() -> usize {\n    core::mem::size_of::<T>()\n}\n\npub open spec fn pod_pnt_is_aligned<T: Pod>(pnt: *const u8) -> bool {\n    (pnt as usize) % pod_size_spec::<T>() == 0\n}\n\npub open spec fn pod_mem_space_is_aligned<T: Pod>(avail: int) -> bool {\n    avail % pod_size_spec::<T>() as int == 0\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/fvt6-vmreader-and-vmwriter/src/pod.rs", "verified": true, "metadata": {"original_id": "vostd_pod_e02b9add994d", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b7f4c8c3eb78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len ()  { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - j\ninvariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_474_iter_3_current.rs", "verified": true, "metadata": {"original_id": "b7f4c8c3eb78", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_95c98c5dcabd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "95c98c5dcabd", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1bbbe1fefda1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 0 < j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 0 < j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "1bbbe1fefda1", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4df1a8b50f58", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4df1a8b50f58", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0e7c856901ef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/res2o_impl.rs", "verified": true, "metadata": {"original_id": "0e7c856901ef", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2897f0d1e19e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2897f0d1e19e", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_statements_2722111d3ecf", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n\n    if x == 0 {\n\n    } else if x == 1 {\n\n    } else if x == 2 {\n\n    } else {\n\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n\n    {\n\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n\n}\n\n} // verus!\n", "target_text": "decreases 100 - i\ninvariant 10 <= i,\n            i <= 100,\n            b1 == i * 2", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nfn test_if(b: bool) {\n    let mut x: u32 = 0;\n    if b {\n        x = 10;\n    }\n    assert(b ==> x == 10);\n    if b {\n        x = x + 3;\n        x = x + 4;\n    } else {\n        x = x + 2;\n    }\n    assert(b ==> x == 17);\n    assert(!b ==> x == 2);\n    assert(x == if b {\n        17int\n    } else {\n        2\n    });\n    if x == 0 {\n        assert(false);\n    } else if x == 1 {\n        assert(false);\n    } else if x == 2 {\n        assert(!b);\n    } else {\n        assert(x == 17);\n    }\n}\n\nfn test_loop() {\n    let mut i: u64 = 10;\n    let mut b1: u8 = 20;\n    let mut b2: u8 = 200;\n    let mut b3: u8 = 30;\n    while i < 100\n        invariant\n            10 <= i,\n            i <= 100,\n            b1 == i * 2,\n        decreases 100 - i,\n    {\n        assert(b2 <= 255);\n        i = i + 1;\n        b1 = b1 + 2;\n        b2 = b2 / 2;\n    }\n    assert(b1 == 200);\n    assert(b3 == 30);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/statements.rs", "verified": true, "metadata": {"original_id": "verus_statements_2722111d3ecf", "function_name": "", "has_requires": false, "has_ensures": false, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_vostd_page_prop_470fb761b33a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 3, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    pub open spec fn new_user_spec(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[verifier::when_used_as_spec(new_user_spec)]\n    pub fn new_user(flags: PageFlags, cache: CachePolicy) -> (res: Self)\n\n    {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    pub open spec fn new_absent_spec() -> Self {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n\n    #[verifier::when_used_as_spec(new_absent_spec)]\n    pub fn new_absent() -> (res: Self)\n\n    {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[verifier::inline]\n    pub open spec fn N_spec() -> usize {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(N_spec)]\n    pub const fn N() -> (res: usize)\n\n    {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn R_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(R_spec)]\n    pub const fn R() -> (res: Self)\n\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn W_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(W_spec)]\n    pub const fn W() -> (res: Self)\n\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn X_spec() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn X() -> (res: Self)\n\n    {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RW_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn RW() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RX_spec)]\n    pub const fn RX() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RWX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RWX_spec)]\n    pub const fn RWX() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn ACCESSED_spec() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(ACCESSED_spec)]\n    pub const fn ACCESSED() -> (res: Self)\n\n    {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn DIRTY_spec() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(DIRTY_spec)]\n    pub const fn DIRTY() -> (res: Self)\n\n    {\n        Self { bits: 0b00010000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn USER_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(USER_spec)]\n    pub const fn USER() -> (res: Self)\n\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn GLOBAL_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(GLOBAL_spec)]\n    pub const fn GLOBAL() -> (res: Self)\n\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn SHARED_spec() -> Self {\n        Self { bits: 0b10000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(SHARED_spec)]\n    pub const fn SHARED() -> (res: Self)\n\n    {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "target_text": "requires #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags, a == b, #[trigger] a.bits == #[trigger] b.bits, a == b, #[trigger] a.bits == #[trigger] b.bits, a == b\nensures a == b, #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags, res == Self::new_user_spec(flags, cache), res == Self::new_absent_spec(), res == Self::N_spec(), res == self.value(), a == b, #[trigger] a.bits == #[trigger] b.bits, res == Self::empty_spec(), res == self.value_spec(), res == Self::from_bits_spec(value),\n            res.bits == value, res == Self::R_spec(), res == Self::W_spec(), res == Self::X_spec(), res == Self::RW_spec(), res == Self::RX_spec(), res == Self::RWX_spec(), res == Self::ACCESSED_spec(), res == Self::DIRTY_spec(), a == b, #[trigger] a.bits == #[trigger] b.bits, res == Self::empty_spec(), res == self.value_spec(), res == Self::from_bits_spec(value), res == Self::USER_spec(), res == Self::GLOBAL_spec(), res == Self::SHARED_spec()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 3, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n    requires\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    pub open spec fn new_user_spec(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[verifier::when_used_as_spec(new_user_spec)]\n    pub fn new_user(flags: PageFlags, cache: CachePolicy) -> (res: Self)\n        ensures\n            res == Self::new_user_spec(flags, cache),\n    {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    pub open spec fn new_absent_spec() -> Self {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n\n    #[verifier::when_used_as_spec(new_absent_spec)]\n    pub fn new_absent() -> (res: Self)\n        ensures\n            res == Self::new_absent_spec(),\n    {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[verifier::inline]\n    pub open spec fn N_spec() -> usize {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(N_spec)]\n    pub const fn N() -> (res: usize)\n        ensures\n            res == Self::N_spec(),\n    {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value(),\n    {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n            res.bits == value,\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn R_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(R_spec)]\n    pub const fn R() -> (res: Self)\n        ensures\n            res == Self::R_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn W_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(W_spec)]\n    pub const fn W() -> (res: Self)\n        ensures\n            res == Self::W_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn X_spec() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn X() -> (res: Self)\n        ensures\n            res == Self::X_spec(),\n    {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RW_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn RW() -> (res: Self)\n        ensures\n            res == Self::RW_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RX_spec)]\n    pub const fn RX() -> (res: Self)\n        ensures\n            res == Self::RX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RWX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RWX_spec)]\n    pub const fn RWX() -> (res: Self)\n        ensures\n            res == Self::RWX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn ACCESSED_spec() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(ACCESSED_spec)]\n    pub const fn ACCESSED() -> (res: Self)\n        ensures\n            res == Self::ACCESSED_spec(),\n    {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn DIRTY_spec() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(DIRTY_spec)]\n    pub const fn DIRTY() -> (res: Self)\n        ensures\n            res == Self::DIRTY_spec(),\n    {\n        Self { bits: 0b00010000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn USER_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(USER_spec)]\n    pub const fn USER() -> (res: Self)\n        ensures\n            res == Self::USER_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn GLOBAL_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(GLOBAL_spec)]\n    pub const fn GLOBAL() -> (res: Self)\n        ensures\n            res == Self::GLOBAL_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn SHARED_spec() -> Self {\n        Self { bits: 0b10000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(SHARED_spec)]\n    pub const fn SHARED() -> (res: Self)\n        ensures\n            res == Self::SHARED_spec(),\n    {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/aster_common/src/page_prop.rs", "verified": true, "metadata": {"original_id": "vostd_page_prop_470fb761b33a", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_29d9c6a0ca2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start <= nums . len ()\ndecreases nums . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_15/verina_advanced_15.rs", "verified": true, "metadata": {"original_id": "29d9c6a0ca2c", "function_name": "loop_search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_afe0528d8763", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { for k in 1 .. arr . len ()  { if arr [k - 1] > arr [k] { return false ; } } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ninvariant forall | i : int , j : int | 0 <= i < j < k ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { for k in 1 .. arr . len () invariant forall | i : int , j : int | 0 <= i < j < k ==> arr [i] <= arr [j] , { if arr [k - 1] > arr [k] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "afe0528d8763", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_93e4da6b5970", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "93e4da6b5970", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_718ed3ac6611", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "718ed3ac6611", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f101c4cc3062", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool)   { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p  { let mut j = p + 1 ; while j < v . len ()  { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires v . len () > 0 , p < v . len () \nensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l])\ndecreases p + 1 - i, v . len () - j\ninvariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l], 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () , ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f101c4cc3062", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_766250ab1e05", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len ()  { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ninvariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "766250ab1e05", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_342f4c21e202", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "342f4c21e202", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b97506b2ab46", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b97506b2ab46", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_98d4b4f2cb18", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "98d4b4f2cb18", "function_name": "M", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1f3be13c8af3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32)   { 0 }\n\n} // verus!", "target_text": "requires 0 < x < y \nensures z >= 0 && z <= y && z != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1f3be13c8af3", "function_name": "m1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_452321dd1361", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)   { let mut i = 0usize ; while i < numbers . len ()  { let mut j = 0usize ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires i != MIN , threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures i < 0 ==> res == - i , i >= 0 ==> res == i, flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold\ndecreases numbers . len () - i, numbers . len () - j\ninvariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold, 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "452321dd1361", "function_name": "has_close_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9660478ada30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "9660478ada30", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c0a1585678d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases exp ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 decreases exp , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c0a1585678d5", "function_name": "pow_exec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_11cd54e75abe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> (ret : bool) { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1 ; let mut i = 2 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } return largest ; }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i , n + 1 - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> (ret : bool) { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } return largest ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "11cd54e75abe", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_985ef365f1a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "985ef365f1a2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_05c9d03701bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "05c9d03701bb", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cc75af96086f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ndecreases l . len () - 1 - i\ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_impl.rs", "verified": true, "metadata": {"original_id": "cc75af96086f", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3af55780098f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3af55780098f", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1b76404351aa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires rain_precond (heights @) \nensures rain_postcond (heights @ , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_62/verina_advanced_62.rs", "verified": true, "metadata": {"original_id": "1b76404351aa", "function_name": "rain", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_61718e46195d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  {   result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> 0 <= i < arr1 . len () && 0 <= i < arr2 . len () && result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> 0 <= i < arr1 . len () && 0 <= i < arr2 . len () && result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "61718e46195d", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d5c0fce34468", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; }   result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } assert (i == arr . len ()) ; assert (result @ . len () == 2 * i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "d5c0fce34468", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d57034d96cd2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2u32 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i, n + 1 - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d57034d96cd2", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0293a6a52a0f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0293a6a52a0f", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a92430013a68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 \nensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_32/verina_advanced_32_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a92430013a68", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_39275a900717", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_concat (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; }   let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; }   result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () + b . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , forall | i : int | 0 <= i && i < b . len () ==> result [i + a . len ()] == b [i] \ndecreases a . len () - i, b . len () - j\ninvariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k && k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k && k < j ==> result [k + a . len ()] == b [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_concat (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () + b . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , forall | i : int | 0 <= i && i < b . len () ==> result [i + a . len ()] == b [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } assert (i == a . len () && result . len () == i) ; assert (result . len () == a . len ()) ; let mut j = 0 ; while j < b . len () invariant 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k && k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k && k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } assert (j == b . len () && result . len () == a . len () + j) ; assert (result . len () == a . len () + b . len ()) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_concat_impl.rs", "verified": true, "metadata": {"original_id": "39275a900717", "function_name": "array_concat", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7e5f64e44c35", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s4lif_impl.rs", "verified": true, "metadata": {"original_id": "7e5f64e44c35", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_78f6202829cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32) requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_7/verina_advanced_7.rs", "verified": true, "metadata": {"original_id": "78f6202829cb", "function_name": "binary_to_decimal", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_float_b1049369b4ac", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nuse vstd::std_specs::ops::AddSpec;\nuse vstd::float::FloatBitsProperties;\n\n/*\nVerus deliberately omits axioms about floating point from vstd,\nbecause the desired set of useful and sound axioms may vary by project and platform.\n(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details\nabout why Rust floating point semantics are complex, may be non-deterministic, and may fall short\nof desired behavior on some platforms.)\nTherefore, projects that want to prove properties of about floating-point numbers may want\nto define their own axioms, or even define different groups of axioms for different situations.\n\nFor example, one useful axiom is that it is always safe to add any two floats\n(this assumes that the platform is correctly configured not to trap on a NaN result,\nwhich should usually be true):\n*/\n\npub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)\n     {\n    f64_add_positive_spec,\n    f64_add_positive_exec,\n    f64_add_positive_ensures,\n}\n\nfn main() {\n    broadcast use f64_add_positive;\n    let a: f64 = 3.1;\n    let b: f64 = 2.8;\n    let c = a + b;\n    let d = b + c;\n    let e = c + d;\n\n    // This would fail the !b.is_sign_negative_spec() precondition:\n    // let f = e + (-0.7);\n\n    // But if we use the more permissive axiom, then we can add a negative number\n    // (albeit with no guarantee about the result):\n    broadcast use f64_can_add_anything;\n    let f = e + (-0.7);\n}\n\n} // verus!\n", "target_text": "requires !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(), !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(), !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec()\nensures #[trigger] a.add_req(b);\n\n/*\nThe axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to\nconstruct positive infinity, to add large negative numbers to construct negative infinity,\nand then add negative infinity to positive infinity to construct a NaN.\nAs an example of verifying something slightly nontrivial,\nthe axioms below only permit addition of positive numbers,\nand guarantee non-NaN results.\n*/\n\npub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #![trigger a.add_spec(b)]\n        !a.add_spec(b).is_nan_spec(),\n        !a.add_spec(b).is_sign_negative_spec();\n\npub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] a.add_req(b);\n\nuse vstd::std_specs::ops::add_ensures;\n\npub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);\n\npub broadcast group f64_add_positive", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nuse vstd::std_specs::ops::AddSpec;\nuse vstd::float::FloatBitsProperties;\n\n/*\nVerus deliberately omits axioms about floating point from vstd,\nbecause the desired set of useful and sound axioms may vary by project and platform.\n(See https://github.com/rust-lang/rfcs/blob/master/text/3514-float-semantics.md for details\nabout why Rust floating point semantics are complex, may be non-deterministic, and may fall short\nof desired behavior on some platforms.)\nTherefore, projects that want to prove properties of about floating-point numbers may want\nto define their own axioms, or even define different groups of axioms for different situations.\n\nFor example, one useful axiom is that it is always safe to add any two floats\n(this assumes that the platform is correctly configured not to trap on a NaN result,\nwhich should usually be true):\n*/\n\npub broadcast axiom fn f64_can_add_anything(a: f64, b: f64)\n    ensures\n        #[trigger] a.add_req(b);\n\n/*\nThe axiom above doesn't guarantee non-NaN results -- it's possible to add large positive numbers to\nconstruct positive infinity, to add large negative numbers to construct negative infinity,\nand then add negative infinity to positive infinity to construct a NaN.\nAs an example of verifying something slightly nontrivial,\nthe axioms below only permit addition of positive numbers,\nand guarantee non-NaN results.\n*/\n\npub broadcast axiom fn f64_add_positive_spec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #![trigger a.add_spec(b)]\n        !a.add_spec(b).is_nan_spec(),\n        !a.add_spec(b).is_sign_negative_spec();\n\npub broadcast axiom fn f64_add_positive_exec(a: f64, b: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] a.add_req(b);\n\nuse vstd::std_specs::ops::add_ensures;\n\npub broadcast axiom fn f64_add_positive_ensures(a: f64, b: f64, o: f64)\n    requires\n        !a.is_nan_spec(),\n        !b.is_nan_spec(),\n        !a.is_sign_negative_spec(),\n        !b.is_sign_negative_spec(),\n    ensures\n        #[trigger] add_ensures::<f64>(a, b, o) ==> o == a.add_spec(b);\n\npub broadcast group f64_add_positive {\n    f64_add_positive_spec,\n    f64_add_positive_exec,\n    f64_add_positive_ensures,\n}\n\nfn main() {\n    broadcast use f64_add_positive;\n    let a: f64 = 3.1;\n    let b: f64 = 2.8;\n    let c = a + b;\n    let d = b + c;\n    let e = c + d;\n\n    // This would fail the !b.is_sign_negative_spec() precondition:\n    // let f = e + (-0.7);\n\n    // But if we use the more permissive axiom, then we can add a negative number\n    // (albeit with no guarantee about the result):\n    broadcast use f64_can_add_anything;\n    let f = e + (-0.7);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/float.rs", "verified": true, "metadata": {"original_id": "verus_float_b1049369b4ac", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bfc29391b754", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant result @ == a @ . subrange (0 , i as int) { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_array_append/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "bfc29391b754", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b9a0758d3b36", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/023-strlen_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b9a0758d3b36", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_02491e81b0c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   {  assume (N <= MAX / 3) ; let result = 3 * N ; sum . set (0 , result) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 3 * N , { assert (N > 0) ; assume (N <= MAX / 3) ; let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "02491e81b0c3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e419f4a84550", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >)  { let result = all_digits (& s) ;  }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) , all_digits_precond (s @)\nensures all_digits_postcond (s @ , result) , result == is_digit_spec (c) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "e419f4a84550", "function_name": "all_digits_spec_satisfied", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1783d6bbb230", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "ensures intervals @ . len () == old (intervals) @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "1783d6bbb230", "function_name": "sort_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d8df50f35fcd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "d8df50f35fcd", "function_name": "three_distinct", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1159a858e02d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32)  { if x >= y { x } else { y } }\n\n} // verus!", "target_text": "ensures r >= x && r >= y , r == x || r == y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1159a858e02d", "function_name": "Max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8533df8b482a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "8533df8b482a", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_af85767dbfc9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool)   { let mut i = 0 ; while i < s . len ()  { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "requires s . len () == p . len () \nensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?'\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_match/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "af85767dbfc9", "function_name": "match_strings", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_11233d03a03e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn mul_div_lemma (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_98/verina_basic_98_impl.rs", "verified": true, "metadata": {"original_id": "11233d03a03e", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f8c555db494e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len ()  { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - idx \ninvariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f8c555db494e", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2fc471fcae5d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2fc471fcae5d", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4b926e5d4b5b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a [i] <= max , exists | i : int | 0 <= i < a . len () && a [i] == max \ndecreases a . len () - idx\ninvariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= max , exists | i : int | 0 <= i < a . len () && a [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/035-max-element_impl.rs", "verified": true, "metadata": {"original_id": "4b926e5d4b5b", "function_name": "max_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b97b454af90a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b97b454af90a", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3dfde2018b4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires has_common_element_precond (a @ , b @) \nensures has_common_element_postcond (a @ , b @ , result) \ndecreases a . len () - i, b . len () - j\ninvariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_9/verina_basic_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3dfde2018b4b", "function_name": "has_common_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a30a136e4ced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "a30a136e4ced", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_fcbd6683598a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 {  return true ; } }  false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } proof { assert (forall | k : int | 0 <= k < arr . len () ==> ! is_even (arr [k])) ; assert (! (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k]))) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_804_iter_3_current.rs", "verified": true, "metadata": {"original_id": "fcbd6683598a", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e978678edf95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires merge_intervals_precond (intervals @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_47/verina_advanced_47_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e978678edf95", "function_name": "merge_intervals", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e6a4215bddf9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 . len () - idx\ninvariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "e6a4215bddf9", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_40cc415a26b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "40cc415a26b9", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d1cc4b8cf2ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_43/verina_basic_43_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d1cc4b8cf2ab", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2212a3b25224", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_13/verina_advanced_13.rs", "verified": true, "metadata": {"original_id": "2212a3b25224", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_external_68f8d7000c35", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::external_body]\nfn test(n: u64, s: Ghost<int>)\n\n{\n    println!(\"hello {}\", n);\n}\n\nfn main() {\n    test(15, Ghost(200));\n}\n\n} // verus!\n", "target_text": "requires n > 10 && s@ >= n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::external_body]\nfn test(n: u64, s: Ghost<int>)\n    requires\n        n > 10 && s@ >= n,\n{\n    println!(\"hello {}\", n);\n}\n\nfn main() {\n    test(15, Ghost(200));\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/external.rs", "verified": true, "metadata": {"original_id": "verus_external_68f8d7000c35", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3dbb5ee1f5b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires task_code_precond (sequence @ . map (| i , x | x as int))\nensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int)))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_75/verina_advanced_75.rs", "verified": true, "metadata": {"original_id": "3dbb5ee1f5b2", "function_name": "task_code", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_249ab2dbe1ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >)  { let result = all_digits (& s) ;  }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) , all_digits_precond (s @)\nensures all_digits_postcond (s @ , result) , result == is_digit_spec (c) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "249ab2dbe1ae", "function_name": "all_digits_spec_satisfied", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ce22f878b9ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - i\ninvariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/max_array_impl.rs", "verified": true, "metadata": {"original_id": "ce22f878b9ff", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ca639623ac23", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >)   { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "requires a . len () <= 100 \nensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] \ndecreases a . len () - i \ninvariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "ca639623ac23", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab3a4ad53cd7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool)  { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == is_lower_case (c), str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == inner_expr_to_uppercase (str1 , j) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == inner_expr_to_uppercase (str1 , j) , decreases str1 . len () - i { let c = str1 [i] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "ab3a4ad53cd7", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c53516632300", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "c53516632300", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e2a5bbc51457", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires unique_product_precond (arr)\nensures true", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_20/verina_basic_20_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e2a5bbc51457", "function_name": "unique_product", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6b8d18615516", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6b8d18615516", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b043bc89f63d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >)  { return None ; }\n\n} // verus!", "target_text": "requires two_sum_precond (nums @ , target)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >) requires two_sum_precond (nums @ , target) { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b043bc89f63d", "function_name": "two_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_23bdb60d18e6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {   let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "23bdb60d18e6", "function_name": "element_wise_subtract", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_394efe356e29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >)   { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len ()  { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "target_text": "requires find_smallest_precond (s @) \nensures find_smallest_postcond (s @ , result) \ndecreases s . len () - i \ninvariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_2/verina_basic_2_impl.rs", "verified": true, "metadata": {"original_id": "394efe356e29", "function_name": "find_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_266020011d8c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires move_zeros_to_end_precond (arr @) \nensures move_zeros_to_end_postcond (arr @ , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_35/verina_basic_35.rs", "verified": true, "metadata": {"original_id": "266020011d8c", "function_name": "move_zeros_to_end", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2535a7a08192", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool)  { (c == ' ') || (c == ',') || (c == '.') }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_732_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2535a7a08192", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_016fa353e019", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "016fa353e019", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_13e1a7296621", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,)  { }\n\n} // verus!", "target_text": "requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,) requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "13e1a7296621", "function_name": "create_all_state", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b47a9c6ddaa0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/brs3_impl.rs", "verified": true, "metadata": {"original_id": "b47a9c6ddaa0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6ed1fc050ed6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_precond (xs @) , xs . len () <= 100", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_precond (xs : Seq < i32 >) -> bool { true }\nfn max_subarray_sum (xs : Vec < i32 >) -> (result : i32) requires max_subarray_sum_precond (xs @) , xs . len () <= 100 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_45/verina_advanced_45.rs", "verified": true, "metadata": {"original_id": "6ed1fc050ed6", "function_name": "max_subarray_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3d022f7329ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_is_even/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "3d022f7329ca", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_431a8a863243", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_array (list : & Vec < i32 > , l : usize) -> (new_list : (Vec < i32 > , Vec < i32 >))   { let mut first_part : Vec < i32 > = Vec :: new () ; let mut second_part : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < l  { first_part . push (list [i]) ; i += 1 ; } let mut j = l ; while j < list . len ()  { second_part . push (list [j]) ; j += 1 ; } (first_part , second_part) }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < l < list @ . len () \nensures new_list . 0 @ == list @ . subrange (0 , l as int) , new_list . 1 @ == list @ . subrange (l as int , list . len () as int) \ndecreases l - i , list . len () - j \ninvariant 0 <= i <= l , l < list . len () , first_part @ == list @ . subrange (0 , i as int) , l <= j <= list . len () , first_part @ == list @ . subrange (0 , l as int) , second_part @ == list @ . subrange (l as int , j as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_array (list : & Vec < i32 > , l : usize) -> (new_list : (Vec < i32 > , Vec < i32 >)) requires list @ . len () > 0 , 0 < l < list @ . len () , ensures new_list . 0 @ == list @ . subrange (0 , l as int) , new_list . 1 @ == list @ . subrange (l as int , list . len () as int) , { let mut first_part : Vec < i32 > = Vec :: new () ; let mut second_part : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < l invariant 0 <= i <= l , l < list . len () , first_part @ == list @ . subrange (0 , i as int) , decreases l - i , { first_part . push (list [i]) ; i += 1 ; } let mut j = l ; while j < list . len () invariant l <= j <= list . len () , first_part @ == list @ . subrange (0 , l as int) , second_part @ == list @ . subrange (l as int , j as int) , decreases list . len () - j , { second_part . push (list [j]) ; j += 1 ; } (first_part , second_part) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_262_iter_2_current.rs", "verified": true, "metadata": {"original_id": "431a8a863243", "function_name": "split_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_43da0f8981d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures single_digit_number_to_char (n as nat) == output ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_impl.rs", "verified": true, "metadata": {"original_id": "43da0f8981d4", "function_name": "single_digit_number_to_char_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_35da7764037c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "35da7764037c", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dc7f79589a5a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut j = 1 ; while j < lists . len ()  { if lists [j] . len () < min_length { min_length = lists [j] . len () ; } j += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - j\ninvariant 0 < j <= lists . len () , exists | i : int | # ! [auto] 0 <= i < j && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < j ==> min_length <= lists [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut j = 1 ; while j < lists . len () invariant 0 < j <= lists . len () , exists | i : int | # ! [auto] 0 <= i < j && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < j ==> min_length <= lists [i] . len () , decreases lists . len () - j { if lists [j] . len () < min_length { min_length = lists [j] . len () ; } j += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "dc7f79589a5a", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1114468138b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ;    let mut i = 0 ; while i < k - 1  {   new_list . push (list [i]) ; i += 1 ; }   let mut j = k ; while j < list . len ()  {  new_list . push (list [j]) ; j += 1 ; }   new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases k - 1 - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "1114468138b6", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a7bc3cc60e7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] == element , decreases arr . len () - i { if arr [i] != element { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_284_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a7bc3cc60e7a", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_827177e88870", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "827177e88870", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a90c9d0156e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a90c9d0156e8", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9b9b793d3774", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right  { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "target_text": "requires old (v) . len () > 0\ndecreases (right + 1) - left\ninvariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9b9b793d3774", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_13e059beed7d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "13e059beed7d", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_39c13a2bda84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right  { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "target_text": "requires old (v) . len () > 0\ndecreases (right + 1) - left\ninvariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { let mut left = 0 ; let mut right = v . len () - 1 ; while left <= right invariant left <= v . len () , right < v . len () , forall | i : int | 0 <= i < left ==> v [i] < 0 , forall | i : int | (right as int) < i < v . len () ==> v [i] >= 0 , decreases (right + 1) - left { if v [left] < 0 { left += 1 ; } else if v [right] >= 0 { if right == 0 { break ; } right -= 1 ; } else { let temp = v [left] ; let right_val = v [right] ; v . set (left , right_val) ; v . set (right , temp) ; left += 1 ; if right == 0 { break ; } right -= 1 ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "39c13a2bda84", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_edc096b52552", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "edc096b52552", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_atomics_4df37194f547", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n         {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n\n{\n    loop\n\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n\n        g = proof_int(g | 23);\n\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "target_text": "requires lock.well_formed()\nensures x == y\ninvariant on field with () is (b: bool, t: Option<T>), lock.well_formed()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/atomics.rs", "verified": true, "metadata": {"original_id": "verus_atomics_4df37194f547", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ba32384a2ed3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_103/verina_basic_103_impl.rs", "verified": true, "metadata": {"original_id": "ba32384a2ed3", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_420bab83e5fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "420bab83e5fd", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6bb69aafc424", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs2_impl.rs", "verified": true, "metadata": {"original_id": "6bb69aafc424", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_82327a98dd41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j\ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "82327a98dd41", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1dd60f4ecab1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/indp2_impl.rs", "verified": true, "metadata": {"original_id": "1dd60f4ecab1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8aff1efd6dcd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8aff1efd6dcd", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d53a7edef4d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool)   { let result = n % 11 == 0 ; if result {  } else { proof {  } } } result }\n\n} // verus!", "target_text": "requires is_divisible_by_11_precond (n as int)\nensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d53a7edef4d3", "function_name": "is_divisible_by_11", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f92e08d18d67", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires difference_min_max_precond (a)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32) requires difference_min_max_precond (a) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_23/verina_basic_23_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f92e08d18d67", "function_name": "difference_min_max", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_71ab3bafa13f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "71ab3bafa13f", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ca87cb45cbfd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int)  {  lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int)   { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires n % 3 == 0, triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, n / 3 * 3 == n, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ca87cb45cbfd", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fd7da980e49e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_array (list : & Vec < i32 > , l : usize) -> (new_list : (Vec < i32 > , Vec < i32 >))   { let mut first_part : Vec < i32 > = Vec :: new () ; let mut second_part : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < l  { first_part . push (list [i]) ; i += 1 ; } let mut j = l ; while j < list . len ()  { second_part . push (list [j]) ; j += 1 ; } (first_part , second_part) }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < l < list @ . len () \nensures new_list . 0 @ == list @ . subrange (0 , l as int) , new_list . 1 @ == list @ . subrange (l as int , list . len () as int) \ndecreases l - i , list . len () - j \ninvariant 0 <= i <= l , l < list . len () , first_part @ == list @ . subrange (0 , i as int) , l <= j <= list . len () , first_part @ == list @ . subrange (0 , l as int) , second_part @ == list @ . subrange (l as int , j as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_array (list : & Vec < i32 > , l : usize) -> (new_list : (Vec < i32 > , Vec < i32 >)) requires list @ . len () > 0 , 0 < l < list @ . len () , ensures new_list . 0 @ == list @ . subrange (0 , l as int) , new_list . 1 @ == list @ . subrange (l as int , list . len () as int) , { let mut first_part : Vec < i32 > = Vec :: new () ; let mut second_part : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < l invariant 0 <= i <= l , l < list . len () , first_part @ == list @ . subrange (0 , i as int) , decreases l - i , { first_part . push (list [i]) ; i += 1 ; } let mut j = l ; while j < list . len () invariant l <= j <= list . len () , first_part @ == list @ . subrange (0 , l as int) , second_part @ == list @ . subrange (l as int , j as int) , decreases list . len () - j , { second_part . push (list [j]) ; j += 1 ; } (first_part , second_part) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_262_impl.rs", "verified": true, "metadata": {"original_id": "fd7da980e49e", "function_name": "split_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8f95f3ae8106", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f95f3ae8106", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_447ea6b32677", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_0_original.rs", "verified": true, "metadata": {"original_id": "447ea6b32677", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_09c4848addaa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "09c4848addaa", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6b44abd3d637", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "6b44abd3d637", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_146b12691683", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "146b12691683", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1abcb777eff1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "1abcb777eff1", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8b9a3246ecde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8b9a3246ecde", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0f4c0cc4a2d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_c) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_c) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "0f4c0cc4a2d0", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_77dfdf9cd7e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "77dfdf9cd7e5", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c1a4cd78e84c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires set_to_seq_precond (s @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >) requires set_to_seq_precond (s @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_89/verina_basic_89.rs", "verified": true, "metadata": {"original_id": "c1a4cd78e84c", "function_name": "set_to_seq", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e4f92ff67020", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_100/verina_basic_100_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "e4f92ff67020", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_48576af6ea0f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "48576af6ea0f", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6a8a144ff39a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/conda_impl.rs", "verified": true, "metadata": {"original_id": "6a8a144ff39a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4ad593736dd5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple3/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4ad593736dd5", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_recursive_types_c0ef99fd2fbd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n\n    // from the definition of f1:\n\n    // taken together:\n\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus  { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    {\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus  {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B>, that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A>\nensures false\ndecreases clauses of recursive specifications and recursive proofs:\nenum List<A>, list  // decreases can be used on values of type List<A> ", "full_verified_code": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursive_types.rs", "verified": true, "metadata": {"original_id": "verus_recursive_types_c0ef99fd2fbd", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b939d6e5c826", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b939d6e5c826", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c86d2afd7c0f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] - arr2 [k]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] - arr2 [k]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_273_impl.rs", "verified": true, "metadata": {"original_id": "c86d2afd7c0f", "function_name": "element_wise_subtract", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c51551a2d340", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "c51551a2d340", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_330f47acf34f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n \ndecreases fuel ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_28/verina_basic_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "330f47acf34f", "function_name": "is_prime_check", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_98978204de78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "98978204de78", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b2f748cf906b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b2f748cf906b", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1f888cc7a809", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "1f888cc7a809", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_61406431865f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { for i in 0 .. arr . len ()  { if arr [i] % 2 != 0 {   return Some (i) ; } } None }\n\n} // verus!", "target_text": "ensures check_find_first_odd (arr , index) \ninvariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0) { if arr [i] % 2 != 0 { assert (forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)) ; assert (arr [i as int] % 2 != 0) ; return Some (i) ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "61406431865f", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a7b74e361717", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires if_power_of_four_precond (n as nat)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_14/verina_advanced_14.rs", "verified": true, "metadata": {"original_id": "a7b74e361717", "function_name": "if_power_of_four", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d1551cc54ff0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "d1551cc54ff0", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fab9edac65d1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "fab9edac65d1", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_af1a74651a1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] != element { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] == element", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "af1a74651a1a", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_c04ba5c8f4b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - i \ninvariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/max_array_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c04ba5c8f4b4", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f4b0c9cb2904", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "f4b0c9cb2904", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ee669c579ff9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1)  {  result . push (first [i]) ; } for i in 0 .. second . len ()  {  result . push (second [i]) ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { assert (i < first . len ()) ; result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { assert (i < second . len ()) ; result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "ee669c579ff9", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9d367969c578", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "9d367969c578", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a5d8372bdaa4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a5d8372bdaa4", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b5dcdc870050", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len ()\nensures result <= nums . len (), result <= nums . len () decreases nums . len () - idx\ndecreases nums . len () - idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_30/verina_advanced_30.rs", "verified": true, "metadata": {"original_id": "b5dcdc870050", "function_name": "longest_increasing_streak_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_24e999cabe6c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "ensures result == odd (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "24e999cabe6c", "function_name": "odd_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9b7d9443feb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9b7d9443feb8", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_da09a0287ddd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "da09a0287ddd", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f9f0d54eaeb2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/cal_div_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f9f0d54eaeb2", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_result_d00d0a51788b", "task": "task_a", "input_text": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "target_text": "requires x < 100000\nensures y > x", "full_verified_code": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n        ensures\n            y > x,\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/std_test/result.rs", "verified": true, "metadata": {"original_id": "verus_result_d00d0a51788b", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_36d1bbda1893", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "36d1bbda1893", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0290c493c3b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; let value = 2 * N + 1 ; while i < N  { a . set (i as usize , value) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , N <= MAX / 2 - 1 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 2 * N + 1 \ndecreases N - i\ninvariant 0 <= i <= N , a . len () == N , value == 2 * N + 1 , forall | k : int | 0 <= k < i ==> a [k as int] == value ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 2 - 1 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 2 * N + 1 , { let mut i = 0 ; let value = 2 * N + 1 ; while i < N invariant 0 <= i <= N , a . len () == N , value == 2 * N + 1 , forall | k : int | 0 <= k < i ==> a [k as int] == value , decreases N - i { a . set (i as usize , value) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina5_impl.rs", "verified": true, "metadata": {"original_id": "0290c493c3b1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6c95fc43cfca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if left < a . len () && ! a [left] { left += 1 ; } else if right > 0 && a [right - 1] { right -= 1 ; } else if left < right - 1 { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } else { break ; } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if left < a . len () && ! a [left] { left += 1 ; } else if right > 0 && a [right - 1] { right -= 1 ; } else if left < right - 1 { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } else { break ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "6c95fc43cfca", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_397895aeaa52", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1\nensures result >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "397895aeaa52", "function_name": "max_coverage_after_removing_one", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d16222322744", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: print_u64 ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum (a : Seq < int > , i : int , j : int) -> int { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)   { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)   {  c [j] - c [i] }\n\n} // verus!", "target_text": "requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c), a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 \nensures sum (a , i , j) == c [j] - c [i], r == sum (seq_to_int (a @) , i as int , j as int), sum (a , i , j) == c [j] - c [i] decreases j - i\ndecreases j - i, j - i", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: pervasive :: print_u64 ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-handout1_tmp_tmptm52no3k_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "d16222322744", "function_name": "query_fast", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_402d55fb00aa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "ensures if let Some (idx) = index\ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 != 0 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () as int ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_807_iter_4_current.rs", "verified": true, "metadata": {"original_id": "402d55fb00aa", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2d5dd977bed4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2d5dd977bed4", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f10934436d39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_element_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f10934436d39", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7b159930815e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. list1 . len ()  { for j in 0 .. list2 . len ()  { if list1 [i] == list2 [j] { return true ; } } }  false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) \ninvariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , i < list1 . len () , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , { for j in 0 .. list2 . len () invariant i < list1 . len () , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if list1 [i] == list2 [j] { return true ; } } } assert (forall | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj]) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "7b159930815e", "function_name": "has_common_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2be32770d437", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "2be32770d437", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2eace5cd4634", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] % 2 != 0 {  return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "requires find_first_odd_precond (a)\nensures find_first_odd_postcond (a , result)\ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { proof { assert (is_odd (a [i as int] as int)) ; } return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_49/verina_basic_49_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2eace5cd4634", "function_name": "find_first_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_575b6114c039", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "575b6114c039", "function_name": "bubbleSorta", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_41cbaa48a2de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "41cbaa48a2de", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ad9b6ac885ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/060-sum_to_n_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ad9b6ac885ca", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6c04be9b8443", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6c04be9b8443", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_df8542f593af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_82/verina_basic_82_impl.rs", "verified": true, "metadata": {"original_id": "df8542f593af", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_aa069d0f8570", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subseq_length_precond (xs @) \nensures longest_increasing_subseq_length_postcond (xs @ , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_31/verina_advanced_31.rs", "verified": true, "metadata": {"original_id": "aa069d0f8570", "function_name": "longest_increasing_subseq_length", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3dc4bbd654da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let target_value = 2 * N + 1 ; let mut i = 0 ; while i < N  { a . set (i as usize , target_value) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> a [k] == 2 * N + 1 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , target_value == 2 * N + 1 , forall | k : int | 0 <= k < i ==> a [k] == 2 * N + 1 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == 2 * N + 1 , { let target_value = 2 * N + 1 ; let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , target_value == 2 * N + 1 , forall | k : int | 0 <= k < i ==> a [k] == 2 * N + 1 , decreases N - i , { a . set (i as usize , target_value) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/sina5_impl.rs", "verified": true, "metadata": {"original_id": "3dc4bbd654da", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_vostd_extra_num_4ccd47badacd", "task": "task_a", "input_text": "use vstd::arithmetic::logarithm::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::layout::is_power_2;\nuse vstd::prelude::*;\n\nverus! {\n\npub broadcast proof fn lemma_pow2_log2(e: nat)\n\n{\n    lemma_pow2(e);\n    lemma_log_pow(2, e);\n}\n\npub broadcast proof fn lemma_pow2_increases(e1: nat, e2: nat)\n\n{\n    if e1 < e2 {\n        lemma_pow2_strictly_increases(e1, e2);\n    } else if e1 == e2 {\n\n    }\n}\n\npub broadcast proof fn lemma_pow2_is_power2(e: nat)\n\n    {\n    if e == 0 {\n\n        };\n\n    } else {\n        lemma_pow2_is_power2((e - 1) as nat);\n        let p = pow2((e - 1) as nat) as int;\n\n        };\n\n    }\n}\n\npub proof fn lemma_is_power2_exists_pow2(e: nat)\n\n    {\n    if e == 0 {\n    } else if e == 1 {\n\n        };\n    } else {\n        lemma_is_power2_exists_pow2(e / 2);\n        let n = choose|n: nat| pow2(n) == e / 2;\n\n        }\n    }\n}\n\npub proof fn lemma2_to64_hi32()\n\n{\n    lemma2_to64();\n    reveal(pow2);\n    reveal(pow);\n    #[verusfmt::skip]\n\n}\n\npub proof fn lemma_pow2_is_power2_to64()\n\n{\n    lemma2_to64();\n    lemma2_to64_hi32();\n    lemma_pow2_is_power2(0);\n    lemma_pow2_is_power2(1);\n    lemma_pow2_is_power2(2);\n    lemma_pow2_is_power2(3);\n    lemma_pow2_is_power2(4);\n    lemma_pow2_is_power2(5);\n    lemma_pow2_is_power2(6);\n    lemma_pow2_is_power2(7);\n    lemma_pow2_is_power2(8);\n    lemma_pow2_is_power2(9);\n    lemma_pow2_is_power2(10);\n    lemma_pow2_is_power2(11);\n    lemma_pow2_is_power2(12);\n    lemma_pow2_is_power2(13);\n    lemma_pow2_is_power2(14);\n    lemma_pow2_is_power2(15);\n    lemma_pow2_is_power2(16);\n    lemma_pow2_is_power2(17);\n    lemma_pow2_is_power2(18);\n    lemma_pow2_is_power2(19);\n    lemma_pow2_is_power2(20);\n    lemma_pow2_is_power2(21);\n    lemma_pow2_is_power2(22);\n    lemma_pow2_is_power2(23);\n    lemma_pow2_is_power2(24);\n    lemma_pow2_is_power2(25);\n    lemma_pow2_is_power2(26);\n    lemma_pow2_is_power2(27);\n    lemma_pow2_is_power2(28);\n    lemma_pow2_is_power2(29);\n    lemma_pow2_is_power2(30);\n    lemma_pow2_is_power2(31);\n    lemma_pow2_is_power2(32);\n    lemma_pow2_is_power2(33);\n    lemma_pow2_is_power2(34);\n    lemma_pow2_is_power2(35);\n    lemma_pow2_is_power2(36);\n    lemma_pow2_is_power2(37);\n    lemma_pow2_is_power2(38);\n    lemma_pow2_is_power2(39);\n    lemma_pow2_is_power2(40);\n    lemma_pow2_is_power2(41);\n    lemma_pow2_is_power2(42);\n    lemma_pow2_is_power2(43);\n    lemma_pow2_is_power2(44);\n    lemma_pow2_is_power2(45);\n    lemma_pow2_is_power2(46);\n    lemma_pow2_is_power2(47);\n    lemma_pow2_is_power2(48);\n    lemma_pow2_is_power2(49);\n    lemma_pow2_is_power2(50);\n    lemma_pow2_is_power2(51);\n    lemma_pow2_is_power2(52);\n    lemma_pow2_is_power2(53);\n    lemma_pow2_is_power2(54);\n    lemma_pow2_is_power2(55);\n    lemma_pow2_is_power2(56);\n    lemma_pow2_is_power2(57);\n    lemma_pow2_is_power2(58);\n    lemma_pow2_is_power2(59);\n    lemma_pow2_is_power2(60);\n    lemma_pow2_is_power2(61);\n    lemma_pow2_is_power2(62);\n    lemma_pow2_is_power2(63);\n    lemma_pow2_is_power2(64);\n}\n\npub proof fn lemma_log2_to64()\n\n{\n    lemma2_to64();\n    lemma2_to64_hi32();\n    lemma_pow2_log2(0);\n    lemma_pow2_log2(1);\n    lemma_pow2_log2(2);\n    lemma_pow2_log2(3);\n    lemma_pow2_log2(4);\n    lemma_pow2_log2(5);\n    lemma_pow2_log2(6);\n    lemma_pow2_log2(7);\n    lemma_pow2_log2(8);\n    lemma_pow2_log2(9);\n    lemma_pow2_log2(10);\n    lemma_pow2_log2(11);\n    lemma_pow2_log2(12);\n    lemma_pow2_log2(13);\n    lemma_pow2_log2(14);\n    lemma_pow2_log2(15);\n    lemma_pow2_log2(16);\n    lemma_pow2_log2(17);\n    lemma_pow2_log2(18);\n    lemma_pow2_log2(19);\n    lemma_pow2_log2(20);\n    lemma_pow2_log2(21);\n    lemma_pow2_log2(22);\n    lemma_pow2_log2(23);\n    lemma_pow2_log2(24);\n    lemma_pow2_log2(25);\n    lemma_pow2_log2(26);\n    lemma_pow2_log2(27);\n    lemma_pow2_log2(28);\n    lemma_pow2_log2(29);\n    lemma_pow2_log2(30);\n    lemma_pow2_log2(31);\n    lemma_pow2_log2(32);\n    lemma_pow2_log2(33);\n    lemma_pow2_log2(34);\n    lemma_pow2_log2(35);\n    lemma_pow2_log2(36);\n    lemma_pow2_log2(37);\n    lemma_pow2_log2(38);\n    lemma_pow2_log2(39);\n    lemma_pow2_log2(40);\n    lemma_pow2_log2(41);\n    lemma_pow2_log2(42);\n    lemma_pow2_log2(43);\n    lemma_pow2_log2(44);\n    lemma_pow2_log2(45);\n    lemma_pow2_log2(46);\n    lemma_pow2_log2(47);\n    lemma_pow2_log2(48);\n    lemma_pow2_log2(49);\n    lemma_pow2_log2(50);\n    lemma_pow2_log2(51);\n    lemma_pow2_log2(52);\n    lemma_pow2_log2(53);\n    lemma_pow2_log2(54);\n    lemma_pow2_log2(55);\n    lemma_pow2_log2(56);\n    lemma_pow2_log2(57);\n    lemma_pow2_log2(58);\n    lemma_pow2_log2(59);\n    lemma_pow2_log2(60);\n    lemma_pow2_log2(61);\n    lemma_pow2_log2(62);\n    lemma_pow2_log2(63);\n    lemma_pow2_log2(64);\n}\n\n} // verus!\nmacro_rules! impl_external_ilog2 {\n    ($uN: ty, $spec_name: ident,\n    $pow2_lemma: ident, $pow2_ilog2_lemma: ident,\n    $log2_bounds_lemma: ident, $ilog2_ordered_lemma: ident, $is_power_2_is_ilog2_pow2_lemma: ident $(,)?) => {\n        verus! {\n            #[verifier::inline]\n            pub open spec fn $spec_name(x: $uN) -> u32\n            {\n                log(2, x as int) as u32\n            }\n\n            #[verifier::when_used_as_spec($spec_name)]\n            pub assume_specification[$uN::ilog2](x:$uN) -> u32\n\n            {\n                lemma_pow2_log2(e as nat);\n            }\n\n            pub broadcast proof fn $pow2_ilog2_lemma(e: u32)\n\n            {\n                $pow2_lemma(e, pow2(e as nat) as $uN);\n            }\n\n            pub proof fn $log2_bounds_lemma(x: $uN)\n\n            {\n                lemma_log_nonnegative(2, x as int);\n\n                };\n\n                };\n\n                };\n            }\n\n            pub proof fn $ilog2_ordered_lemma(x: $uN, y: $uN)\n\n            {\n                $log2_bounds_lemma(x);\n                $log2_bounds_lemma(y);\n                lemma_log_is_ordered(2, x as int, y as int);\n            }\n\n            pub broadcast proof fn $is_power_2_is_ilog2_pow2_lemma(x: $uN)\n\n            {\n                lemma_is_power2_exists_pow2(x as nat);\n                let n = choose |n: nat| pow2(n) == x as nat;\n\n                };\n\n                };\n                lemma_pow2(n);\n                lemma_pow2($uN::BITS as nat);\n\n                };\n\n            }\n        }\n    };\n}\n\nimpl_external_ilog2!(\n    u8,\n    u8_ilog2_spec,\n    lemma_u8_pow2_ilog2_x,\n    lemma_u8_pow2_ilog2,\n    lemma_u8_log2_bounds,\n    lemma_u8_ilog2_ordered,\n    lemma_u8_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u16,\n    u16_ilog2_spec,\n    lemma_u16_pow2_ilog2_x,\n    lemma_u16_pow2_ilog2,\n    lemma_u16_log2_bounds,\n    lemma_u16_ilog2_ordered,\n    lemma_u16_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u32,\n    u32_ilog2_spec,\n    lemma_u32_pow2_ilog2_x,\n    lemma_u32_pow2_ilog2,\n    lemma_u32_log2_bounds,\n    lemma_u32_ilog2_ordered,\n    lemma_u32_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    usize,\n    usize_ilog2_spec,\n    lemma_usize_pow2_ilog2_x,\n    lemma_usize_pow2_ilog2,\n    lemma_usize_log2_bounds,\n    lemma_usize_ilog2_ordered,\n    lemma_usize_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u64,\n    u64_ilog2_spec,\n    lemma_u64_pow2_ilog2_x,\n    lemma_u64_pow2_ilog2,\n    lemma_u64_log2_bounds,\n    lemma_u64_ilog2_ordered,\n    lemma_u64_is_power_2_is_ilog2_pow2,\n);\n\nverus! {\n\npub proof fn lemma_u8_ilog2_to8()\n\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u16_ilog2_to16()\n\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u32_ilog2_to32()\n\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_usize_ilog2_to32()\n\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u64_ilog2_to64()\n\n{\n    lemma_log2_to64();\n}\n\npub broadcast proof fn lemma_usize_shl_is_mul(x: usize, shift: usize)\n\n{\n    if usize::BITS == 64 {\n        lemma_u64_shl_is_mul(x as u64, shift as u64);\n    } else if usize::BITS == 32 {\n        lemma_u32_shl_is_mul(x as u32, shift as u32);\n    } else {\n\n    }\n}\n\npub broadcast proof fn lemma_usize_pow2_shl_is_pow2(x: usize, shift: usize)\n\n{\n    lemma_is_power2_exists_pow2(x as nat);\n    let n = choose|n: nat| pow2(n) == x as nat;\n    lemma_usize_shl_is_mul(x, shift);\n\n    lemma_pow2_adds(n, shift as nat);\n\n    lemma_pow2_is_power2(n + shift as nat);\n\n}\n\n} // verus!\n", "target_text": "requires e1 <= e2, is_power_2(e as int), x > 0,\n                returns\n                    log(2, x as int) as u32,\n                opens_invariants none\n                no_unwind;\n\n            pub broadcast proof fn $pow2_lemma(e: u32, x: $uN)\n                requires\n                    #[trigger] pow2(e as nat) == x, pow2(e as nat) <= $uN::MAX, x <= y, #[trigger] is_power_2(x as int), 0 <= shift < usize::BITS,\n        x * pow2(shift as nat) <= usize::MAX, 0 <= shift < usize::BITS,\n        is_power_2(x as int),\n        x * pow2(shift as nat) <= usize::MAX\nensures #[trigger] log(2, pow2(e) as int) == e, #[trigger] pow2(e1) <= #[trigger] pow2(e2), #[trigger] is_power_2(pow2(e) as int), exists|n: nat| pow2(n) == e, pow2(33) == 0x200000000,\n        pow2(34) == 0x400000000,\n        pow2(35) == 0x800000000,\n        pow2(36) == 0x1000000000,\n        pow2(37) == 0x2000000000,\n        pow2(38) == 0x4000000000,\n        pow2(39) == 0x8000000000,\n        pow2(40) == 0x10000000000,\n        pow2(41) == 0x20000000000,\n        pow2(42) == 0x40000000000,\n        pow2(43) == 0x80000000000,\n        pow2(44) == 0x100000000000,\n        pow2(45) == 0x200000000000,\n        pow2(46) == 0x400000000000,\n        pow2(47) == 0x800000000000,\n        pow2(48) == 0x1000000000000,\n        pow2(49) == 0x2000000000000,\n        pow2(50) == 0x4000000000000,\n        pow2(51) == 0x8000000000000,\n        pow2(52) == 0x10000000000000,\n        pow2(53) == 0x20000000000000,\n        pow2(54) == 0x40000000000000,\n        pow2(55) == 0x80000000000000,\n        pow2(56) == 0x100000000000000,\n        pow2(57) == 0x200000000000000,\n        pow2(58) == 0x400000000000000,\n        pow2(59) == 0x800000000000000,\n        pow2(60) == 0x1000000000000000,\n        pow2(61) == 0x2000000000000000,\n        pow2(62) == 0x4000000000000000,\n        pow2(63) == 0x8000000000000000,\n        pow2(64) == 0x10000000000000000, is_power_2(0x1),\n        is_power_2(0x2),\n        is_power_2(0x4),\n        is_power_2(0x8),\n        is_power_2(0x10),\n        is_power_2(0x20),\n        is_power_2(0x40),\n        is_power_2(0x80),\n        is_power_2(0x100),\n        is_power_2(0x200),\n        is_power_2(0x400),\n        is_power_2(0x800),\n        is_power_2(0x1000),\n        is_power_2(0x2000),\n        is_power_2(0x4000),\n        is_power_2(0x8000),\n        is_power_2(0x10000),\n        is_power_2(0x20000),\n        is_power_2(0x40000),\n        is_power_2(0x80000),\n        is_power_2(0x100000),\n        is_power_2(0x200000),\n        is_power_2(0x400000),\n        is_power_2(0x800000),\n        is_power_2(0x1000000),\n        is_power_2(0x2000000),\n        is_power_2(0x4000000),\n        is_power_2(0x8000000),\n        is_power_2(0x10000000),\n        is_power_2(0x20000000),\n        is_power_2(0x40000000),\n        is_power_2(0x80000000),\n        is_power_2(0x100000000),\n        is_power_2(0x200000000),\n        is_power_2(0x400000000),\n        is_power_2(0x800000000),\n        is_power_2(0x1000000000),\n        is_power_2(0x2000000000),\n        is_power_2(0x4000000000),\n        is_power_2(0x8000000000),\n        is_power_2(0x10000000000),\n        is_power_2(0x20000000000),\n        is_power_2(0x40000000000),\n        is_power_2(0x80000000000),\n        is_power_2(0x100000000000),\n        is_power_2(0x200000000000),\n        is_power_2(0x400000000000),\n        is_power_2(0x800000000000),\n        is_power_2(0x1000000000000),\n        is_power_2(0x2000000000000),\n        is_power_2(0x4000000000000),\n        is_power_2(0x8000000000000),\n        is_power_2(0x10000000000000),\n        is_power_2(0x20000000000000),\n        is_power_2(0x40000000000000),\n        is_power_2(0x80000000000000),\n        is_power_2(0x100000000000000),\n        is_power_2(0x200000000000000),\n        is_power_2(0x400000000000000),\n        is_power_2(0x800000000000000),\n        is_power_2(0x1000000000000000),\n        is_power_2(0x2000000000000000),\n        is_power_2(0x4000000000000000),\n        is_power_2(0x8000000000000000),\n        is_power_2(0x10000000000000000), log(2, 0x1) == 0,\n        log(2, 0x2) == 1,\n        log(2, 0x4) == 2,\n        log(2, 0x8) == 3,\n        log(2, 0x10) == 4,\n        log(2, 0x20) == 5,\n        log(2, 0x40) == 6,\n        log(2, 0x80) == 7,\n        log(2, 0x100) == 8,\n        log(2, 0x200) == 9,\n        log(2, 0x400) == 10,\n        log(2, 0x800) == 11,\n        log(2, 0x1000) == 12,\n        log(2, 0x2000) == 13,\n        log(2, 0x4000) == 14,\n        log(2, 0x8000) == 15,\n        log(2, 0x10000) == 16,\n        log(2, 0x20000) == 17,\n        log(2, 0x40000) == 18,\n        log(2, 0x80000) == 19,\n        log(2, 0x100000) == 20,\n        log(2, 0x200000) == 21,\n        log(2, 0x400000) == 22,\n        log(2, 0x800000) == 23,\n        log(2, 0x1000000) == 24,\n        log(2, 0x2000000) == 25,\n        log(2, 0x4000000) == 26,\n        log(2, 0x8000000) == 27,\n        log(2, 0x10000000) == 28,\n        log(2, 0x20000000) == 29,\n        log(2, 0x40000000) == 30,\n        log(2, 0x80000000) == 31,\n        log(2, 0x100000000) == 32,\n        log(2, 0x200000000) == 33,\n        log(2, 0x400000000) == 34,\n        log(2, 0x800000000) == 35,\n        log(2, 0x1000000000) == 36,\n        log(2, 0x2000000000) == 37,\n        log(2, 0x4000000000) == 38,\n        log(2, 0x8000000000) == 39,\n        log(2, 0x10000000000) == 40,\n        log(2, 0x20000000000) == 41,\n        log(2, 0x40000000000) == 42,\n        log(2, 0x80000000000) == 43,\n        log(2, 0x100000000000) == 44,\n        log(2, 0x200000000000) == 45,\n        log(2, 0x400000000000) == 46,\n        log(2, 0x800000000000) == 47,\n        log(2, 0x1000000000000) == 48,\n        log(2, 0x2000000000000) == 49,\n        log(2, 0x4000000000000) == 50,\n        log(2, 0x8000000000000) == 51,\n        log(2, 0x10000000000000) == 52,\n        log(2, 0x20000000000000) == 53,\n        log(2, 0x40000000000000) == 54,\n        log(2, 0x80000000000000) == 55,\n        log(2, 0x100000000000000) == 56,\n        log(2, 0x200000000000000) == 57,\n        log(2, 0x400000000000000) == 58,\n        log(2, 0x800000000000000) == 59,\n        log(2, 0x1000000000000000) == 60,\n        log(2, 0x2000000000000000) == 61,\n        log(2, 0x4000000000000000) == 62,\n        log(2, 0x8000000000000000) == 63,\n        log(2, 0x10000000000000000) == 64, #[trigger] x.ilog2() == e, #[trigger] (pow2(e as nat) as $uN).ilog2() == e, 0 <= log(2, x as int) <= $uN::BITS,\n                    0 <= x.ilog2() <= $uN::BITS, x.ilog2() <= y.ilog2(), x as nat == pow2(x.ilog2() as nat), (0x1 as u8).ilog2() == 0,\n        (0x2 as u8).ilog2() == 1,\n        (0x4 as u8).ilog2() == 2,\n        (0x8 as u8).ilog2() == 3,\n        (0x10 as u8).ilog2() == 4,\n        (0x20 as u8).ilog2() == 5,\n        (0x40 as u8).ilog2() == 6,\n        (0x80 as u8).ilog2() == 7, (0x1 as u16).ilog2() == 0,\n        (0x2 as u16).ilog2() == 1,\n        (0x4 as u16).ilog2() == 2,\n        (0x8 as u16).ilog2() == 3,\n        (0x10 as u16).ilog2() == 4,\n        (0x20 as u16).ilog2() == 5,\n        (0x40 as u16).ilog2() == 6,\n        (0x80 as u16).ilog2() == 7,\n        (0x100 as u16).ilog2() == 8,\n        (0x200 as u16).ilog2() == 9,\n        (0x400 as u16).ilog2() == 10,\n        (0x800 as u16).ilog2() == 11,\n        (0x1000 as u16).ilog2() == 12,\n        (0x2000 as u16).ilog2() == 13,\n        (0x4000 as u16).ilog2() == 14,\n        (0x8000 as u16).ilog2() == 15, (0x1 as u32).ilog2() == 0,\n        (0x2 as u32).ilog2() == 1,\n        (0x4 as u32).ilog2() == 2,\n        (0x8 as u32).ilog2() == 3,\n        (0x10 as u32).ilog2() == 4,\n        (0x20 as u32).ilog2() == 5,\n        (0x40 as u32).ilog2() == 6,\n        (0x80 as u32).ilog2() == 7,\n        (0x100 as u32).ilog2() == 8,\n        (0x200 as u32).ilog2() == 9,\n        (0x400 as u32).ilog2() == 10,\n        (0x800 as u32).ilog2() == 11,\n        (0x1000 as u32).ilog2() == 12,\n        (0x2000 as u32).ilog2() == 13,\n        (0x4000 as u32).ilog2() == 14,\n        (0x8000 as u32).ilog2() == 15,\n        (0x10000 as u32).ilog2() == 16,\n        (0x20000 as u32).ilog2() == 17,\n        (0x40000 as u32).ilog2() == 18,\n        (0x80000 as u32).ilog2() == 19,\n        (0x100000 as u32).ilog2() == 20,\n        (0x200000 as u32).ilog2() == 21,\n        (0x400000 as u32).ilog2() == 22,\n        (0x800000 as u32).ilog2() == 23,\n        (0x1000000 as u32).ilog2() == 24,\n        (0x2000000 as u32).ilog2() == 25,\n        (0x4000000 as u32).ilog2() == 26,\n        (0x8000000 as u32).ilog2() == 27,\n        (0x10000000 as u32).ilog2() == 28,\n        (0x20000000 as u32).ilog2() == 29,\n        (0x40000000 as u32).ilog2() == 30,\n        (0x80000000 as u32).ilog2() == 31, (0x1 as usize).ilog2() == 0,\n        (0x2 as usize).ilog2() == 1,\n        (0x4 as usize).ilog2() == 2,\n        (0x8 as usize).ilog2() == 3,\n        (0x10 as usize).ilog2() == 4,\n        (0x20 as usize).ilog2() == 5,\n        (0x40 as usize).ilog2() == 6,\n        (0x80 as usize).ilog2() == 7,\n        (0x100 as usize).ilog2() == 8,\n        (0x200 as usize).ilog2() == 9,\n        (0x400 as usize).ilog2() == 10,\n        (0x800 as usize).ilog2() == 11,\n        (0x1000 as usize).ilog2() == 12,\n        (0x2000 as usize).ilog2() == 13,\n        (0x4000 as usize).ilog2() == 14,\n        (0x8000 as usize).ilog2() == 15,\n        (0x10000 as usize).ilog2() == 16,\n        (0x20000 as usize).ilog2() == 17,\n        (0x40000 as usize).ilog2() == 18,\n        (0x80000 as usize).ilog2() == 19,\n        (0x100000 as usize).ilog2() == 20,\n        (0x200000 as usize).ilog2() == 21,\n        (0x400000 as usize).ilog2() == 22,\n        (0x800000 as usize).ilog2() == 23,\n        (0x1000000 as usize).ilog2() == 24,\n        (0x2000000 as usize).ilog2() == 25,\n        (0x4000000 as usize).ilog2() == 26,\n        (0x8000000 as usize).ilog2() == 27,\n        (0x10000000 as usize).ilog2() == 28,\n        (0x20000000 as usize).ilog2() == 29,\n        (0x40000000 as usize).ilog2() == 30,\n        (0x80000000 as usize).ilog2() == 31, (0x1 as u64).ilog2() == 0,\n        (0x2 as u64).ilog2() == 1,\n        (0x4 as u64).ilog2() == 2,\n        (0x8 as u64).ilog2() == 3,\n        (0x10 as u64).ilog2() == 4,\n        (0x20 as u64).ilog2() == 5,\n        (0x40 as u64).ilog2() == 6,\n        (0x80 as u64).ilog2() == 7,\n        (0x100 as u64).ilog2() == 8,\n        (0x200 as u64).ilog2() == 9,\n        (0x400 as u64).ilog2() == 10,\n        (0x800 as u64).ilog2() == 11,\n        (0x1000 as u64).ilog2() == 12,\n        (0x2000 as u64).ilog2() == 13,\n        (0x4000 as u64).ilog2() == 14,\n        (0x8000 as u64).ilog2() == 15,\n        (0x10000 as u64).ilog2() == 16,\n        (0x20000 as u64).ilog2() == 17,\n        (0x40000 as u64).ilog2() == 18,\n        (0x80000 as u64).ilog2() == 19,\n        (0x100000 as u64).ilog2() == 20,\n        (0x200000 as u64).ilog2() == 21,\n        (0x400000 as u64).ilog2() == 22,\n        (0x800000 as u64).ilog2() == 23,\n        (0x1000000 as u64).ilog2() == 24,\n        (0x2000000 as u64).ilog2() == 25,\n        (0x4000000 as u64).ilog2() == 26,\n        (0x8000000 as u64).ilog2() == 27,\n        (0x10000000 as u64).ilog2() == 28,\n        (0x20000000 as u64).ilog2() == 29,\n        (0x40000000 as u64).ilog2() == 30,\n        (0x80000000 as u64).ilog2() == 31,\n        (0x100000000 as u64).ilog2() == 32,\n        (0x200000000 as u64).ilog2() == 33,\n        (0x400000000 as u64).ilog2() == 34,\n        (0x800000000 as u64).ilog2() == 35,\n        (0x1000000000 as u64).ilog2() == 36,\n        (0x2000000000 as u64).ilog2() == 37,\n        (0x4000000000 as u64).ilog2() == 38,\n        (0x8000000000 as u64).ilog2() == 39,\n        (0x10000000000 as u64).ilog2() == 40,\n        (0x20000000000 as u64).ilog2() == 41,\n        (0x40000000000 as u64).ilog2() == 42,\n        (0x80000000000 as u64).ilog2() == 43,\n        (0x100000000000 as u64).ilog2() == 44,\n        (0x200000000000 as u64).ilog2() == 45,\n        (0x400000000000 as u64).ilog2() == 46,\n        (0x800000000000 as u64).ilog2() == 47,\n        (0x1000000000000 as u64).ilog2() == 48,\n        (0x2000000000000 as u64).ilog2() == 49,\n        (0x4000000000000 as u64).ilog2() == 50,\n        (0x8000000000000 as u64).ilog2() == 51,\n        (0x10000000000000 as u64).ilog2() == 52,\n        (0x20000000000000 as u64).ilog2() == 53,\n        (0x40000000000000 as u64).ilog2() == 54,\n        (0x80000000000000 as u64).ilog2() == 55,\n        (0x100000000000000 as u64).ilog2() == 56,\n        (0x200000000000000 as u64).ilog2() == 57,\n        (0x400000000000000 as u64).ilog2() == 58,\n        (0x800000000000000 as u64).ilog2() == 59,\n        (0x1000000000000000 as u64).ilog2() == 60,\n        (0x2000000000000000 as u64).ilog2() == 61,\n        (0x4000000000000000 as u64).ilog2() == 62,\n        (0x8000000000000000 as u64).ilog2() == 63, #[trigger] (x << shift) == x * pow2(shift as nat), #[trigger] is_power_2((x << shift) as int), #[trigger] is_power_2(pow2(e) as int),\n    decreases e, exists|n: nat| pow2(n) == e,\n    decreases e\ndecreases e, e", "full_verified_code": "use vstd::arithmetic::logarithm::*;\nuse vstd::arithmetic::power::*;\nuse vstd::arithmetic::power2::*;\nuse vstd::bits::*;\nuse vstd::layout::is_power_2;\nuse vstd::prelude::*;\n\nverus! {\n\npub broadcast proof fn lemma_pow2_log2(e: nat)\n    ensures\n        #[trigger] log(2, pow2(e) as int) == e,\n{\n    lemma_pow2(e);\n    lemma_log_pow(2, e);\n}\n\npub broadcast proof fn lemma_pow2_increases(e1: nat, e2: nat)\n    requires\n        e1 <= e2,\n    ensures\n        #[trigger] pow2(e1) <= #[trigger] pow2(e2),\n{\n    if e1 < e2 {\n        lemma_pow2_strictly_increases(e1, e2);\n    } else if e1 == e2 {\n        assert(pow2(e1) == pow2(e2));\n    }\n}\n\npub broadcast proof fn lemma_pow2_is_power2(e: nat)\n    ensures\n        #[trigger] is_power_2(pow2(e) as int),\n    decreases e,\n{\n    if e == 0 {\n        assert(pow2(e) == 1) by {\n            lemma2_to64();\n        };\n        assert(is_power_2(1));\n    } else {\n        lemma_pow2_is_power2((e - 1) as nat);\n        let p = pow2((e - 1) as nat) as int;\n        assert(is_power_2(p));\n        assert(pow2(e) == 2 * p) by {\n            lemma_pow2_unfold(e);\n        };\n        assert(pow2(e) % 2 == 0);\n        assert(is_power_2(2 * p / 2));\n        assert(is_power_2(p));\n    }\n}\n\npub proof fn lemma_is_power2_exists_pow2(e: nat)\n    requires\n        is_power_2(e as int),\n    ensures\n        exists|n: nat| pow2(n) == e,\n    decreases e,\n{\n    if e == 0 {\n    } else if e == 1 {\n        assert(pow2(0) == 1) by {\n            lemma2_to64();\n        };\n    } else {\n        lemma_is_power2_exists_pow2(e / 2);\n        let n = choose|n: nat| pow2(n) == e / 2;\n        assert(pow2(n + 1) == e) by {\n            lemma_pow2_unfold(n + 1);\n        }\n    }\n}\n\npub proof fn lemma2_to64_hi32()\n    ensures\n        pow2(33) == 0x200000000,\n        pow2(34) == 0x400000000,\n        pow2(35) == 0x800000000,\n        pow2(36) == 0x1000000000,\n        pow2(37) == 0x2000000000,\n        pow2(38) == 0x4000000000,\n        pow2(39) == 0x8000000000,\n        pow2(40) == 0x10000000000,\n        pow2(41) == 0x20000000000,\n        pow2(42) == 0x40000000000,\n        pow2(43) == 0x80000000000,\n        pow2(44) == 0x100000000000,\n        pow2(45) == 0x200000000000,\n        pow2(46) == 0x400000000000,\n        pow2(47) == 0x800000000000,\n        pow2(48) == 0x1000000000000,\n        pow2(49) == 0x2000000000000,\n        pow2(50) == 0x4000000000000,\n        pow2(51) == 0x8000000000000,\n        pow2(52) == 0x10000000000000,\n        pow2(53) == 0x20000000000000,\n        pow2(54) == 0x40000000000000,\n        pow2(55) == 0x80000000000000,\n        pow2(56) == 0x100000000000000,\n        pow2(57) == 0x200000000000000,\n        pow2(58) == 0x400000000000000,\n        pow2(59) == 0x800000000000000,\n        pow2(60) == 0x1000000000000000,\n        pow2(61) == 0x2000000000000000,\n        pow2(62) == 0x4000000000000000,\n        pow2(63) == 0x8000000000000000,\n        pow2(64) == 0x10000000000000000,\n{\n    lemma2_to64();\n    reveal(pow2);\n    reveal(pow);\n    #[verusfmt::skip]\n    assert(\n        pow2(33) == 0x200000000 &&\n        pow2(34) == 0x400000000 &&\n        pow2(35) == 0x800000000 &&\n        pow2(36) == 0x1000000000 &&\n        pow2(37) == 0x2000000000 &&\n        pow2(38) == 0x4000000000 &&\n        pow2(39) == 0x8000000000 &&\n        pow2(40) == 0x10000000000 &&\n        pow2(41) == 0x20000000000 &&\n        pow2(42) == 0x40000000000 &&\n        pow2(43) == 0x80000000000 &&\n        pow2(44) == 0x100000000000 &&\n        pow2(45) == 0x200000000000 &&\n        pow2(46) == 0x400000000000 &&\n        pow2(47) == 0x800000000000 &&\n        pow2(48) == 0x1000000000000 &&\n        pow2(49) == 0x2000000000000 &&\n        pow2(50) == 0x4000000000000 &&\n        pow2(51) == 0x8000000000000 &&\n        pow2(52) == 0x10000000000000 &&\n        pow2(53) == 0x20000000000000 &&\n        pow2(54) == 0x40000000000000 &&\n        pow2(55) == 0x80000000000000 &&\n        pow2(56) == 0x100000000000000 &&\n        pow2(57) == 0x200000000000000 &&\n        pow2(58) == 0x400000000000000 &&\n        pow2(59) == 0x800000000000000 &&\n        pow2(60) == 0x1000000000000000 &&\n        pow2(61) == 0x2000000000000000 &&\n        pow2(62) == 0x4000000000000000 &&\n        pow2(63) == 0x8000000000000000 &&\n        pow2(64) == 0x10000000000000000\n    ) by (compute_only);\n}\n\npub proof fn lemma_pow2_is_power2_to64()\n    ensures\n        is_power_2(0x1),\n        is_power_2(0x2),\n        is_power_2(0x4),\n        is_power_2(0x8),\n        is_power_2(0x10),\n        is_power_2(0x20),\n        is_power_2(0x40),\n        is_power_2(0x80),\n        is_power_2(0x100),\n        is_power_2(0x200),\n        is_power_2(0x400),\n        is_power_2(0x800),\n        is_power_2(0x1000),\n        is_power_2(0x2000),\n        is_power_2(0x4000),\n        is_power_2(0x8000),\n        is_power_2(0x10000),\n        is_power_2(0x20000),\n        is_power_2(0x40000),\n        is_power_2(0x80000),\n        is_power_2(0x100000),\n        is_power_2(0x200000),\n        is_power_2(0x400000),\n        is_power_2(0x800000),\n        is_power_2(0x1000000),\n        is_power_2(0x2000000),\n        is_power_2(0x4000000),\n        is_power_2(0x8000000),\n        is_power_2(0x10000000),\n        is_power_2(0x20000000),\n        is_power_2(0x40000000),\n        is_power_2(0x80000000),\n        is_power_2(0x100000000),\n        is_power_2(0x200000000),\n        is_power_2(0x400000000),\n        is_power_2(0x800000000),\n        is_power_2(0x1000000000),\n        is_power_2(0x2000000000),\n        is_power_2(0x4000000000),\n        is_power_2(0x8000000000),\n        is_power_2(0x10000000000),\n        is_power_2(0x20000000000),\n        is_power_2(0x40000000000),\n        is_power_2(0x80000000000),\n        is_power_2(0x100000000000),\n        is_power_2(0x200000000000),\n        is_power_2(0x400000000000),\n        is_power_2(0x800000000000),\n        is_power_2(0x1000000000000),\n        is_power_2(0x2000000000000),\n        is_power_2(0x4000000000000),\n        is_power_2(0x8000000000000),\n        is_power_2(0x10000000000000),\n        is_power_2(0x20000000000000),\n        is_power_2(0x40000000000000),\n        is_power_2(0x80000000000000),\n        is_power_2(0x100000000000000),\n        is_power_2(0x200000000000000),\n        is_power_2(0x400000000000000),\n        is_power_2(0x800000000000000),\n        is_power_2(0x1000000000000000),\n        is_power_2(0x2000000000000000),\n        is_power_2(0x4000000000000000),\n        is_power_2(0x8000000000000000),\n        is_power_2(0x10000000000000000),\n{\n    lemma2_to64();\n    lemma2_to64_hi32();\n    lemma_pow2_is_power2(0);\n    lemma_pow2_is_power2(1);\n    lemma_pow2_is_power2(2);\n    lemma_pow2_is_power2(3);\n    lemma_pow2_is_power2(4);\n    lemma_pow2_is_power2(5);\n    lemma_pow2_is_power2(6);\n    lemma_pow2_is_power2(7);\n    lemma_pow2_is_power2(8);\n    lemma_pow2_is_power2(9);\n    lemma_pow2_is_power2(10);\n    lemma_pow2_is_power2(11);\n    lemma_pow2_is_power2(12);\n    lemma_pow2_is_power2(13);\n    lemma_pow2_is_power2(14);\n    lemma_pow2_is_power2(15);\n    lemma_pow2_is_power2(16);\n    lemma_pow2_is_power2(17);\n    lemma_pow2_is_power2(18);\n    lemma_pow2_is_power2(19);\n    lemma_pow2_is_power2(20);\n    lemma_pow2_is_power2(21);\n    lemma_pow2_is_power2(22);\n    lemma_pow2_is_power2(23);\n    lemma_pow2_is_power2(24);\n    lemma_pow2_is_power2(25);\n    lemma_pow2_is_power2(26);\n    lemma_pow2_is_power2(27);\n    lemma_pow2_is_power2(28);\n    lemma_pow2_is_power2(29);\n    lemma_pow2_is_power2(30);\n    lemma_pow2_is_power2(31);\n    lemma_pow2_is_power2(32);\n    lemma_pow2_is_power2(33);\n    lemma_pow2_is_power2(34);\n    lemma_pow2_is_power2(35);\n    lemma_pow2_is_power2(36);\n    lemma_pow2_is_power2(37);\n    lemma_pow2_is_power2(38);\n    lemma_pow2_is_power2(39);\n    lemma_pow2_is_power2(40);\n    lemma_pow2_is_power2(41);\n    lemma_pow2_is_power2(42);\n    lemma_pow2_is_power2(43);\n    lemma_pow2_is_power2(44);\n    lemma_pow2_is_power2(45);\n    lemma_pow2_is_power2(46);\n    lemma_pow2_is_power2(47);\n    lemma_pow2_is_power2(48);\n    lemma_pow2_is_power2(49);\n    lemma_pow2_is_power2(50);\n    lemma_pow2_is_power2(51);\n    lemma_pow2_is_power2(52);\n    lemma_pow2_is_power2(53);\n    lemma_pow2_is_power2(54);\n    lemma_pow2_is_power2(55);\n    lemma_pow2_is_power2(56);\n    lemma_pow2_is_power2(57);\n    lemma_pow2_is_power2(58);\n    lemma_pow2_is_power2(59);\n    lemma_pow2_is_power2(60);\n    lemma_pow2_is_power2(61);\n    lemma_pow2_is_power2(62);\n    lemma_pow2_is_power2(63);\n    lemma_pow2_is_power2(64);\n}\n\npub proof fn lemma_log2_to64()\n    ensures\n        log(2, 0x1) == 0,\n        log(2, 0x2) == 1,\n        log(2, 0x4) == 2,\n        log(2, 0x8) == 3,\n        log(2, 0x10) == 4,\n        log(2, 0x20) == 5,\n        log(2, 0x40) == 6,\n        log(2, 0x80) == 7,\n        log(2, 0x100) == 8,\n        log(2, 0x200) == 9,\n        log(2, 0x400) == 10,\n        log(2, 0x800) == 11,\n        log(2, 0x1000) == 12,\n        log(2, 0x2000) == 13,\n        log(2, 0x4000) == 14,\n        log(2, 0x8000) == 15,\n        log(2, 0x10000) == 16,\n        log(2, 0x20000) == 17,\n        log(2, 0x40000) == 18,\n        log(2, 0x80000) == 19,\n        log(2, 0x100000) == 20,\n        log(2, 0x200000) == 21,\n        log(2, 0x400000) == 22,\n        log(2, 0x800000) == 23,\n        log(2, 0x1000000) == 24,\n        log(2, 0x2000000) == 25,\n        log(2, 0x4000000) == 26,\n        log(2, 0x8000000) == 27,\n        log(2, 0x10000000) == 28,\n        log(2, 0x20000000) == 29,\n        log(2, 0x40000000) == 30,\n        log(2, 0x80000000) == 31,\n        log(2, 0x100000000) == 32,\n        log(2, 0x200000000) == 33,\n        log(2, 0x400000000) == 34,\n        log(2, 0x800000000) == 35,\n        log(2, 0x1000000000) == 36,\n        log(2, 0x2000000000) == 37,\n        log(2, 0x4000000000) == 38,\n        log(2, 0x8000000000) == 39,\n        log(2, 0x10000000000) == 40,\n        log(2, 0x20000000000) == 41,\n        log(2, 0x40000000000) == 42,\n        log(2, 0x80000000000) == 43,\n        log(2, 0x100000000000) == 44,\n        log(2, 0x200000000000) == 45,\n        log(2, 0x400000000000) == 46,\n        log(2, 0x800000000000) == 47,\n        log(2, 0x1000000000000) == 48,\n        log(2, 0x2000000000000) == 49,\n        log(2, 0x4000000000000) == 50,\n        log(2, 0x8000000000000) == 51,\n        log(2, 0x10000000000000) == 52,\n        log(2, 0x20000000000000) == 53,\n        log(2, 0x40000000000000) == 54,\n        log(2, 0x80000000000000) == 55,\n        log(2, 0x100000000000000) == 56,\n        log(2, 0x200000000000000) == 57,\n        log(2, 0x400000000000000) == 58,\n        log(2, 0x800000000000000) == 59,\n        log(2, 0x1000000000000000) == 60,\n        log(2, 0x2000000000000000) == 61,\n        log(2, 0x4000000000000000) == 62,\n        log(2, 0x8000000000000000) == 63,\n        log(2, 0x10000000000000000) == 64,\n{\n    lemma2_to64();\n    lemma2_to64_hi32();\n    lemma_pow2_log2(0);\n    lemma_pow2_log2(1);\n    lemma_pow2_log2(2);\n    lemma_pow2_log2(3);\n    lemma_pow2_log2(4);\n    lemma_pow2_log2(5);\n    lemma_pow2_log2(6);\n    lemma_pow2_log2(7);\n    lemma_pow2_log2(8);\n    lemma_pow2_log2(9);\n    lemma_pow2_log2(10);\n    lemma_pow2_log2(11);\n    lemma_pow2_log2(12);\n    lemma_pow2_log2(13);\n    lemma_pow2_log2(14);\n    lemma_pow2_log2(15);\n    lemma_pow2_log2(16);\n    lemma_pow2_log2(17);\n    lemma_pow2_log2(18);\n    lemma_pow2_log2(19);\n    lemma_pow2_log2(20);\n    lemma_pow2_log2(21);\n    lemma_pow2_log2(22);\n    lemma_pow2_log2(23);\n    lemma_pow2_log2(24);\n    lemma_pow2_log2(25);\n    lemma_pow2_log2(26);\n    lemma_pow2_log2(27);\n    lemma_pow2_log2(28);\n    lemma_pow2_log2(29);\n    lemma_pow2_log2(30);\n    lemma_pow2_log2(31);\n    lemma_pow2_log2(32);\n    lemma_pow2_log2(33);\n    lemma_pow2_log2(34);\n    lemma_pow2_log2(35);\n    lemma_pow2_log2(36);\n    lemma_pow2_log2(37);\n    lemma_pow2_log2(38);\n    lemma_pow2_log2(39);\n    lemma_pow2_log2(40);\n    lemma_pow2_log2(41);\n    lemma_pow2_log2(42);\n    lemma_pow2_log2(43);\n    lemma_pow2_log2(44);\n    lemma_pow2_log2(45);\n    lemma_pow2_log2(46);\n    lemma_pow2_log2(47);\n    lemma_pow2_log2(48);\n    lemma_pow2_log2(49);\n    lemma_pow2_log2(50);\n    lemma_pow2_log2(51);\n    lemma_pow2_log2(52);\n    lemma_pow2_log2(53);\n    lemma_pow2_log2(54);\n    lemma_pow2_log2(55);\n    lemma_pow2_log2(56);\n    lemma_pow2_log2(57);\n    lemma_pow2_log2(58);\n    lemma_pow2_log2(59);\n    lemma_pow2_log2(60);\n    lemma_pow2_log2(61);\n    lemma_pow2_log2(62);\n    lemma_pow2_log2(63);\n    lemma_pow2_log2(64);\n}\n\n} // verus!\nmacro_rules! impl_external_ilog2 {\n    ($uN: ty, $spec_name: ident,\n    $pow2_lemma: ident, $pow2_ilog2_lemma: ident,\n    $log2_bounds_lemma: ident, $ilog2_ordered_lemma: ident, $is_power_2_is_ilog2_pow2_lemma: ident $(,)?) => {\n        verus! {\n            #[verifier::inline]\n            pub open spec fn $spec_name(x: $uN) -> u32\n            {\n                log(2, x as int) as u32\n            }\n\n            #[verifier::when_used_as_spec($spec_name)]\n            pub assume_specification[$uN::ilog2](x:$uN) -> u32\n                requires\n                    x > 0,\n                returns\n                    log(2, x as int) as u32,\n                opens_invariants none\n                no_unwind;\n\n            pub broadcast proof fn $pow2_lemma(e: u32, x: $uN)\n                requires\n                    #[trigger] pow2(e as nat) == x,\n                ensures\n                    #[trigger] x.ilog2() == e,\n            {\n                lemma_pow2_log2(e as nat);\n            }\n\n            pub broadcast proof fn $pow2_ilog2_lemma(e: u32)\n                requires\n                    pow2(e as nat) <= $uN::MAX,\n                ensures\n                    #[trigger] (pow2(e as nat) as $uN).ilog2() == e,\n            {\n                $pow2_lemma(e, pow2(e as nat) as $uN);\n            }\n\n            pub proof fn $log2_bounds_lemma(x: $uN)\n                ensures\n                    0 <= log(2, x as int) <= $uN::BITS,\n                    0 <= x.ilog2() <= $uN::BITS,\n            {\n                lemma_log_nonnegative(2, x as int);\n                assert(x <= $uN::MAX);\n                assert(($uN::MAX as int) < (pow2($uN::BITS as nat) as int)) by {\n                    lemma2_to64();\n                };\n                assert(log(2, x as int) <= log(2, pow2($uN::BITS as nat) as int)) by {\n                    lemma_log_is_ordered(2, x as int, pow2($uN::BITS as nat) as int);\n                };\n                assert(log(2, pow2($uN::BITS as nat) as int) == $uN::BITS) by {\n                    lemma_pow2_log2($uN::BITS as nat);\n                };\n            }\n\n            pub proof fn $ilog2_ordered_lemma(x: $uN, y: $uN)\n                requires\n                    x <= y,\n                ensures\n                    x.ilog2() <= y.ilog2(),\n            {\n                $log2_bounds_lemma(x);\n                $log2_bounds_lemma(y);\n                lemma_log_is_ordered(2, x as int, y as int);\n            }\n\n            pub broadcast proof fn $is_power_2_is_ilog2_pow2_lemma(x: $uN)\n                requires\n                    #[trigger] is_power_2(x as int),\n                ensures\n                    x as nat == pow2(x.ilog2() as nat),\n            {\n                lemma_is_power2_exists_pow2(x as nat);\n                let n = choose |n: nat| pow2(n) == x as nat;\n                assert(log(2, x as int) == n) by {\n                    lemma_pow2_log2(n);\n                };\n                assert($uN::MAX as int + 1 == pow2($uN::BITS as nat) as int) by {\n                    lemma2_to64();\n                };\n                lemma_pow2(n);\n                lemma_pow2($uN::BITS as nat);\n                assert(n <= $uN::BITS) by {\n                    lemma_pow_increases_converse(2, n, $uN::BITS as nat);\n                };\n                assert(x.ilog2() == n);\n            }\n        }\n    };\n}\n\nimpl_external_ilog2!(\n    u8,\n    u8_ilog2_spec,\n    lemma_u8_pow2_ilog2_x,\n    lemma_u8_pow2_ilog2,\n    lemma_u8_log2_bounds,\n    lemma_u8_ilog2_ordered,\n    lemma_u8_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u16,\n    u16_ilog2_spec,\n    lemma_u16_pow2_ilog2_x,\n    lemma_u16_pow2_ilog2,\n    lemma_u16_log2_bounds,\n    lemma_u16_ilog2_ordered,\n    lemma_u16_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u32,\n    u32_ilog2_spec,\n    lemma_u32_pow2_ilog2_x,\n    lemma_u32_pow2_ilog2,\n    lemma_u32_log2_bounds,\n    lemma_u32_ilog2_ordered,\n    lemma_u32_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    usize,\n    usize_ilog2_spec,\n    lemma_usize_pow2_ilog2_x,\n    lemma_usize_pow2_ilog2,\n    lemma_usize_log2_bounds,\n    lemma_usize_ilog2_ordered,\n    lemma_usize_is_power_2_is_ilog2_pow2,\n);\n\nimpl_external_ilog2!(\n    u64,\n    u64_ilog2_spec,\n    lemma_u64_pow2_ilog2_x,\n    lemma_u64_pow2_ilog2,\n    lemma_u64_log2_bounds,\n    lemma_u64_ilog2_ordered,\n    lemma_u64_is_power_2_is_ilog2_pow2,\n);\n\nverus! {\n\npub proof fn lemma_u8_ilog2_to8()\n    ensures\n        (0x1 as u8).ilog2() == 0,\n        (0x2 as u8).ilog2() == 1,\n        (0x4 as u8).ilog2() == 2,\n        (0x8 as u8).ilog2() == 3,\n        (0x10 as u8).ilog2() == 4,\n        (0x20 as u8).ilog2() == 5,\n        (0x40 as u8).ilog2() == 6,\n        (0x80 as u8).ilog2() == 7,\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u16_ilog2_to16()\n    ensures\n        (0x1 as u16).ilog2() == 0,\n        (0x2 as u16).ilog2() == 1,\n        (0x4 as u16).ilog2() == 2,\n        (0x8 as u16).ilog2() == 3,\n        (0x10 as u16).ilog2() == 4,\n        (0x20 as u16).ilog2() == 5,\n        (0x40 as u16).ilog2() == 6,\n        (0x80 as u16).ilog2() == 7,\n        (0x100 as u16).ilog2() == 8,\n        (0x200 as u16).ilog2() == 9,\n        (0x400 as u16).ilog2() == 10,\n        (0x800 as u16).ilog2() == 11,\n        (0x1000 as u16).ilog2() == 12,\n        (0x2000 as u16).ilog2() == 13,\n        (0x4000 as u16).ilog2() == 14,\n        (0x8000 as u16).ilog2() == 15,\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u32_ilog2_to32()\n    ensures\n        (0x1 as u32).ilog2() == 0,\n        (0x2 as u32).ilog2() == 1,\n        (0x4 as u32).ilog2() == 2,\n        (0x8 as u32).ilog2() == 3,\n        (0x10 as u32).ilog2() == 4,\n        (0x20 as u32).ilog2() == 5,\n        (0x40 as u32).ilog2() == 6,\n        (0x80 as u32).ilog2() == 7,\n        (0x100 as u32).ilog2() == 8,\n        (0x200 as u32).ilog2() == 9,\n        (0x400 as u32).ilog2() == 10,\n        (0x800 as u32).ilog2() == 11,\n        (0x1000 as u32).ilog2() == 12,\n        (0x2000 as u32).ilog2() == 13,\n        (0x4000 as u32).ilog2() == 14,\n        (0x8000 as u32).ilog2() == 15,\n        (0x10000 as u32).ilog2() == 16,\n        (0x20000 as u32).ilog2() == 17,\n        (0x40000 as u32).ilog2() == 18,\n        (0x80000 as u32).ilog2() == 19,\n        (0x100000 as u32).ilog2() == 20,\n        (0x200000 as u32).ilog2() == 21,\n        (0x400000 as u32).ilog2() == 22,\n        (0x800000 as u32).ilog2() == 23,\n        (0x1000000 as u32).ilog2() == 24,\n        (0x2000000 as u32).ilog2() == 25,\n        (0x4000000 as u32).ilog2() == 26,\n        (0x8000000 as u32).ilog2() == 27,\n        (0x10000000 as u32).ilog2() == 28,\n        (0x20000000 as u32).ilog2() == 29,\n        (0x40000000 as u32).ilog2() == 30,\n        (0x80000000 as u32).ilog2() == 31,\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_usize_ilog2_to32()\n    ensures\n        (0x1 as usize).ilog2() == 0,\n        (0x2 as usize).ilog2() == 1,\n        (0x4 as usize).ilog2() == 2,\n        (0x8 as usize).ilog2() == 3,\n        (0x10 as usize).ilog2() == 4,\n        (0x20 as usize).ilog2() == 5,\n        (0x40 as usize).ilog2() == 6,\n        (0x80 as usize).ilog2() == 7,\n        (0x100 as usize).ilog2() == 8,\n        (0x200 as usize).ilog2() == 9,\n        (0x400 as usize).ilog2() == 10,\n        (0x800 as usize).ilog2() == 11,\n        (0x1000 as usize).ilog2() == 12,\n        (0x2000 as usize).ilog2() == 13,\n        (0x4000 as usize).ilog2() == 14,\n        (0x8000 as usize).ilog2() == 15,\n        (0x10000 as usize).ilog2() == 16,\n        (0x20000 as usize).ilog2() == 17,\n        (0x40000 as usize).ilog2() == 18,\n        (0x80000 as usize).ilog2() == 19,\n        (0x100000 as usize).ilog2() == 20,\n        (0x200000 as usize).ilog2() == 21,\n        (0x400000 as usize).ilog2() == 22,\n        (0x800000 as usize).ilog2() == 23,\n        (0x1000000 as usize).ilog2() == 24,\n        (0x2000000 as usize).ilog2() == 25,\n        (0x4000000 as usize).ilog2() == 26,\n        (0x8000000 as usize).ilog2() == 27,\n        (0x10000000 as usize).ilog2() == 28,\n        (0x20000000 as usize).ilog2() == 29,\n        (0x40000000 as usize).ilog2() == 30,\n        (0x80000000 as usize).ilog2() == 31,\n{\n    lemma_log2_to64();\n}\n\npub proof fn lemma_u64_ilog2_to64()\n    ensures\n        (0x1 as u64).ilog2() == 0,\n        (0x2 as u64).ilog2() == 1,\n        (0x4 as u64).ilog2() == 2,\n        (0x8 as u64).ilog2() == 3,\n        (0x10 as u64).ilog2() == 4,\n        (0x20 as u64).ilog2() == 5,\n        (0x40 as u64).ilog2() == 6,\n        (0x80 as u64).ilog2() == 7,\n        (0x100 as u64).ilog2() == 8,\n        (0x200 as u64).ilog2() == 9,\n        (0x400 as u64).ilog2() == 10,\n        (0x800 as u64).ilog2() == 11,\n        (0x1000 as u64).ilog2() == 12,\n        (0x2000 as u64).ilog2() == 13,\n        (0x4000 as u64).ilog2() == 14,\n        (0x8000 as u64).ilog2() == 15,\n        (0x10000 as u64).ilog2() == 16,\n        (0x20000 as u64).ilog2() == 17,\n        (0x40000 as u64).ilog2() == 18,\n        (0x80000 as u64).ilog2() == 19,\n        (0x100000 as u64).ilog2() == 20,\n        (0x200000 as u64).ilog2() == 21,\n        (0x400000 as u64).ilog2() == 22,\n        (0x800000 as u64).ilog2() == 23,\n        (0x1000000 as u64).ilog2() == 24,\n        (0x2000000 as u64).ilog2() == 25,\n        (0x4000000 as u64).ilog2() == 26,\n        (0x8000000 as u64).ilog2() == 27,\n        (0x10000000 as u64).ilog2() == 28,\n        (0x20000000 as u64).ilog2() == 29,\n        (0x40000000 as u64).ilog2() == 30,\n        (0x80000000 as u64).ilog2() == 31,\n        (0x100000000 as u64).ilog2() == 32,\n        (0x200000000 as u64).ilog2() == 33,\n        (0x400000000 as u64).ilog2() == 34,\n        (0x800000000 as u64).ilog2() == 35,\n        (0x1000000000 as u64).ilog2() == 36,\n        (0x2000000000 as u64).ilog2() == 37,\n        (0x4000000000 as u64).ilog2() == 38,\n        (0x8000000000 as u64).ilog2() == 39,\n        (0x10000000000 as u64).ilog2() == 40,\n        (0x20000000000 as u64).ilog2() == 41,\n        (0x40000000000 as u64).ilog2() == 42,\n        (0x80000000000 as u64).ilog2() == 43,\n        (0x100000000000 as u64).ilog2() == 44,\n        (0x200000000000 as u64).ilog2() == 45,\n        (0x400000000000 as u64).ilog2() == 46,\n        (0x800000000000 as u64).ilog2() == 47,\n        (0x1000000000000 as u64).ilog2() == 48,\n        (0x2000000000000 as u64).ilog2() == 49,\n        (0x4000000000000 as u64).ilog2() == 50,\n        (0x8000000000000 as u64).ilog2() == 51,\n        (0x10000000000000 as u64).ilog2() == 52,\n        (0x20000000000000 as u64).ilog2() == 53,\n        (0x40000000000000 as u64).ilog2() == 54,\n        (0x80000000000000 as u64).ilog2() == 55,\n        (0x100000000000000 as u64).ilog2() == 56,\n        (0x200000000000000 as u64).ilog2() == 57,\n        (0x400000000000000 as u64).ilog2() == 58,\n        (0x800000000000000 as u64).ilog2() == 59,\n        (0x1000000000000000 as u64).ilog2() == 60,\n        (0x2000000000000000 as u64).ilog2() == 61,\n        (0x4000000000000000 as u64).ilog2() == 62,\n        (0x8000000000000000 as u64).ilog2() == 63,\n{\n    lemma_log2_to64();\n}\n\npub broadcast proof fn lemma_usize_shl_is_mul(x: usize, shift: usize)\n    requires\n        0 <= shift < usize::BITS,\n        x * pow2(shift as nat) <= usize::MAX,\n    ensures\n        #[trigger] (x << shift) == x * pow2(shift as nat),\n{\n    if usize::BITS == 64 {\n        lemma_u64_shl_is_mul(x as u64, shift as u64);\n    } else if usize::BITS == 32 {\n        lemma_u32_shl_is_mul(x as u32, shift as u32);\n    } else {\n        assert(false);\n    }\n}\n\npub broadcast proof fn lemma_usize_pow2_shl_is_pow2(x: usize, shift: usize)\n    requires\n        0 <= shift < usize::BITS,\n        is_power_2(x as int),\n        x * pow2(shift as nat) <= usize::MAX,\n    ensures\n        #[trigger] is_power_2((x << shift) as int),\n{\n    lemma_is_power2_exists_pow2(x as nat);\n    let n = choose|n: nat| pow2(n) == x as nat;\n    lemma_usize_shl_is_mul(x, shift);\n    assert(x << shift == x * pow2(shift as nat));\n    lemma_pow2_adds(n, shift as nat);\n    assert(x * pow2(shift as nat) == pow2(n + shift as nat));\n    lemma_pow2_is_power2(n + shift as nat);\n    assert(is_power_2((x << shift) as int));\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/extra_num.rs", "verified": true, "metadata": {"original_id": "vostd_extra_num_4ccd47badacd", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b39d5d780de1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int)  {  lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int)   { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires n % 3 == 0, triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, n / 3 * 3 == n, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b39d5d780de1", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c88c1ef2481f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn M () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "c88c1ef2481f", "function_name": "M", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ca4fd00d9375", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)   { let mut i = 0usize ; while i < numbers . len ()  { let mut j = 0usize ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires i != MIN , threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures i < 0 ==> res == - i , i >= 0 ==> res == i, flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold\ndecreases numbers . len () - i, numbers . len () - j\ninvariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold, 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ca4fd00d9375", "function_name": "has_close_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e29169259713", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e29169259713", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2d8f476a02db", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "2d8f476a02db", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_639b157b34a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "639b157b34a0", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_351d7857ec9b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant c @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "351d7857ec9b", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f5eb73065f36", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f5eb73065f36", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ed7268e84226", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "ed7268e84226", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a2692118e64d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "a2692118e64d", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d5a83ba741ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop  { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases high - low\ninvariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "d5a83ba741ec", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7abf24a196b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { return false ; }\n\n} // verus!", "target_text": "requires is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7abf24a196b4", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4173315a5ef2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4173315a5ef2", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b75a5b215173", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_is_even/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b75a5b215173", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_29e57b1f2011", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >) ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/062-derivative_iter_0_original.rs", "verified": true, "metadata": {"original_id": "29e57b1f2011", "function_name": "derivative", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_888330bc363f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "888330bc363f", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f27e0ae271be", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_44/verina_advanced_44.rs", "verified": true, "metadata": {"original_id": "f27e0ae271be", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_68652cb1403d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 \nensures r == decode_char_spec (c as int) , 65 <= r <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "68652cb1403d", "function_name": "decode_char", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_301be56a5b52", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize)  { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i]  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int]\ndecreases a . len () - i\ninvariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "301be56a5b52", "function_name": "longest_prefix", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a85e1baaacfe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_update_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a85e1baaacfe", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dce8a0b1d050", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - j", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_inner (nums : & Vec < i32 > , target : i32 , x : i32 , i : usize , j : usize) -> Option < usize > decreases nums . len () - j { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "dce8a0b1d050", "function_name": "two_sum_inner", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6819490f02b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6819490f02b6", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_24d8a176ce70", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "24d8a176ce70", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_66d7e84fd392", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "66d7e84fd392", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8361c88285f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len ()  { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ninvariant result . len () == 2 * i - (if i == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "8361c88285f7", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8c284a4963a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)   { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len ()  { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "target_text": "requires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>\ninvariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c284a4963a0", "function_name": "pluck_smallest_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_dd6c17a7f567", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882\nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dd6c17a7f567", "function_name": "Triple1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eb8ed59c5584", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i]  { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires longest_common_prefix_precond (str1 @ , str2 @)\nensures longest_common_prefix_postcond (str1 @ , str2 @ , result @)\ndecreases str1 @ . len () - i\ninvariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >) requires longest_common_prefix_precond (str1 @ , str2 @) ensures longest_common_prefix_postcond (str1 @ , str2 @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i] invariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j] decreases str1 @ . len () - i { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_71/verina_basic_71_iter_5_current.rs", "verified": true, "metadata": {"original_id": "eb8ed59c5584", "function_name": "longest_common_prefix", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_59afb611841a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn is_lower_case_exec (c : char) -> (result : bool)  { c >= 'a' && c <= 'z' }\n\n} // verus!", "target_text": "ensures result == is_lower_case (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "59afb611841a", "function_name": "is_lower_case_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_48c949066cae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut index = 0 ; while index < arr . len ()  { copied . push (arr [index]) ; index += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - index\ninvariant index <= arr . len () , copied @ . len () == index , forall | i : int | (0 <= i < index) ==> arr [i] == copied [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut index = 0 ; while index < arr . len () invariant index <= arr . len () , copied @ . len () == index , forall | i : int | (0 <= i < index) ==> arr [i] == copied [i] , decreases arr . len () - index { copied . push (arr [index]) ; index += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "48c949066cae", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_99f92347c2e5", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \" We model the persistent memory as getting flushed in chunks,\"] # [doc = \" where each chunk has `const_persistence_chunk_size()` bytes. We refer\"] # [doc = \" to chunk number `c` as the set of addresses `addr` such that\"] # [doc = \" `addr / const_persistence_chunk_size() == c`.\"] pub open spec fn const_persistence_chunk_size () -> int { 8 }\npub exec fn persistence_chunk_size () -> (out : usize)  { 8 }\n\n} // verus!", "target_text": "ensures out == const_persistence_chunk_size ()\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \" We model the persistent memory as getting flushed in chunks,\"] # [doc = \" where each chunk has `const_persistence_chunk_size()` bytes. We refer\"] # [doc = \" to chunk number `c` as the set of addresses `addr` such that\"] # [doc = \" `addr / const_persistence_chunk_size() == c`.\"] pub open spec fn const_persistence_chunk_size () -> int { 8 }\npub exec fn persistence_chunk_size () -> (out : usize) ensures out == const_persistence_chunk_size () { 8 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "99f92347c2e5", "function_name": "persistence_chunk_size", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_55e969d48129", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first_element = a [0] ; let mut i : usize = 1 ; while i < a . len ()  { if a [i] != first_element { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first_element ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first_element = a [0] ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first_element , decreases a . len () - i { if a [i] != first_element { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "55e969d48129", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c807ee344383", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32)   { let mut i = N ; while i != 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "c807ee344383", "function_name": "down_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_playground_2f09eff4d1ad", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nstruct S<A> {\n    a: A,\n    b: bool,\n}\n\nfn add1(a: &mut u32)\n\n{\n    *a = *a + 1;\n}\n\nfn foo(s: S<u32>) {\n    // let mut s = s;\n    let mut s = S { a: 5, b: false };\n    add1(&mut s.a);\n\n}\n\n// The following causes a trigger loop (useful for testing rlimit-related features):\n//\n// spec fn f(x: nat, y: nat) -> bool;\n//\n// proof fn goodbye_z3()\n//           {\n// }\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires *old(a) < 10, forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> (#[trigger] f(x, y)),\n//\nensures *a == *old(a) + 1, forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),\n//", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[derive(PartialEq, Eq, Structural)]\nstruct S<A> {\n    a: A,\n    b: bool,\n}\n\nfn add1(a: &mut u32)\n    requires\n        *old(a) < 10,\n    ensures\n        *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn foo(s: S<u32>) {\n    // let mut s = s;\n    let mut s = S { a: 5, b: false };\n    add1(&mut s.a);\n    assert(s.a == 6);\n    assert(s.b == false);\n    assert(s == S { a: 6u32, b: false });\n}\n\n// The following causes a trigger loop (useful for testing rlimit-related features):\n//\n// spec fn f(x: nat, y: nat) -> bool;\n//\n// proof fn goodbye_z3()\n//     requires forall|x: nat, y: nat| f(x + 1, 2 * y) && f(2 * x, y + x) || f(y, x) ==> (#[trigger] f(x, y)),\n//     ensures forall|x: nat, y: nat| x > 2318 && y < 100 ==> f(x, y),\n// {\n// }\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/playground.rs", "verified": true, "metadata": {"original_id": "verus_playground_2f09eff4d1ad", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2f7261f8e3d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f7261f8e3d5", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_08e5cbd8d9f4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut pos = 0 ; let mut i = 0 ; while i < a . len ()  { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len ()  { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i, a . len () - i\ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "08e5cbd8d9f4", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2981e1bee084", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) \nensures result == is_digit_spec (c) , all_digits_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2981e1bee084", "function_name": "all_digits", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_78e542bc9dd1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - idx\ninvariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "78e542bc9dd1", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fef94c2f1dde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { let mut i : usize = 0 ; while i < list1 . len ()  { let mut j : usize = 0 ; while j < list2 . len ()  { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) \ndecreases list1 . len () - i, list2 . len () - j\ninvariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { let mut i : usize = 0 ; while i < list1 . len () invariant forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , decreases list1 . len () - i { let mut j : usize = 0 ; while j < list2 . len () invariant i < list1 . len () , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < list2 . len () ==> list1 [ii] != list2 [jj] , forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , decreases list2 . len () - j { if list1 [i] == list2 [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "fef94c2f1dde", "function_name": "has_common_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d3988c602022", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "d3988c602022", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a390392acdae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires has_common_element_precond (a @ , b @) \nensures has_common_element_postcond (a @ , b @ , result) \ndecreases a . len () - i, b . len () - j\ninvariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "a390392acdae", "function_name": "has_common_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9ecf147a7a6c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)   { let result = arr [k - 1] ;  result }\n\n} // verus!", "target_text": "requires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9ecf147a7a6c", "function_name": "kth_element", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c31b95e4ed9", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ninvariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len () invariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/findmax_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7c31b95e4ed9", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_dab3cce94266", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32)   { x + 15 }\n\n} // verus!", "target_text": "requires 10 <= x <= 1000\nensures 25 <= y", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32) requires 10 <= x <= 1000 ensures 25 <= y { x + 15 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "dab3cce94266", "function_name": "MyMethod", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f8a4ea34e547", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool)  { for i in 0 .. v . len ()  { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "target_text": "ensures b == positive (v @)\ninvariant forall | u : int | 0 <= u < i ==> v [u] >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool) ensures b == positive (v @) { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8a4ea34e547", "function_name": "mpositive", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_62609aea4c5d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs2_impl.rs", "verified": true, "metadata": {"original_id": "62609aea4c5d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a70f23c8aa9d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a70f23c8aa9d", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c19ba825f92e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c19ba825f92e", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3536863dfc81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)   { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n  { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n  { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len ()\nensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i]\ndecreases n - i, n - j\ninvariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k], 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/WIP/WIP__transpose_matrix_impl.rs", "verified": true, "metadata": {"original_id": "3536863dfc81", "function_name": "transpose", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a4883566b769", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a4883566b769", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_66a036ce0471", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "66a036ce0471", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_853b2c483409", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < arr1 . len ()  {     let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "853b2c483409", "function_name": "element_wise_division", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9cf715209978", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {     let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "9cf715209978", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4ebba314eff1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. list1 . len ()  { for j in 0 .. list2 . len ()  { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] {  } return true ; } } }  } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) \ninvariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "4ebba314eff1", "function_name": "has_common_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b7fdb534c54b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b7fdb534c54b", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fcc1a2e5ae27", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool)   { let mut i = 0 ; while i < sub . len ()  {  if main [idx + i] != sub [i] { return false ; } i += 1 ; }  true }\n\n} // verus!", "target_text": "requires 0 <= idx <= (main . len () - sub . len ()) \nensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) \ndecreases sub . len () - i \ninvariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx as int + j] == sub @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx as int + j] == sub @ [j] , decreases sub . len () - i , { assert (idx + i < main . len ()) ; if main [idx + i] != sub [i] { return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx as int + j] == sub @ [j]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_576_v2_impl.rs", "verified": true, "metadata": {"original_id": "fcc1a2e5ae27", "function_name": "sub_array_at_index", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_52f39105505a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {   return true ; } i = i + 1 ; }  return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "52f39105505a", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_926719c1a1de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str . len ()  { let c = str [idx] ; let flipped_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_c) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - idx \ninvariant idx <= str . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == flip_case_spec (str [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str . len () invariant idx <= str . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == flip_case_spec (str [i]) , decreases str . len () - idx , { let c = str [idx] ; let flipped_c = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_c) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/027-flip_case_iter_3_current.rs", "verified": true, "metadata": {"original_id": "926719c1a1de", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ccb6e3e74b2d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "ccb6e3e74b2d", "function_name": "secondSmallestAux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_938dc2dfa2f5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len ()  { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - k\ninvariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "938dc2dfa2f5", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7d3b7367a2dc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   {  sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , N <= MAX / 2 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 2 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 2 * N , { assert (2 * N <= MAX) ; sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s2if_impl.rs", "verified": true, "metadata": {"original_id": "7d3b7367a2dc", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_27d2755c5821", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {   return true ; } i = i + 1 ; }  false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "27d2755c5821", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3b59283454f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)   { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >)   { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , append_precond (a @ , b) \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , append_postcond (a @ , b , result @) , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3b59283454f1", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_84298e3bd0ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0  { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases i\ninvariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0 invariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] , decreases i { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/reverse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "84298e3bd0ca", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_077aef354975", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_iter_1_current.rs", "verified": true, "metadata": {"original_id": "077aef354975", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e042e9cac08d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list @ . len () - i, n - j\ninvariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_586_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e042e9cac08d", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_060d7318ed68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >)  { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures single_digit_number_to_char (n as nat) == output , char_vec @ == number_to_char (n as nat) , char_vec @ == number_to_char (n as nat) , decreases n\ndecreases n , n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "060d7318ed68", "function_name": "number_to_char_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_dc79c0fb0aec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)   { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_of_list_precond (lst @) \nensures max_of_list_postcond (lst @ , result) \ndecreases lst . len () - i \ninvariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "dc79c0fb0aec", "function_name": "max_of_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c2bf3cd57575", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/filter_weak.rs", "verified": true, "metadata": {"original_id": "c2bf3cd57575", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_19a6d9bf2e8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_avg/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "19a6d9bf2e8e", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9a96518386dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "9a96518386dd", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2e001cd80059", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j as int] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j as int] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "2e001cd80059", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b74dc91e1167", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)   { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_of_list_precond (lst @) \nensures max_of_list_postcond (lst @ , result) \ndecreases lst . len () - i \ninvariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_39/verina_advanced_39_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b74dc91e1167", "function_name": "max_of_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_552d73d621e7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  {    result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "552d73d621e7", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_40f5d07b3997", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases j\ninvariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/reverse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "40f5d07b3997", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cf96657aad73", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >)   { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len ()  { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "target_text": "requires find_smallest_precond (s @) \nensures find_smallest_postcond (s @ , result) \ndecreases s . len () - i \ninvariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_2/verina_basic_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cf96657aad73", "function_name": "find_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ca65ef766ffb", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ndecreases nums . len () - idx\ninvariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/findmax_impl.rs", "verified": true, "metadata": {"original_id": "ca65ef766ffb", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6d602cf559d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx : usize = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx : usize = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "6d602cf559d5", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b9c1d5c54120", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list @ . len () - i , n - j \ninvariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "b9c1d5c54120", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5bbab599ec56", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32)  { if x >= y { x } else { y } }\n\n} // verus!", "target_text": "ensures r >= x && r >= y , r == x || r == y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "5bbab599ec56", "function_name": "Max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b43b0fe6a5bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/unique_better_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b43b0fe6a5bc", "function_name": "unique_better", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c543be5855ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "c543be5855ae", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d825a717b1f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len ()  { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - index \ninvariant 0 < index <= lists . len () , min_length == lists [0] . len () || exists | j : int | # ! [auto] 1 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len () invariant 0 < index <= lists . len () , min_length == lists [0] . len () || exists | j : int | # ! [auto] 1 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () , decreases lists . len () - index , { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "d825a717b1f8", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_322bd234c857", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len ()  { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - j \ninvariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "322bd234c857", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f001f5ced977", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f001f5ced977", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e6b58a67275b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut idx = 0 ; while idx < arr1 . len ()  {    if arr1 [idx] <= arr2 [idx] {   return false ; } idx += 1 ; }  true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - idx \ninvariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e6b58a67275b", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_583214b13fb7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s4if_impl.rs", "verified": true, "metadata": {"original_id": "583214b13fb7", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_90d3f62990f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX\nensures longest_increasing_subsequence_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32) requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX ensures longest_increasing_subsequence_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_34/verina_advanced_34.rs", "verified": true, "metadata": {"original_id": "90d3f62990f2", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fb8fe6ce0b4c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >)  { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures single_digit_number_to_char (n as nat) == output , char_vec @ == number_to_char (n as nat) , char_vec @ == number_to_char (n as nat) , decreases n\ndecreases n , n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_impl.rs", "verified": true, "metadata": {"original_id": "fb8fe6ce0b4c", "function_name": "number_to_char_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ac591ad72f9a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "ac591ad72f9a", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_198202ea060b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx { let c = str1 [idx] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "198202ea060b", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1d6324b3cfd8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1d6324b3cfd8", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8b201773d392", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32)   { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_min_impl.rs", "verified": true, "metadata": {"original_id": "8b201773d392", "function_name": "min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_vostd_map_extra_a1f35ebe1435", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::{map::*, set::*};\n\nverus! {\n\n/// The length of inserting a key-value pair `(k,v)` into a map `m` depends on whether\n/// the key `k` already exists in the map. If it does, the length remains the same;\n/// if it doesn't, the length increases by 1.\npub proof fn lemma_map_insert_len<K, V>(m: Map<K, V>, k: K, v: V)\n\n     {\n            0int\n        } else {\n            1\n        }),\n{\n    axiom_map_insert_domain(m, k, v)\n}\n\n/// The length of removing a key-value pair `(k,v)` from a map `m` depends on whether\n/// the key `k` exists in the map. If it does, the length {\n            1\n        } else {\n            0int\n        }),\n{\n    axiom_map_remove_domain(m, k)\n}\n\n/// Filters a map based on a predicate function applied to its values.\npub open spec fn value_filter<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> Map<K, V> {\n    m.restrict(m.dom().filter(|s| f(m[s])))\n}\n\npub open spec fn value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> K {\n    choose|k: K| value_filter(m, f).contains_key(k)\n}\n\npub broadcast group group_value_filter_lemmas {\n    lemma_value_filter_finite,\n    lemma_value_filter_choose,\n    lemma_insert_value_filter_same_len,\n    lemma_insert_value_filter_different_len_contains,\n    lemma_insert_value_filter_different_len_not_contains,\n}\n\n/// The result of value-filtering a finite map is also finite.\npub broadcast proof fn lemma_value_filter_finite<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n\n{\n\n    m.dom().lemma_len_filter(|s| f(m[s]));\n}\n\n/// If a key `k` exists in the map `m`, then whether the value-filtered map\n/// contains the key depends on whether the predicate function `f` is true for\n/// its value.\npub proof fn lemma_value_filter_contains<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n\n     {\n            value_filter(m, f).contains_key(k)\n        } else {\n            !value_filter(m, f).contains_key(k)\n        },\n{\n}\n\n/// If the predicate function `f` is true for all values in the map `m`, then\n/// the value-filtered map is equal to the original map.\npub proof fn lemma_value_filter_all_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n\n{\n}\n\n/// If the predicate function `f` is false for all values in the map `m`, then\n/// the value-filtered map is empty.\npub proof fn lemma_value_filter_all_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n\n{\n    if value_filter(m, f).is_empty() {\n        }\n    }\n}\n\n/// If the predicate function `f` is true for `m[k]`, then fist removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// applying the value filter first and then removing `k` from the result.\npub proof fn lemma_remove_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n\n{\n}\n\n/// If the predicate function `f` is false for `m[k]`, then first removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// directly applying the value filter to the original map `m`.\npub proof fn lemma_remove_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n\n{\n}\n\n/// If the predicate function `f` is true for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then inserting `(k,v)` into the result.\npub proof fn lemma_insert_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n\n{\n}\n\n/// If the predicate function `f` is false for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then removing `k` from the result (if 'k' exists in 'm') or leaving it unchanged\n/// (if it doesn't).\npub proof fn lemma_insert_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n\n     {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n{\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// if `k` exists in `m`, and `m[k]` and `v` both satisfy/un-satisfy the predicate\n/// function `f`.\npub broadcast proof fn lemma_insert_value_filter_same_len<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n\n{\n    lemma_value_filter_finite(m, f);\n    if f(v) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(value_filter(m, f), k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `m[k]` does not satisfy `f` but `v` does, and minus one if\n/// `m[k]` satisfies `f` but `v` does not.\npub broadcast proof fn lemma_insert_value_filter_different_len_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n\n     {\n            1\n        } else {\n            -1\n        },\n{\n    lemma_value_filter_finite(m, f);\n    if (f(v)) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(m, k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `k` does not exist in `m` and `v` satisfies the predicate function `f`.\npub broadcast proof fn lemma_insert_value_filter_different_len_not_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n\n{\n    lemma_value_filter_finite(m, f);\n    lemma_insert_value_filter_true(m, f, k, v);\n    lemma_map_insert_len(m, k, v);\n}\n\npub proof fn lemma_value_filter_contains_key<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n\n{\n}\n\npub broadcast proof fn lemma_value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n\n{\n    if value_filter(m, f).dom().finite() {\n        axiom_set_choose_len(value_filter(m, f).dom());\n    } else {\n        axiom_set_choose_infinite(value_filter(m, f).dom());\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(k,v)` holds for all `(k,v)` in `map`.\npub open spec fn forall_map<K, V>(map: Map<K, V>, f: spec_fn(K, V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(k, map[k])\n}\n\n/// Returns true if predicate `f(v)` holds for all values in `map`.\npub open spec fn forall_map_values<K, V>(map: Map<K, V>, f: spec_fn(V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(map[k])\n}\n\npub broadcast group group_forall_map_lemmas {\n    lemma_forall_map_insert,\n    lemma_forall_map_values_insert,\n    lemma_forall_map_remove,\n    lemma_forall_map_values_remove,\n}\n\n/// For any key in the map, `f(k, map[k])` holds if `forall_map(map, f)` holds.\npub proof fn lemma_forall_map_entry<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n\n{\n}\n\n/// For any key in the map, `f(map[k])` holds if `forall_map_values(map, f)` holds.\npub proof fn lemma_forall_map_values_entry<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n\n{\n}\n\n/// `forall_map(m.insert(k, v), f)` holds if `f(k, v)` holds and\n/// `forall_map(m.remove(k),f)` (if `m` contains `k`) or `forall_map(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(K, V) -> bool,\n    k: K,\n    v: V,\n)\n     {\n            forall_map(m.remove(k), f)\n        } else {\n            forall_map(m, f)\n        },\n{\n\n    if m.contains_key(k) {\n\n    } else {\n\n    }\n    if forall_map(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n\n        }\n    }\n}\n\n/// `forall_map_values(m.insert(k, v), f)` holds if `f(v)` holds and\n/// `forall_map_values(m.remove(k),f)` (if `m` contains `k`) or `forall_map_values(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_values_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n     {\n            forall_map_values(m.remove(k), f)\n        } else {\n            forall_map_values(m, f)\n        },\n{\n\n    if m.contains_key(k) {\n\n    } else {\n\n    }\n    if forall_map_values(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n\n        }\n    }\n}\n\n/// `forall_map(m,f)` holds if `forall_map(m.remove(k), f)` holds and\n/// `f(k, m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_remove<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n\n{\n    if m.contains_key(k) {\n\n    } else {\n\n    }\n}\n\n/// `forall_map_values(m,f)` holds if `forall_map_values(m.remove(k), f)` holds and\n/// `f(m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_values_remove<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n)\n\n{\n    if m.contains_key(k) {\n\n    } else {\n\n    }\n\n}\n\n/// Returns a new map that projects the first key of a pair `(K1, K2)`,\n/// keeping the values associated with the second key `K2`.\npub open spec fn project_first_key<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1) -> Map<K2, V> {\n    Map::new(|k2: K2| m.contains_key((k1, k2)), |k2: K2| m[(k1, k2)])\n}\n\n/// Returns a new map that projects the second key of a pair `(K1, K2)`,\n/// keeping the values associated with the first key `K1`.\npub open spec fn project_second_key<K1, K2, V>(m: Map<(K1, K2), V>, k2: K2) -> Map<K1, V> {\n    Map::new(|k1: K1| m.contains_key((k1, k2)), |k1: K1| m[(k1, k2)])\n}\n\n/// A lemma showing that `project_first_key`` is sound.\n/// There is no need to actually use this lemma in practice at most of the time because Verus can automatically prove it.\npub proof fn lemma_project_first_key_sound<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n\n            {\n                &&& #[trigger] project_first_key(m, k1).contains_key(k2) <==> m.contains_key(\n                    (k1, k2),\n                )\n                &&& project_first_key(m, k1).contains_key(k2) ==> project_first_key(m, k1)[k2]\n                    == m[(k1, k2)]\n            },\n{\n}\n\n/// If the value filter of the projected map is non-empty, then there exists a key `k2`\n/// such that the original map contains the pair `(k1, k2)` and `m[(k1, k2)]` satisfies the predicate `f`.\npub proof fn lemma_project_first_key_value_filter_non_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n\n{\n    lemma_value_filter_choose(project_first_key(m, k1), f);\n    let k2 = value_filter_choose(project_first_key(m, k1), f);\n\n}\n\npub proof fn lemma_project_first_key_value_filter_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n\n{\n    }\n}\n\n/// If the original map is finite, then the projected map is also finite.\npub proof fn lemma_project_first_key_finite<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n\n    {\n    if m.dom().len() == 0 {\n\n    } else {\n        let pair = m.dom().choose();\n        lemma_project_first_key_finite(m.remove(pair), k1);\n        if pair.0 != k1 {\n\n        } else {\n\n        }\n    }\n}\n\n} // verus!\n", "target_text": "requires m.dom().finite(), m.dom().finite(), m.dom().finite(), m.contains_key(k), forall|k: K| m.contains_key(k) ==> #[trigger] f(m[k]), f(m[k]), !f(m[k]), f(v), !f(v), m.dom().finite(),\n        m.contains_key(k) && f(m[k]) == f(v) || !m.contains_key(k) && !f(v), m.dom().finite(),\n        m.contains_key(k),\n        f(m[k]) != f(v), m.dom().finite(),\n        !m.contains_key(k),\n        f(v), value_filter(m, f).contains_key(k), value_filter(m, f).len() != 0, forall_map(m, f),\n        m.contains_key(k), forall_map_values(m, f),\n        m.contains_key(k), value_filter(project_first_key(m, k1), f).len() != 0, m.dom().finite(),\n        value_filter(project_first_key(m, k1), f).len() == 0, m.dom().finite()\nensures #[trigger] m.insert(k, v).len() == m.len() + (if m.contains_key(k), m.len() == #[trigger] m.remove(k).len() + (if m.contains_key(k), #[trigger] value_filter(m, f).dom().finite(), if f(m[k]), value_filter(m, f) =~= m, value_filter(m, f).is_empty() <==> forall|k: K| m.contains_key(k) ==> !#[trigger] f(m[k]), value_filter(m.remove(k), f) =~= value_filter(m, f).remove(k), value_filter(m.remove(k), f) =~= value_filter(m, f), value_filter(m.insert(k, v), f) =~= value_filter(m, f).insert(k, v), value_filter(m.insert(k, v), f) =~= if m.contains_key(k), #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len(), #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + if f(v), #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + 1, m.contains_key(k), value_filter(m, f).contains_key(#[trigger] value_filter_choose(m, f)),\n        f(m[value_filter_choose(m, f)]), f(k, m[k]), f(m[k]), #[trigger] forall_map(m.insert(k, v), f) ==> f(k, v) && if m.contains_key(k), #[trigger] forall_map_values(m.insert(k, v), f) ==> f(v) && if m.contains_key(k), forall_map(m, f) <==> #[trigger] forall_map(m.remove(k), f) && (m.contains_key(k) ==> f(\n            k,\n            m[k],\n        )), forall_map_values(m, f) <==> #[trigger] forall_map_values(m.remove(k), f) && (\n        m.contains_key(k) ==> f(m[k])), forall|k2: K2|, exists|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) && f(project_first_key(m, k1)[k2]), forall|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) ==> !f(project_first_key(m, k1)[k2]), project_first_key(m, k1).dom().finite(), project_first_key(m, k1).dom().finite(),\n    decreases m.dom().len()\ndecreases by 1; if it doesn't,\n/// the length remains the same.\npub proof fn lemma_map_remove_len<K, V>(m: Map<K, V>, k: K)\n    requires\n        m.dom().finite(),\n    ensures\n        m.len() == #[trigger] m.remove(k).len() + (if m.contains_key(k), m.dom().len()", "full_verified_code": "use vstd::prelude::*;\nuse vstd::{map::*, set::*};\n\nverus! {\n\n/// The length of inserting a key-value pair `(k,v)` into a map `m` depends on whether\n/// the key `k` already exists in the map. If it does, the length remains the same;\n/// if it doesn't, the length increases by 1.\npub proof fn lemma_map_insert_len<K, V>(m: Map<K, V>, k: K, v: V)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] m.insert(k, v).len() == m.len() + (if m.contains_key(k) {\n            0int\n        } else {\n            1\n        }),\n{\n    axiom_map_insert_domain(m, k, v)\n}\n\n/// The length of removing a key-value pair `(k,v)` from a map `m` depends on whether\n/// the key `k` exists in the map. If it does, the length decreases by 1; if it doesn't,\n/// the length remains the same.\npub proof fn lemma_map_remove_len<K, V>(m: Map<K, V>, k: K)\n    requires\n        m.dom().finite(),\n    ensures\n        m.len() == #[trigger] m.remove(k).len() + (if m.contains_key(k) {\n            1\n        } else {\n            0int\n        }),\n{\n    axiom_map_remove_domain(m, k)\n}\n\n/// Filters a map based on a predicate function applied to its values.\npub open spec fn value_filter<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> Map<K, V> {\n    m.restrict(m.dom().filter(|s| f(m[s])))\n}\n\npub open spec fn value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> K {\n    choose|k: K| value_filter(m, f).contains_key(k)\n}\n\npub broadcast group group_value_filter_lemmas {\n    lemma_value_filter_finite,\n    lemma_value_filter_choose,\n    lemma_insert_value_filter_same_len,\n    lemma_insert_value_filter_different_len_contains,\n    lemma_insert_value_filter_different_len_not_contains,\n}\n\n/// The result of value-filtering a finite map is also finite.\npub broadcast proof fn lemma_value_filter_finite<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] value_filter(m, f).dom().finite(),\n{\n    assert(value_filter(m, f).dom() == m.dom().filter(|s| f(m[s])));\n    m.dom().lemma_len_filter(|s| f(m[s]));\n}\n\n/// If a key `k` exists in the map `m`, then whether the value-filtered map\n/// contains the key depends on whether the predicate function `f` is true for\n/// its value.\npub proof fn lemma_value_filter_contains<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        m.contains_key(k),\n    ensures\n        if f(m[k]) {\n            value_filter(m, f).contains_key(k)\n        } else {\n            !value_filter(m, f).contains_key(k)\n        },\n{\n}\n\n/// If the predicate function `f` is true for all values in the map `m`, then\n/// the value-filtered map is equal to the original map.\npub proof fn lemma_value_filter_all_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        forall|k: K| m.contains_key(k) ==> #[trigger] f(m[k]),\n    ensures\n        value_filter(m, f) =~= m,\n{\n}\n\n/// If the predicate function `f` is false for all values in the map `m`, then\n/// the value-filtered map is empty.\npub proof fn lemma_value_filter_all_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    ensures\n        value_filter(m, f).is_empty() <==> forall|k: K| m.contains_key(k) ==> !#[trigger] f(m[k]),\n{\n    if value_filter(m, f).is_empty() {\n        assert forall|k: K| m.contains_key(k) implies !#[trigger] f(m[k]) by {\n            if f(m[k]) {\n                assert(value_filter(m, f).contains_key(k));\n            }\n        }\n    }\n}\n\n/// If the predicate function `f` is true for `m[k]`, then fist removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// applying the value filter first and then removing `k` from the result.\npub proof fn lemma_remove_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f).remove(k),\n{\n}\n\n/// If the predicate function `f` is false for `m[k]`, then first removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// directly applying the value filter to the original map `m`.\npub proof fn lemma_remove_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        !f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f),\n{\n}\n\n/// If the predicate function `f` is true for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then inserting `(k,v)` into the result.\npub proof fn lemma_insert_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= value_filter(m, f).insert(k, v),\n{\n}\n\n/// If the predicate function `f` is false for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then removing `k` from the result (if 'k' exists in 'm') or leaving it unchanged\n/// (if it doesn't).\npub proof fn lemma_insert_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        !f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n{\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// if `k` exists in `m`, and `m[k]` and `v` both satisfy/un-satisfy the predicate\n/// function `f`.\npub broadcast proof fn lemma_insert_value_filter_same_len<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k) && f(m[k]) == f(v) || !m.contains_key(k) && !f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len(),\n{\n    lemma_value_filter_finite(m, f);\n    if f(v) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(value_filter(m, f), k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `m[k]` does not satisfy `f` but `v` does, and minus one if\n/// `m[k]` satisfies `f` but `v` does not.\npub broadcast proof fn lemma_insert_value_filter_different_len_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k),\n        f(m[k]) != f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + if f(v) {\n            1\n        } else {\n            -1\n        },\n{\n    lemma_value_filter_finite(m, f);\n    if (f(v)) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(m, k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        assert(value_filter(m.insert(k, v), f).len() == value_filter(m, f).remove(k).len());\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `k` does not exist in `m` and `v` satisfies the predicate function `f`.\npub broadcast proof fn lemma_insert_value_filter_different_len_not_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        !m.contains_key(k),\n        f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + 1,\n{\n    lemma_value_filter_finite(m, f);\n    lemma_insert_value_filter_true(m, f, k, v);\n    lemma_map_insert_len(m, k, v);\n}\n\npub proof fn lemma_value_filter_contains_key<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        value_filter(m, f).contains_key(k),\n    ensures\n        m.contains_key(k),\n{\n}\n\npub broadcast proof fn lemma_value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        value_filter(m, f).len() != 0,\n    ensures\n        value_filter(m, f).contains_key(#[trigger] value_filter_choose(m, f)),\n        f(m[value_filter_choose(m, f)]),\n{\n    if value_filter(m, f).dom().finite() {\n        axiom_set_choose_len(value_filter(m, f).dom());\n    } else {\n        axiom_set_choose_infinite(value_filter(m, f).dom());\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(k,v)` holds for all `(k,v)` in `map`.\npub open spec fn forall_map<K, V>(map: Map<K, V>, f: spec_fn(K, V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(k, map[k])\n}\n\n/// Returns true if predicate `f(v)` holds for all values in `map`.\npub open spec fn forall_map_values<K, V>(map: Map<K, V>, f: spec_fn(V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(map[k])\n}\n\npub broadcast group group_forall_map_lemmas {\n    lemma_forall_map_insert,\n    lemma_forall_map_values_insert,\n    lemma_forall_map_remove,\n    lemma_forall_map_values_remove,\n}\n\n/// For any key in the map, `f(k, map[k])` holds if `forall_map(map, f)` holds.\npub proof fn lemma_forall_map_entry<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    requires\n        forall_map(m, f),\n        m.contains_key(k),\n    ensures\n        f(k, m[k]),\n{\n}\n\n/// For any key in the map, `f(map[k])` holds if `forall_map_values(map, f)` holds.\npub proof fn lemma_forall_map_values_entry<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        forall_map_values(m, f),\n        m.contains_key(k),\n    ensures\n        f(m[k]),\n{\n}\n\n/// `forall_map(m.insert(k, v), f)` holds if `f(k, v)` holds and\n/// `forall_map(m.remove(k),f)` (if `m` contains `k`) or `forall_map(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(K, V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map(m.insert(k, v), f) ==> f(k, v) && if m.contains_key(k) {\n            forall_map(m.remove(k), f)\n        } else {\n            forall_map(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map_values(m.insert(k, v), f)` holds if `f(v)` holds and\n/// `forall_map_values(m.remove(k),f)` (if `m` contains `k`) or `forall_map_values(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_values_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map_values(m.insert(k, v), f) ==> f(v) && if m.contains_key(k) {\n            forall_map_values(m.remove(k), f)\n        } else {\n            forall_map_values(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map_values(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map(m,f)` holds if `forall_map(m.remove(k), f)` holds and\n/// `f(k, m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_remove<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    ensures\n        forall_map(m, f) <==> #[trigger] forall_map(m.remove(k), f) && (m.contains_key(k) ==> f(\n            k,\n            m[k],\n        )),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n}\n\n/// `forall_map_values(m,f)` holds if `forall_map_values(m.remove(k), f)` holds and\n/// `f(m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_values_remove<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n)\n    ensures\n        forall_map_values(m, f) <==> #[trigger] forall_map_values(m.remove(k), f) && (\n        m.contains_key(k) ==> f(m[k])),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n\n}\n\n/// Returns a new map that projects the first key of a pair `(K1, K2)`,\n/// keeping the values associated with the second key `K2`.\npub open spec fn project_first_key<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1) -> Map<K2, V> {\n    Map::new(|k2: K2| m.contains_key((k1, k2)), |k2: K2| m[(k1, k2)])\n}\n\n/// Returns a new map that projects the second key of a pair `(K1, K2)`,\n/// keeping the values associated with the first key `K1`.\npub open spec fn project_second_key<K1, K2, V>(m: Map<(K1, K2), V>, k2: K2) -> Map<K1, V> {\n    Map::new(|k1: K1| m.contains_key((k1, k2)), |k1: K1| m[(k1, k2)])\n}\n\n/// A lemma showing that `project_first_key`` is sound.\n/// There is no need to actually use this lemma in practice at most of the time because Verus can automatically prove it.\npub proof fn lemma_project_first_key_sound<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    ensures\n        forall|k2: K2|\n            {\n                &&& #[trigger] project_first_key(m, k1).contains_key(k2) <==> m.contains_key(\n                    (k1, k2),\n                )\n                &&& project_first_key(m, k1).contains_key(k2) ==> project_first_key(m, k1)[k2]\n                    == m[(k1, k2)]\n            },\n{\n}\n\n/// If the value filter of the projected map is non-empty, then there exists a key `k2`\n/// such that the original map contains the pair `(k1, k2)` and `m[(k1, k2)]` satisfies the predicate `f`.\npub proof fn lemma_project_first_key_value_filter_non_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        value_filter(project_first_key(m, k1), f).len() != 0,\n    ensures\n        exists|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) && f(project_first_key(m, k1)[k2]),\n{\n    lemma_value_filter_choose(project_first_key(m, k1), f);\n    let k2 = value_filter_choose(project_first_key(m, k1), f);\n    assert(project_first_key(m, k1).contains_key(k2) && f(m[(k1, k2)]));\n}\n\npub proof fn lemma_project_first_key_value_filter_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        m.dom().finite(),\n        value_filter(project_first_key(m, k1), f).len() == 0,\n    ensures\n        forall|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) ==> !f(project_first_key(m, k1)[k2]),\n{\n    assert forall|k2: K2| #[trigger] project_first_key(m, k1).contains_key(k2) implies !f(\n        project_first_key(m, k1)[k2],\n    ) by {\n        if f(project_first_key(m, k1)[k2]) {\n            assert(value_filter(project_first_key(m, k1), f).dom().contains(k2));\n            lemma_project_first_key_finite(m, k1);\n            lemma_value_filter_finite(project_first_key(m, k1), f);\n            Set::lemma_len0_is_empty(value_filter(project_first_key(m, k1), f).dom());\n            assert(false);\n        }\n    }\n}\n\n/// If the original map is finite, then the projected map is also finite.\npub proof fn lemma_project_first_key_finite<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    requires\n        m.dom().finite(),\n    ensures\n        project_first_key(m, k1).dom().finite(),\n    decreases m.dom().len(),\n{\n    if m.dom().len() == 0 {\n        assert(project_first_key(m, k1).dom() == Set::<K2>::empty());\n    } else {\n        let pair = m.dom().choose();\n        lemma_project_first_key_finite(m.remove(pair), k1);\n        if pair.0 != k1 {\n            assert(project_first_key(m, k1) == project_first_key(m.remove(pair), k1));\n        } else {\n            assert(project_first_key(m, k1).dom() == project_first_key(\n                m.remove(pair),\n                k1,\n            ).dom().insert(pair.1));\n        }\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/map_extra.rs", "verified": true, "metadata": {"original_id": "vostd_map_extra_a1f35ebe1435", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4611ed5c0662", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_43/verina_basic_43_impl.rs", "verified": true, "metadata": {"original_id": "4611ed5c0662", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_bst_map_62a66282bf35", "task": "task_a", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n\n        {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n\n        {\n        if key == self.key {\n            self.value = value;\n\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n\n        {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n\n        {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n         {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n         { Some(&self.as_map()[key]) } else { None }),\n        {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n\n            Self::get_from_optional(&self.left, key)\n        } else {\n\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n         { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    tree_map.delete(17);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "requires old(node).is_some() ==> old(node).unwrap().well_formed(), old(self).well_formed(), old(self).well_formed(), old(node).is_some() ==> old(node).unwrap().well_formed(), old(node).is_some(),\n            old(node).unwrap().well_formed(), old(self).well_formed(), node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node, self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key), self.well_formed(),\n        returns\n            (if self@.dom().contains(key), tree_map.well_formed()\nensures tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value), self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem, self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node)\ndecreases node_opt, self, self, *old(node), *old(self), *old(node), *old(node), node, self", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_62a66282bf35", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a36bf648885d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32)   { x + 15 }\n\n} // verus!", "target_text": "requires 10 <= x <= 1000\nensures 25 <= y", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32) requires 10 <= x <= 1000 ensures 25 <= y { x + 15 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a36bf648885d", "function_name": "MyMethod", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7ad7d4238da4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "7ad7d4238da4", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_vectors_b2d489eae1bd", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn reverse(v: &mut Vec<u64>)\n\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\n#[verifier::loop_isolation(false)]\nfn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)\n\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n\n    {\n        let ghost d = i2 - i1;\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n\n    }\n    i1\n}\n\n#[verifier::loop_isolation(false)]\nfn reverse_no_spinoff(v: &mut Vec<u64>)\n\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\nfn pusher() -> Vec<u64> {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    v.push(4);\n    let ghost goal = Seq::new(5, |i: int| i as u64);\n\n    v.pop();\n    v.push(4);\n\n    v\n}\n\nuninterp spec fn uninterp_fn(x: u64) -> bool;\n\nfn pop_test(t: Vec<u64>)\n\n{\n    let mut t = t;\n    let x = t.pop().unwrap();\n\n}\n\nfn push_test(t: Vec<u64>, y: u64)\n\n{\n    let mut t = t;\n    t.push(y);\n\n}\n\n} // verus!\nfn main() {\n    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    println!(\"{}\", binary_search(&v, 70));\n    println!();\n    reverse(&mut v);\n    for x in v {\n        println!(\"{}\", x);\n    }\n\n    println!(\"Pushed 5 values:\");\n    for x in pusher() {\n        println!(\"{}\", x);\n    }\n}\n", "target_text": "requires forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i], forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i], t.len() > 0,\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]), forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y)\nensures r < v.len(),\n        k == v[r as int], v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1], r < v.len(),\n        k == v[r as int], v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1]\ndecreases i2 - i1, i2 - i1\ninvariant i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j], length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i], i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i], length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i]", "full_verified_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn reverse(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\n#[verifier::loop_isolation(false)]\nfn binary_search_no_spinoff(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n        decreases i2 - i1,\n    {\n        let ghost d = i2 - i1;\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n        assert(i2 - i1 < d);\n    }\n    i1\n}\n\n#[verifier::loop_isolation(false)]\nfn reverse_no_spinoff(v: &mut Vec<u64>)\n    ensures\n        v.len() == old(v).len(),\n        forall|i: int| 0 <= i < old(v).len() ==> v[i] == old(v)[old(v).len() - i - 1],\n{\n    let length = v.len();\n    let ghost v1 = v@;\n    for n in 0..(length / 2)\n        invariant\n            length == v.len(),\n            forall|i: int| 0 <= i < n ==> v[i] == v1[length - i - 1],\n            forall|i: int| 0 <= i < n ==> v1[i] == v[length - i - 1],\n            forall|i: int| n <= i && i + n < length ==> #[trigger] v[i] == v1[i],\n    {\n        let x = v[n];\n        let y = v[length - 1 - n];\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n    }\n}\n\nfn pusher() -> Vec<u64> {\n    let mut v = Vec::new();\n    v.push(0);\n    v.push(1);\n    v.push(2);\n    v.push(3);\n    v.push(4);\n    let ghost goal = Seq::new(5, |i: int| i as u64);\n    assert(v@ =~= goal);\n    assert(v[2] == 2);\n    v.pop();\n    v.push(4);\n    assert(v@ =~= goal);\n    v\n}\n\nuninterp spec fn uninterp_fn(x: u64) -> bool;\n\nfn pop_test(t: Vec<u64>)\n    requires\n        t.len() > 0,\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n{\n    let mut t = t;\n    let x = t.pop().unwrap();\n    assert(uninterp_fn(x));\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\nfn push_test(t: Vec<u64>, y: u64)\n    requires\n        forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]),\n        uninterp_fn(y),\n{\n    let mut t = t;\n    t.push(y);\n    assert(forall|i: int| #![auto] 0 <= i < t.len() ==> uninterp_fn(t[i]));\n}\n\n} // verus!\nfn main() {\n    let mut v = vec![0, 10, 20, 30, 40, 50, 60, 70, 80, 90];\n    println!(\"{}\", binary_search(&v, 70));\n    println!();\n    reverse(&mut v);\n    for x in v {\n        println!(\"{}\", x);\n    }\n\n    println!(\"Pushed 5 values:\");\n    for x in pusher() {\n        println!(\"{}\", x);\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/vectors.rs", "verified": true, "metadata": {"original_id": "verus_vectors_b2d489eae1bd", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_79e4faecada6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "79e4faecada6", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_98bbc66b5fa6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { return binary_search_recursive (v , elem , mid + 1 , f) ; } else { return binary_search_recursive (v , elem , c , mid - 1) ; } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { return binary_search_recursive (v , elem , mid + 1 , f) ; } else { return binary_search_recursive (v , elem , c , mid - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "98bbc66b5fa6", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a93966c76536", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a93966c76536", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1e0ee0de7a1b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "1e0ee0de7a1b", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_aa21f257d2de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "aa21f257d2de", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a7d07e85cdf7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len ()\nensures result <= nums . len (), result <= nums . len () decreases nums . len () - idx\ndecreases nums . len () - idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a7d07e85cdf7", "function_name": "longest_increasing_streak_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0af91bffe18f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0af91bffe18f", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a7733bc6c36c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { false }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a7733bc6c36c", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e2ed5df5f5bf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)   { let mut i = 0 ; while i < x . len ()  { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB \nensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "e2ed5df5f5bf", "function_name": "myfun2", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7959cef72ca9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let division_result = arr1 [i] / arr2 [i] ; result . push (division_result) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i \ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let division_result = arr1 [i] / arr2 [i] ; result . push (division_result) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "7959cef72ca9", "function_name": "element_wise_division", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1f06fb34afe9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "1f06fb34afe9", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9f1be843d987", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9f1be843d987", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a95f4205bbca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "a95f4205bbca", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_01b0e8384b49", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires difference_min_max_precond (a)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32) requires difference_min_max_precond (a) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_23/verina_basic_23_iter_0_original.rs", "verified": true, "metadata": {"original_id": "01b0e8384b49", "function_name": "difference_min_max", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0306fe9a5801", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >)  { let len = a . len () ; let mut i : usize = 0 ; while i < len  { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \ndecreases len - i, len - j\ninvariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_selectionsort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0306fe9a5801", "function_name": "selection_sort", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4b07a583ad56", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4b07a583ad56", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1a57e53fca47", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_68/verina_basic_68_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1a57e53fca47", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1839b2af5d5d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s2if_impl.rs", "verified": true, "metadata": {"original_id": "1839b2af5d5d", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0f6e1bbdfe8c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len ()  { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique_impl.rs", "verified": true, "metadata": {"original_id": "0f6e1bbdfe8c", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e75adfdfc345", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "e75adfdfc345", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2229ff3b20ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right  { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()\ndecreases right - left\ninvariant left <= right <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_24/verina_advanced_24_impl.rs", "verified": true, "metadata": {"original_id": "2229ff3b20ec", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_152e3b47b1f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if (n % i) == 0 {    return false ; } i = i + 1 ; }   return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if (n % i) == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "152e3b47b1f2", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1724c5b4309e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1724c5b4309e", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_717d1b5b1bc2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple3/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "717d1b5b1bc2", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1238ec7a1dc4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_odd_at_index_odd_precond (a @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool) requires is_odd_at_index_odd_precond (a @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_44/verina_basic_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1238ec7a1dc4", "function_name": "is_odd_at_index_odd", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7b3ff3eab4b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7b3ff3eab4b6", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2f9be6b03364", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f9be6b03364", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5bad090f8fd5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires rain_precond (heights @) \nensures rain_postcond (heights @ , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_62/verina_advanced_62_iter_0_original.rs", "verified": true, "metadata": {"original_id": "5bad090f8fd5", "function_name": "rain", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9f8fba720391", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9f8fba720391", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ea4aa97c6d20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ea4aa97c6d20", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c6d460687d5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/060-sum_to_n.rs", "verified": true, "metadata": {"original_id": "c6d460687d5f", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_260ee288b5cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left \ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left , { if ! a [left] { left += 1 ; } else if a [right - 1] { right -= 1 ; } else { swap (a , left , right - 1) ; left += 1 ; right -= 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "260ee288b5cf", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_requires_ensures_1f3807d45949", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nfn print_two_digit_number(i: i8)\n\n{\n    println!(\"The answer is {}\", i);\n}\n\nfn octuple(x1: i8) -> (x8: i8)\n\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n\nfn main() {\n    let n = octuple(10);\n\n    print_two_digit_number(n);\n}\n\n} // verus!\n", "target_text": "requires -99 <= i < 100, -16 <= x1 < 16\nensures x8 == 8 * x1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nfn print_two_digit_number(i: i8)\n    requires\n        -99 <= i < 100,\n{\n    println!(\"The answer is {}\", i);\n}\n\nfn octuple(x1: i8) -> (x8: i8)\n    requires\n        -16 <= x1 < 16,\n    ensures\n        x8 == 8 * x1,\n{\n    let x2 = x1 + x1;\n    let x4 = x2 + x2;\n    x4 + x4\n}\n\nfn main() {\n    let n = octuple(10);\n    assert(n == 80);\n    print_two_digit_number(n);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/requires_ensures.rs", "verified": true, "metadata": {"original_id": "verus_requires_ensures_1f3807d45949", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5ee60dca4f3f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "5ee60dca4f3f", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_96d7cbfd7fd9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >) ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/062-derivative_iter_0_original.rs", "verified": true, "metadata": {"original_id": "96d7cbfd7fd9", "function_name": "derivative", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_lib_12891addb104", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::*;\n\nverus! {\n\nproof fn contradiction_test() {\n    assert_by_contradiction!(1 == 0 + 1, {\n\n    });\n}\n\nproof fn map_test() {\n    let m1 = map![1nat => true, 2 => false];\n    let m2 = map![1nat => true, 2 => false];\n    assert_maps_equal!(m1, m2);\n}\n\nproof fn seq_test() {\n    let s1 = seq![true, false];\n    let s2 = Seq::empty().push(true).push(false);\n    assert_seqs_equal!(s1, s2);\n}\n\nproof fn calc_test(x: int, y: int, z: int)\n\n{\n    calc! {\n        (==)\n        x + y;\n            {}\n        z;\n    }\n}\n\npub fn do_something(x: u64, y: u64, z: u64) -> (w: u64)\n\n{\n\n    if x < y {\n        x\n    } else {\n        z\n    }\n}\n\n} // verus!\n", "target_text": "requires x + y == z, x + y == z", "full_verified_code": "use vstd::prelude::*;\nuse vstd::*;\n\nverus! {\n\nproof fn contradiction_test() {\n    assert_by_contradiction!(1 == 0 + 1, {\n        assert(false);\n    });\n}\n\nproof fn map_test() {\n    let m1 = map![1nat => true, 2 => false];\n    let m2 = map![1nat => true, 2 => false];\n    assert_maps_equal!(m1, m2);\n}\n\nproof fn seq_test() {\n    let s1 = seq![true, false];\n    let s2 = Seq::empty().push(true).push(false);\n    assert_seqs_equal!(s1, s2);\n}\n\nproof fn calc_test(x: int, y: int, z: int) \n    requires x + y == z,\n{\n    calc! {\n        (==)\n        x + y; \n            {}\n        z;\n    }\n}\n\npub fn do_something(x: u64, y: u64, z: u64) -> (w: u64)\n    requires x + y == z,\n{\n    proof {\n        calc_test(x as int, y as int, z as int);\n    }\n    if x < y {\n        x\n    } else {\n        z\n    }\n}\n\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/vstd_macro_usage/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_12891addb104", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_33692cd4e3cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >)   { let mut result = dest ; let mut i = 0 ; while i < len  { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires src . len () >= s_start + len , dest . len () >= d_start + len \nensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) \ndecreases len - i\ninvariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >) requires src . len () >= s_start + len , dest . len () >= d_start + len , ensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) , { let mut result = dest ; let mut i = 0 ; while i < len invariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) , decreases len - i { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_copy_part/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "33692cd4e3cb", "function_name": "copy_impl", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_205b1d77fbcb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "205b1d77fbcb", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_85c9ceb38045", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "85c9ceb38045", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_54bb1eb78d02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "54bb1eb78d02", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3a90c8c00046", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "3a90c8c00046", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8b51381fc709", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8b51381fc709", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_68495cee3d02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] <= N \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/condn_impl.rs", "verified": true, "metadata": {"original_id": "68495cee3d02", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_95f3adf14501", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 4 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s32if_impl.rs", "verified": true, "metadata": {"original_id": "95f3adf14501", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6c7a251264eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool)  { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len ()  { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) , happy <==> happy_spec (s @) \ndecreases s . len () - j\ninvariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "6c7a251264eb", "function_name": "is_happy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_740a5e98952d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { r . len () == x . len () }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { r . len () == x . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "740a5e98952d", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bb75602a79cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "bb75602a79cf", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fc13cae53e1e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fc13cae53e1e", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d1f1d801d228", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_100/verina_basic_100_impl.rs", "verified": true, "metadata": {"original_id": "d1f1d801d228", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9eafcf90cf77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start <= nums . len ()\ndecreases nums . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9eafcf90cf77", "function_name": "loop_search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0f689999fd88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_99/verina_basic_99_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0f689999fd88", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3fcb98de6636", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3fcb98de6636", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4888b01b9538", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires index <= lst . len () , lst . len () <= 100\ndecreases lst . len () - index", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_45/verina_advanced_45_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4888b01b9538", "function_name": "helper", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2ead9a18c535", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs5_impl.rs", "verified": true, "metadata": {"original_id": "2ead9a18c535", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_733272a0f358", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "733272a0f358", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_53f6e2e66b6e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "53f6e2e66b6e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ffb656e76d9f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires missing_number_precond (nums @)\nensures missing_number_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn missing_number_postcond (nums : Seq < usize > , result : usize) -> bool { let n = nums . len () ; result <= n && ! contains (nums , result) && (forall | x : usize | # ! [trigger contains (nums , x)] x <= n && x != result ==> contains (nums , x)) }\nspec fn missing_number_precond (nums : Seq < usize >) -> bool { (forall | i : int | 0 <= i < nums . len () ==> nums [i] <= nums . len ()) && (forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] != nums [j]) }\nspec fn contains (nums : Seq < usize > , x : usize) -> bool { exists | i : int | 0 <= i < nums . len () && nums [i] == x }\n# [verifier :: external_body] fn missing_number (nums : Vec < usize >) -> (result : usize) requires missing_number_precond (nums @) ensures missing_number_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_54/verina_advanced_54.rs", "verified": true, "metadata": {"original_id": "ffb656e76d9f", "function_name": "missing_number", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4bdd3cc020a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "4bdd3cc020a1", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e0e141c91d8f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "ensures result == odd (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e0e141c91d8f", "function_name": "odd_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f05be54535e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; }  index += 1 ; }  upper_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "f05be54535e8", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f090d446b7f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f090d446b7f8", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_287f0b128be0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "287f0b128be0", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_acee6bb0a8b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn square_nums (nums : & Vec < i32 >) -> (squared : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < nums . len ()  {  let squared_val = nums [i] * nums [i] ; result . push (squared_val) ; i += 1 ;  } result }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) \nensures nums . len () == squared . len () , forall | k : int | 0 <= k < nums . len () ==> (# [trigger] squared [k] == nums [k] * nums [k]) \ndecreases nums . len () - i\ninvariant i <= nums . len () , result . len () == i , forall | k : int | 0 <= k < i ==> (# [trigger] result [k] == nums [k] * nums [k]) , forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn square_nums (nums : & Vec < i32 >) -> (squared : Vec < i32 >) requires forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) , ensures nums . len () == squared . len () , forall | k : int | 0 <= k < nums . len () ==> (# [trigger] squared [k] == nums [k] * nums [k]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < nums . len () invariant i <= nums . len () , result . len () == i , forall | k : int | 0 <= k < i ==> (# [trigger] result [k] == nums [k] * nums [k]) , forall | k : int | 0 <= k < nums . len () ==> (0 <= # [trigger] nums [k] * # [trigger] nums [k] < MAX) decreases nums . len () - i { assert (0 <= nums [i as int] * nums [i as int] < MAX) ; let squared_val = nums [i] * nums [i] ; result . push (squared_val) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> result [k] == nums [k] * nums [k]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_8_impl.rs", "verified": true, "metadata": {"original_id": "acee6bb0a8b9", "function_name": "square_nums", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a1c226ba5ecf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a1c226ba5ecf", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7a3bec4446fa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize)   { let mut i = c ; while i < f  { let mut min_idx = i ; let mut j = i + 1 ; while j < f  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires c <= f , f <= old (a) . len () \nensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) \ndecreases f - i, f - j\ninvariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "7a3bec4446fa", "function_name": "sel_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e2deed44497c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e2deed44497c", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a44c330cf656", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 1 ; while idx < arr . len ()  { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - idx \ninvariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a44c330cf656", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_39670f69002a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  {    b [i as usize] = N + 2 ; i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 \ndecreases N - i\ninvariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N < 1000 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N < 1000 , decreases N - i { assert (i < N) ; assert (0 <= i < b . len ()) ; assert (N < 1000) ; b [i as usize] = N + 2 ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina4_impl.rs", "verified": true, "metadata": {"original_id": "39670f69002a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_280cd61f844f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "target_text": "ensures result as nat == spec_nat_abs_diff (x , y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "280cd61f844f", "function_name": "nat_abs_diff", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a92c832c9478", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_all_occurrences (text : Seq < char > , pattern : Seq < char >) -> (result : Vec < usize >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires true\nensures true", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_all_occurrences (text : Seq < char > , pattern : Seq < char >) -> (result : Vec < usize >) requires true ensures true { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Practice_tmp_tmphnmt4ovh_Pattern Matching/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a92c832c9478", "function_name": "find_all_occurrences", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_49dcd78eab5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l  { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i, p - j, l - k\ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_64/verina_basic_64_impl.rs", "verified": true, "metadata": {"original_id": "49dcd78eab5e", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b3d63354fb75", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b3d63354fb75", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b11d94c23d98", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b11d94c23d98", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_38eafbb9869c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >)  { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >)  { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures char_vec @ == number_to_char (n as nat) , single_digit_number_to_char (n as nat) == output , string_seq @ == string_sequence (n as nat) , char_vec @ == number_to_char (n as nat) , decreases n, string_seq @ == string_sequence (n as nat) , decreases n\ndecreases n , n , n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn string_sequence (n : nat) -> (result : Seq < char >) decreases n , { if n == 0 { seq ! ['0'] } else { string_sequence ((n - 1) as nat) . add (seq ! [' '] . add (number_to_char (n))) } }\nspec fn number_to_char (n : nat) -> (result : Seq < char >) decreases n , { if (n == 0) { seq ! [] } else { number_to_char (n / 10) . add (seq ! [single_digit_number_to_char (n % 10)]) } }\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn number_to_char_impl (n : u8) -> (char_vec : Vec < char >) ensures char_vec @ == number_to_char (n as nat) , decreases n { if n == 0 { Vec :: new () } else { let mut result = number_to_char_impl (n / 10) ; let digit_char = single_digit_number_to_char_impl (n % 10) ; result . push (digit_char) ; result } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\nfn string_sequence_impl (n : u8) -> (string_seq : Vec < char >) ensures string_seq @ == string_sequence (n as nat) , decreases n { if n == 0 { vec ! ['0'] } else { let mut result = string_sequence_impl (n - 1) ; result . push (' ') ; let mut num_chars = number_to_char_impl (n) ; result . append (& mut num_chars) ; result } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "38eafbb9869c", "function_name": "string_sequence_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_20267ae8e034", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires index <= lst . len () , lst . len () <= 100\ndecreases lst . len () - index", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_45/verina_advanced_45_iter_0_original.rs", "verified": true, "metadata": {"original_id": "20267ae8e034", "function_name": "helper", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a53ae1316ec6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "a53ae1316ec6", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_809be6ce8058", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_test_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "809be6ce8058", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3927d1a322ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/unverified/cal_div_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3927d1a322ca", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_febef9af8c48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32)   { let mut i = N ; while i > 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "febef9af8c48", "function_name": "down_while_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6a7db61f17ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6a7db61f17ea", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e6e626c93321", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e6e626c93321", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_84f1fcf3e5ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "84f1fcf3e5ee", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a4f81c8e5082", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i : usize = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len () , v [odd_index as int] % 2 == 1\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () , v [odd_index as int] % 2 == 1 { let mut i : usize = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/choose_odd_iter_4_current.rs", "verified": true, "metadata": {"original_id": "a4f81c8e5082", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_341d1f1d3c31", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "341d1f1d3c31", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6d87f75435ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "6d87f75435ae", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_eb58b6b82a47", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires solution_precond (nums @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_74/verina_advanced_74_iter_0_original.rs", "verified": true, "metadata": {"original_id": "eb58b6b82a47", "function_name": "solution", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9bcbb335e30e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >)  { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len ()\ndecreases a . len () - i\ninvariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_append_impl.rs", "verified": true, "metadata": {"original_id": "9bcbb335e30e", "function_name": "append_with_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f45441f5a3c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires square_root_precond (n as nat) , n <= 100 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn square_root_precond (n : nat) -> bool { true }\nfn square_root (n : u32) -> (result : u32) requires square_root_precond (n as nat) , n <= 100 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_65/verina_basic_65_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f45441f5a3c2", "function_name": "square_root", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0bd480704750", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len ()  { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - i\ninvariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len () invariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) , decreases str . len () - i { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/027-flip_case_impl.rs", "verified": true, "metadata": {"original_id": "0bd480704750", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b1a3c51bb6df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b1a3c51bb6df", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_864ba66e3545", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/replace_iter_2_current.rs", "verified": true, "metadata": {"original_id": "864ba66e3545", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_adf0e1fa635a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "adf0e1fa635a", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_vostd_bit_cee84d73f5e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn bit_full_spec() -> nat {\n    u64::MAX as nat\n}\n\nconst fn bit_full() -> (res: u64)\n\n{\n    u64::MAX\n}\n\npub open spec fn bit_reverse_spec(val: nat) -> nat {\n    (bit_full_spec() - val) as nat\n}\n\nconst fn bit_reverse(val: u64) -> (res: u64)\n\n{\n    bit_full() - val\n}\n\npub open spec fn bit_and_spec(x: nat, y: nat) -> nat {\n    (x as u64 & y as u64) as nat\n}\n\nconst fn bit_and(x: u64, y: u64) -> (res: u64)\n\n{\n    x & y\n}\n\n} // verus!\n", "target_text": "ensures res == bit_full_spec(), res == bit_reverse_spec(val as nat), res == bit_and_spec(x as nat, y as nat)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn bit_full_spec() -> nat {\n    u64::MAX as nat\n}\n\nconst fn bit_full() -> (res: u64)\n    ensures\n        res == bit_full_spec(),\n{\n    u64::MAX\n}\n\npub open spec fn bit_reverse_spec(val: nat) -> nat {\n    (bit_full_spec() - val) as nat\n}\n\nconst fn bit_reverse(val: u64) -> (res: u64)\n    ensures\n        res == bit_reverse_spec(val as nat),\n{\n    bit_full() - val\n}\n\npub open spec fn bit_and_spec(x: nat, y: nat) -> nat {\n    (x as u64 & y as u64) as nat\n}\n\nconst fn bit_and(x: u64, y: u64) -> (res: u64)\n    ensures\n        res == bit_and_spec(x as nat, y as nat),\n{\n    x & y\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/aster_common/src/cpu/set/bit.rs", "verified": true, "metadata": {"original_id": "vostd_bit_cee84d73f5e3", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d7c8adc99e51", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d7c8adc99e51", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fc12360a6125", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms4_impl.rs", "verified": true, "metadata": {"original_id": "fc12360a6125", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f134f43fe138", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant 0 <= i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant 0 <= j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "f134f43fe138", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c5d92037ee32", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "ensures check_find_first_odd (arr , index) \ndecreases arr . len () - i \ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 , decreases arr . len () - i , { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_807_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c5d92037ee32", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_58a0eaec350f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool)   { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1  { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires is_sorted_precond (a @) \nensures is_sorted_postcond (a @ , result) \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_19/verina_basic_19_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58a0eaec350f", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_fun_ext_a3079e1a29d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\nproof fn test_funext_specific_1(f1: spec_fn(u8) -> int, f2: spec_fn(u8) -> int)\n\n{\n\n}\n\nproof fn test_funext_specific_1_alt(f1: spec_fn(u8) -> int, f2: spec_fn(u8) -> int)\n\n{\n\n}\n\nproof fn test_funext_specific_2(f1: spec_fn(u8, u16) -> int, f2: spec_fn(u8, u16) -> int)\n\n{\n\n}\n\n} // verus!\n", "target_text": "requires forall|x: u8| #[trigger] f1(x) == f2(x), forall|x: u8| #[trigger] f1(x) == f2(x), forall|x, y| #[trigger] f1(x, y) == f2(x, y)\nensures f1 == f2, f1 == f2, f1 == f2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\nproof fn test_funext_specific_1(f1: spec_fn(u8) -> int, f2: spec_fn(u8) -> int)\n    requires\n        forall|x: u8| #[trigger] f1(x) == f2(x),\n    ensures\n        f1 == f2,\n{\n    assert(f1 =~= f2);\n}\n\nproof fn test_funext_specific_1_alt(f1: spec_fn(u8) -> int, f2: spec_fn(u8) -> int)\n    requires\n        forall|x: u8| #[trigger] f1(x) == f2(x),\n    ensures\n        f1 == f2,\n{\n    assert(f1 =~= f2);\n}\n\nproof fn test_funext_specific_2(f1: spec_fn(u8, u16) -> int, f2: spec_fn(u8, u16) -> int)\n    requires\n        forall|x, y| #[trigger] f1(x, y) == f2(x, y),\n    ensures\n        f1 == f2,\n{\n    assert(f1 =~= f2);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/fun_ext.rs", "verified": true, "metadata": {"original_id": "verus_fun_ext_a3079e1a29d0", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9879c1c30590", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "requires old (a) . len () > 0 \nensures result == odd (n as int), a @ . len () == old (a) @ . len () \ndecreases right - left\ninvariant left <= right , right <= a @ . len () , a @ . len () == old (a) @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a @ . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9879c1c30590", "function_name": "partition_odd_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9ca61254863f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "9ca61254863f", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5b2eaf2a217b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >)  { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result @ . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5b2eaf2a217b", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_699aeebfbb04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < a . len ()  { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == N \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "699aeebfbb04", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4e101efb5315", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_53/verina_advanced_53_impl.rs", "verified": true, "metadata": {"original_id": "4e101efb5315", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_027dff1f363f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires unique_sorted_precond (arr @)\nensures unique_sorted_postcond (arr @ , result @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @) ensures unique_sorted_postcond (arr @ , result @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_81/verina_advanced_81_iter_0_original.rs", "verified": true, "metadata": {"original_id": "027dff1f363f", "function_name": "unique_sorted", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_69b3fbda5b5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "69b3fbda5b5e", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_42fd355a8ad8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "42fd355a8ad8", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ad9e6c415137", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ad9e6c415137", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9313283c3d39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_99/verina_basic_99_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9313283c3d39", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e221c587ea97", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_characters_same (char_arr : & [u8]) -> (result : bool)  { if char_arr . len () == 0 { return true ; } let first_char = char_arr [0] ; for i in 1 .. char_arr . len ()  { if char_arr [i] != first_char {     return false ; }  }  true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 1 <= i < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [i]) \ninvariant first_char == char_arr [0] , forall | j : int | 1 <= j < i ==> first_char == # [trigger] char_arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_characters_same (char_arr : & [u8]) -> (result : bool) ensures result == (forall | i : int | 1 <= i < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [i]) , { if char_arr . len () == 0 { return true ; } let first_char = char_arr [0] ; for i in 1 .. char_arr . len () invariant first_char == char_arr [0] , forall | j : int | 1 <= j < i ==> first_char == # [trigger] char_arr [j] , { if char_arr [i] != first_char { assert (first_char != char_arr [i as int]) ; assert (char_arr [0] != char_arr [i as int]) ; assert (1 <= i < char_arr @ . len ()) ; assert (! (forall | k : int | 1 <= k < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [k])) ; return false ; } assert (first_char == char_arr [i as int]) ; } assert (forall | j : int | 1 <= j < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [j]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_741_impl.rs", "verified": true, "metadata": {"original_id": "e221c587ea97", "function_name": "all_characters_same", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_289b89279439", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "289b89279439", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4747cf4a9985", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "4747cf4a9985", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ded41f6af3ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i])\ndecreases str1 . len () - index \ninvariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "ded41f6af3ca", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_interner_63d8677f4199", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n\n                } else {\n\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n\n                } else {\n\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        {\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n\n    {\n\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n\n    {\n\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n\n}\n\n} // verus!\n", "target_text": "requires old(self).wf(inst), self.wf(inst) && interned.wf(inst), self.wf(inst), self.wf(inst) && other.wf(inst)\nensures res <==> (a === b), (, self.wf(inst) && st.wf(inst) && st@ === val, *st === interned@, s.wf(inst) && s@ === self@, b == (self@ === other@)\ninvariant 0 <= idx && idx <= self.store@.len(),\n                self.wf(inst)", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/interner.rs", "verified": true, "metadata": {"original_id": "verus_interner_63d8677f4199", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7ca6875f86c9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "target_text": "ensures result == is_valid_digit (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "7ca6875f86c9", "function_name": "is_valid_digit_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8a622034a1a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "8a622034a1a1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4cb9b92967dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique_better.rs", "verified": true, "metadata": {"original_id": "4cb9b92967dd", "function_name": "unique_better", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4526b9c09f63", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_array_postcond (xs : Seq < int > , result : Seq < int >) -> bool { result . len () == xs . len () && (forall | i : int | 0 <= i < xs . len () ==> result [i] == xs [i]) }\nspec fn to_array_precond (xs : Seq < int >) -> bool { true }\nfn to_array (xs : Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < xs . len ()  { result . push (xs [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires to_array_precond (xs @) \nensures to_array_postcond (xs @ , result @) \ndecreases xs . len () - i \ninvariant 0 <= i <= xs . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result @ [j] == xs @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_array_postcond (xs : Seq < int > , result : Seq < int >) -> bool { result . len () == xs . len () && (forall | i : int | 0 <= i < xs . len () ==> result [i] == xs [i]) }\nspec fn to_array_precond (xs : Seq < int >) -> bool { true }\nfn to_array (xs : Vec < int >) -> (result : Vec < int >) requires to_array_precond (xs @) , ensures to_array_postcond (xs @ , result @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < xs . len () invariant 0 <= i <= xs . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result @ [j] == xs @ [j] , decreases xs . len () - i , { result . push (xs [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_88/verina_basic_88_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4526b9c09f63", "function_name": "to_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_180b38adcc4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "180b38adcc4b", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3374ebbe261b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "3374ebbe261b", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_576bec463ce8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "576bec463ce8", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f667faf54409", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "f667faf54409", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5d39fa8616fb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_251_iter_1_current.rs", "verified": true, "metadata": {"original_id": "5d39fa8616fb", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d07b7e8b87ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)   { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)   {  c [j] - c [i] }\n\n} // verus!", "target_text": "requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c), a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 \nensures sum (a , i , j) == c [j] - c [i], r == sum (seq_to_int (a @) , i as int , j as int), sum (a , i , j) == c [j] - c [i] decreases j - i\ndecreases j - i, j - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d07b7e8b87ad", "function_name": "query_fast", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f92bdc82d05e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { c - 1 } else { let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/binary_search_recursive_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f92bdc82d05e", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3f28bf6a6158", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool recommends n >= 0 { if n == 0 { true } else if n > 0 { ! even (n - 1) } else { arbitrary () } }\nproof fn lemma_even_mod_equiv (n : nat)  { if n == 0 {   } else if n == 1 {    } else { lemma_even_mod_equiv ((n - 1) as nat) ;    } }\nfn is_even (n : u32) -> (r : bool)   {  n % 2 == 0 }\n\n} // verus!", "target_text": "requires n >= 0 \nensures even (n as int) <==> (n % 2 == 0), r <==> even (n as int), even (n as int) <==> (n % 2 == 0) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool recommends n >= 0 decreases n { if n == 0 { true } else if n > 0 { ! even (n - 1) } else { arbitrary () } }\nproof fn lemma_even_mod_equiv (n : nat) ensures even (n as int) <==> (n % 2 == 0) decreases n { if n == 0 { assert (even (0int) == true) ; assert (0nat % 2 == 0) ; } else if n == 1 { assert (even (1int) == ! even (0int)) ; assert (! even (0int) == false) ; assert (1nat % 2 == 1) ; } else { lemma_even_mod_equiv ((n - 1) as nat) ; assert (even (n as int) == ! even ((n - 1) as int)) ; assert (((n - 1) % 2 == 0) ==> (n % 2 == 1)) ; assert (((n - 1) % 2 == 1) ==> (n % 2 == 0)) ; } }\nfn is_even (n : u32) -> (r : bool) requires n >= 0 , ensures r <==> even (n as int) { proof { lemma_even_mod_equiv (n as nat) ; } n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "3f28bf6a6158", "function_name": "is_even", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_27115a7684a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { x + x + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "27115a7684a0", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4a911c3d8f32", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4a911c3d8f32", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f417526be3c4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)   { let mut i = 0 ; while i < numbers . len ()  { let mut j = 0 ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold\ndecreases numbers . len () - i, numbers . len () - j\ninvariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold, 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f417526be3c4", "function_name": "has_close_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f7de326d8817", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] \ndecreases a . len () - i \ninvariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "f7de326d8817", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_42d9a48a409e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { return false ; }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code.rs", "verified": true, "metadata": {"original_id": "42d9a48a409e", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6e320ade8f8f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/linear_search2_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6e320ade8f8f", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1ef6da17a6e6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , (6 * N) as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , (6 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "1ef6da17a6e6", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_20d04e680ad2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases exp ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 decreases exp , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "20d04e680ad2", "function_name": "pow_exec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bad1fa29fe85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn derivative (xs : & Vec < usize >) -> (ret : Option < Vec < usize > >) ensures ret . is_some () ==> xs @ . len () == 0 || xs @ . map (| i : int , x | i * x) . skip (1) =~= ret . unwrap () @ . map_values (| x | x as int) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/062-derivative.rs", "verified": true, "metadata": {"original_id": "bad1fa29fe85", "function_name": "derivative", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_622cdb8d2163", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize  { if i < a . len () && i < b . len () { let val_a = if a [i] > 1 { 1 } else if a [i] < 0 { 0 } else { a [i] } ; let val_b = if b [i] > 1 { 1 } else if b [i] < 0 { 0 } else { b [i] } ; total = total + val_a + val_b ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N \ndecreases N as usize - i\ninvariant i <= N as usize , total <= 2 * (i as i32) , a . len () == N , b . len () == N , sum . len () == 1 , N > 0 , N < 1000 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize invariant i <= N as usize , total <= 2 * (i as i32) , a . len () == N , b . len () == N , sum . len () == 1 , N > 0 , N < 1000 , decreases N as usize - i { if i < a . len () && i < b . len () { let val_a = if a [i] > 1 { 1 } else if a [i] < 0 { 0 } else { a [i] } ; let val_b = if b [i] > 1 { 1 } else if b [i] < 0 { 0 } else { b [i] } ; total = total + val_a + val_b ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/res1_impl.rs", "verified": true, "metadata": {"original_id": "622cdb8d2163", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6da2fffcdc2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "6da2fffcdc2c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ac8769e95854", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "ac8769e95854", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2e1491add538", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32)   { let mut i = 0 ; while i != N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "2e1491add538", "function_name": "up_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_417608269795", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires find_majority_element_precond (lst @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_11/verina_advanced_11_iter_0_original.rs", "verified": true, "metadata": {"original_id": "417608269795", "function_name": "find_majority_element", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_00c068f859ed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32)   {   let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut idx = 0 ; while idx < arr . len ()  {   if arr [idx] [1] < min_second { min_second = arr [idx] [1] ; result_first = arr [idx] [0] ; } idx = idx + 1 ; }  result_first }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 \nensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 , forall | k : int | 0 <= k < idx ==> min_second <= # [trigger] arr [k] [1] , exists | k : int | 0 <= k < arr . len () && result_first == # [trigger] arr [k] [0] && arr [k] [1] == min_second , forall | k : int | 0 <= k < idx ==> min_second <= # [trigger] arr [k] [1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 , ensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) , { assert (0 < arr . len ()) ; assert (arr [0] . len () >= 2) ; let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 , forall | k : int | 0 <= k < idx ==> min_second <= # [trigger] arr [k] [1] , exists | k : int | 0 <= k < arr . len () && result_first == # [trigger] arr [k] [0] && arr [k] [1] == min_second , forall | k : int | 0 <= k < idx ==> min_second <= # [trigger] arr [k] [1] , decreases arr . len () - idx , { assert (idx < arr . len ()) ; assert (arr [idx as int] . len () >= 2) ; if arr [idx] [1] < min_second { min_second = arr [idx] [1] ; result_first = arr [idx] [0] ; } idx = idx + 1 ; } assert (forall | j : int | 0 <= j < arr . len () ==> min_second <= # [trigger] arr [j] [1]) ; result_first }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_94_impl.rs", "verified": true, "metadata": {"original_id": "00c068f859ed", "function_name": "min_second_value_first", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_65fe05bf6dc5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires run_length_encoder_precond (input @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >) requires run_length_encoder_precond (input @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_68/verina_advanced_68_iter_0_original.rs", "verified": true, "metadata": {"original_id": "65fe05bf6dc5", "function_name": "run_length_encoder", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a5cc4bb71e8b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a5cc4bb71e8b", "function_name": "sum_powers_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_555370735660", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "555370735660", "function_name": "canyon_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d5a297a84b1d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,)  { }\n\n} // verus!", "target_text": "requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,) requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k.rs", "verified": true, "metadata": {"original_id": "d5a297a84b1d", "function_name": "create_all_state", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fe91a61fa5bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "fe91a61fa5bb", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_16311594898c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_non_prime_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16311594898c", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_integers_4d5451d5deb7", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n\n    //  // FAILS\n\n    //  // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n\n    //  // FAILS\n\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n     // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "target_text": "ensures true", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/integers.rs", "verified": true, "metadata": {"original_id": "verus_integers_4d5451d5deb7", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_642f3c310079", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "642f3c310079", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_02bc440edcf8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ndecreases arr . len () - i , arr1 . len () - i \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "02bc440edcf8", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dfab1c7c31dc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; }  index += 1 ; }  upper_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dfab1c7c31dc", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_72c281552f85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize) requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "72c281552f85", "function_name": "calculate_coverage", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6d4cd0860435", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6d4cd0860435", "function_name": "max_array_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_98c9513f870b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "98c9513f870b", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_694d08a3ee41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "ensures result == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "694d08a3ee41", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bcca45a68483", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "bcca45a68483", "function_name": "compare_bool", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1a323275286e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1a323275286e", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_391659179429", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/res1o_impl.rs", "verified": true, "metadata": {"original_id": "391659179429", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a7e46ea7d4f4", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_ilog (x : u32 , base : u32) -> (ret : u32)   { x . ilog (base) }\n\n} // verus!", "target_text": "requires x > 0 , base > 1 \nensures ret == log (base as int , x as int) ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_ilog (x : u32 , base : u32) -> (ret : u32) requires x > 0 , base > 1 , ensures ret == log (base as int , x as int) , { x . ilog (base) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/not_finished_proof/076-is_simple_power_impl.rs", "verified": true, "metadata": {"original_id": "a7e46ea7d4f4", "function_name": "ex_ilog", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_907a56a58ae6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { for i in 0 .. l . len ()  { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ninvariant forall | j : int | 0 <= j < i ==> l [j] < t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/052-below-threshold_impl.rs", "verified": true, "metadata": {"original_id": "907a56a58ae6", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_44fd58226b88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_1_current.rs", "verified": true, "metadata": {"original_id": "44fd58226b88", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b22aeab90b3a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "b22aeab90b3a", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_596b07424754", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { 3 * x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "596b07424754", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_55769cda55ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "55769cda55ba", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_630cebc02917", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "630cebc02917", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c904adc7a69", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "7c904adc7a69", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1cd3097a81fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/res2_impl.rs", "verified": true, "metadata": {"original_id": "1cd3097a81fd", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_36ef68a1fdb4", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int)   { let remainder = addr % alignment ; if remainder != 0 {  }   } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64)   { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64)   {  if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "target_text": "requires 0 < alignment , 0 < alignment , 0 < alignment \nensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment), result == space_needed_for_alignment (addr as int , alignment as int), v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) \ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "36ef68a1fdb4", "function_name": "align_checked_u64", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_405bd2a45d8a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { x + x + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "405bd2a45d8a", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_44f8991ac449", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires has_close_elements_precond (numbers @ , threshold) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool) requires has_close_elements_precond (numbers @ , threshold) , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "44f8991ac449", "function_name": "has_close_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_47eacb8efff5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len ()  { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - j \ninvariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant 0 <= j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j , { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "47eacb8efff5", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7df986bba7c9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n \ndecreases fuel ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_28/verina_basic_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7df986bba7c9", "function_name": "is_prime_check", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_cbfdc10a023e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ndecreases numbers . len () - i\ninvariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j && j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/intersperse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cbfdc10a023e", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_333d67384858", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ndecreases arr . len () - i, list1 . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases list1 . len () - i { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "333d67384858", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_af24ef4d27ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i, list @ . len () - j\ninvariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "af24ef4d27ab", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f3fd3ea10561", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms4_impl.rs", "verified": true, "metadata": {"original_id": "f3fd3ea10561", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4a8c135ac4f9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires first_duplicate_precond (lst @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_12/verina_advanced_12.rs", "verified": true, "metadata": {"original_id": "4a8c135ac4f9", "function_name": "first_duplicate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9a578c399d78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)   { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols  { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows  { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () \nensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i]\ndecreases cols - i, rows - j\ninvariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols, new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases cols - i { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows invariant new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases rows - j { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/WIP/WIP__transpose_matrix_impl.rs", "verified": true, "metadata": {"original_id": "9a578c399d78", "function_name": "transpose", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0c368556b649", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { if r . len () == 0 || x . len () == 0 { return false ; } r . len () == x . len () }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { if r . len () == 0 || x . len () == 0 { return false ; } r . len () == x . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c368556b649", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_syntax_f99cb97e6734", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\nconst EXTERNAL_C: u8 = 7;\n\nfn external_f(u: u8) -> u8 {\n    u / 2\n}\n\nverus! {\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/\n{\n    x + y\n}\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\nfn test_my_funs(x: u32, y: u32)\n\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n\n}\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n/// Recursive functions must have {\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\n/// Multiple {\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    {\n    if x < 1 {\n        0\n    } else {\n\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - {\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    {\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n\n{\n    let s = a + b;  // s is an exec variable\n\n}\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\nfn assert_by_test() {\n      // reveal f1's definition just inside this block\n    }\n\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\nfn assert_by_provers(x: u32) {\n\n}\n\n/// \"assert by\" provers can also appear on function signatures to select a specific prover\n/// for the function body.\nproof fn lemma_mul_upper_bound(x: int, x_bound: int, y: int, y_bound: int)\n    by (nonlinear_arith)\n\n{\n}\n\n/// \"assert by\" can use nonlinear_arith with proof code,\n/// where \"requires\" clauses selectively make facts available to the proof code.\nproof fn test5_bound_checking(x: u32, y: u32, z: u32)\n\n{\n\n    }\n}\n\n/// The syntax for forall and exists quantifiers is based on closures:\nfn test_quantifier() {\n\n}\n\n/// \"assert forall by\" may be used to prove foralls:\nfn test_assert_forall_by() {\n    // to prove forall|...| P ==> Q, write }\n\n/// To extract ghost witness values from exists, use choose:\nfn test_choose() {\n    assume(exists|x: int| f1(x) == 10);\n\n    assume(exists|x: int, y: int| f1(x) + f1(y) == 30);\n\n}\n\n/// To manually specify a trigger to use for the SMT solver to match on when instantiating a forall\n/// or proving an exists, use #[trigger]:\nfn test_single_trigger1() {\n    // Use [my_spec_fun(x, y)] as the trigger\n    assume(forall|x: int, y: int| f1(x) < 100 && f1(y) < 100 ==> #[trigger] my_spec_fun(x, y) >= x);\n}\n\nfn test_single_trigger2() {\n    // Use [f1(x), f1(y)] as the trigger\n    assume(forall|x: int, y: int| #[trigger]\n        f1(x) < 100 && #[trigger] f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// To manually specify multiple triggers, use #![trigger]:\nfn test_multiple_triggers() {\n    // Use both [my_spec_fun(x, y)] and [f1(x), f1(y)] as triggers\n    assume(forall|x: int, y: int|\n        #![trigger my_spec_fun(x, y)]\n        #![trigger f1(x), f1(y)]\n        f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// Verus can often automatically choose a trigger if no manual trigger is given.\n/// Use the command-line option --triggers to print the chosen triggers.\nfn test_auto_trigger1() {\n    // Verus automatically chose [my_spec_fun(x, y)] as the trigger.\n    // (It considers this safer, i.e. likely to match less often, than the trigger [f1(x), f1(y)].)\n    assume(forall|x: int, y: int| f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// If Verus prints a note saying that it automatically chose a trigger with low confidence,\n/// you can supply manual triggers or use #![auto] to accept the automatically chosen trigger.\nfn test_auto_trigger2() {\n    // Verus chose [f1(x), f1(y)] as the trigger; go ahead and accept that\n    assume(forall|x: int, y: int| #![auto] f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(3, y) >= 3);\n}\n\n/// &&& and ||| are like && and ||, but have low precedence (lower than all other binary operators,\n/// and lower than forall/exists/choose).\n/// &&& must appear before each conjunct, rather than between the conjuncts (similarly for |||).\n/// &&& must appear directly inside a block or at the end of a block.\nspec fn simple_conjuncts(x: int, y: int) -> bool {\n    &&& 1 < x\n    &&& y > 9 ==> x + y < 50\n    &&& x < 100\n    &&& y < 100\n}\n\nspec fn complex_conjuncts(x: int, y: int) -> bool {\n    let b = x < y;\n    &&& b\n    &&& if false {\n        &&& b ==> b\n        &&& !b ==> !b\n    } else {\n        ||| b ==> b\n        ||| !b\n    }\n    &&& false ==> true\n}\n\n/// ==> associates to the right, while <== associates to the left.\n/// <==> is nonassociative.\n/// == is SMT equality.\n/// != is SMT disequality.\npub(crate) proof fn binary_ops<A>(a: A, x: int) {\n\n}\n\n/// In specs, <=, <, >=, and > may be chained together so that, for example, a <= b < c means\n/// a <= b && b < c.  (Note on efficiency: if b is a complex expression,\n/// Verus will automatically introduce a temporary variable under the hood so that\n/// the expression doesn't duplicate b: {let x_b = b; a <= x_b && x_b < c}.)\nproof fn chained_comparisons(i: int, j: int, k: int)\n\n{\n}\n\n/// In specs, e@ is an abbreviation for e.view()\n/// Many types implement a view() method to get an abstract ghost view of a concrete type.\nfn test_views() {\n    let mut v: Vec<u8> = Vec::new();\n    v.push(10);\n    v.push(20);\n\n}\n\n/// struct and enum declarations may be declared exec (default), tracked, or ghost,\n/// and fields may be declared exec (default), tracked or ghost.\ntracked struct TrackedAndGhost<T, G>(tracked T, ghost G);\n\n/// Proof code may manipulate tracked variables directly.\n/// Declarations of tracked variables must be explicitly marked as \"tracked\".\nproof fn consume(tracked x: int) {\n}\n\nproof fn test_tracked(\n    tracked w: int,\n    tracked x: int,\n    tracked y: int,\n    z: int,\n) -> tracked TrackedAndGhost<(int, int), int> {\n    consume(w);\n    let tracked tag: TrackedAndGhost<(int, int), int> = TrackedAndGhost((x, y), z);\n    let tracked TrackedAndGhost((a, b), c) = tag;\n    TrackedAndGhost((a, b), c)\n}\n\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n\n}\n\n/// Variables in exec code may be exec, ghost, or tracked.\n/// However, exec function parameters and return values are always exec.\n/// In these places, the library types Ghost and Tracked are used\n/// to wrap ghost values and tracked values.\n/// Ghost and tracked expressions Ghost(expr) and Tracked(expr) create values of type Ghost<T>\n/// and Tracked<T>, where expr is treated as proof code whose value is wrapped inside Ghost or Tracked.\n/// The view x@ of a Ghost or Tracked x is the ghost or tracked value inside the Ghost or Tracked.\nfn test_ghost_wrappers(x: u32, y: Ghost<u32>)\n\n{\n    // Ghost(...) expressions can create values of type Ghost<...>:\n    let u: Ghost<int> = Ghost(my_spec_fun(x as int, y@ as int));\n    let mut v: Ghost<int> = Ghost(u@ + 1);\n\n    let w: Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v@ + 1;\n            temp + 1\n        },\n    );\n\n}\n\nfn test_consume(t: Tracked<int>)\n\n{\n\n}\n\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n\n}\n\nstruct S {}\n\n/// Exec code can use \"let ghost\" and \"let tracked\" to create local ghost and tracked variables.\n/// Exec code can extract individual ghost and tracked values from Ghost and Tracked wrappers\n/// with \"let ...Ghost(x)...\" and \"let ...Tracked(x)...\".\nfn test_ghost_tuple_match(t: (Tracked<S>, Tracked<S>, Ghost<int>, Ghost<int>)) -> Tracked<S> {\n    let ghost g: (int, int) = (10, 20);\n\n    let ghost (g1, g2) = g;\n\n    // b1, b2: Tracked<S> and g3, g4: Ghost<int>\n    let (Tracked(b1), Tracked(b2), Ghost(g3), Ghost(g4)) = t;\n    Tracked(b2)\n}\n\n/// Exec code can Ghost(...) or Tracked(...) unwrapped parameter\n/// to create a mutable ghost or tracked parameter:\nfn test_ghost_mut(Ghost(g): Ghost<&mut int>)\n\n{\n\n}\n\nfn test_call_ghost_mut() {\n    let ghost mut g = 10int;\n    test_ghost_mut(Ghost(&mut g));\n\n}\n\n/// Spec functions are not checked for correctness (although they are checked for termination).\n/// However, marking a spec function as \"spec(checked)\" enables lightweight \"recommends checking\"\n/// inside the spec function.\nspec(checked) fn my_spec_fun2(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    // Because of spec(checked), Verus checks that my_spec_fun's recommends clauses are satisfied here:\n    my_spec_fun(x, y)\n}\n\n/// Spec functions may omit their body, in which case they are considered\n/// uninterpreted (returning an arbitrary value of the return type depending on the input values).\n/// This is safe, since spec functions (unlike proof and exec functions) may always\n/// return arbitrary values of any type,\n/// where the value may be special \"bottom\" value for otherwise uninhabited types.\nuninterp spec fn my_uninterpreted_fun1(i: int, j: int) -> int;\n\nuninterp spec fn my_uninterpreted_fun2(i: int, j: int) -> int\n    recommends\n        0 <= i < 10,\n        0 <= j < 10,\n;\n\n/// Trait functions may have specifications\ntrait T {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int)\n\n        {\n            if i >= j { i } else { j }\n        }\n}\n\nstruct S1;\nstruct S2;\n\n/// An impl can choose to use the default impl of my_function_with_a_default,\n/// in which case the default_ensures applies to my_function_with_a_default\nimpl T for S1 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n}\n\n/// An impl can choose not to use the default impl of my_function_with_a_default,\n/// and instead provide its own impl, in which case the default_ensures is ignored\nimpl T for S2 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n\n    {\n        i + j\n    }\n}\n\nenum ThisOrThat {\n    This(nat),\n    That { v: int },\n}\n\nproof fn uses_is(t: ThisOrThat) {\n    match t {\n        ThisOrThat::This(..) => {\n\n        },\n        ThisOrThat::That { .. } => {\n\n        },\n    }\n}\n\nproof fn uses_arrow_matches_1(t: ThisOrThat)\n\n{\n\n}\n\nproof fn uses_arrow_matches_2(t: ThisOrThat)\n     { v: a } && a == 3,\n{\n\n}\n\nproof fn uses_spec_has(s: Set<int>, ms: vstd::multiset::Multiset<int>)\n\n{\n\n}\n\nproof fn broadcast_use() {\n    // you can use broadcase use on the module level, in proof functions,\n    // in proof blocks, or in assert-by\n    broadcast use vstd::seq_lib::group_seq_properties;\n    // you can also use multiple broadcast lemmas at once\n    broadcast use {\n        vstd::multiset::group_multiset_properties,\n        vstd::multiset::group_multiset_axioms,\n    };\n    // although we don't support a list of paths with common prefix like:\n    // broadcast use vstd::multiset::{group_multiset_properties, group_multiset_axioms};\n\n    assert forall|s: Seq<usize>, v: usize, x: usize|\n        { s.contains(x) ==> s.push(v).contains(x) } by {\n        broadcast use vstd::seq_lib::group_seq_properties;\n\n    };\n}\n\n/// Specifications can be assumed for functions and constants from outside Verus.\n/// Warning: such specifications are trusted to be correct, so they must be chosen carefully.\nassume_specification[EXTERNAL_C] -> u8\n    returns\n        7u8,\n;\n\nassume_specification[external_f](u: u8) -> (r: u8)\n     {\n\n    let x = external_f(10);\n\n}\n\n} // verus!\n", "target_text": "requires x < 100,\n        y < 100, x < 100,\n        y < 100, x < 100,\n        y < 100, 0 < x < 100,\n        y < 100 - x, a < 100,\n        b < 100, x <= x_bound,\n        y <= y_bound,\n        0 <= x,\n        0 <= y, x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff, x <= 0xffff,\n            z <= 0xffff, 0 <= i + 1 <= j + 10 < k + 7, x < 100,\n        y < 100, x < 100,\n        y@ < 100, t@ <= 7, 0 <= i < 10,\n            0 <= j < 10, 0 <= i < 10,\n            0 <= j < 10, t is That ==> t->v == 3,\n        t is This ==> t->0 == 4, t matches ThisOrThat::That, s has 3,\n        ms has 4\nensures ///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\nfn my_exec_fun(x: u32, y: u32) -> (sum: u32)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200, sum < 200, x * y <= x_bound * y_bound, j < k, *g == *old(g) + 1, i <= r,\n            j <= r,\n    ;\n\n    /// A trait function may have a default (provided) implementation,\n    /// and this default may have additional ensures specified with default_ensures\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n        default_ensures\n            i == r || j == r, is ignored\nimpl T for S2, r == i + j, r <= u,\n;\n\nfn test_external(), applies to my_function_with_a_default\nimpl T for S1\ndecreases clauses so that Verus can verify that the functions\n/// terminate.\nfn test_rec(x: u64, y: u64)\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x, clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y, x, .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends, a,\n    when a > 0\n    via dec0_decreases", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\nconst EXTERNAL_C: u8 = 7;\n\nfn external_f(u: u8) -> u8 {\n    u / 2\n}\n\nverus! {\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\nfn my_exec_fun(x: u32, y: u32) -> (sum: u32)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\nfn test_my_funs(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\nfn test_rec(x: u64, y: u64)\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n    requires\n        a < 100,\n        b < 100,\n{\n    let s = a + b;  // s is an exec variable\n    proof {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\nfn assert_by_test() {\n    assert(f1(3) > 3) by {\n        reveal(f1);  // reveal f1's definition just inside this block\n    }\n    assert(f1(3) > 3);\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\nfn assert_by_provers(x: u32) {\n    assert(x ^ x == 0u32) by (bit_vector);\n    assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n}\n\n/// \"assert by\" provers can also appear on function signatures to select a specific prover\n/// for the function body.\nproof fn lemma_mul_upper_bound(x: int, x_bound: int, y: int, y_bound: int)\n    by (nonlinear_arith)\n    requires\n        x <= x_bound,\n        y <= y_bound,\n        0 <= x,\n        0 <= y,\n    ensures\n        x * y <= x_bound * y_bound,\n{\n}\n\n/// \"assert by\" can use nonlinear_arith with proof code,\n/// where \"requires\" clauses selectively make facts available to the proof code.\nproof fn test5_bound_checking(x: u32, y: u32, z: u32)\n    requires\n        x <= 0xffff,\n        y <= 0xffff,\n        z <= 0xffff,\n{\n    assert(x * z == mul(x, z)) by (nonlinear_arith)\n        requires\n            x <= 0xffff,\n            z <= 0xffff,\n    {\n        assert(0 <= x * z);\n        assert(x * z <= 0xffff * 0xffff);\n    }\n}\n\n/// The syntax for forall and exists quantifiers is based on closures:\nfn test_quantifier() {\n    assert(forall|x: int, y: int| 0 <= x < 100 && 0 <= y < 100 ==> my_spec_fun(x, y) >= x);\n    assert(my_spec_fun(10, 20) == 30);\n    assert(exists|x: int, y: int| my_spec_fun(x, y) == 30);\n}\n\n/// \"assert forall by\" may be used to prove foralls:\nfn test_assert_forall_by() {\n    assert forall|x: int, y: int| f1(x) + f1(y) == x + y + 2 by {\n        reveal(f1);\n    }\n    assert(f1(1) + f1(2) == 5);\n    assert(f1(3) + f1(4) == 9);\n    // to prove forall|...| P ==> Q, write assert forall|...| P implies Q by {...}\n    assert forall|x: int| x < 10 implies f1(x) < 11 by {\n        assert(x < 10);\n        reveal(f1);\n        assert(f1(x) < 11);\n    }\n    assert(f1(3) < 11);\n}\n\n/// To extract ghost witness values from exists, use choose:\nfn test_choose() {\n    assume(exists|x: int| f1(x) == 10);\n    proof {\n        let x_witness = choose|x: int| f1(x) == 10;\n        assert(f1(x_witness) == 10);\n    }\n    assume(exists|x: int, y: int| f1(x) + f1(y) == 30);\n    proof {\n        let (x_witness, y_witness): (int, int) = choose|x: int, y: int| f1(x) + f1(y) == 30;\n        assert(f1(x_witness) + f1(y_witness) == 30);\n    }\n}\n\n/// To manually specify a trigger to use for the SMT solver to match on when instantiating a forall\n/// or proving an exists, use #[trigger]:\nfn test_single_trigger1() {\n    // Use [my_spec_fun(x, y)] as the trigger\n    assume(forall|x: int, y: int| f1(x) < 100 && f1(y) < 100 ==> #[trigger] my_spec_fun(x, y) >= x);\n}\n\nfn test_single_trigger2() {\n    // Use [f1(x), f1(y)] as the trigger\n    assume(forall|x: int, y: int| #[trigger]\n        f1(x) < 100 && #[trigger] f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// To manually specify multiple triggers, use #![trigger]:\nfn test_multiple_triggers() {\n    // Use both [my_spec_fun(x, y)] and [f1(x), f1(y)] as triggers\n    assume(forall|x: int, y: int|\n        #![trigger my_spec_fun(x, y)]\n        #![trigger f1(x), f1(y)]\n        f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// Verus can often automatically choose a trigger if no manual trigger is given.\n/// Use the command-line option --triggers to print the chosen triggers.\nfn test_auto_trigger1() {\n    // Verus automatically chose [my_spec_fun(x, y)] as the trigger.\n    // (It considers this safer, i.e. likely to match less often, than the trigger [f1(x), f1(y)].)\n    assume(forall|x: int, y: int| f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(x, y) >= x);\n}\n\n/// If Verus prints a note saying that it automatically chose a trigger with low confidence,\n/// you can supply manual triggers or use #![auto] to accept the automatically chosen trigger.\nfn test_auto_trigger2() {\n    // Verus chose [f1(x), f1(y)] as the trigger; go ahead and accept that\n    assume(forall|x: int, y: int| #![auto] f1(x) < 100 && f1(y) < 100 ==> my_spec_fun(3, y) >= 3);\n}\n\n/// &&& and ||| are like && and ||, but have low precedence (lower than all other binary operators,\n/// and lower than forall/exists/choose).\n/// &&& must appear before each conjunct, rather than between the conjuncts (similarly for |||).\n/// &&& must appear directly inside a block or at the end of a block.\nspec fn simple_conjuncts(x: int, y: int) -> bool {\n    &&& 1 < x\n    &&& y > 9 ==> x + y < 50\n    &&& x < 100\n    &&& y < 100\n}\n\nspec fn complex_conjuncts(x: int, y: int) -> bool {\n    let b = x < y;\n    &&& b\n    &&& if false {\n        &&& b ==> b\n        &&& !b ==> !b\n    } else {\n        ||| b ==> b\n        ||| !b\n    }\n    &&& false ==> true\n}\n\n/// ==> associates to the right, while <== associates to the left.\n/// <==> is nonassociative.\n/// == is SMT equality.\n/// != is SMT disequality.\npub(crate) proof fn binary_ops<A>(a: A, x: int) {\n    assert(false ==> true);\n    assert(true && false ==> false && false);\n    assert(!(true && (false ==> false) && false));\n    assert(false ==> false ==> false);\n    assert(false ==> (false ==> false));\n    assert(!((false ==> false) ==> false));\n    assert(false <== false <== false);\n    assert(!(false <== (false <== false)));\n    assert((false <== false) <== false);\n    assert(2 + 2 !== 3);\n    assert(a == a);\n    assert(false <==> true && false);\n}\n\n/// In specs, <=, <, >=, and > may be chained together so that, for example, a <= b < c means\n/// a <= b && b < c.  (Note on efficiency: if b is a complex expression,\n/// Verus will automatically introduce a temporary variable under the hood so that\n/// the expression doesn't duplicate b: {let x_b = b; a <= x_b && x_b < c}.)\nproof fn chained_comparisons(i: int, j: int, k: int)\n    requires\n        0 <= i + 1 <= j + 10 < k + 7,\n    ensures\n        j < k,\n{\n}\n\n/// In specs, e@ is an abbreviation for e.view()\n/// Many types implement a view() method to get an abstract ghost view of a concrete type.\nfn test_views() {\n    let mut v: Vec<u8> = Vec::new();\n    v.push(10);\n    v.push(20);\n    proof {\n        let s: Seq<u8> = v@;  // v@ is equivalent to v.view()\n        assert(s[0] == 10);\n        assert(s[1] == 20);\n    }\n}\n\n/// struct and enum declarations may be declared exec (default), tracked, or ghost,\n/// and fields may be declared exec (default), tracked or ghost.\ntracked struct TrackedAndGhost<T, G>(tracked T, ghost G);\n\n/// Proof code may manipulate tracked variables directly.\n/// Declarations of tracked variables must be explicitly marked as \"tracked\".\nproof fn consume(tracked x: int) {\n}\n\nproof fn test_tracked(\n    tracked w: int,\n    tracked x: int,\n    tracked y: int,\n    z: int,\n) -> tracked TrackedAndGhost<(int, int), int> {\n    consume(w);\n    let tracked tag: TrackedAndGhost<(int, int), int> = TrackedAndGhost((x, y), z);\n    let tracked TrackedAndGhost((a, b), c) = tag;\n    TrackedAndGhost((a, b), c)\n}\n\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Variables in exec code may be exec, ghost, or tracked.\n/// However, exec function parameters and return values are always exec.\n/// In these places, the library types Ghost and Tracked are used\n/// to wrap ghost values and tracked values.\n/// Ghost and tracked expressions Ghost(expr) and Tracked(expr) create values of type Ghost<T>\n/// and Tracked<T>, where expr is treated as proof code whose value is wrapped inside Ghost or Tracked.\n/// The view x@ of a Ghost or Tracked x is the ghost or tracked value inside the Ghost or Tracked.\nfn test_ghost_wrappers(x: u32, y: Ghost<u32>)\n    requires\n        x < 100,\n        y@ < 100,\n{\n    // Ghost(...) expressions can create values of type Ghost<...>:\n    let u: Ghost<int> = Ghost(my_spec_fun(x as int, y@ as int));\n    let mut v: Ghost<int> = Ghost(u@ + 1);\n    assert(v@ == x + y@ + 1);\n    proof {\n        v@ = v@ + 1;  // proof code may assign to the view of exec variables of type Ghost/Tracked\n    }\n    let w: Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v@ + 1;\n            temp + 1\n        },\n    );\n    assert(w@ == x + y@ + 4);\n}\n\nfn test_consume(t: Tracked<int>)\n    requires\n        t@ <= 7,\n{\n    proof {\n        let tracked x = t.get();\n        assert(x <= 7);\n        consume(x);\n    }\n}\n\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\nstruct S {}\n\n/// Exec code can use \"let ghost\" and \"let tracked\" to create local ghost and tracked variables.\n/// Exec code can extract individual ghost and tracked values from Ghost and Tracked wrappers\n/// with \"let ...Ghost(x)...\" and \"let ...Tracked(x)...\".\nfn test_ghost_tuple_match(t: (Tracked<S>, Tracked<S>, Ghost<int>, Ghost<int>)) -> Tracked<S> {\n    let ghost g: (int, int) = (10, 20);\n    assert(g.0 + g.1 == 30);\n    let ghost (g1, g2) = g;\n    assert(g1 + g2 == 30);\n    // b1, b2: Tracked<S> and g3, g4: Ghost<int>\n    let (Tracked(b1), Tracked(b2), Ghost(g3), Ghost(g4)) = t;\n    Tracked(b2)\n}\n\n/// Exec code can Ghost(...) or Tracked(...) unwrapped parameter\n/// to create a mutable ghost or tracked parameter:\nfn test_ghost_mut(Ghost(g): Ghost<&mut int>)\n    ensures\n        *g == *old(g) + 1,\n{\n    proof {\n        *g = *g + 1;\n    }\n}\n\nfn test_call_ghost_mut() {\n    let ghost mut g = 10int;\n    test_ghost_mut(Ghost(&mut g));\n    assert(g == 11);\n}\n\n/// Spec functions are not checked for correctness (although they are checked for termination).\n/// However, marking a spec function as \"spec(checked)\" enables lightweight \"recommends checking\"\n/// inside the spec function.\nspec(checked) fn my_spec_fun2(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    // Because of spec(checked), Verus checks that my_spec_fun's recommends clauses are satisfied here:\n    my_spec_fun(x, y)\n}\n\n/// Spec functions may omit their body, in which case they are considered\n/// uninterpreted (returning an arbitrary value of the return type depending on the input values).\n/// This is safe, since spec functions (unlike proof and exec functions) may always\n/// return arbitrary values of any type,\n/// where the value may be special \"bottom\" value for otherwise uninhabited types.\nuninterp spec fn my_uninterpreted_fun1(i: int, j: int) -> int;\n\nuninterp spec fn my_uninterpreted_fun2(i: int, j: int) -> int\n    recommends\n        0 <= i < 10,\n        0 <= j < 10,\n;\n\n/// Trait functions may have specifications\ntrait T {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int)\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    ;\n\n    /// A trait function may have a default (provided) implementation,\n    /// and this default may have additional ensures specified with default_ensures\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n        default_ensures\n            i == r || j == r,\n        {\n            if i >= j { i } else { j }\n        }\n}\n\nstruct S1;\nstruct S2;\n\n/// An impl can choose to use the default impl of my_function_with_a_default,\n/// in which case the default_ensures applies to my_function_with_a_default\nimpl T for S1 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n}\n\n/// An impl can choose not to use the default impl of my_function_with_a_default,\n/// and instead provide its own impl, in which case the default_ensures is ignored\nimpl T for S2 {\n    proof fn my_function_decl(&self, i: int, j: int) -> (r: int) {\n        i + j\n    }\n\n    fn my_function_with_a_default(&self, i: u32, j: u32) -> (r: u32)\n        ensures\n            r == i + j,\n    {\n        i + j\n    }\n}\n\nenum ThisOrThat {\n    This(nat),\n    That { v: int },\n}\n\nproof fn uses_is(t: ThisOrThat) {\n    match t {\n        ThisOrThat::This(..) => {\n            assert(t is This);\n            assert(t !is That);\n        },\n        ThisOrThat::That { .. } => {\n            assert(t is That);\n            assert(t !is This);\n        },\n    }\n}\n\nproof fn uses_arrow_matches_1(t: ThisOrThat)\n    requires\n        t is That ==> t->v == 3,\n        t is This ==> t->0 == 4,\n{\n    assert(t matches ThisOrThat::This(k) ==> k == 4);\n    assert(t matches ThisOrThat::That { v } ==> v == 3);\n}\n\nproof fn uses_arrow_matches_2(t: ThisOrThat)\n    requires\n        t matches ThisOrThat::That { v: a } && a == 3,\n{\n    assert(t is That && t->v == 3);\n}\n\nproof fn uses_spec_has(s: Set<int>, ms: vstd::multiset::Multiset<int>)\n    requires\n        s has 3,\n        ms has 4,\n{\n    assert(s has 3);\n    assert(s has 3 == s has 3);\n    assert(ms has 4);\n    assert(ms has 4 == ms has 4);\n}\n\nproof fn broadcast_use() {\n    // you can use broadcase use on the module level, in proof functions,\n    // in proof blocks, or in assert-by\n    broadcast use vstd::seq_lib::group_seq_properties;\n    // you can also use multiple broadcast lemmas at once\n    broadcast use {\n        vstd::multiset::group_multiset_properties,\n        vstd::multiset::group_multiset_axioms,\n    };\n    // although we don't support a list of paths with common prefix like:\n    // broadcast use vstd::multiset::{group_multiset_properties, group_multiset_axioms};\n\n    assert forall|s: Seq<usize>, v: usize, x: usize|\n        { s.contains(x) ==> s.push(v).contains(x) } by {\n        broadcast use vstd::seq_lib::group_seq_properties;\n\n    };\n}\n\n/// Specifications can be assumed for functions and constants from outside Verus.\n/// Warning: such specifications are trusted to be correct, so they must be chosen carefully.\nassume_specification[EXTERNAL_C] -> u8\n    returns\n        7u8,\n;\n\nassume_specification[external_f](u: u8) -> (r: u8)\n    ensures\n        r <= u,\n;\n\nfn test_external() {\n    assert(EXTERNAL_C == 7);\n    let x = external_f(10);\n    assert(x <= 10);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/syntax.rs", "verified": true, "metadata": {"original_id": "verus_syntax_f99cb97e6734", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ac09e9633e26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ac09e9633e26", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b317f7559d1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b317f7559d1", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a464d007e6e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a464d007e6e5", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a2378f16ca4f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases j\ninvariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "a2378f16ca4f", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0950cf6fc38a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires run_length_encoder_precond (input @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >) requires run_length_encoder_precond (input @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_68/verina_advanced_68_iter_0_original.rs", "verified": true, "metadata": {"original_id": "0950cf6fc38a", "function_name": "run_length_encoder", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_173d5a806fa4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k.rs", "verified": true, "metadata": {"original_id": "173d5a806fa4", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f350ee6f590d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >)  { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { ch } else { str1 [i] }) , { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str . len () == index , forall | i : int | 0 <= i < index ==> out_str [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == 32 { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "f350ee6f590d", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_02f422f0dd20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)   { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize)  { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "target_text": "requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , canyon_search_precond (a @ , b @) \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n\ndecreases a . len () + b . len () - m - n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn canyon_search_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 && is_sorted (a) && is_sorted (b) }\nspec fn is_sorted (s : Seq < i32 >) -> bool { forall | i : int , j : int | 0 <= i < j < s . len () ==> s [i] <= s [j] }\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\nfn canyon_search (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : usize) requires canyon_search_precond (a @ , b @) , { let initial_diff = nat_abs_diff (a [0] , b [0]) ; canyon_search_aux (a , b , 0 , 0 , initial_diff) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_current.rs", "verified": true, "metadata": {"original_id": "02f422f0dd20", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4992a05a5b8b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "4992a05a5b8b", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fd655cfaff58", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)   { let mut i = 0 ; let ghost original_x = x @ ; while i < x . len ()  { let old_val = x [i] ;   x . set (i , old_val + 4) ;   i += 1 ; }  }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB \nensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , original_x == old (x) @ , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == original_x [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == original_x [k] , forall | k : int | 0 <= k < x . len () ==> original_x [k] <= 0x7FFF_FFFB ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; let ghost original_x = x @ ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , original_x == old (x) @ , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == original_x [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == original_x [k] , forall | k : int | 0 <= k < x . len () ==> original_x [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (original_x [i as int] == old_val) ; assert (old_val <= 0x7FFF_FFFB) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < (i + 1) ==> # [trigger] x @ [k] == original_x [k] + 4) ; assert (forall | k : int | (i + 1) <= k < x . len () ==> # [trigger] x @ [k] == original_x [k]) ; i += 1 ; } assert (forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/map_impl.rs", "verified": true, "metadata": {"original_id": "fd655cfaff58", "function_name": "myfun2", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_dist_rwlock_ec71fb95be4e", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\ntokenized_state_machine!{\n    DistRwLock<T> {\n        fields {\n            #[sharding(constant)]\n            pub rc_width: int,\n\n            #[sharding(storage_option)]\n            pub storage: Option<T>,\n\n            #[sharding(variable)]\n            pub exc_locked: bool,\n\n            #[sharding(map)]\n            pub ref_counts: Map<int, int>,\n\n            #[sharding(option)]\n            pub exc_pending: Option<int>,\n\n            #[sharding(option)]\n            pub exc_guard: Option<()>,\n\n            #[sharding(multiset)]\n            pub shared_pending: Multiset<int>,\n\n            #[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,\n        }\n\n        init!{\n            initialize(rc_width: int, init_t: T) {\n                require(0 < rc_width);\n                init rc_width = rc_width;\n                init storage = Option::Some(init_t);\n                init exc_locked = false;\n                init ref_counts = Map::new(\n                    |i| 0 <= i < rc_width,\n                    |i| 0,\n                );\n                init exc_pending = Option::None;\n                init exc_guard = Option::None;\n                init shared_pending = Multiset::empty();\n                init shared_guard = Multiset::empty();\n            }\n        }\n\n        transition!{\n            exc_start() {\n                require(!pre.exc_locked);\n                update exc_locked = true;\n                add exc_pending += Some(0);\n            }\n        }\n\n        transition!{\n            exc_check_count() {\n                remove exc_pending -= Some(let r);\n                have ref_counts >= [r => 0];\n\n                add exc_pending += Some(r + 1);\n            }\n        }\n\n        transition!{\n            exc_finish() {\n                remove exc_pending -= Some(pre.rc_width);\n                add exc_guard += Some(());\n                withdraw storage -= Some(let _);\n            }\n        }\n\n        transition!{\n            exc_release(t: T) {\n                update exc_locked = false;\n                remove exc_guard -= Some(());\n                deposit storage += Some(t);\n            }\n        }\n\n        transition!{\n            shared_start(r: int) {\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc + 1];\n                add shared_pending += {r};\n            }\n        }\n\n        transition!{\n            shared_finish(r: int) {\n                require(!pre.exc_locked);\n                remove shared_pending -= {r};\n\n                birds_eye let t = pre.storage->0;\n                add shared_guard += {(r, t)};\n            }\n        }\n\n        transition!{\n            shared_release(val: (int, T)) {\n                remove shared_guard -= {val};\n\n                let r = val.0;\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc - 1];\n\n                };\n            }\n        }\n\n        property!{\n            do_guard(val: (int, T)) {\n                have shared_guard >= {val};\n                guard storage >= Some(val.1);\n            }\n        }\n\n        ///// Invariants and proofs\n\n        #[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n            &&& 0 < self.rc_width\n            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn exc_inv(&self) -> bool {\n            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)\n            &&& self.storage is Some <==> self.exc_guard is None\n            &&& if let Option::Some(cur_r) = self.exc_pending {\n                &&& 0 <= cur_r <= self.rc_width\n                &&& self.exc_guard is None\n                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)\n            } else {\n                true\n            }\n        }\n\n        #[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)\n        }\n\n        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n            shared_guard.filter(|val: (int, T)| val.0 == r)\n        }\n\n        #[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n            forall |r| 0 <= r < self.rc_width ==>\n                #[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +\n                        Self::filter_r(self.shared_guard, r).len() as int\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n            }\n\n        #[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n\n        }\n\n        #[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n            let prev_r = pre.exc_pending->0;\n            }\n\n        #[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n        }\n\n        #[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n        }\n\n        #[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) { }\n\n        #[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n            let t = pre.storage->0;\n\n            else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n\n                }\n            }\n        }\n\n        #[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n            let r = val.0;\n            else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                }\n            }\n        }\n    }\n}\n\nstruct_with_invariants!{\n    struct RwLock<T> {\n        inst: Tracked<DistRwLock::Instance<T>>,\n        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,\n        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,\n    }\n\n    spec fn wf(&self) -> bool {\n\n        predicate {\n            &&& self.inst@.rc_width() == self.ref_counts@.len()\n\n            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>\n                #[trigger] self.ref_counts@.index(i).well_formed()\n                && self.ref_counts@.index(i).constant() === (self.inst, i)\n        }\n\n         {\n            g.instance_id() == inst@.id()\n            && g.value() == b\n        }\n\n        {\n            g.instance_id() == inst@.id()\n            && g.key() == i\n            && g.value() == v as int\n        }\n    }\n}\n\nimpl<T> RwLock<T> {\n    #[verifier::spinoff_prover]\n    fn new(rc_width: usize, t: T) -> (s: Self)\n\n    {\n        let tracked inst;\n        let tracked exc_locked_token;\n        let tracked mut ref_counts_tokens;\n\n        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n        let exc_locked_atomic = AtomicBool::new(\n            Ghost(tracked_inst),\n            false,\n            Tracked(exc_locked_token),\n        );\n        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n        let mut i: usize = 0;\n        while i < rc_width\n\n        {\n\n            let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n            let rc_atomic = AtomicU64::new(\n                Ghost((tracked_inst, i as int)),\n                0,\n                Tracked(ref_count_token),\n            );\n            v.push(rc_atomic);\n            i = i + 1;\n            }\n        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n\n        s\n    }\n}\n\n} // verus!\nfn main() {}\n", "target_text": "requires 0 < rc_width\nensures s.wf()\ninvariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>), on ref_counts with (inst)\n            forall |i: int|\n            where (0 <= i < self.ref_counts@.len())\n            specifically (self.ref_counts@[i])\n            is (v: u64, g: DistRwLock::ref_counts<T>), i <= rc_width,\n                v@.len() == i as int,\n                forall|j: int|\n                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),\n                tracked_inst@ == inst,\n                ref_counts_tokens.instance_id() == inst.id(),\n                forall|j: int|\n                    #![trigger( ref_counts_tokens.dom().contains(j) )]\n                    #![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n                      && equal(ref_counts_tokens.index(j), 0))", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::map::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\nverus! {\n\ntokenized_state_machine!{\n    DistRwLock<T> {\n        fields {\n            #[sharding(constant)]\n            pub rc_width: int,\n\n            #[sharding(storage_option)]\n            pub storage: Option<T>,\n\n            #[sharding(variable)]\n            pub exc_locked: bool,\n\n            #[sharding(map)]\n            pub ref_counts: Map<int, int>,\n\n            #[sharding(option)]\n            pub exc_pending: Option<int>,\n\n            #[sharding(option)]\n            pub exc_guard: Option<()>,\n\n            #[sharding(multiset)]\n            pub shared_pending: Multiset<int>,\n\n            #[sharding(multiset)]\n            pub shared_guard: Multiset<(int, T)>,\n        }\n\n        init!{\n            initialize(rc_width: int, init_t: T) {\n                require(0 < rc_width);\n                init rc_width = rc_width;\n                init storage = Option::Some(init_t);\n                init exc_locked = false;\n                init ref_counts = Map::new(\n                    |i| 0 <= i < rc_width,\n                    |i| 0,\n                );\n                init exc_pending = Option::None;\n                init exc_guard = Option::None;\n                init shared_pending = Multiset::empty();\n                init shared_guard = Multiset::empty();\n            }\n        }\n\n        transition!{\n            exc_start() {\n                require(!pre.exc_locked);\n                update exc_locked = true;\n                add exc_pending += Some(0);\n            }\n        }\n\n        transition!{\n            exc_check_count() {\n                remove exc_pending -= Some(let r);\n                have ref_counts >= [r => 0];\n\n                add exc_pending += Some(r + 1);\n            }\n        }\n\n        transition!{\n            exc_finish() {\n                remove exc_pending -= Some(pre.rc_width);\n                add exc_guard += Some(());\n                withdraw storage -= Some(let _);\n            }\n        }\n\n        transition!{\n            exc_release(t: T) {\n                update exc_locked = false;\n                remove exc_guard -= Some(());\n                deposit storage += Some(t);\n            }\n        }\n\n        transition!{\n            shared_start(r: int) {\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc + 1];\n                add shared_pending += {r};\n            }\n        }\n\n        transition!{\n            shared_finish(r: int) {\n                require(!pre.exc_locked);\n                remove shared_pending -= {r};\n\n                birds_eye let t = pre.storage->0;\n                add shared_guard += {(r, t)};\n            }\n        }\n\n        transition!{\n            shared_release(val: (int, T)) {\n                remove shared_guard -= {val};\n\n                let r = val.0;\n                remove ref_counts -= [r => let rc];\n                add ref_counts += [r => rc - 1];\n\n                assert(rc > 0) by {\n                    assert(0 <= r < pre.rc_width);\n                    assert(pre.shared_guard.count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).count(val) > 0);\n                    assert(Self::filter_r(pre.shared_guard, r).len() > 0);\n                    assert(pre.ref_counts.index(r) > 0);\n                };\n            }\n        }\n\n        property!{\n            do_guard(val: (int, T)) {\n                have shared_guard >= {val};\n                guard storage >= Some(val.1);\n            }\n        }\n\n        ///// Invariants and proofs\n\n        #[invariant]\n        pub fn ref_counts_domain(&self) -> bool {\n            &&& 0 < self.rc_width\n            &&& forall |i: int| 0 <= i < self.rc_width <==> self.ref_counts.dom().contains(i)\n        }\n\n        #[invariant]\n        pub fn exc_inv(&self) -> bool {\n            &&& self.exc_locked <==> (self.exc_pending is Some || self.exc_guard is Some)\n            &&& self.storage is Some <==> self.exc_guard is None\n            &&& if let Option::Some(cur_r) = self.exc_pending {\n                &&& 0 <= cur_r <= self.rc_width\n                &&& self.exc_guard is None\n                &&& forall |x| self.shared_guard.count(x) > 0 ==> !(0 <= x.0 < cur_r)\n            } else {\n                true\n            }\n        }\n\n        #[invariant]\n        pub fn shared_pending_in_range(&self) -> bool {\n            forall |r| self.shared_pending.count(r) > 0 ==> (0 <= r < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_guard_in_range(&self) -> bool {\n            forall |x| self.shared_guard.count(x) > 0 ==> (0 <= x.0 < self.rc_width)\n        }\n\n        #[invariant]\n        pub fn shared_inv_agree(&self) -> bool {\n            forall |v| #[trigger] self.shared_guard.count(v) > 0 ==>\n                self.storage === Option::Some(v.1)\n        }\n\n        pub closed spec fn filter_r(shared_guard: Multiset<(int, T)>, r: int) -> Multiset<(int, T)> {\n            shared_guard.filter(|val: (int, T)| val.0 == r)\n        }\n\n        #[invariant]\n        pub fn shared_counts_agree(&self) -> bool {\n            forall |r| 0 <= r < self.rc_width ==>\n                #[trigger] self.ref_counts.index(r) ==\n                    self.shared_pending.count(r) as int +\n                        Self::filter_r(self.shared_guard, r).len() as int\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, rc_width: int, init_t: T) {\n            assert forall |r| 0 <= r < post.rc_width implies\n                #[trigger] post.ref_counts.index(r) ==\n                    post.shared_pending.count(r) as int +\n                        Self::filter_r(post.shared_guard, r).len() as int\n            by {\n                assert(post.ref_counts.index(r) == 0);\n                assert(post.shared_pending.count(r) == 0);\n                assert_multisets_equal!(\n                    Self::filter_r(post.shared_guard, r),\n                    Multiset::empty(),\n                );\n                assert(Self::filter_r(post.shared_guard, r).len() == 0);\n            }\n            assert(post.shared_counts_agree());\n        }\n\n        #[inductive(exc_start)]\n        fn exc_start_inductive(pre: Self, post: Self) {\n\n        }\n\n        #[inductive(exc_check_count)]\n        fn exc_check_count_inductive(pre: Self, post: Self) {\n            let prev_r = pre.exc_pending->0;\n            assert forall |x| #[trigger] post.shared_guard.count(x) > 0\n                && x.0 == prev_r implies false\n            by {\n                assert(Self::filter_r(post.shared_guard, prev_r).count(x) > 0);\n            }\n        }\n\n        #[inductive(exc_finish)]\n        fn exc_finish_inductive(pre: Self, post: Self) {\n        }\n\n        #[inductive(exc_release)]\n        fn exc_release_inductive(pre: Self, post: Self, t: T) {\n\n        }\n\n        #[inductive(shared_start)]\n        fn shared_start_inductive(pre: Self, post: Self, r: int) { }\n\n        #[inductive(shared_finish)]\n        fn shared_finish_inductive(pre: Self, post: Self, r: int) {\n            let t = pre.storage->0;\n\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r == r0 {\n                    assert_multisets_equal!(\n                        pre.shared_pending,\n                        post.shared_pending.add(Multiset::singleton(r))\n                    );\n                    assert_multisets_equal!(\n                        Self::filter_r(post.shared_guard, r),\n                        Self::filter_r(pre.shared_guard, r).add(\n                            Multiset::singleton((r, t)))\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                    assert(post.ref_counts.index(r0) ==\n                        post.shared_pending.count(r0) as int +\n                            Self::filter_r(post.shared_guard, r0).len() as int);\n                }\n            }\n        }\n\n        #[inductive(shared_release)]\n        fn shared_release_inductive(pre: Self, post: Self, val: (int, T)) {\n            let r = val.0;\n            assert forall |r0| 0 <= r0 < post.rc_width implies\n                #[trigger] post.ref_counts.index(r0) ==\n                    post.shared_pending.count(r0) as int +\n                        Self::filter_r(post.shared_guard, r0).len() as int\n            by {\n                if r0 == r {\n                    assert_multisets_equal!(\n                        Self::filter_r(pre.shared_guard, r),\n                        Self::filter_r(post.shared_guard, r).add(\n                            Multiset::singleton(val))\n                    );\n                } else {\n                    assert_multisets_equal!(\n                          Self::filter_r(post.shared_guard, r0),\n                          Self::filter_r(pre.shared_guard, r0)\n                    );\n                }\n            }\n        }\n    }\n}\n\nstruct_with_invariants!{\n    struct RwLock<T> {\n        inst: Tracked<DistRwLock::Instance<T>>,\n        exc_locked: AtomicBool<_, DistRwLock::exc_locked<T>, _>,\n        ref_counts: Vec<AtomicU64<_, DistRwLock::ref_counts<T>, _>>,\n    }\n\n    spec fn wf(&self) -> bool {\n\n        predicate {\n            &&& self.inst@.rc_width() == self.ref_counts@.len()\n\n            &&& forall |i: int| (0 <= i && i < self.ref_counts@.len()) ==>\n                #[trigger] self.ref_counts@.index(i).well_formed()\n                && self.ref_counts@.index(i).constant() === (self.inst, i)\n        }\n\n        invariant on exc_locked with (inst) is (b: bool, g: DistRwLock::exc_locked<T>) {\n            g.instance_id() == inst@.id()\n            && g.value() == b\n        }\n\n        invariant on ref_counts with (inst)\n            forall |i: int|\n            where (0 <= i < self.ref_counts@.len())\n            specifically (self.ref_counts@[i])\n            is (v: u64, g: DistRwLock::ref_counts<T>)\n        {\n            g.instance_id() == inst@.id()\n            && g.key() == i\n            && g.value() == v as int\n        }\n    }\n}\n\nimpl<T> RwLock<T> {\n    #[verifier::spinoff_prover]\n    fn new(rc_width: usize, t: T) -> (s: Self)\n        requires\n            0 < rc_width,\n        ensures\n            s.wf(),\n    {\n        let tracked inst;\n        let tracked exc_locked_token;\n        let tracked mut ref_counts_tokens;\n        proof {\n            let tracked (\n                Tracked(inst0),\n                Tracked(exc_locked_token0),\n                Tracked(ref_counts_tokens0),\n                _,\n                _,\n                _,\n                _,\n            ) = DistRwLock::Instance::initialize(rc_width as int, t, Option::Some(t));\n            inst = inst0;\n            exc_locked_token = exc_locked_token0;\n            ref_counts_tokens = ref_counts_tokens0;\n        }\n        let tracked_inst: Tracked<DistRwLock::Instance<T>> = Tracked(inst.clone());\n        let exc_locked_atomic = AtomicBool::new(\n            Ghost(tracked_inst),\n            false,\n            Tracked(exc_locked_token),\n        );\n        let mut v: Vec<AtomicU64<(Tracked<DistRwLock::Instance<T>>, int), DistRwLock::ref_counts<T>, _>> = Vec::new();\n        let mut i: usize = 0;\n        assert forall|j: int|\n            i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)\n        by {\n            assert(ref_counts_tokens.dom().contains(j));\n            assert(equal(ref_counts_tokens.index(j), 0));\n        }\n        assert(forall|j: int|\n            #![trigger( ref_counts_tokens.dom().contains(j) )]\n            #![trigger( ref_counts_tokens.index(j) )]\n            i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n              && equal(ref_counts_tokens.index(j), 0)));\n        while i < rc_width\n            invariant\n                i <= rc_width,\n                v@.len() == i as int,\n                forall|j: int|\n                    0 <= j && j < i ==> #[trigger] v@.index(j).well_formed()\n                      && equal(v@.index(j).constant(), (tracked_inst, j)),\n                tracked_inst@ == inst,\n                ref_counts_tokens.instance_id() == inst.id(),\n                forall|j: int|\n                    #![trigger( ref_counts_tokens.dom().contains(j) )]\n                    #![trigger( ref_counts_tokens.index(j) )]\n                    i <= j && j < rc_width ==> (ref_counts_tokens.dom().contains(j)\n                      && equal(ref_counts_tokens.index(j), 0)),\n        {\n            assert(ref_counts_tokens.dom().contains(i as int));\n            let tracked ref_count_token = ref_counts_tokens.remove(i as int);\n            let rc_atomic = AtomicU64::new(\n                Ghost((tracked_inst, i as int)),\n                0,\n                Tracked(ref_count_token),\n            );\n            v.push(rc_atomic);\n            i = i + 1;\n            assert forall|j: int|\n                i <= j && j < rc_width implies #[trigger] ref_counts_tokens.dom().contains(j)\n                && equal(ref_counts_tokens.index(j), 0)\n            by {\n                assert(ref_counts_tokens.dom().contains(j));\n                assert(equal(ref_counts_tokens.index(j), 0));\n            }\n        }\n        let s = RwLock { inst: Tracked(inst), exc_locked: exc_locked_atomic, ref_counts: v };\n        assert(s.inst@.rc_width() == s.ref_counts@.len());\n        s\n    }\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/dist_rwlock.rs", "verified": true, "metadata": {"original_id": "verus_dist_rwlock_ec71fb95be4e", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0d7fc03d6b31", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "ensures if let Some (idx) = index\ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "0d7fc03d6b31", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_59491bd7047f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "59491bd7047f", "function_name": "secondSmallestAux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_905451bd1db2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s2if_impl.rs", "verified": true, "metadata": {"original_id": "905451bd1db2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ce23c4a317b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start <= end , end < nums . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize) requires start <= end , end < nums . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_74/verina_advanced_74.rs", "verified": true, "metadata": {"original_id": "ce23c4a317b5", "function_name": "count_distinct_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_568c63b3821b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "568c63b3821b", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0b80a21ebf16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "0b80a21ebf16", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_365d1b5de023", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "365d1b5de023", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_80e5ff8a1c6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "80e5ff8a1c6b", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5981a860cec4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut i = 1 ; while i < lists . len ()  { if lists [i] . len () < min_length { min_length = lists [i] . len () ; } i += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - i\ninvariant 1 <= i <= lists . len () , exists | j : int | # ! [auto] 0 <= j < i && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < i ==> min_length <= lists [j] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut i = 1 ; while i < lists . len () invariant 1 <= i <= lists . len () , exists | j : int | # ! [auto] 0 <= j < i && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < i ==> min_length <= lists [j] . len () , decreases lists . len () - i { if lists [i] . len () < min_length { min_length = lists [i] . len () ; } i += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "5981a860cec4", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c79f8e3c801e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for j in 0 .. text . len ()  { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c79f8e3c801e", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_24f503f98de4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "24f503f98de4", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d19a2f294596", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { new_char } else { str1 [k] }) , { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char\ndecreases str1 @ . len () - index\ninvariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 @ . len () , result_str @ . len () == index , forall | k : int | 0 <= k < index ==> result_str [k] == (if str1 [k] == old_char { new_char } else { str1 [k] }) , decreases str1 @ . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d19a2f294596", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_28cea2e5ca93", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "28cea2e5ca93", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_220392b1dbcd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 9 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 9 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "220392b1dbcd", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6d7eea4062f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_11/verina_basic_11_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6d7eea4062f0", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cc992d27e65f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_8/verina_basic_8_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cc992d27e65f", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8b01d3f77b68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "8b01d3f77b68", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6fb842169152", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "6fb842169152", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_481feda38498", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "481feda38498", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6ca652996d59", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases j\ninvariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/reverse_impl.rs", "verified": true, "metadata": {"original_id": "6ca652996d59", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_03383a09eecd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_impl.rs", "verified": true, "metadata": {"original_id": "03383a09eecd", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3e18ee679b08", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "3e18ee679b08", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c2cae5d7ae88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len ()  { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - idx\ninvariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_len = lists [0] . len () ; let mut idx = 0 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx ==> min_len == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_len <= lists [i] . len () , min_len == lists [0] . len () || exists | i : int | # ! [auto] 0 <= i < idx && min_len == lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_len { min_len = lists [idx] . len () ; } idx += 1 ; } min_len }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "c2cae5d7ae88", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_79af04ba5740", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)   { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "target_text": "requires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] \ndecreases a . len () - i , b . len () - j \ninvariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , decreases a . len () - i , { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] , decreases b . len () - j , { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_concat_strong_iter_2_current.rs", "verified": true, "metadata": {"original_id": "79af04ba5740", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_461dd9f512e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "461dd9f512e3", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_546d43a7e6b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { if r . len () == 0 || x . len () == 0 { return false ; } r . len () == x . len () }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { if r . len () == 0 || x . len () == 0 { return false ; } r . len () == x . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "546d43a7e6b7", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9a7e15a407f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9a7e15a407f2", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_00f622c61972", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "00f622c61972", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f59b35d8bc93", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_consecutive_numbers (arr : & Vec < i32 >) -> (is_consecutive : bool)   { for idx in 0 .. arr . len () - 1  {    if arr [idx] + 1 != arr [idx + 1] { return false ; } } return true ; }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) \nensures is_consecutive == (forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 ==> (arr [i] + 1 == arr [j])) \ninvariant arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 && j <= idx ==> (arr [i] + 1 == arr [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_consecutive_numbers (arr : & Vec < i32 >) -> (is_consecutive : bool) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , ensures is_consecutive == (forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 ==> (arr [i] + 1 == arr [j])) , { for idx in 0 .. arr . len () - 1 invariant arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 && j <= idx ==> (arr [i] + 1 == arr [j]) , { assert (idx < arr . len () - 1) ; assert (idx + 1 < arr . len ()) ; assert (0 <= arr [idx as int] + 1 < MAX) ; if arr [idx] + 1 != arr [idx + 1] { return false ; } } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_472_impl.rs", "verified": true, "metadata": {"original_id": "f59b35d8bc93", "function_name": "contains_consecutive_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6fa6a4b78604", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)   { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len ()  { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "target_text": "requires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>\ninvariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_impl.rs", "verified": true, "metadata": {"original_id": "6fa6a4b78604", "function_name": "pluck_smallest_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4a0a6071762c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4a0a6071762c", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1911c106f11b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1911c106f11b", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c8b0aaf19948", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/conditional_average_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c8b0aaf19948", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_40b51ce988ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "40b51ce988ca", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ec23d0a58b0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "ec23d0a58b0c", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_854232062866", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "854232062866", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ba2b93e9b86f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ba2b93e9b86f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7f75b9518fba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ninvariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int) { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_even_list/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7f75b9518fba", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_50296f7919e9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "50296f7919e9", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6fe2a4613e65", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)   { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "target_text": "requires 0 <= n <= 9 \nensures single_digit_number_to_char (n as nat) == output ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6fe2a4613e65", "function_name": "single_digit_number_to_char_impl", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fc4987386731", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_477_impl.rs", "verified": true, "metadata": {"original_id": "fc4987386731", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e63aef947d25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool)   { let first_len = seq [0] . len () ; for k in 1 .. seq . len ()  { if seq [k] . len () != first_len {   return false ; } }   true }\n\n} // verus!", "target_text": "requires seq . len () > 0 \nensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) \ninvariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , forall | i : int , j : int | (0 <= i < k && 0 <= j < k) ==> seq [i] . len () == seq [j] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , forall | i : int , j : int | (0 <= i < k && 0 <= j < k) ==> seq [i] . len () == seq [j] . len () , { if seq [k] . len () != first_len { assert (seq [0] . len () != seq [k as int] . len ()) ; assert (! (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ())) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; assert (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ()) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "e63aef947d25", "function_name": "all_sequence_equal_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1b7c625ce440", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)   { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len ()  { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "target_text": "requires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>\ninvariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1b7c625ce440", "function_name": "pluck_smallest_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_553a4b7e9bf1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/replace_iter_2_current.rs", "verified": true, "metadata": {"original_id": "553a4b7e9bf1", "function_name": "replace", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_26115561dc1d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2u32 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "26115561dc1d", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_84a6c8f03f06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "84a6c8f03f06", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a667ec7fce1e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m \ndecreases a . len () - idx \ninvariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a667ec7fce1e", "function_name": "MaxA", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ca3ab1ad7572", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)   {       }\nfn encode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let encoded = encode_char (s [i]) ; result . push (encoded) ;  i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 , 65 <= c <= 90 , forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 \nensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , r == encode_char_spec (c as int) , 65 <= r <= 90 , s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] \ndecreases s . len () - i \ninvariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "ca3ab1ad7572", "function_name": "encode_shift", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3d99d9e8b328", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/cal_div_impl.rs", "verified": true, "metadata": {"original_id": "3d99d9e8b328", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7de4d12e5805", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >)  { let len = a . len () ; let mut i : usize = 0 ; while i < len  { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \ndecreases len - i, len - j\ninvariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_selectionsort/verus_code_iter_4_current.rs", "verified": true, "metadata": {"original_id": "7de4d12e5805", "function_name": "selection_sort", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f5067fb24cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_72/verina_advanced_72_impl.rs", "verified": true, "metadata": {"original_id": "0f5067fb24cf", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0b02a12a0f0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { return 0 ; }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_24/verina_advanced_24_iter_0_original.rs", "verified": true, "metadata": {"original_id": "0b02a12a0f0b", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ee0ef33b3821", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ee0ef33b3821", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1e5fdb50a7b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/023-strlen_impl.rs", "verified": true, "metadata": {"original_id": "1e5fdb50a7b8", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_04656fd6220f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/063-fibfib_iter_0_original.rs", "verified": true, "metadata": {"original_id": "04656fd6220f", "function_name": "fibfib", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d0e8f0582195", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "d0e8f0582195", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2270ec249b07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32)   { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len ()  { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "target_text": "requires v . len () > 0 \nensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] \ndecreases v . len () - idx\ninvariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "2270ec249b07", "function_name": "min_of_vec", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0451d58550f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32)   { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "requires d > 0, count_sum_divisible_by_precond (n as nat , d as nat)\nensures result == is_sum_divisible_by (x as nat , d as nat), result == sum_of_digits (x as nat), result == count_sum_divisible_by_spec (n as nat , d as nat)\ndecreases n, x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "0451d58550f1", "function_name": "count_sum_divisible_by", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_fef14b4409cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "fef14b4409cb", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b12bea9078ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b12bea9078ca", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7bc3232cdb17", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len ()  { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; }  max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - k\ninvariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "7bc3232cdb17", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1b9fc28a6b85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms5_impl.rs", "verified": true, "metadata": {"original_id": "1b9fc28a6b85", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_32f4dd8b6917", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64)   { if k == 0 || k == n { return 1 ; } let actual_k = if k > n - k { n - k } else { k } ; let mut dp = Vec :: new () ; dp . push (1u64) ; for i in 1 ..= n { let mut new_row = Vec :: new () ; new_row . push (1u64) ; for j in 1 ..= actual_k { if j > i { new_row . push (0u64) ; } else if j == i { new_row . push (1u64) ; } else { let prev_val = if j < dp . len () as u64 { dp [j as usize] } else { 0u64 } ; let prev_val_minus_1 = if j > 0 && (j - 1) < dp . len () as u64 { dp [(j - 1) as usize] } else { 0u64 } ; new_row . push (prev_val + prev_val_minus_1) ; } } dp = new_row ; } if actual_k < dp . len () as u64 { dp [actual_k as usize] } else { 0 } }\n\n} // verus!", "target_text": "requires 0 <= k <= n \nensures result as nat == comb (n as nat , k as nat) \ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn comb (n : nat , k : nat) -> nat recommends 0 <= k <= n decreases n { if k == 0 || k == n { 1 } else if k > n { 0 } else { comb (sub (n , 1) , k) + comb (sub (n , 1) , sub (k , 1)) } }\n# [verifier :: external_body] fn comb_method (n : u64 , k : u64) -> (result : u64) requires 0 <= k <= n , ensures result as nat == comb (n as nat , k as nat) , { if k == 0 || k == n { return 1 ; } let actual_k = if k > n - k { n - k } else { k } ; let mut dp = Vec :: new () ; dp . push (1u64) ; for i in 1 ..= n { let mut new_row = Vec :: new () ; new_row . push (1u64) ; for j in 1 ..= actual_k { if j > i { new_row . push (0u64) ; } else if j == i { new_row . push (1u64) ; } else { let prev_val = if j < dp . len () as u64 { dp [j as usize] } else { 0u64 } ; let prev_val_minus_1 = if j > 0 && (j - 1) < dp . len () as u64 { dp [(j - 1) as usize] } else { 0u64 } ; new_row . push (prev_val + prev_val_minus_1) ; } } dp = new_row ; } if actual_k < dp . len () as u64 { dp [actual_k as usize] } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyProjects_tmp_tmp2acw_s4s_CombNK/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "32f4dd8b6917", "function_name": "comb_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c30a896098fa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c30a896098fa", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_92787446740f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len ()  { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - index\ninvariant lists . len () > 0 , 1 <= index <= lists . len () , exists | j : int | # ! [auto] 0 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut index = 1 ; while index < lists . len () invariant lists . len () > 0 , 1 <= index <= lists . len () , exists | j : int | # ! [auto] 0 <= j < index && min_length == lists [j] . len () , forall | j : int | # ! [auto] 0 <= j < index ==> min_length <= lists [j] . len () , decreases lists . len () - index { if lists [index] . len () < min_length { min_length = lists [index] . len () ; } index += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "92787446740f", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_20ea3409a894", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut idx = 0 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ndecreases nums . len () - idx\ninvariant 0 <= idx <= nums . len () , nums . len () > 0 , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < nums @ . len () && nums @ [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 0 ; while idx < nums . len () invariant 0 <= idx <= nums . len () , nums . len () > 0 , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < nums @ . len () && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "20ea3409a894", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_18e19141fc74", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx \ninvariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "18e19141fc74", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4e0f7b3ed23b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "4e0f7b3ed23b", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c55fc8a62bc8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "c55fc8a62bc8", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_42686e039876", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { if n <= a [i] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> n > a [j] decreases a . len () - i { if n <= a [i] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_10/verina_basic_10_iter_2_current.rs", "verified": true, "metadata": {"original_id": "42686e039876", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bcd1a0f2c0c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_triple3/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "bcd1a0f2c0c0", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_efd0d863cf28", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "efd0d863cf28", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e7149d4ece38", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut index = 0 ; while index < arr1 . len ()  {  if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - index \ninvariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e7149d4ece38", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e860a0dfb500", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn pow (base : int , exp : nat) -> int { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool)   {  if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "target_text": "requires is_power_of_two_precond (n as int) \nensures is_power_of_two_postcond (n as int , result) \ndecreases exp", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn pow (base : int , exp : nat) -> int decreases exp { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool) requires is_power_of_two_precond (n as int) , ensures is_power_of_two_postcond (n as int , result) , { proof { admit () ; } if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_23/verina_advanced_23_impl.rs", "verified": true, "metadata": {"original_id": "e860a0dfb500", "function_name": "is_power_of_two", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_851b2d1edccf", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ninvariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len () invariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/findmax_iter_1_current.rs", "verified": true, "metadata": {"original_id": "851b2d1edccf", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6261e84a8efc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6261e84a8efc", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e7d4b3a9c731", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max \ndecreases a . len () - idx\ninvariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/035-max-element_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e7d4b3a9c731", "function_name": "max_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3c122e30da50", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rotation_split (len : usize , n : usize) -> int { len - (n % len) }\nfn rotate_right (list : & Vec < u32 > , n : usize) -> (new_list : Vec < u32 >)   { let len = list . len () ; let split_point = len - (n % len) ;     let mut new_list = Vec :: new () ; let mut i = split_point ; while i < len  {   new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < split_point  {    new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures new_list . len () == list . len () , new_list @ == list @ . subrange (rotation_split (list . len () , n) as int , list @ . len () as int) . add (list @ . subrange (0 , rotation_split (list . len () , n) as int) ,) \ndecreases len - i , split_point - j \ninvariant list . len () > 0 , len == list . len () , split_point <= len , split_point <= i <= len , new_list . len () == i - split_point , split_point as int <= i as int <= len as int , split_point as int <= list @ . len () , i as int <= list @ . len () , new_list @ == list @ . subrange (split_point as int , i as int) , list . len () > 0 , len == list . len () , split_point <= len , 0 <= j <= split_point , new_list . len () == (len - split_point) + j , split_point as int <= len as int , j as int <= split_point as int , j as int <= len as int , 0 <= j as int , split_point as int <= list @ . len () , len as int == list @ . len () , new_list @ == list @ . subrange (split_point as int , len as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rotation_split (len : usize , n : usize) -> int { len - (n % len) }\nfn rotate_right (list : & Vec < u32 > , n : usize) -> (new_list : Vec < u32 >) requires list . len () > 0 , ensures new_list . len () == list . len () , new_list @ == list @ . subrange (rotation_split (list . len () , n) as int , list @ . len () as int) . add (list @ . subrange (0 , rotation_split (list . len () , n) as int) ,) , { let len = list . len () ; let split_point = len - (n % len) ; assert (split_point <= len) ; assert (split_point == len - (n % len)) ; assert (n % len < len) ; assert (split_point >= 0) ; let mut new_list = Vec :: new () ; let mut i = split_point ; while i < len invariant list . len () > 0 , len == list . len () , split_point <= len , split_point <= i <= len , new_list . len () == i - split_point , split_point as int <= i as int <= len as int , split_point as int <= list @ . len () , i as int <= list @ . len () , new_list @ == list @ . subrange (split_point as int , i as int) , decreases len - i , { assert (i < len) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < split_point invariant list . len () > 0 , len == list . len () , split_point <= len , 0 <= j <= split_point , new_list . len () == (len - split_point) + j , split_point as int <= len as int , j as int <= split_point as int , j as int <= len as int , 0 <= j as int , split_point as int <= list @ . len () , len as int == list @ . len () , new_list @ == list @ . subrange (split_point as int , len as int) . add (list @ . subrange (0 , j as int)) , decreases split_point - j , { assert (j < split_point) ; assert (split_point <= len) ; assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_743_impl.rs", "verified": true, "metadata": {"original_id": "3c122e30da50", "function_name": "rotate_right", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_328ac51dd5ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "328ac51dd5ab", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b332b249c5a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b332b249c5a1", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_74aa4741c084", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize)   { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n\n} // verus!", "target_text": "requires 0 < alignment \nensures result == space_needed_for_alignment (addr as int , alignment as int)\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "74aa4741c084", "function_name": "get_space_needed_for_alignment_usize", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a4ddf50d615f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "a4ddf50d615f", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_36c743448a89", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires find_majority_element_precond (lst @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_11/verina_advanced_11.rs", "verified": true, "metadata": {"original_id": "36c743448a89", "function_name": "find_majority_element", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6b01cb537ca4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/barrier_impl.rs", "verified": true, "metadata": {"original_id": "6b01cb537ca4", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a19ad3009255", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize)  { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "target_text": "ensures result as nat == spec_nat_abs_diff (x , y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a19ad3009255", "function_name": "nat_abs_diff", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9096ee632f69", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_11/verina_basic_11_impl.rs", "verified": true, "metadata": {"original_id": "9096ee632f69", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_464782cdce4a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "464782cdce4a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8f1df1d685c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f1df1d685c7", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fbed276fae94", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 \nensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_32/verina_advanced_32.rs", "verified": true, "metadata": {"original_id": "fbed276fae94", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1b038818209c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > decreases nums . len () - i { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_79/verina_advanced_79.rs", "verified": true, "metadata": {"original_id": "1b038818209c", "function_name": "two_sum_outer", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7ba704a37606", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] , decreases arr . len () - idx , { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "7ba704a37606", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ea55d24710b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/arithmetic_weird.rs", "verified": true, "metadata": {"original_id": "ea55d24710b2", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5e38c6e4aff3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >)  { let len = v . len () ; let mut i = 0 ; while i < len / 2  { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] \ndecreases len / 2 - i \ninvariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/reverse_iter_3_current.rs", "verified": true, "metadata": {"original_id": "5e38c6e4aff3", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bfcbd4afcb83", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 . len () - idx\ninvariant 0 <= idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant 0 <= idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "bfcbd4afcb83", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0ffd97c39815", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "0ffd97c39815", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ea5b1ba7cfac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ea5b1ba7cfac", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_add8d9e87bf3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len ()  { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - idx\ninvariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "add8d9e87bf3", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4244d29e83ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4244d29e83ab", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_445e1ae99e9c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len ()  { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - idx\ninvariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "445e1ae99e9c", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_960dc809f6e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "960dc809f6e3", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0dd2909ea3ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list @ . len () - i, n - j\ninvariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "0dd2909ea3ee", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_db2f0d692240", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires difference_min_max_precond (a)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn difference_min_max_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn difference_min_max (a : & Vec < i32 >) -> (result : i32) requires difference_min_max_precond (a) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_23/verina_basic_23.rs", "verified": true, "metadata": {"original_id": "db2f0d692240", "function_name": "difference_min_max", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2a643fceefe9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2a643fceefe9", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_83b2365e77cf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 \nensures r == decode_char_spec (c as int) , 65 <= r <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "83b2365e77cf", "function_name": "decode_char", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5625c3a81d0f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires trap_rain_water_precond (height @)\nensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_77/verina_advanced_77.rs", "verified": true, "metadata": {"original_id": "5625c3a81d0f", "function_name": "trap_rain_water", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_05396bfaaf4e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "05396bfaaf4e", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_85cb3c01a038", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32))  { (27 , 2) }\n\n} // verus!", "target_text": "ensures r . 0 == 27 , r . 1 == 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/unverified/cal_div_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "85cb3c01a038", "function_name": "cal_div", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9a70d0591c1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_808_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9a70d0591c1a", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_374cf55dc764", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "374cf55dc764", "function_name": "max_array_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d0ce9f93b5b4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "d0ce9f93b5b4", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6dcac5c92df2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_97/verina_basic_97_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6dcac5c92df2", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fe69ac43052f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/023-strlen_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fe69ac43052f", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1a2824875b68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882\nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1a2824875b68", "function_name": "Triple1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f3d256efd2b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f3d256efd2b7", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a4636b413b3c", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64)   {  arr [i] }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) \nensures ret == i + 2 , ret == arr @ [i as int] ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> bool { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/trigger_impl.rs", "verified": true, "metadata": {"original_id": "a4636b413b3c", "function_name": "get_element_check_property", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9497d405b2e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires all_digits_precond (s @) \nensures result == is_digit_spec (c) , all_digits_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "9497d405b2e3", "function_name": "all_digits", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ca7d8ff7a219", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)   { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] \ninvariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "ca7d8ff7a219", "function_name": "index_wise_addition", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a82d5c36bfb3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a82d5c36bfb3", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5d3008e0cbc4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_55/verina_basic_55_impl.rs", "verified": true, "metadata": {"original_id": "5d3008e0cbc4", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dfd9edf0ce2b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dfd9edf0ce2b", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8a32f56ddb47", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases k - 1 - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 < list . len () , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , k < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "8a32f56ddb47", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d6570104686d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)  { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim\ndecreases numbers . len () - i\ninvariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/intersperse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d6570104686d", "function_name": "intersperse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f5db45215f15", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_14/verina_advanced_14.rs", "verified": true, "metadata": {"original_id": "f5db45215f15", "function_name": "helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_049e286d6201", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "049e286d6201", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ed9dd14180ef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ed9dd14180ef", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4be28fcf4ca8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires move_zeros_to_end_precond (arr @) \nensures move_zeros_to_end_postcond (arr @ , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_35/verina_basic_35_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4be28fcf4ca8", "function_name": "move_zeros_to_end", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c7b2a9edc407", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , result . len () == if i <= pos", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "c7b2a9edc407", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_96bb08f9621e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { let mut idx = 0 ; while idx < l . len ()  { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ndecreases l . len () - idx\ninvariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { let mut idx = 0 ; while idx < l . len () invariant 0 <= idx <= l . len () , forall | i : int | 0 <= i < idx ==> l [i] < t , decreases l . len () - idx { if l [idx] >= t { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/052-below-threshold_iter_2_current.rs", "verified": true, "metadata": {"original_id": "96bb08f9621e", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9bef30898e7f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/conditional_average_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9bef30898e7f", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cdeef5d27818", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "cdeef5d27818", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_606681853ccd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "606681853ccd", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_684624990ee8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "684624990ee8", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3a6b3f861a2e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 9 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 9 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3a6b3f861a2e", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_07fb3dfabcde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "07fb3dfabcde", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d2b21a9d851b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d2b21a9d851b", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3c1e83347ea1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "3c1e83347ea1", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_438e679b8773", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)   { let mut i = 0 ; while i < x . len ()  { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB \nensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/map_iter_2_current.rs", "verified": true, "metadata": {"original_id": "438e679b8773", "function_name": "myfun2", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_extensionality_b096ad3afeb9", "task": "task_a", "input_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n\n{\n    assert_seqs_equal!(s1, s2);\n\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n\n{\n    assert_seqs_equal!(s, t, i => {\n         // trigger\n    });\n\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n\n{\n    assert_maps_equal!(m, q, i => {\n         // trigger\n    });\n\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8, s.len() >= 1, 0 <= i <= s.len(), s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i), m.contains_pair(5, 17), forall|i| maps_are_equal_on(m, q, i)", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/extensionality.rs", "verified": true, "metadata": {"original_id": "verus_extensionality_b096ad3afeb9", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9ceb3195803b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/057-monotonic_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9ceb3195803b", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fcc40bdcef11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >)   { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len ()  { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "target_text": "requires start <= chars . len (), letter_combinations_precond (digits @)\nensures result == is_valid_digit (c), result @ == digit_to_letters (c), letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @))\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1, 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >) requires letter_combinations_precond (digits @) ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "fcc40bdcef11", "function_name": "letter_combinations", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f5ab7af4643e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size\ndecreases a . len (), size - i\ninvariant i <= size , result . len () == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f5ab7af4643e", "function_name": "gaussian", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_statics_af0e1e25c69a", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n         {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n\n    {\n        loop\n\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires self.wf()\nensures s.wf(), LAZY_X.wf()\ninvariant on state with (cell) is (v: u64, g: GhostState<T>), self.wf()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::prelude::*;\nuse vstd::*;\nuse vstd::raw_ptr::MemContents;\n\nuse std::sync::atomic::*;\n\nverus! {\n\n// A simple counter, albeit with nothing verified about it.\nexec static GLOBAL_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);\n\nfn increment_counter() {\n    GLOBAL_COUNTER.fetch_add(1, Ordering::Relaxed);\n}\n\n// Thread-safe lazy initialization\npub tracked enum GhostState<T: 'static> {\n    Uninitialized(cell::PointsTo<Option<T>>),\n    Initializing,\n    Initialized(&'static cell::PointsTo<Option<T>>),\n}\n\nstruct_with_invariants!{\n    struct Lazy<T: 'static> {\n        pub cell: PCell<Option<T>>,\n        pub state: vstd::atomic_ghost::AtomicU64<_, GhostState<T>, _>\n    }\n\n    spec fn wf(&self) -> bool {\n        invariant on state with (cell) is (v: u64, g: GhostState<T>) {\n            // State = 0: Uninitialized\n            // State = 1: currently initializing\n            // State = 2: is initialized\n            match g {\n                GhostState::Uninitialized(points_to) => {\n                    v == 0\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() === MemContents::Init(None))\n                }\n                GhostState::Initializing => {\n                    v == 1\n                }\n                GhostState::Initialized(points_to) => {\n                    v == 2\n                      && points_to.id() == cell.id()\n                      && (points_to.mem_contents() matches MemContents::Init(Some(_)))\n                }\n            }\n        }\n    }\n}\n\ntrait Initializable: Sized {\n    fn initialize() -> Self;\n}\n\nimpl<T: Initializable> Lazy<T> {\n    const fn new() -> (s: Self)\n        ensures\n            s.wf(),\n    {\n        let (pcell, Tracked(points_to)) = PCell::new(None);\n        Lazy {\n            cell: pcell,\n            state: vstd::atomic_ghost::AtomicU64::new(\n                Ghost(pcell),\n                0,\n                Tracked(GhostState::Uninitialized(points_to)),\n            ),\n        }\n    }\n\n    fn get<'a>(&'a self) -> &'a T\n        requires\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let tracked mut readonly_points_to: Option<&'static cell::PointsTo<Option<T>>> = None;\n            let cur_state =\n                atomic_with_ghost!(&self.state => load(); ghost g => {\n                match &g {\n                    GhostState::Initialized(points_to) => {\n                        readonly_points_to = Some(points_to);\n                    }\n                    _ => { }\n                }\n            });\n            if cur_state == 2 {\n                // Already initialized.\n                return self.cell.borrow(\n                    Tracked(readonly_points_to.tracked_borrow()),\n                ).as_ref().unwrap();\n            } else {\n                // Initialization is required. Try to take the lock if initialization\n                // isn't already in progress.\n                let mut do_initialization = (cur_state == 0);\n                let tracked mut points_to: Option<cell::PointsTo<Option<T>>> = None;\n                if do_initialization {\n                    let res =\n                        atomic_with_ghost!(&self.state => compare_exchange(0, 1);\n                        returning res; ghost g =>\n                    {\n                        g = match g {\n                            GhostState::Uninitialized(pt) => {\n                                points_to = Some(pt);\n                                GhostState::Initializing\n                            }\n                            GhostState::Initializing => {\n                                GhostState::Initializing\n                            }\n                            GhostState::Initialized(x) => {\n                                GhostState::Initialized(x)\n                            }\n                        };\n                    });\n                    if res.is_err() {\n                        // don't initialize after all\n                        do_initialization = false;\n                    }\n                }\n                if do_initialization {\n                    // Do initialization\n                    let t = T::initialize();\n                    let tracked mut points_to = points_to.tracked_unwrap();\n                    self.cell.replace(Tracked(&mut points_to), Some(t));\n                    let tracked static_points_to = vstd::modes::tracked_static_ref(points_to);\n                    atomic_with_ghost!(&self.state => store(2); ghost g => {\n                        g = GhostState::Initialized(static_points_to);\n                    });\n                    return self.cell.borrow(Tracked(static_points_to)).as_ref().unwrap();\n                } else {\n                    // Wait for initialization to complete by a different thread\n                    // (Try again in the next iteration of the loop.)\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nstruct X {}\n\nimpl Initializable for X {\n    fn initialize() -> Self {\n        X {  }\n    }\n}\n\nexec static LAZY_X: Lazy<X>\n    ensures\n        LAZY_X.wf(),\n{\n    Lazy::<X>::new()\n}\n\nfn get_lazy_x() -> &'static X {\n    LAZY_X.get()\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/statics.rs", "verified": true, "metadata": {"original_id": "verus_statics_af0e1e25c69a", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a2c6d590c065", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a2c6d590c065", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_25b4a97f7bf0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } return false ; }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "25b4a97f7bf0", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ee265d3064ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/unique_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ee265d3064ec", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3fc17499fe26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i , second . len () - j \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3fc17499fe26", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_80bb5140282f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant i <= arr1 . len () , i <= arr2 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , i <= arr2 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "80bb5140282f", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_159babe2aeed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "159babe2aeed", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ec175788c1b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if ! a [left] { left = left + 1 ; } else { right = right - 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () , old (a) . len () <= 100_000 \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n# [verifier :: loop_isolation (false)] fn two_way_sort (a : & mut Vec < bool >) requires old (a) . len () <= 100_000 , ensures a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | i : int , j : int | 0 <= i < j < a . len () ==> ! a [i] || a [j] , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , a . len () == old (a) . len () , a @ . to_multiset () == old (a) @ . to_multiset () , forall | k : int | 0 <= k < left ==> ! a [k] , forall | k : int | right <= k < a . len () ==> a [k] , decreases right - left { if ! a [left] { left = left + 1 ; } else { right = right - 1 ; if left < right { swap (a , left , right) ; } } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ec175788c1b5", "function_name": "two_way_sort", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_437d26afe3f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - i \ninvariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "437d26afe3f0", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ec8090f2b64a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx \ninvariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "ec8090f2b64a", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b46b25419bbd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)   { let mut i = 0 ; while i < x . len ()  { let old_val = x [i] ;   x . set (i , old_val + 4) ;  i += 1 ; } }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB \nensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "b46b25419bbd", "function_name": "myfun2", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_05b5ba19fc41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_43/verina_advanced_43_iter_0_original.rs", "verified": true, "metadata": {"original_id": "05b5ba19fc41", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a268b32765ce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires merge_intervals_precond (intervals @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_47/verina_advanced_47_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a268b32765ce", "function_name": "merge_intervals", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1320de41d5b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant result @ == a @ . subrange (0 , i as int) { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1320de41d5b9", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_975af8ab7916", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX\nensures longest_increasing_subsequence_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32) requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX ensures longest_increasing_subsequence_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_34/verina_advanced_34_iter_0_original.rs", "verified": true, "metadata": {"original_id": "975af8ab7916", "function_name": "longest_increasing_subsequence", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fe5bc5cad225", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "fe5bc5cad225", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9e5f2f932c53", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_97/verina_basic_97_impl.rs", "verified": true, "metadata": {"original_id": "9e5f2f932c53", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2d584196c6a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires increasing_triplet_precond (nums @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2d584196c6a2", "function_name": "increasing_triplet", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_14011bb7b030", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "14011bb7b030", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_27cf31e730b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "27cf31e730b7", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_506562aef461", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)   { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols  { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows  { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () \nensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i]\ndecreases cols - i, rows - j\ninvariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols, new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let mut result : Vec < Vec < i32 > > = Vec :: new () ; let rows = matrix . len () ; let cols = matrix [0] . len () ; let mut i = 0 ; while i < cols invariant result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , i <= cols , cols == matrix [0] . len () , rows == matrix . len () , rows > 0 , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases cols - i { let mut new_row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < rows invariant new_row . len () == j , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] . len () == rows , forall | k : int , l : int | 0 <= k < i && 0 <= l < rows ==> result [k] [l] == matrix [l] [k] , forall | l : int | 0 <= l < j ==> new_row [l] == matrix [l] [i as int] , j <= rows , i < cols , cols == matrix [0] . len () , rows == matrix . len () , forall | m : int | 0 <= m < matrix . len () ==> matrix [m] . len () == cols decreases rows - j { new_row . push (matrix [j] [i]) ; j += 1 ; } result . push (new_row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/WIP/WIP__transpose_matrix_iter_4_current.rs", "verified": true, "metadata": {"original_id": "506562aef461", "function_name": "transpose", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_basic_lock2_23c0941244c7", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n         {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n\n    {\n        loop\n\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "target_text": "requires self.wf(), self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\nensures lock.wf(), points_to@.id() == self.cell.id(), points_to@.is_init()\ninvariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>), self.wf()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/basic_lock2.rs", "verified": true, "metadata": {"original_id": "verus_basic_lock2_23c0941244c7", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_88254dfc569b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len ()  { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - idx\ninvariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len () invariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] , decreases arr . len () - idx { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_307_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88254dfc569b", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ef2fc0cb7ed7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x < 0 { - x } else { x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_impl.rs", "verified": true, "metadata": {"original_id": "ef2fc0cb7ed7", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4975da42ec1c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn calculate_coverage (intervals : & Vec < (usize , usize) >) -> (result : usize) requires forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4975da42ec1c", "function_name": "calculate_coverage", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_86fb88eba4f6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let mut found = false ; for j in 0 .. result . len ()  { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , found <==> (exists | k : int | 0 <= k < j && result [k] == a [i as int]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let mut found = false ; for j in 0 .. result . len () invariant forall | k : int | 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , found <==> (exists | k : int | 0 <= k < j && result [k] == a [i as int]) , { if result [j] == a [i] { found = true ; break ; } } if ! found { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "86fb88eba4f6", "function_name": "remove_duplicates", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b5a38cf7f6c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s1lif_impl.rs", "verified": true, "metadata": {"original_id": "b5a38cf7f6c0", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ef09854a9049", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ef09854a9049", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_36fe77b07f8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool)  { (c == ' ') || (c == ',') || (c == '.') }\n\n} // verus!", "target_text": "ensures result == is_space_comma_dot_spec (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { (c == ' ') || (c == ',') || (c == '.') }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "36fe77b07f8e", "function_name": "is_space_comma_dot", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_50ff4a81a595", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int)  { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ;    }\nfn triple (x : i32) -> (result : i32)   {  x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_98/verina_basic_98_iter_2_current.rs", "verified": true, "metadata": {"original_id": "50ff4a81a595", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_88733084b74c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos  { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i , p - j , (l - at_pos) - k \ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i , { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j , { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos invariant k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases (l - at_pos) - k , { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_64/verina_basic_64_iter_3_current.rs", "verified": true, "metadata": {"original_id": "88733084b74c", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_659e36320796", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "requires j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j , a . len () == old (a) . len () , decreases i \ndecreases i - j , i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "659e36320796", "function_name": "bubble_outer", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_15352c76ef04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "15352c76ef04", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_420628818d00", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "420628818d00", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_test_440e3ca56607", "task": "task_a", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\npub fn foo(a: u64) -> u64\n\n{\n    a + 1\n}\n\nfn main() {\n    let c = 1;\n    let mut b = 3;\n    b = 4;\n    b = foo(c);\n}\n\n} // verus!\n", "target_text": "requires a < 100", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\npub fn foo(a: u64) -> u64\n    requires\n        a < 100,\n{\n    a + 1\n}\n\nfn main() {\n    let c = 1;\n    let mut b = 3;\n    b = 4;\n    b = foo(c);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/test.rs", "verified": true, "metadata": {"original_id": "verus_test_440e3ca56607", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a9a4d08af375", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a9a4d08af375", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e91c94989fde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e91c94989fde", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b61aea969787", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b61aea969787", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_55abd22e2f7f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >)   { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "requires a . len () <= 100 \nensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] \ndecreases a . len () - i\ninvariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/array_copy_strong_iter_2_current.rs", "verified": true, "metadata": {"original_id": "55abd22e2f7f", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c9ec81a21486", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "c9ec81a21486", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_vostd_math_c3577f5d3987", "task": "task_a", "input_text": "use vstd::math::max;\nuse vstd::prelude::*;\nuse vstd::bits::*;\n\nverus! {\n\npub proof fn lemma_page_shl()\n\n{\n    broadcast use lemma_u64_shl_is_mul;\n\n}\n\npub proof fn lemma_u64_and_less_than(a: u64, b: u64)\n\n{\n\n    let max = max(a as int, b as int) as u64;\n}\n\npub proof fn lemma_usize_mod_0_maintain_after_add(x: usize, m: usize)\n\n{\n    use vstd::arithmetic::div_mod::*;\n\n    lemma_mod_adds(x as int, m as int, m as int);\n}\n\n} // verus!\n", "target_text": "requires x % m == 0,\n        m > 0\nensures (4096 as u64) << 0 == 0x1000,\n        (4096 as u64) << 1 == 0x2000,\n        (4096 as u64) << 2 == 0x4000,\n        (4096 as u64) << 3 == 0x8000,\n        (4096 as u64) << 4 == 0x10000,\n        (4096 as u64) << 5 == 0x20000,\n        (4096 as u64) << 6 == 0x40000,\n        (4096 as u64) << 7 == 0x80000,\n        (4096 as u64) << 8 == 0x100000,\n        (4096 as u64) << 9 == 0x200000,\n        (4096 as u64) << 10 == 0x400000,\n        (4096 as u64) << 11 == 0x800000,\n        (4096 as u64) << 12 == 0x1000000,\n        (4096 as u64) << 13 == 0x2000000,\n        (4096 as u64) << 14 == 0x4000000,\n        (4096 as u64) << 15 == 0x8000000,\n        (4096 as u64) << 16 == 0x10000000,\n        (4096 as u64) << 17 == 0x20000000,\n        (4096 as u64) << 18 == 0x40000000,\n        (4096 as u64) << 19 == 0x80000000,\n        (4096 as u64) << 20 == 0x100000000,\n        (4096 as u64) << 21 == 0x200000000,\n        (4096 as u64) << 22 == 0x400000000,\n        (4096 as u64) << 23 == 0x800000000,\n        (4096 as u64) << 24 == 0x1000000000,\n        (4096 as u64) << 25 == 0x2000000000,\n        (4096 as u64) << 26 == 0x4000000000,\n        (4096 as u64) << 27 == 0x8000000000, a & b <= a,\n        a & b <= b,\n        a & b <= max(a as int, b as int) as u64, (x + m) % m as int == 0", "full_verified_code": "use vstd::math::max;\nuse vstd::prelude::*;\nuse vstd::bits::*;\n\nverus! {\n\npub proof fn lemma_page_shl()\n    ensures\n        (4096 as u64) << 0 == 0x1000,\n        (4096 as u64) << 1 == 0x2000,\n        (4096 as u64) << 2 == 0x4000,\n        (4096 as u64) << 3 == 0x8000,\n        (4096 as u64) << 4 == 0x10000,\n        (4096 as u64) << 5 == 0x20000,\n        (4096 as u64) << 6 == 0x40000,\n        (4096 as u64) << 7 == 0x80000,\n        (4096 as u64) << 8 == 0x100000,\n        (4096 as u64) << 9 == 0x200000,\n        (4096 as u64) << 10 == 0x400000,\n        (4096 as u64) << 11 == 0x800000,\n        (4096 as u64) << 12 == 0x1000000,\n        (4096 as u64) << 13 == 0x2000000,\n        (4096 as u64) << 14 == 0x4000000,\n        (4096 as u64) << 15 == 0x8000000,\n        (4096 as u64) << 16 == 0x10000000,\n        (4096 as u64) << 17 == 0x20000000,\n        (4096 as u64) << 18 == 0x40000000,\n        (4096 as u64) << 19 == 0x80000000,\n        (4096 as u64) << 20 == 0x100000000,\n        (4096 as u64) << 21 == 0x200000000,\n        (4096 as u64) << 22 == 0x400000000,\n        (4096 as u64) << 23 == 0x800000000,\n        (4096 as u64) << 24 == 0x1000000000,\n        (4096 as u64) << 25 == 0x2000000000,\n        (4096 as u64) << 26 == 0x4000000000,\n        (4096 as u64) << 27 == 0x8000000000,\n{\n    broadcast use lemma_u64_shl_is_mul;\n\n    assert((4096 as u64) << 0 == 0x1000) by (compute_only);\n    assert((4096 as u64) << 1 == 0x2000) by (compute_only);\n    assert((4096 as u64) << 2 == 0x4000) by (compute_only);\n    assert((4096 as u64) << 3 == 0x8000) by (compute_only);\n    assert((4096 as u64) << 4 == 0x10000) by (compute_only);\n    assert((4096 as u64) << 5 == 0x20000) by (compute_only);\n    assert((4096 as u64) << 6 == 0x40000) by (compute_only);\n    assert((4096 as u64) << 7 == 0x80000) by (compute_only);\n    assert((4096 as u64) << 8 == 0x100000) by (compute_only);\n    assert((4096 as u64) << 9 == 0x200000) by (compute_only);\n    assert((4096 as u64) << 10 == 0x400000) by (compute_only);\n    assert((4096 as u64) << 11 == 0x800000) by (compute_only);\n    assert((4096 as u64) << 12 == 0x1000000) by (compute_only);\n    assert((4096 as u64) << 13 == 0x2000000) by (compute_only);\n    assert((4096 as u64) << 14 == 0x4000000) by (compute_only);\n    assert((4096 as u64) << 15 == 0x8000000) by (compute_only);\n    assert((4096 as u64) << 16 == 0x10000000) by (compute_only);\n    assert((4096 as u64) << 17 == 0x20000000) by (compute_only);\n    assert((4096 as u64) << 18 == 0x40000000) by (compute_only);\n    assert((4096 as u64) << 19 == 0x80000000) by (compute_only);\n    assert((4096 as u64) << 20 == 0x100000000) by (compute_only);\n    assert((4096 as u64) << 21 == 0x200000000) by (compute_only);\n    assert((4096 as u64) << 22 == 0x400000000) by (compute_only);\n    assert((4096 as u64) << 23 == 0x800000000) by (compute_only);\n    assert((4096 as u64) << 24 == 0x1000000000) by (compute_only);\n    assert((4096 as u64) << 25 == 0x2000000000) by (compute_only);\n    assert((4096 as u64) << 26 == 0x4000000000) by (compute_only);\n    assert((4096 as u64) << 27 == 0x8000000000) by (compute_only);\n}\n\npub proof fn lemma_u64_and_less_than(a: u64, b: u64)\n    ensures\n        a & b <= a,\n        a & b <= b,\n        a & b <= max(a as int, b as int) as u64,\n{\n    assert(a & b <= a) by (bit_vector);\n    assert(a & b <= b) by (bit_vector);\n    let max = max(a as int, b as int) as u64;\n}\n\npub proof fn lemma_usize_mod_0_maintain_after_add(x: usize, m: usize)\n    requires\n        x % m == 0,\n        m > 0,\n    ensures\n        (x + m) % m as int == 0,\n{\n    use vstd::arithmetic::div_mod::*;\n\n    lemma_mod_adds(x as int, m as int, m as int);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/lock-protocol-rcu/src/helpers/math.rs", "verified": true, "metadata": {"original_id": "vostd_math_c3577f5d3987", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_assert_by_compute_a4dde075646d", "task": "task_a", "input_text": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //  // Fails without more fuel\n\n          // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        //\n\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n\n        {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n\n        {\n        if p.len() == 0 {\n\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //\n    spec const v: int = 1;\n\n    fn crc_compute() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //\n    spec const v: int = 1;\n\n    fn crc_compute() {\n\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        //\n    }\n\n}\n\n} // verus!\n", "target_text": "requires p.len() == q.len()\nensures zeroes(l).len() == l, xor(p, q).len() == p.len(), zeroes(l).len() == l,\n        decreases l, xor(p, q).len() == p.len(),\n        decreases p.len()\ndecreases x, exp, l, l, l, s.len(), len, l, l, p.len(), p.len(), p.len(), s.len(), len, p.len(), s.len()", "full_verified_code": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/assert_by_compute.rs", "verified": true, "metadata": {"original_id": "verus_assert_by_compute_a4dde075646d", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_mergesort_10088e65c335", "task": "task_a", "input_text": "use vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq_lib::group_seq_properties;\n\nverus! {\n\npub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}\n\nfn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)\n\n{\n    for i in start..v.len()\n\n    {\n        r.push(v[i]);\n    }\n}\n\npub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)\n\n    {\n    s2.to_multiset_ensures();\n    if s2.len() == 0 {\n\n    } else {\n        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());\n        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);\n\n        (s1 + s2).drop_last().to_multiset_ensures();\n    }\n}\n\nproof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)\n\n{\n}\n\nproof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)\n\n{\n}\n\nfn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)\n\n{\n    broadcast use lemma_to_multiset_distributes_over_add;\n\n    let mut r: Vec<u64> = Vec::new();\n    let mut i1: usize = 0;\n    let mut i2: usize = 0;\n\n    while i1 < v1.len() && i2 < v2.len()\n\n    {\n\n        if v1[i1] < v2[i2] {\n            r.push(v1[i1]);\n\n            i1 += 1;\n        } else {\n            r.push(v2[i2]);\n\n            i2 += 1;\n        }\n\n    }\n\n    if i1 < v1.len() {\n        extend_from_idx(&mut r, v1, i1);\n\n    } else if i2 < v2.len() {\n        extend_from_idx(&mut r, v2, i2);\n\n    }\n    r\n}\n\nfn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)\n\n    {\n    let n = v.len();\n    let mut v1 = v.clone();\n    if (n <= 1) {\n        v1\n    } else {\n        let mut v2 = v1.split_off(n / 2);\n\n        let r1 = merge_sort(&mut v1);\n        let r2 = merge_sort(&mut v2);\n\n        let r = merge(&r1, &r2);\n        r\n    }\n}\n\nfn main() {\n    let v = vec![9, 10, 4, 5, 1, 3];\n    let v_sorted = merge_sort(&v);\n    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];\n\n}\n\n} // verus!\n", "target_text": "requires start < v.len(), 0 <= start <= end < s1.len(), 0 <= start <= mid <= end <= s1.len(), is_sorted(v1),\n        is_sorted(v2)\nensures r@ == old(r)@ + v@.subrange(start as int, v.len() as int), #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()), s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1), s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end), r@.to_multiset() == (v1@ + v2@).to_multiset(),\n        is_sorted(&r), r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r), #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(), r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r),\n    decreases v.len()\ndecreases s2.len(), v1.len() + v2.len() - i1 - i2, v.len()\ninvariant r@ =~= old(r)@ + v@.subrange(start as int, i as int), 0 <= i1 <= v1.len(),\n            0 <= i2 <= v2.len(),\n            is_sorted(v1),\n            is_sorted(v2),\n            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],\n            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],\n            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(\n                0 as int,\n                i2 as int,\n            )).to_multiset(),\n            is_sorted(&r)", "full_verified_code": "use vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq_lib::group_seq_properties;\n\nverus! {\n\npub open spec fn is_sorted(v: &Vec<u64>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> #[trigger] v[i] <= #[trigger] v[j]\n}\n\nfn extend_from_idx(r: &mut Vec<u64>, v: &Vec<u64>, start: usize)\n    requires\n        start < v.len(),\n    ensures\n        r@ == old(r)@ + v@.subrange(start as int, v.len() as int),\n{\n    for i in start..v.len()\n        invariant\n            r@ =~= old(r)@ + v@.subrange(start as int, i as int),\n    {\n        r.push(v[i]);\n    }\n}\n\npub broadcast proof fn lemma_to_multiset_distributes_over_add(s1: Seq<u64>, s2: Seq<u64>)\n    ensures\n        #[trigger] (s1 + s2).to_multiset() =~= s1.to_multiset().add(s2.to_multiset()),\n    decreases s2.len(),\n{\n    s2.to_multiset_ensures();\n    if s2.len() == 0 {\n        assert((s1 + s2).to_multiset() =~= s1.to_multiset());\n        assert(s2.to_multiset() =~= Multiset::<u64>::empty());\n    } else {\n        lemma_to_multiset_distributes_over_add(s1, s2.drop_last());\n        vstd::seq::Seq::drop_last_distributes_over_add(s1, s2);\n        assert(s2.drop_last() =~= s2.remove(s2.len() - 1));\n        assert(s1 + s2 =~= (s1 + s2).drop_last().push(s2[(s2.len() - 1) as int]));\n        assert((s1 + s2).to_multiset() =~= ((s1 + s2).drop_last().push(\n            s2[(s2.len() - 1) as int],\n        )).to_multiset());\n        (s1 + s2).drop_last().to_multiset_ensures();\n    }\n}\n\nproof fn lemma_subrange_push(s1: Seq<u64>, start: int, end: int)\n    requires\n        0 <= start <= end < s1.len(),\n    ensures\n        s1.subrange(start, end).push(s1[end]) =~= s1.subrange(start, end + 1),\n{\n}\n\nproof fn lemma_subrange_add(s1: Seq<u64>, start: int, mid: int, end: int)\n    requires\n        0 <= start <= mid <= end <= s1.len(),\n    ensures\n        s1.subrange(start, mid) + s1.subrange(mid, end) =~= s1.subrange(start, end),\n{\n}\n\nfn merge(v1: &Vec<u64>, v2: &Vec<u64>) -> (r: Vec<u64>)\n    requires\n        is_sorted(v1),\n        is_sorted(v2),\n    ensures\n        r@.to_multiset() == (v1@ + v2@).to_multiset(),\n        is_sorted(&r),\n{\n    broadcast use lemma_to_multiset_distributes_over_add;\n\n    let mut r: Vec<u64> = Vec::new();\n    let mut i1: usize = 0;\n    let mut i2: usize = 0;\n    assert(v1@.subrange(0 as int, i1 as int) == Seq::<u64>::empty());\n\n    while i1 < v1.len() && i2 < v2.len()\n        invariant\n            0 <= i1 <= v1.len(),\n            0 <= i2 <= v2.len(),\n            is_sorted(v1),\n            is_sorted(v2),\n            forall|i: int| i1 < v1.len() ==> 0 <= i < r.len() ==> r[i] <= v1[i1 as int],\n            forall|i: int| i2 < v2.len() ==> 0 <= i < r.len() ==> r[i] <= v2[i2 as int],\n            r@.to_multiset() =~= (v1@.subrange(0 as int, i1 as int) + v2@.subrange(\n                0 as int,\n                i2 as int,\n            )).to_multiset(),\n            is_sorted(&r),\n        decreases v1.len() + v2.len() - i1 - i2,\n    {\n        proof {\n            r@.to_multiset_ensures();\n        }\n        if v1[i1] < v2[i2] {\n            r.push(v1[i1]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v1@.subrange(0 as int, i1 as int).to_multiset_ensures();\n                lemma_subrange_push(v1@, 0 as int, i1 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, (i1 + 1) as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n            }\n            i1 += 1;\n        } else {\n            r.push(v2[i2]);\n            proof {\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, i2 as int),\n                );\n                v2@.subrange(0 as int, i2 as int).to_multiset_ensures();\n                lemma_subrange_push(v2@, 0 as int, i2 as int);\n                lemma_to_multiset_distributes_over_add(\n                    v1@.subrange(0 as int, i1 as int),\n                    v2@.subrange(0 as int, (i2 + 1) as int),\n                );\n            }\n            i2 += 1;\n        }\n\n    }\n    assert(v1@.subrange(0 as int, v1.len() as int) =~= v1@);\n    assert(v2@.subrange(0 as int, v2.len() as int) =~= v2@);\n\n    if i1 < v1.len() {\n        extend_from_idx(&mut r, v1, i1);\n        proof {\n            lemma_subrange_add(v1@, 0 as int, i1 as int, v1.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    } else if i2 < v2.len() {\n        extend_from_idx(&mut r, v2, i2);\n        proof {\n            lemma_subrange_add(v2@, 0 as int, i2 as int, v2.len() as int);\n            assert(r@.to_multiset() =~= (v1@ + v2@).to_multiset());\n        }\n    }\n    r\n}\n\nfn merge_sort(v: &Vec<u64>) -> (r: Vec<u64>)\n    ensures\n        r@.to_multiset() == (*v)@.to_multiset(),\n        is_sorted(&r),\n    decreases v.len(),\n{\n    let n = v.len();\n    let mut v1 = v.clone();\n    if (n <= 1) {\n        v1\n    } else {\n        let mut v2 = v1.split_off(n / 2);\n        assert(v1@ + v2@ == v@);\n        proof {\n            lemma_to_multiset_distributes_over_add(v1@, v2@);\n        }\n        let r1 = merge_sort(&mut v1);\n        let r2 = merge_sort(&mut v2);\n        proof {\n            lemma_to_multiset_distributes_over_add(r1@, r2@);\n        }\n        let r = merge(&r1, &r2);\n        r\n    }\n}\n\nfn main() {\n    let v = vec![9, 10, 4, 5, 1, 3];\n    let v_sorted = merge_sort(&v);\n    let ghost expected_res: Seq<u64> = seq![1, 3, 4, 5, 9, 10];\n    proof {\n        broadcast use group_seq_properties; \n        assert(v@ =~= seq![9].push(10).push(4).push(5).push(1).push(3));\n        assert(expected_res =~= seq![1].push(3).push(4).push(5).push(9).push(10));\n\n        assert(expected_res.to_multiset() =~= v@.to_multiset());\n        vstd::seq_lib::lemma_sorted_unique(expected_res, v_sorted@, |a: u64, b: u64| a <= b);\n        assert(v_sorted@ =~= expected_res);\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/mergesort.rs", "verified": true, "metadata": {"original_id": "verus_mergesort_10088e65c335", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a9e0650f7c77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "a9e0650f7c77", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a365c319b9d6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "a365c319b9d6", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d5cc238fed87", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "d5cc238fed87", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_853f27d27bb1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start <= nums . len ()\ndecreases nums . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "853f27d27bb1", "function_name": "loop_search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2d5a9f0108a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i : usize = 0 ; while i < a . len ()  { a . set (i , N) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == N \ndecreases a . len () - i \ninvariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i , { a . set (i , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2d5a9f0108a3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verified-nrkernel_extra_c92552ed5a7d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus!{\n\npub open spec fn inj_on<A, B>(f: spec_fn(A) -> B, da: Set<A>) -> bool {\n    forall|x:A,y:A| da.contains(x) && da.contains(y) && f(x) == f(y) ==> x == y\n}\n\npub proof fn lemma_filter_len_le<A>(f: spec_fn(A) -> bool, da: Set<A>)\n\n    {\n    if da.is_empty() {\n\n    } else {\n        let x = da.choose();\n        lemma_filter_len_le(f, da.remove(x));\n        if f(x) {\n\n        } else {\n\n        }\n    }\n}\n\npub proof fn lemma_map_len_le<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n\n    {\n    if da.is_empty() {\n\n    } else {\n        let x = da.choose();\n        lemma_map_len_le(f, da.remove(x));\n\n    }\n}\n\npub proof fn lemma_map_len_eq<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n\n    {\n    if da.is_empty() {\n\n    } else {\n        let x = da.choose();\n        lemma_map_len_eq(f, da.remove(x));\n\n    }\n}\n\n/// Creates a finite set of natural numbers in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains numbers in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n\n    {\n    if lo == hi {\n\n    } else {\n        lemma_nat_range(lo, sub(hi, 1));\n\n    }\n}\n\n//spec fn inj<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj_on(f, univ())\n//}\n//\n//spec fn bij_betw<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj(f) && univ::<A>.map(f) ==\n//}\n\n//spec fn univ<A>() -> Set<A> {\n//    Set::new(|a:A| true)\n//}\n\n}\n", "target_text": "requires da.finite(), // TODO: necessary?, da.finite(), da.finite(),\n        inj_on(f, da), lo <= hi\nensures da.filter(f).finite(),\n        da.filter(f).len() <= da.len(), da.map(f).finite(),\n        da.map(f).len() <= da.len(), da.map(f).finite(),\n        da.map(f).len() == da.len(), set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo, da.filter(f).finite(),\n        da.filter(f).len() <= da.len(),\n    decreases da.len(), da.map(f).finite(),\n        da.map(f).len() <= da.len(),\n    decreases da.len(), da.map(f).finite(),\n        da.map(f).len() == da.len(),\n    decreases da.len(), set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases hi - lo\ndecreases da.len(), da.len(), da.len(), hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus!{\n\npub open spec fn inj_on<A, B>(f: spec_fn(A) -> B, da: Set<A>) -> bool {\n    forall|x:A,y:A| da.contains(x) && da.contains(y) && f(x) == f(y) ==> x == y\n}\n\npub proof fn lemma_filter_len_le<A>(f: spec_fn(A) -> bool, da: Set<A>)\n    requires da.finite(), // TODO: necessary?\n    ensures\n        da.filter(f).finite(),\n        da.filter(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.filter(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_filter_len_le(f, da.remove(x));\n        if f(x) {\n            assert(da.remove(x).filter(f).insert(x) =~= da.filter(f));\n        } else {\n            assert(da.remove(x).filter(f) =~= da.filter(f));\n        }\n    }\n}\n\npub proof fn lemma_map_len_le<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires da.finite()\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_le(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\npub proof fn lemma_map_len_eq<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires\n        da.finite(),\n        inj_on(f, da)\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() == da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_eq(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\n/// Creates a finite set of natural numbers in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains numbers in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n    requires\n        lo <= hi,\n    ensures\n        set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases hi - lo,\n{\n    if lo == hi {\n        assert(set_nat_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_nat_range(lo, sub(hi, 1));\n        assert(set_nat_range(lo, sub(hi, 1)).insert(sub(hi, 1)) =~= set_nat_range(lo, hi));\n    }\n}\n\n//spec fn inj<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj_on(f, univ())\n//}\n//\n//spec fn bij_betw<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj(f) && univ::<A>.map(f) ==\n//}\n\n//spec fn univ<A>() -> Set<A> {\n//    Set::new(|a:A| true)\n//}\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-nrkernel/verified-node-replication/verified-node-replication/src/extra.rs", "verified": true, "metadata": {"original_id": "verified-nrkernel_extra_c92552ed5a7d", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_doubly_linked_xor_034d7a0db0a4", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::*;\n\n// \"XOR Linked List\". This is a sorta-cute (if not usually practical) folk data structure:\n// A doubly-linked list which saves memory by having each node store the XOR of the two\n// pointers to its two neighbors.\n//\n// This example uses the XOR Linked List to build a deque.\n//\n// TODO should really use usize, but bit-vector operations on usize aren't supported right now,\n// so we use u64 and assume it's equivalent to usize.\n\nverus! {\n\n#[verifier::external_body]\nproof fn lemma_usize_u64(x: u64)\n\n{\n    unimplemented!();\n}\n\n// Single node in the list\nstruct Node<V> {\n    xored: u64,\n    v: V,\n}\n\n// Doubly-linked list\n// Contains head pointer, tail pointer\n// and in ghost code, tracks all the pointers and all the permissions to access the nodes\ntype MemPerms<V> = PointsTo<Node<V>>;\n\n// The xor-doubly-linked list  {\n    ptrs: Ghost<Seq<PPtr<Node<V>>>>,\n    perms: Tracked<Map<nat, MemPerms<V>>>,\n    head: u64,\n    tail: u64,\n}\n\nimpl<V> DListXor<V> {\n    spec fn wf_perms(&self) -> bool {\n        forall|i: nat| 0 <= i < self.ptrs@.len() ==> self.wf_perm(i)\n    }\n\n    spec fn prev_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i == 0 {\n            0\n        } else {\n            self.ptrs@[i - 1].addr() as u64\n        }\n    }\n\n    spec fn next_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i + 1 == self.ptrs@.len() {\n            0\n        } else {\n            self.ptrs@[i + 1int].addr() as u64\n        }\n    }\n\n    spec fn wf_perm(&self, i: nat) -> bool\n        recommends\n            i < self.ptrs@.len(),\n    {\n        &&& self.perms@.dom().contains(i)\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& 0 < self.ptrs@[i as int].addr()\n        &&& self.ptrs@[i as int].addr() < 0x10000000000000000\n        &&& self.perms@[i].is_init()\n        &&& self.perms@[i].value().xored == (self.prev_of(i) ^ self.next_of(i))\n    }\n\n    spec fn wf_head(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.head == 0\n        } else {\n            self.head == self.ptrs@[0].addr()\n        }\n    }\n\n    spec fn wf_tail(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.tail == 0\n        } else {\n            self.tail == self.ptrs@[self.ptrs@.len() - 1].addr()\n        }\n    }\n\n    spec fn wf(&self) -> bool {\n        self.wf_perms() && self.wf_head() && self.wf_tail()\n    }\n\n    spec fn view(&self) -> Seq<V>\n        recommends\n            self.wf(),\n    {\n        Seq::<V>::new(self.ptrs@.len(), |i: int| { self.perms@[i as nat].value().v })\n    }\n\n    fn new() -> (s: Self)\n\n    {\n        DListXor {\n            ptrs: Ghost(Seq::empty()),\n            perms: Tracked(Map::tracked_empty()),\n            head: 0,\n            tail: 0,\n        }\n    }\n\n    fn push_empty_case(&mut self, v: V)\n\n    {\n        let (ptr, Tracked(perm)) = PPtr::new(Node::<V> { xored: 0, v });\n\n        self.tail = ptr.addr() as u64;\n        self.head = self.tail;\n\n    }\n\n    fn push_back(&mut self, v: V)\n\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n\n            self.push_empty_case(v);\n        } else {\n\n            let tail_ptr_u64 = self.tail;\n\n            let tail_ptr = PPtr::<Node<V>>::from_usize(tail_ptr_u64 as usize);\n            let tracked mut tail_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 1) as nat,\n            );\n            let mut tail_node = tail_ptr.take(Tracked(&mut tail_perm));\n            let second_to_last_ptr = tail_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: tail_ptr_u64, v },\n            );\n\n            let new_ptr_u64 = ptr.addr() as u64;\n            tail_node.xored = second_to_last_ptr ^ new_ptr_u64;\n            tail_ptr.put(Tracked(&mut tail_perm), tail_node);\n\n            self.tail = new_ptr_u64;\n\n        }\n    }\n\n    fn pop_back(&mut self) -> (v: V)\n\n    {\n\n        let last_u64 = self.tail;\n\n        let last_ptr = PPtr::<Node<V>>::from_usize(last_u64 as usize);\n        let tracked last_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n            (self.ptrs@.len() - 1) as nat,\n        );\n        let last_node = last_ptr.into_inner(Tracked(last_perm));\n        let penult_u64 = last_node.xored;\n        let v = last_node.v;\n\n        if penult_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n\n        } else {\n            self.tail = penult_u64;\n\n            let penult_ptr = PPtr::<Node<V>>::from_usize(penult_u64 as usize);\n            let tracked mut penult_perm = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 2) as nat,\n            );\n            let mut penult_node = penult_ptr.take(Tracked(&mut penult_perm));\n            let t: Ghost<u64> = Ghost(self.prev_of((self.ptrs@.len() - 2) as nat));\n\n            penult_node.xored = penult_node.xored ^ last_u64;\n\n            penult_ptr.put(Tracked(&mut penult_perm), penult_node);\n\n        }\n\n        v\n    }\n\n    fn pop_front(&mut self) -> (v: V)\n\n    {\n\n        let first_u64 = self.head;\n\n        let first_ptr = PPtr::<Node<V>>::from_usize(first_u64 as usize);\n        let tracked first_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(0);\n        let first_node = first_ptr.into_inner(Tracked(first_perm));\n        let second_u64 = first_node.xored;\n        let v = first_node.v;\n\n        if second_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n\n        } else {\n            self.head = second_u64;\n\n            let second_ptr = PPtr::<Node<V>>::from_usize(second_u64 as usize);\n            let tracked mut second_perm = (self.perms.borrow_mut()).tracked_remove(1);\n            let mut second_node = second_ptr.take(Tracked(&mut second_perm));\n            let t: Ghost<u64> = Ghost(self.next_of(1));\n\n            second_node.xored = second_node.xored ^ first_u64;\n\n            second_ptr.put(Tracked(&mut second_perm), second_node);\n\n        }\n\n        v\n    }\n\n    fn push_front(&mut self, v: V)\n\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n\n            self.push_empty_case(v);\n\n        } else {\n\n            let head_ptr_u64 = self.head;\n\n            let head_ptr = PPtr::<Node<V>>::from_usize(head_ptr_u64 as usize);\n            let tracked mut head_perm: MemPerms<V> = (self.perms.borrow_mut()).tracked_remove(\n                0,\n            );\n            let mut head_node = head_ptr.take(Tracked(&mut head_perm));\n            let second_ptr = head_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: head_ptr_u64, v },\n            );\n\n            let new_ptr_u64 = ptr.addr() as u64;\n            head_node.xored = new_ptr_u64 ^ second_ptr;\n            head_ptr.put(Tracked(&mut head_perm), head_node);\n\n            self.head = new_ptr_u64;\n\n        }\n    }\n}\n\n#[verifier::external_body]\nfn print_result(msg: &'static str, value: u32) {\n    println!(\"{}: {value}\", msg);\n}\n\nfn main() {\n    let mut t = DListXor::<u32>::new();\n    t.push_back(2);\n    t.push_back(3);\n    t.push_front(1);  // 1, 2, 3\n    print_result(\"pushed\", 2);\n    print_result(\"pushed\", 3);\n    print_result(\"pushed\", 1);\n    let x = t.pop_back();  // 3\n    let y = t.pop_front();  // 1\n    let z = t.pop_front();  // 2\n\n    print_result(\"popped\", x);\n    print_result(\"popped\", y);\n    print_result(\"popped\", z);\n}\n\n} // verus!\n", "target_text": "requires old(self).wf(),\n            old(self).ptrs@.len() == 0, old(self).wf(), old(self).wf(),\n            old(self)@.len() > 0, old(self).wf(),\n            old(self)@.len() > 0, old(self).wf()\nensures x as usize as u64 == x, s.wf(),\n            s@.len() == 0, self.wf(),\n            self@ == old(self)@.push(v), self.wf(),\n            self@ == old(self)@.push(v), self.wf(),\n            self@ == old(self)@.drop_last(),\n            v == old(self)@[old(self)@.len() - 1], self.wf(),\n            self@ == old(self)@.subrange(1, old(self)@.len() as int),\n            v == old(self)@[0], self.wf(),\n            self@ == seq![v].add(old(self)@)", "full_verified_code": "use vstd::prelude::*;\nuse vstd::simple_pptr::*;\nuse vstd::*;\n\n// \"XOR Linked List\". This is a sorta-cute (if not usually practical) folk data structure:\n// A doubly-linked list which saves memory by having each node store the XOR of the two\n// pointers to its two neighbors.\n//\n// This example uses the XOR Linked List to build a deque.\n//\n// TODO should really use usize, but bit-vector operations on usize aren't supported right now,\n// so we use u64 and assume it's equivalent to usize.\n\nverus! {\n\n#[verifier::external_body]\nproof fn lemma_usize_u64(x: u64)\n    ensures\n        x as usize as u64 == x,\n{\n    unimplemented!();\n}\n\n// Single node in the list\nstruct Node<V> {\n    xored: u64,\n    v: V,\n}\n\n// Doubly-linked list\n// Contains head pointer, tail pointer\n// and in ghost code, tracks all the pointers and all the permissions to access the nodes\ntype MemPerms<V> = PointsTo<Node<V>>;\n\n// The xor-doubly-linked list requires us to treat pointers as integer addresses.\n// This is somewhat tricky because it forces us to think a bit about pointer provenance.\n// The simple_pptr library abstracts this away (and verifies it) and thus lets us treat pointers\n// as isomoprhic to usize values.\n\nstruct DListXor<V> {\n    ptrs: Ghost<Seq<PPtr<Node<V>>>>,\n    perms: Tracked<Map<nat, MemPerms<V>>>,\n    head: u64,\n    tail: u64,\n}\n\nimpl<V> DListXor<V> {\n    spec fn wf_perms(&self) -> bool {\n        forall|i: nat| 0 <= i < self.ptrs@.len() ==> self.wf_perm(i)\n    }\n\n    spec fn prev_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i == 0 {\n            0\n        } else {\n            self.ptrs@[i - 1].addr() as u64\n        }\n    }\n\n    spec fn next_of(&self, i: nat) -> u64\n        recommends\n            i < self.ptrs@.len(),\n    {\n        if i + 1 == self.ptrs@.len() {\n            0\n        } else {\n            self.ptrs@[i + 1int].addr() as u64\n        }\n    }\n\n    spec fn wf_perm(&self, i: nat) -> bool\n        recommends\n            i < self.ptrs@.len(),\n    {\n        &&& self.perms@.dom().contains(i)\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& self.perms@[i].pptr() == self.ptrs@[i as int]\n        &&& 0 < self.ptrs@[i as int].addr()\n        &&& self.ptrs@[i as int].addr() < 0x10000000000000000\n        &&& self.perms@[i].is_init()\n        &&& self.perms@[i].value().xored == (self.prev_of(i) ^ self.next_of(i))\n    }\n\n    spec fn wf_head(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.head == 0\n        } else {\n            self.head == self.ptrs@[0].addr()\n        }\n    }\n\n    spec fn wf_tail(&self) -> bool {\n        if self.ptrs@.len() == 0 {\n            self.tail == 0\n        } else {\n            self.tail == self.ptrs@[self.ptrs@.len() - 1].addr()\n        }\n    }\n\n    spec fn wf(&self) -> bool {\n        self.wf_perms() && self.wf_head() && self.wf_tail()\n    }\n\n    spec fn view(&self) -> Seq<V>\n        recommends\n            self.wf(),\n    {\n        Seq::<V>::new(self.ptrs@.len(), |i: int| { self.perms@[i as nat].value().v })\n    }\n\n    fn new() -> (s: Self)\n        ensures\n            s.wf(),\n            s@.len() == 0,\n    {\n        DListXor {\n            ptrs: Ghost(Seq::empty()),\n            perms: Tracked(Map::tracked_empty()),\n            head: 0,\n            tail: 0,\n        }\n    }\n\n    fn push_empty_case(&mut self, v: V)\n        requires\n            old(self).wf(),\n            old(self).ptrs@.len() == 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        let (ptr, Tracked(perm)) = PPtr::new(Node::<V> { xored: 0, v });\n        proof {\n            self.ptrs@ = self.ptrs@.push(ptr);\n            (&perm).is_nonnull();\n            self.perms.borrow_mut().tracked_insert((self.ptrs@.len() - 1) as nat, perm);\n        }\n        self.tail = ptr.addr() as u64;\n        self.head = self.tail;\n        assert(0u64 ^ 0u64 == 0u64) by (bit_vector);\n        assert(self@ =~= old(self)@.push(v));\n    }\n\n    fn push_back(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == old(self)@.push(v),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            let tail_ptr_u64 = self.tail;\n            proof {\n                lemma_usize_u64(tail_ptr_u64);\n            }\n            let tail_ptr = PPtr::<Node<V>>::from_usize(tail_ptr_u64 as usize);\n            let tracked mut tail_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 1) as nat,\n            );\n            let mut tail_node = tail_ptr.take(Tracked(&mut tail_perm));\n            let second_to_last_ptr = tail_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: tail_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            tail_node.xored = second_to_last_ptr ^ new_ptr_u64;\n            tail_ptr.put(Tracked(&mut tail_perm), tail_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 1) as nat,\n                    tail_perm,\n                );\n                self.perms.borrow_mut().tracked_insert(self.ptrs@.len(), perm);\n                self.ptrs@ = self.ptrs@.push(ptr);\n            }\n            self.tail = new_ptr_u64;\n            proof {\n                assert(tail_ptr_u64 ^ 0 == tail_ptr_u64) by (bit_vector);\n                let i = (self.ptrs@.len() - 2) as nat;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let prev_of_i = self.prev_of(i);\n                assert(prev_of_i ^ 0 == prev_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.wf_perm((self.ptrs@.len() - 2) as nat));\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                assert(forall|i: nat|\n                    i < self.ptrs@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[self.ptrs@.len() - 1] == v);\n                assert forall|i: int| 0 <= i < self.ptrs@.len() - 1 implies old(self)@[i]\n                    == self@[i] by {\n                    assert(old(self).wf_perm(i as nat));  // trigger\n                };\n                assert(self@ =~= old(self)@.push(v));\n            }\n        }\n    }\n\n    fn pop_back(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.drop_last(),\n            v == old(self)@[old(self)@.len() - 1],\n    {\n        assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n        let last_u64 = self.tail;\n        proof {\n            lemma_usize_u64(last_u64);\n        }\n        let last_ptr = PPtr::<Node<V>>::from_usize(last_u64 as usize);\n        let tracked last_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(\n            (self.ptrs@.len() - 1) as nat,\n        );\n        let last_node = last_ptr.into_inner(Tracked(last_perm));\n        let penult_u64 = last_node.xored;\n        let v = last_node.v;\n        proof {\n            let self_head = self.head;\n            assert(self_head ^ 0 == self_head) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if penult_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n                    #[verifier::spec] let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                    assert(actual_penult_u64 ^ 0 == actual_penult_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.tail = penult_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm((self.ptrs@.len() - 2) as nat));\n            proof {\n                let actual_penult_u64 = self.prev_of((self.ptrs@.len() - 1) as nat);\n                assert(actual_penult_u64 ^ 0 == actual_penult_u64) by (bit_vector);\n                lemma_usize_u64(penult_u64);\n            }\n            let penult_ptr = PPtr::<Node<V>>::from_usize(penult_u64 as usize);\n            let tracked mut penult_perm = self.perms.borrow_mut().tracked_remove(\n                (self.ptrs@.len() - 2) as nat,\n            );\n            let mut penult_node = penult_ptr.take(Tracked(&mut penult_perm));\n            let t: Ghost<u64> = Ghost(self.prev_of((self.ptrs@.len() - 2) as nat));\n            assert((t@ ^ last_u64) ^ last_u64 == t@ ^ 0) by (bit_vector);\n            penult_node.xored = penult_node.xored ^ last_u64;\n            assert(penult_node.xored == t@ ^ 0);\n            penult_ptr.put(Tracked(&mut penult_perm), penult_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(\n                    (self.ptrs@.len() - 2) as nat,\n                    penult_perm,\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.drop_last();\n        }\n        proof {\n            assert(self.wf_head());\n            assert(self.wf_tail());\n            if self.ptrs@.len() > 0 {\n                /*#[verifier::spec] let i = self.ptrs@.len() - 1;\n                assert(self.ptrs@.len() == old(self).ptrs@.len() - 1);\n                assert(self.perms@.dom().contains(i));\n                assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                assert(0 < self.ptrs@[i]@);\n                assert(self.ptrs@[i]@ < 0x10000000000000000);\n                assert(self.perms@[i].value.is_Some());\n                assert(self.perms@[i].value.get_Some_0().xored == (\n                    self.prev_of(i) ^ self.next_of(i)\n                ));*/\n                assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.drop_last()[i] by {\n                assert(old(self).wf_perm(i as nat));  // trigger\n            }\n            assert(self@ =~= old(self)@.drop_last());\n        }\n        v\n    }\n\n    fn pop_front(&mut self) -> (v: V)\n        requires\n            old(self).wf(),\n            old(self)@.len() > 0,\n        ensures\n            self.wf(),\n            self@ == old(self)@.subrange(1, old(self)@.len() as int),\n            v == old(self)@[0],\n    {\n        assert(self.wf_perm(0));\n        let first_u64 = self.head;\n        proof {\n            lemma_usize_u64(first_u64);\n        }\n        let first_ptr = PPtr::<Node<V>>::from_usize(first_u64 as usize);\n        let tracked first_perm: MemPerms<V> = self.perms.borrow_mut().tracked_remove(0);\n        let first_node = first_ptr.into_inner(Tracked(first_perm));\n        let second_u64 = first_node.xored;\n        let v = first_node.v;\n        proof {\n            let self_tail = self.tail;\n            assert(self_tail ^ 0 == self_tail) by (bit_vector);\n            assert(0u64 ^ 0 == 0) by (bit_vector);\n        }\n        if second_u64 == 0 {\n            self.tail = 0;\n            self.head = 0;\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 1, {\n                    assert(old(self).wf_perm(1));\n                    #[verifier::spec] let actual_second_u64 = self.next_of(0);\n                    assert(0 ^ actual_second_u64 == actual_second_u64) by(bit_vector);\n                });\n            }\n        } else {\n            self.head = second_u64;\n            assert(old(self)@.len() != 1);\n            assert(old(self)@.len() >= 2);\n            assert(old(self).wf_perm(1));\n            proof {\n                let actual_second_u64 = self.next_of(0);\n                assert(0 ^ actual_second_u64 == actual_second_u64) by (bit_vector);\n                lemma_usize_u64(second_u64);\n            }\n            let second_ptr = PPtr::<Node<V>>::from_usize(second_u64 as usize);\n            let tracked mut second_perm = (self.perms.borrow_mut()).tracked_remove(1);\n            let mut second_node = second_ptr.take(Tracked(&mut second_perm));\n            let t: Ghost<u64> = Ghost(self.next_of(1));\n            assert((first_u64 ^ t@) ^ first_u64 == 0 ^ t@) by (bit_vector);\n            second_node.xored = second_node.xored ^ first_u64;\n            assert(second_node.xored == 0 ^ t@);\n            second_ptr.put(Tracked(&mut second_perm), second_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(1, second_perm);\n                assert forall|j: nat| 1 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                (self.perms.borrow_mut()).tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 0 <= j < old(self)@.len() - 1,\n                        |j: nat| (j + 1) as nat,\n                    ),\n                );\n            }\n        }\n        proof {\n            self.ptrs@ = self.ptrs@.subrange(1, self.ptrs@.len() as int);\n        }\n        proof {\n            assert(self.wf_tail());\n            assert(self.wf_head());\n            if self.ptrs@.len() > 0 {\n                assert(self.wf_perm(0));\n            }\n            assert(forall|i: nat| i < self@.len() ==> old(self).wf_perm(i + 1) ==> self.wf_perm(i));\n            assert(self.wf_perms());\n            assert forall|i: int| 0 <= i < self@.len() implies #[trigger] self@[i] == old(\n                self,\n            )@.subrange(1, old(self)@.len() as int)[i] by {\n                assert(old(self).wf_perm(i as nat + 1));  // trigger\n            }\n            assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n        }\n        v\n    }\n\n    fn push_front(&mut self, v: V)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self@ == seq![v].add(old(self)@),\n    {\n        if self.tail == 0 {\n            // Special case: list is empty\n            proof {\n                assert_by_contradiction!(self.ptrs@.len() == 0, {\n                    assert(self.wf_perm((self.ptrs@.len() - 1) as nat));\n                });\n            }\n            self.push_empty_case(v);\n            assert(self@ =~= seq![v].add(old(self)@));\n        } else {\n            assert(self.ptrs@.len() > 0);\n            assert(self.wf_perm(0));\n            let head_ptr_u64 = self.head;\n            proof {\n                lemma_usize_u64(head_ptr_u64);\n            }\n            let head_ptr = PPtr::<Node<V>>::from_usize(head_ptr_u64 as usize);\n            let tracked mut head_perm: MemPerms<V> = (self.perms.borrow_mut()).tracked_remove(\n                0,\n            );\n            let mut head_node = head_ptr.take(Tracked(&mut head_perm));\n            let second_ptr = head_node.xored;\n            let (ptr, Tracked(perm)) = PPtr::new(\n                Node::<V> { xored: head_ptr_u64, v },\n            );\n            proof {\n                perm.is_nonnull();\n            }\n            let new_ptr_u64 = ptr.addr() as u64;\n            head_node.xored = new_ptr_u64 ^ second_ptr;\n            head_ptr.put(Tracked(&mut head_perm), head_node);\n            proof {\n                self.perms.borrow_mut().tracked_insert(0, head_perm);\n                assert forall|j: nat| 0 <= j < old(self)@.len() implies self.perms@.dom().contains(\n                    j,\n                ) by {\n                    assert(old(self).wf_perm(j));\n                }\n                self.perms.borrow_mut().tracked_map_keys_in_place(\n                    Map::<nat, nat>::new(\n                        |j: nat| 1 <= j <= old(self)@.len(),\n                        |j: nat| (j - 1) as nat,\n                    ),\n                );\n                self.perms.borrow_mut().tracked_insert(0, perm);\n                self.ptrs@ = seq![ptr].add(self.ptrs@);\n            }\n            self.head = new_ptr_u64;\n            proof {\n                assert(0 ^ head_ptr_u64 == head_ptr_u64) by (bit_vector);\n                let i = 1;\n                //assert(self.perms@.dom().contains(i));\n                //assert(self.perms@[i]@.pptr == self.ptrs@[i]@);\n                //assert(self.perms@[i].value.is_Some());\n                let next_of_i = self.next_of(i);\n                assert(0 ^ next_of_i == next_of_i) by (bit_vector);\n                //assert(self.prev_of(i) == second_to_last_ptr);\n                //assert(self.next_of(i) == new_ptr_int);\n                //assert(self.perms@[i].value.get_Some_0().xored == (\n                //    self.prev_of(i) ^ self.next_of(i)\n                //));\n                assert(self.perms@.index(1).value().xored == new_ptr_u64\n                    ^ second_ptr);\n                assert(self.perms@.index(0).value().xored == head_ptr_u64);\n                assert(self.perms@.index(1).pptr().addr() == head_ptr_u64);\n                assert(self.wf_perm(1));\n                assert(self.wf_perm(0));\n                assert(forall|i: nat|\n                    1 <= i <= old(self).ptrs@.len() ==> old(self).wf_perm((i - 1) as nat)\n                        ==> #[trigger] self.wf_perm(i));\n                assert(self.wf_perms());\n                assert(self.wf_tail());\n                assert(self@[0] == v);\n                assert forall|i: int| 1 <= i <= self.ptrs@.len() - 1 implies old(self)@[i - 1]\n                    == self@[i] by {\n                    assert(old(self).wf_perm((i - 1) as nat));  // trigger\n                };\n                assert(self@ =~= seq![v].add(old(self)@));\n            }\n        }\n    }\n}\n\n#[verifier::external_body]\nfn print_result(msg: &'static str, value: u32) {\n    println!(\"{}: {value}\", msg);\n}\n\nfn main() {\n    let mut t = DListXor::<u32>::new();\n    t.push_back(2);\n    t.push_back(3);\n    t.push_front(1);  // 1, 2, 3\n    print_result(\"pushed\", 2);\n    print_result(\"pushed\", 3);\n    print_result(\"pushed\", 1);\n    let x = t.pop_back();  // 3\n    let y = t.pop_front();  // 1\n    let z = t.pop_front();  // 2\n    assert(x == 3);\n    assert(y == 1);\n    assert(z == 2);\n    print_result(\"popped\", x);\n    print_result(\"popped\", y);\n    print_result(\"popped\", z);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/doubly_linked_xor.rs", "verified": true, "metadata": {"original_id": "verus_doubly_linked_xor_034d7a0db0a4", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a50a64f0e6c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a50a64f0e6c2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_81a036e0d295", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >)  { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { ch } else { str1 [k] }) , { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32 { ch } else { str1 [k] }) , decreases str1 . len () - index { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_230_iter_2_current.rs", "verified": true, "metadata": {"original_id": "81a036e0d295", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cdab3d5f9cc9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) { let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len ()  { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "target_text": "ensures (\ndecreases arr @ . len () - i\ninvariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn largest_smallest_integers (arr : & Vec < i32 >) -> (res : (Option < i32 > , Option < i32 >)) ensures ({ let (a , b) = res ; (a . is_some () ==> (a . unwrap () < 0 && arr @ . contains (a . unwrap ()))) && (a . is_some () ==> forall | x : i32 | arr @ . contains (x) && x < 0 ==> x <= a . unwrap ()) && (a . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x >= 0) && (b . is_some () ==> (b . unwrap () > 0 && arr @ . contains (b . unwrap ()))) && (b . is_some () ==> forall | x : i32 | arr @ . contains (x) && x > 0 ==> x >= b . unwrap ()) && (b . is_none () ==> forall | x : i32 | arr @ . contains (x) ==> x <= 0) }) , { let mut i : usize = 0 ; let mut a = None ; let mut b = None ; while i < arr . len () invariant 0 <= i <= arr @ . len () , a . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] >= 0 , a . is_some () ==> arr @ . contains (a . unwrap ()) && a . unwrap () < 0 , a . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] < 0 ==> arr @ [j] <= a . unwrap () , b . is_none () ==> forall | j : int | 0 <= j < i ==> arr @ [j] <= 0 , b . is_some () ==> arr @ . contains (b . unwrap ()) && b . unwrap () > 0 , b . is_some () ==> forall | j : int | 0 <= j < i && arr @ [j] > 0 ==> arr @ [j] >= b . unwrap () , decreases arr @ . len () - i { if arr [i] < 0 && (a . is_none () || arr [i] >= a . unwrap ()) { a = Some (arr [i]) ; } if arr [i] > 0 && (b . is_none () || arr [i] <= b . unwrap ()) { b = Some (arr [i]) ; } i = i + 1 ; } (a , b) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/136-largest_smallest_integers_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cdab3d5f9cc9", "function_name": "largest_smallest_integers", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_14a947f9a02f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i \ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i , { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "14a947f9a02f", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_454700cdab4e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "454700cdab4e", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_01364d90b6bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for j in 0 .. text . len ()  { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "01364d90b6bb", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_46621589bac8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  {   a [i as usize] = N + 1 ;   i = i + 1 ;  } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N < 1000 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N < 1000 , decreases N - i , { assert (i < N) ; assert (0 <= i < a . len ()) ; a [i as usize] = N + 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; assert (a [i as int] == N + 1) ; i = i + 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina3_impl.rs", "verified": true, "metadata": {"original_id": "46621589bac8", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9b99f208a161", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < i ==> ! arr2 @ . contains (arr1 [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < i ==> ! arr2 @ . contains (arr1 [k]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "9b99f208a161", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1779bf38f977", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "1779bf38f977", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_chapter-6-1_513a985e5f4b", "task": "task_a", "input_text": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\n#[verifier::external_body]  /* vattr */\npub struct Key {}\n\n#[verifier::external_body]  /* vattr */\npub struct Value {}\n\n#[verifier::external_body]  /* vattr */\n#[verifier::spec]\npub fn default() -> Value {\n    unimplemented!()\n}\n\nstate_machine!{\n    MapSpec {\n        fields {\n            pub map: Map<Key, Value>,\n        }\n\n        init!{\n            empty() {\n                init map = Map::total(|k| default());\n            }\n        }\n\n        transition!{\n            insert_op(key: Key, value: Value) {\n                update map = pre.map.insert(key, value);\n            }\n        }\n\n        transition!{\n            query_op(key: Key, value: Value) {\n                require(pre.map.contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            noop() {\n            }\n        }\n    }\n}\n\nstate_machine!{\n    ShardedKVProtocol {\n        fields {\n            // TODO have a way to annotate this as a constant outside of tokenized mode\n            pub map_count: int,\n\n            pub maps: Seq<Map<Key, Value>>,\n        }\n\n        init!{\n            initialize(map_count: int) {\n                require(0 < map_count);\n                init map_count = map_count;\n                init maps = Seq::new(map_count as nat, |i| {\n                    if i == 0 {\n                        Map::total(|k| default())\n                    } else {\n                        Map::empty()\n                    }\n                });\n            }\n        }\n\n        pub open spec fn valid_host(&self, i: int) -> bool {\n            0 <= i < self.map_count\n        }\n\n        transition!{\n            insert(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).dom().contains(key));\n                update maps[idx][key] = value;\n            }\n        }\n\n        transition!{\n            query(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n                require(pre.valid_host(send_idx));\n                require(pre.valid_host(recv_idx));\n                require(pre.maps.index(send_idx).contains_pair(key, value));\n                require(send_idx != recv_idx);\n                update maps[send_idx] = pre.maps.index(send_idx).remove(key);\n                update maps[recv_idx][key] = value;\n            }\n        }\n\n        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n            self.valid_host(hostidx)\n            && self.maps.index(hostidx).dom().contains(key)\n        }\n\n        pub open spec fn key_holder(&self, key: Key) -> int {\n            choose|idx| self.host_has_key(idx, key)\n        }\n\n        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {\n            if exists |idx| self.host_has_key(idx, key) {\n                self.maps.index(self.key_holder(key)).index(key)\n            } else {\n                default()\n            }\n        }\n\n        pub open spec fn interp_map(&self) -> Map<Key, Value> {\n            Map::total(|key| self.abstraction_one_key(key))\n        }\n\n        #[invariant]\n        pub open fn num_hosts(&self) -> bool {\n            self.maps.len() == self.map_count\n        }\n\n        #[invariant]\n        pub open fn inv_no_dupes(&self) -> bool {\n            forall |i: int, j: int, key: Key|\n                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n        }\n\n        #[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n            //\n            //\n            //\n\n        }\n\n        #[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }\n\n        #[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n\n            /*assert_forall_by(|i: int, j: int, k: Key| {\n                requires(post.host_has_key(i, k) && post.host_has_key(j, k));\n                ensures(i == j);\n                if equal(k, key) {\n\n                    if i != recv_idx {\n\n                    }\n                    if i != recv_idx && j != recv_idx {\n\n                    }\n\n                } else {\n\n                }\n            });*/\n        }\n    }\n}\n\nspec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {\n    MapSpec::State { map: a.interp_map() }\n}\n\nproof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)\n\n{\n    case_on_next!{pre, post, ShardedKVProtocol => {\n        insert(idx, key, value) => {\n            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {\n                if equal(k, key) {\n\n                } else {\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n\n                    } else {\n\n                        /*\n\n                        */\n                    }\n\n                    /*\n                    */\n                }\n            });\n            MapSpec::show::insert_op(interp(pre), interp(post), key, value);\n        }\n        query(idx, key, value) => {\n            //\n            //\n\n            //\n            //\n            //\n\n            //\n            //\n            //\n\n            //\n            //\n\n            //\n            //\n            MapSpec::show::query_op(interp(pre), interp(post), key, value);\n        }\n        transfer(send_idx, recv_idx, key, value) => {\n            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {\n                if equal(k, key) {\n\n                } else {\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n\n                    } else {\n\n                    }\n                }\n            });\n            MapSpec::show::noop(interp(pre), interp(post));\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)\n\n{\n    case_on_init!{post, ShardedKVProtocol => {\n        initialize(n) => {\n            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {\n\n            });\n\n            MapSpec::show::empty(interp(post));\n        }\n    }}\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires pre.invariant(),\n        post.invariant(),\n        interp(pre).invariant(),\n        ShardedKVProtocol::State::next(pre, post), post.invariant() && ShardedKVProtocol::State::init(post)\nensures MapSpec::State::next(interp(pre), interp(post)), MapSpec::State::init(interp(post))", "full_verified_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::map::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::{pervasive::*, *};\n\nuse verus_state_machines_macros::case_on_init;\nuse verus_state_machines_macros::case_on_next;\nuse verus_state_machines_macros::state_machine;\n\nverus! {\n\n#[verifier::external_body]  /* vattr */\npub struct Key {}\n\n#[verifier::external_body]  /* vattr */\npub struct Value {}\n\n#[verifier::external_body]  /* vattr */\n#[verifier::spec]\npub fn default() -> Value {\n    unimplemented!()\n}\n\nstate_machine!{\n    MapSpec {\n        fields {\n            pub map: Map<Key, Value>,\n        }\n\n        init!{\n            empty() {\n                init map = Map::total(|k| default());\n            }\n        }\n\n        transition!{\n            insert_op(key: Key, value: Value) {\n                update map = pre.map.insert(key, value);\n            }\n        }\n\n        transition!{\n            query_op(key: Key, value: Value) {\n                require(pre.map.contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            noop() {\n            }\n        }\n    }\n}\n\nstate_machine!{\n    ShardedKVProtocol {\n        fields {\n            // TODO have a way to annotate this as a constant outside of tokenized mode\n            pub map_count: int,\n\n            pub maps: Seq<Map<Key, Value>>,\n        }\n\n        init!{\n            initialize(map_count: int) {\n                require(0 < map_count);\n                init map_count = map_count;\n                init maps = Seq::new(map_count as nat, |i| {\n                    if i == 0 {\n                        Map::total(|k| default())\n                    } else {\n                        Map::empty()\n                    }\n                });\n            }\n        }\n\n        pub open spec fn valid_host(&self, i: int) -> bool {\n            0 <= i < self.map_count\n        }\n\n        transition!{\n            insert(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).dom().contains(key));\n                update maps[idx][key] = value;\n            }\n        }\n\n        transition!{\n            query(idx: int, key: Key, value: Value) {\n                require(pre.valid_host(idx));\n                require(pre.maps.index(idx).contains_pair(key, value));\n            }\n        }\n\n        transition!{\n            transfer(send_idx: int, recv_idx: int, key: Key, value: Value) {\n                require(pre.valid_host(send_idx));\n                require(pre.valid_host(recv_idx));\n                require(pre.maps.index(send_idx).contains_pair(key, value));\n                require(send_idx != recv_idx);\n                update maps[send_idx] = pre.maps.index(send_idx).remove(key);\n                update maps[recv_idx][key] = value;\n            }\n        }\n\n        pub open spec fn host_has_key(&self, hostidx: int, key: Key) -> bool {\n            self.valid_host(hostidx)\n            && self.maps.index(hostidx).dom().contains(key)\n        }\n\n        pub open spec fn key_holder(&self, key: Key) -> int {\n            choose|idx| self.host_has_key(idx, key)\n        }\n\n        pub open spec fn abstraction_one_key(&self, key: Key) -> Value {\n            if exists |idx| self.host_has_key(idx, key) {\n                self.maps.index(self.key_holder(key)).index(key)\n            } else {\n                default()\n            }\n        }\n\n        pub open spec fn interp_map(&self) -> Map<Key, Value> {\n            Map::total(|key| self.abstraction_one_key(key))\n        }\n\n        #[invariant]\n        pub open fn num_hosts(&self) -> bool {\n            self.maps.len() == self.map_count\n        }\n\n        #[invariant]\n        pub open fn inv_no_dupes(&self) -> bool {\n            forall |i: int, j: int, key: Key|\n                self.host_has_key(i, key) && self.host_has_key(j, key) ==> i == j\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, map_count: int) {\n        }\n\n        #[inductive(insert)]\n        fn insert_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) {\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) ==> post.host_has_key(idx, k)));\n            //assert(forall(|k: Key| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k)));\n            //assert(forall(|k: Key| pre.host_has_key(idx, k) == post.host_has_key(idx, k)));\n            assert(forall |i: int, k: Key| pre.host_has_key(i, k) == post.host_has_key(i, k));\n        }\n\n        #[inductive(query)]\n        fn query_inductive(pre: Self, post: Self, idx: int, key: Key, value: Value) { }\n\n        #[inductive(transfer)]\n        fn transfer_inductive(pre: Self, post: Self, send_idx: int, recv_idx: int, key: Key, value: Value) {\n            assert(forall |i: int, k: Key| !equal(k, key) ==> pre.host_has_key(i, k) == post.host_has_key(i, k));\n            assert(forall |i: int| i != send_idx && i != recv_idx ==> pre.host_has_key(i, key) == post.host_has_key(i, key));\n\n            assert(equal(post.maps.index(send_idx),\n                pre.maps.index(send_idx).remove(key)));\n\n            assert(!post.host_has_key(send_idx, key));\n            assert(pre.host_has_key(send_idx, key));\n\n            /*assert_forall_by(|i: int, j: int, k: Key| {\n                requires(post.host_has_key(i, k) && post.host_has_key(j, k));\n                ensures(i == j);\n                if equal(k, key) {\n                    assert(i != send_idx);\n                    assert(j != send_idx);\n                    if i != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                    }\n                    if i != recv_idx && j != recv_idx {\n                        assert(pre.host_has_key(i, key));\n                        assert(pre.host_has_key(j, key));\n                        assert(pre.inv_no_dupes());\n                        assert(i == j);\n                    }\n                    assert(i == j);\n                } else {\n                    assert(i == j);\n                }\n            });*/\n        }\n    }\n}\n\nspec fn interp(a: ShardedKVProtocol::State) -> MapSpec::State {\n    MapSpec::State { map: a.interp_map() }\n}\n\nproof fn next_refines_next_with_macro(pre: ShardedKVProtocol::State, post: ShardedKVProtocol::State)\n    requires\n        pre.invariant(),\n        post.invariant(),\n        interp(pre).invariant(),\n        ShardedKVProtocol::State::next(pre, post),\n    ensures\n        MapSpec::State::next(interp(pre), interp(post)),\n{\n    case_on_next!{pre, post, ShardedKVProtocol => {\n        insert(idx, key, value) => {\n            assert_maps_equal!(pre.interp_map().insert(key, value), post.interp_map(), k => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(idx, key));\n                    assert(post.host_has_key(idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                        /*assert(forall |idx| !post.host_has_key(idx, k));\n                        assert(!exists(|idx| post.host_has_key(idx, k)));\n                        assert(equal(pre.abstraction_one_key(k), default()));\n                        assert(equal(post.abstraction_one_key(k), default()));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));*/\n                    }\n\n                    /*assert(pre.interp_map().dom().contains(k) ==>\n                        post.interp_map().dom().contains(k)\n                        && equal(pre.interp_map().index(k), post.interp_map().index(k))\n                    );\n                    assert(post.interp_map().dom().contains(k) ==>\n                        pre.interp_map().dom().contains(k));*/\n                }\n            });\n            MapSpec::show::insert_op(interp(pre), interp(post), key, value);\n        }\n        query(idx, key, value) => {\n            //assert(interp(pre).map =~= interp(post).map);\n            //assert(equal(interp(pre).map, interp(post).map));\n\n            //assert(equal(Map::total(|key| pre.abstraction_one_key(key)).dom(),\n            //    Set::empty().complement()));\n            //assert(equal(pre.interp_map(),\n            //    Map::total(|key| pre.abstraction_one_key(key))));\n            //assert(equal(pre.interp_map().dom(), Set::empty().complement()));\n\n            //assert(equal(interp(pre).map.dom(), Set::empty().complement()));\n            //assert(interp(pre).map.dom().contains(key));\n            //assert(equal(interp(pre).map.index(key),\n            //    pre.abstraction_one_key(key)));\n\n            assert(pre.host_has_key(idx, key));\n            //assert(pre.host_has_key(pre.key_holder(key), key));\n            //assert(equal(pre.key_holder(key), idx));\n\n            //assert(equal(pre.abstraction_one_key(key), value));\n            //assert(equal(interp(pre).map.index(key), value));\n            MapSpec::show::query_op(interp(pre), interp(post), key, value);\n        }\n        transfer(send_idx, recv_idx, key, value) => {\n            assert_maps_equal!(pre.interp_map(), post.interp_map(), k: Key => {\n                if equal(k, key) {\n                    assert(pre.host_has_key(send_idx, key));\n                    assert(post.host_has_key(recv_idx, key));\n                } else {\n                    assert(pre.interp_map().dom().contains(k));\n                    assert(post.interp_map().dom().contains(k));\n\n                    if exists |idx| pre.host_has_key(idx, k) {\n                        let i = pre.key_holder(k);\n                        assert(pre.host_has_key(i, k));\n                        assert(post.host_has_key(i, k));\n                        assert(equal(pre.interp_map().index(k), post.interp_map().index(k)));\n                    } else {\n                        assert(forall |idx| post.host_has_key(idx, k) ==> pre.host_has_key(idx, k));\n                    }\n                }\n            });\n            MapSpec::show::noop(interp(pre), interp(post));\n        }\n    }}\n}\n\nproof fn init_refines_init_with_macro(post: ShardedKVProtocol::State)\n    requires\n        post.invariant() && ShardedKVProtocol::State::init(post),\n    ensures\n        MapSpec::State::init(interp(post)),\n{\n    case_on_init!{post, ShardedKVProtocol => {\n        initialize(n) => {\n            assert_maps_equal!(interp(post).map, Map::total(|k| default()), k: Key => {\n                assert(interp(post).map.dom().contains(k));\n                assert(equal(interp(post).map.index(k), default()));\n            });\n\n            MapSpec::show::empty(interp(post));\n        }\n    }}\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-6-1.rs", "verified": true, "metadata": {"original_id": "verus_chapter-6-1_513a985e5f4b", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_top_sort_dfs_ea18631d9b04", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::slice::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n#[verifier::reject_recursive_types(V)]\npub struct DirectedGraph<V> {\n    pub edges: Set<(V, V)>,\n}\n\nimpl<V> DirectedGraph<V> {\n    pub open spec fn dest_set(&self, v: V) -> Set<V> {\n        Set::new(|w: V| self.edges.contains((v, w)))\n    }\n\n    pub open spec fn is_sorted(&self, s: Seq<V>) -> bool {\n        forall|i, j: int| 0 <= i <= j < s.len() ==> !self.edges.contains((s.index(i), s.index(j)))\n    }\n\n    pub open spec fn is_cycle_i(&self, s: Seq<V>, i: int) -> bool {\n        self.edges.contains((s[i], s[i + 1]))\n    }\n\n    pub open spec fn is_cycle(&self, s: Seq<V>) -> bool {\n        s.len() > 0 && (forall|i: int| 0 <= i < s.len() - 1 ==> self.is_cycle_i(s, i))\n            && self.edges.contains((s.last(), s[0]))\n    }\n}\n\ntokenized_state_machine!{\n    #[verifier::reject_recursive_types(V)]\n    TopSort<V> {\n        fields {\n            #[sharding(constant)]\n            pub graph: DirectedGraph<V>,\n\n            #[sharding(set)]\n            pub unvisited: Set<V>,\n\n            #[sharding(persistent_set)]\n            pub visited: Set<V>,\n\n            #[sharding(variable)]\n            pub top_sort: Seq<V>,\n        }\n\n        init!{\n            initialize(graph: DirectedGraph<V>) {\n                init graph = graph;\n                init unvisited = Set::full();\n                init visited = Set::empty();\n                init top_sort = Seq::empty();\n            }\n        }\n\n        transition!{\n            push_into_top_sort(v: V) {\n                have visited >= (pre.graph.dest_set(v));\n\n                remove unvisited -= set { v };\n                add visited (union)= set { v };\n\n                update top_sort = pre.top_sort.push(v);\n            }\n        }\n\n        property!{\n            done(s: Set<V>) {\n                have visited >= (s);\n\n            }\n        }\n\n        #[invariant]\n        pub fn un_vis(&self) -> bool {\n            self.unvisited === self.visited.complement()\n        }\n\n        #[invariant]\n        pub fn top_sort_is_sort(&self) -> bool {\n            self.graph.is_sorted(self.top_sort)\n        }\n\n        #[invariant]\n        pub fn visited_closed_under_dep(&self) -> bool {\n            forall |v, w| #[trigger] self.graph.edges.contains((v, w)) ==>\n                self.visited.contains(v) ==>\n                self.visited.contains(w)\n        }\n\n        #[invariant]\n        pub fn top_sort_matches_visited(&self) -> bool {\n            forall |v| #[trigger] self.visited.contains(v) <==>\n                self.top_sort.contains(v)\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, graph: DirectedGraph<V>) { }\n\n        #[inductive(push_into_top_sort)]\n        fn push_into_top_sort_inductive(pre: Self, post: Self, v: V) {\n            assert_sets_equal!(post.unvisited, post.visited.complement());\n\n            else {\n\n                    let i = choose |i| 0 <= i < pre.top_sort.len() && pre.top_sort.index(i) === a;\n\n                }\n            }\n\n            }\n\n    }\n}\n\nstruct ConcreteDirectedGraph {\n    edges: Vec<Vec<usize>>,\n}\n\nimpl ConcreteDirectedGraph {\n    spec fn well_formed(&self) -> bool {\n        forall|i, j|\n            0 <= i < self.edges@.len() && 0 <= j < self.edges@.index(i)@.len() ==> 0 <= (\n            #[trigger] self.edges@.index(i)@.index(j)) < self.edges@.len()\n    }\n\n    spec fn view(&self) -> DirectedGraph<usize> {\n        DirectedGraph {\n            edges: Set::<(usize, usize)>::new(\n                |p: (usize, usize)|\n                    0 <= (p.0 as int) < (self.edges@.len() as int) && self.edges@.index(\n                        p.0 as int,\n                    )@.contains(p.1),\n            ),\n        }\n    }\n}\n\nenum NodeToken {\n    Unvisited(TopSort::unvisited<usize>),\n    InProgress,\n    Visited(TopSort::visited<usize>),\n}\n\nstruct NodeState {\n    visited: bool,\n    in_stack: bool,\n    token: Tracked<NodeToken>,\n}\n\nimpl NodeState {\n    spec fn well_formed(&self, i: int, inst: TopSort::Instance<usize>) -> bool {\n        match self.token@ {\n            NodeToken::Unvisited(token) => {\n                &&& !self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n            NodeToken::InProgress => {\n                &&& self.visited\n                &&& self.in_stack\n            },\n            NodeToken::Visited(token) => {\n                &&& self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n        }\n    }\n}\n\nstruct DfsState {\n    top_sort: Vec<usize>,\n    cur_stack: Vec<usize>,\n    cycle: Vec<usize>,\n    node_states: Vec<NodeState>,\n    top_sort_token: Tracked<TopSort::top_sort<usize>>,\n    instance: Tracked<TopSort::Instance<usize>>,\n}\n\nspec fn valid_stack_i(cur_stack: Seq<usize>, graph: DirectedGraph<usize>, i: int) -> bool {\n    graph.edges.contains((cur_stack[i], cur_stack[i + 1]))\n}\n\nspec fn valid_stack(cur_stack: Seq<usize>, graph: DirectedGraph<usize>) -> bool {\n    forall|i: int| 0 <= i < cur_stack.len() as int - 1 ==> valid_stack_i(cur_stack, graph, i)\n}\n\nimpl DfsState {\n    spec fn well_formed(&self, graph: &ConcreteDirectedGraph) -> bool {\n        &&& graph.well_formed()\n        &&& self.node_states@.len() == graph.edges@.len()\n        &&& forall|i|\n            0 <= i < self.node_states@.len() ==> self.node_states@[i].well_formed(i, self.instance@)\n        &&& self.top_sort_token@.instance_id() === self.instance@.id()\n        &&& self.top_sort_token@.value() === self.top_sort@\n        &&& self.instance@.graph() === graph@\n        &&& valid_stack(self.cur_stack@, graph@)\n        &&& forall|i: usize|\n            0 <= i < self.node_states@.len() ==> (self.node_states@[i as int].in_stack\n                <==> self.cur_stack@.contains(i))\n    }\n}\n\nspec fn is_complete_top_sort(top_sort: &Vec<usize>, graph: &ConcreteDirectedGraph) -> bool {\n    graph@.is_sorted(top_sort@) && forall|i: usize|\n        0 <= i < graph.edges@.len() ==> top_sort@.contains(i)\n}\n\nfn vec_find(v: &Vec<usize>, needle: usize) -> (idx: usize)\n\n{\n    let mut idx = 0;\n    loop\n\n    {\n        if v[idx] == needle {\n            return idx;\n        }\n\n        idx = idx + 1;\n    }\n}\n\nfn find_cycle(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize)\n\n{\n    let j = vec_find(&dfs_state.cur_stack, v);\n    let len = dfs_state.cur_stack.len();\n    let tmp1 = dfs_state.cur_stack.as_slice();\n    let tmp2 = slice_subrange(tmp1, j, len);\n    let cycle = slice_to_vec(tmp2);\n    dfs_state.cycle = cycle;\n\n      // trigger\n        }\n    };\n}\n\nfn visit(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize) -> (res: (\n    bool,\n    Tracked<Option<TopSort::visited<usize>>>,\n))\n\n{\n    let node_state = &dfs_state.node_states[v as usize];\n    if node_state.in_stack {\n        find_cycle(graph, dfs_state, v);\n        return (false, Tracked(None));\n    }\n    if node_state.visited {\n        let tracked tok = match node_state.token.borrow() {\n            NodeToken::Visited(tok) => tok.clone(),\n            _ => proof_from_false(),\n        };\n        return (true, Tracked(Some(tok)));\n    }\n    let mut node_state_tmp = NodeState {\n        in_stack: true,\n        visited: true,\n        token: Tracked(NodeToken::InProgress),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    let tracked unvisited = match node_state_tmp.token.get() {\n        NodeToken::Unvisited(unvisited) => unvisited,\n        _ => proof_from_false(),\n    };\n    dfs_state.cur_stack.push(v);\n\n        else {\n                if old(dfs_state).cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n\n                }\n                if dfs_state.cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n\n                }\n\n            }\n        }\n    }\n    let ghost extended_cur_stack = dfs_state.cur_stack;\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> =\n        TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    let mut idx: usize = 0;\n    while idx < graph.edges[v as usize].len()\n         {\n                    let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n                    map_visited_deps.contains(w)\n                },\n    {\n        let w = graph.edges[v as usize][idx];\n\n        let (b, Tracked(opt_visited)) = visit(graph, dfs_state, w);\n        if !b {\n            return (false, Tracked(None));\n        }\n        let ghost old_map_visited_deps = map_visited_deps;\n        let ghost old_idx = idx;\n\n        idx = idx + 1;\n        assert forall|idx0: int| 0 <= idx0 && idx0 < idx implies ({\n            let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n            map_visited_deps.contains(w)\n        }) by {\n            assume(false);\n        }\n    }\n    dfs_state.cur_stack.pop();\n\n    let tracked visited = dfs_state.instance.borrow().push_into_top_sort(\n        v,\n        unvisited,\n        &map_visited_deps,\n        dfs_state.top_sort_token.borrow_mut(),\n    );\n    dfs_state.top_sort.push(v);\n    let mut node_state_tmp = NodeState {\n        in_stack: false,  // TODO don't need to write this field again\n        visited: true,\n        token: Tracked(NodeToken::Visited(visited.clone())),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n\n        assume(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==> (dfs_state.node_states@.index(\n                i as int,\n            ).in_stack == dfs_state.cur_stack@.contains(i)));\n    };\n    (true, Tracked(Some(visited)))\n}\n\nfn init_node_states(\n    n: usize,\n    Tracked(instance): Tracked<TopSort::Instance<usize>>,\n    Tracked(unv): Tracked<TopSort::unvisited_set<usize>>,\n) -> (node_states: Vec<NodeState>)\n\n{\n    let mut node_states = Vec::<NodeState>::new();\n    let mut i: usize = 0;\n    let tracked mut unv = unv;\n    while i < n\n\n    {\n\n        let tracked unv1 = unv.remove(i);\n        node_states.push(\n            NodeState {\n                visited: false,\n                in_stack: false,\n                token: Tracked(NodeToken::Unvisited(unv1)),\n            },\n        );\n        i = i + 1;\n        /*let ghost i_spec = i;\n        assert_forall_by(|j: int| {\n            requires(0 <= j && j < i);\n            ensures(node_states@.index(j).well_formed(j, instance));\n\n            if j + 1 < i_spec {\n\n            } else {\n\n            }\n        });*/\n    }\n    node_states\n}\n\nenum TopSortResult {\n    TopSort(Vec<usize>),\n    Cycle(Vec<usize>),\n}\n\nfn compute_top_sort(graph: &ConcreteDirectedGraph) -> (tsr: TopSortResult)\n\n     {\n            TopSortResult::TopSort(top_sort) => is_complete_top_sort(&top_sort, graph),\n            TopSortResult::Cycle(cycle) => graph@.is_cycle(cycle@),\n        }),\n{\n    let tracked (Tracked(instance), Tracked(unv), _, Tracked(top_sort_token)) =\n        TopSort::Instance::<usize>::initialize(graph@);\n    let mut dfs_state = DfsState {\n        top_sort: Vec::new(),\n        cur_stack: Vec::new(),\n        cycle: Vec::new(),\n        node_states: init_node_states(\n            graph.edges.len() as usize,\n            Tracked(instance.clone()),\n            Tracked(unv),\n        ),\n        top_sort_token: Tracked(top_sort_token),\n        instance: Tracked(instance),\n    };\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> = TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n\n    }\n    let mut v: usize = 0;\n    while v < graph.edges.len() as usize\n\n    {\n        let (b, Tracked(opt_visited)) = visit(graph, &mut dfs_state, v);\n        if !b {\n            return TopSortResult::Cycle(dfs_state.cycle);\n        }\n\n        v = v + 1;\n    }\n    let DfsState { top_sort, top_sort_token: Tracked(top_sort_token), .. } = dfs_state;\n\n    TopSortResult::TopSort(top_sort)\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires v@.contains(needle), 0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n        old(dfs_state).node_states@.index(v as int).in_stack, 0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ), forall|j: usize| 0 <= j && j < n ==> unv.contains(j),\n        unv.instance_id() == instance.id(), graph.well_formed()\nensures 0 <= idx < v@.len() && v@[idx as int] == needle, graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance), res.0 ==> dfs_state.well_formed(graph),\n        res.0 ==> equal(dfs_state.cur_stack@, old(dfs_state).cur_stack@),\n        res.0 ==> res.1@ is Some && res.1@->0.instance_id() == dfs_state.instance@.id()\n            && res.1@->0.element() == v,\n        !res.0 ==> graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance), node_states@.len() == n as int,\n        forall|j: int|\n            0 <= j && j < node_states@.len() ==> node_states@.index(j).well_formed(j, instance),\n        forall|j: int| 0 <= j && j < node_states@.len() ==> !node_states@.index(j).in_stack, (match tsr\ninvariant v@.contains(needle),\n            0 <= idx < v@.len(),\n            forall|j| 0 <= j < idx ==> v@[j] != needle, equal(dfs_state.instance, old(dfs_state).instance),\n            dfs_state.cur_stack@.len() > 0,\n            dfs_state.cur_stack@.last() == v,\n            0 <= v && v < graph.edges@.len(),\n            0 <= idx && idx <= graph.edges@.index(v as int)@.len(),\n            dfs_state.well_formed(graph),\n            equal(dfs_state.cur_stack@, extended_cur_stack@),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|idx0: int|\n                0 <= idx0 && idx0 < idx ==>, 0 <= i && i <= n,\n            node_states@.len() == i as int,\n            forall|j: int| 0 <= j && j < i ==> node_states@.index(j).well_formed(j, instance),\n            forall|j: int| 0 <= j && j < i ==> !node_states@.index(j).in_stack,\n            forall|j: usize| i <= j && j < n ==> #[trigger] unv.contains(j),\n            unv.instance_id() == instance.id(), graph.well_formed(),\n            dfs_state.well_formed(graph),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|w| 0 <= w && (w as int) < (v as int) ==> map_visited_deps.contains(w),\n            dfs_state.cur_stack@.len() == 0", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_state_machines_macros::tokenized_state_machine;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::set::*;\nuse vstd::slice::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\n#[verifier::reject_recursive_types(V)]\npub struct DirectedGraph<V> {\n    pub edges: Set<(V, V)>,\n}\n\nimpl<V> DirectedGraph<V> {\n    pub open spec fn dest_set(&self, v: V) -> Set<V> {\n        Set::new(|w: V| self.edges.contains((v, w)))\n    }\n\n    pub open spec fn is_sorted(&self, s: Seq<V>) -> bool {\n        forall|i, j: int| 0 <= i <= j < s.len() ==> !self.edges.contains((s.index(i), s.index(j)))\n    }\n\n    pub open spec fn is_cycle_i(&self, s: Seq<V>, i: int) -> bool {\n        self.edges.contains((s[i], s[i + 1]))\n    }\n\n    pub open spec fn is_cycle(&self, s: Seq<V>) -> bool {\n        s.len() > 0 && (forall|i: int| 0 <= i < s.len() - 1 ==> self.is_cycle_i(s, i))\n            && self.edges.contains((s.last(), s[0]))\n    }\n}\n\ntokenized_state_machine!{\n    #[verifier::reject_recursive_types(V)]\n    TopSort<V> {\n        fields {\n            #[sharding(constant)]\n            pub graph: DirectedGraph<V>,\n\n            #[sharding(set)]\n            pub unvisited: Set<V>,\n\n            #[sharding(persistent_set)]\n            pub visited: Set<V>,\n\n            #[sharding(variable)]\n            pub top_sort: Seq<V>,\n        }\n\n        init!{\n            initialize(graph: DirectedGraph<V>) {\n                init graph = graph;\n                init unvisited = Set::full();\n                init visited = Set::empty();\n                init top_sort = Seq::empty();\n            }\n        }\n\n        transition!{\n            push_into_top_sort(v: V) {\n                have visited >= (pre.graph.dest_set(v));\n\n                remove unvisited -= set { v };\n                add visited (union)= set { v };\n\n                update top_sort = pre.top_sort.push(v);\n            }\n        }\n\n        property!{\n            done(s: Set<V>) {\n                have visited >= (s);\n                assert(forall |i| s.contains(i) ==> pre.top_sort.contains(i));\n                assert(pre.graph.is_sorted(pre.top_sort));\n            }\n        }\n\n        #[invariant]\n        pub fn un_vis(&self) -> bool {\n            self.unvisited === self.visited.complement()\n        }\n\n        #[invariant]\n        pub fn top_sort_is_sort(&self) -> bool {\n            self.graph.is_sorted(self.top_sort)\n        }\n\n        #[invariant]\n        pub fn visited_closed_under_dep(&self) -> bool {\n            forall |v, w| #[trigger] self.graph.edges.contains((v, w)) ==>\n                self.visited.contains(v) ==>\n                self.visited.contains(w)\n        }\n\n        #[invariant]\n        pub fn top_sort_matches_visited(&self) -> bool {\n            forall |v| #[trigger] self.visited.contains(v) <==>\n                self.top_sort.contains(v)\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inductive(post: Self, graph: DirectedGraph<V>) { }\n\n        #[inductive(push_into_top_sort)]\n        fn push_into_top_sort_inductive(pre: Self, post: Self, v: V) {\n            assert_sets_equal!(post.unvisited, post.visited.complement());\n\n            assert forall |a| #[trigger] post.visited.contains(a) implies\n                post.top_sort.contains(a)\n            by {\n                if a === v {\n                    assert(post.top_sort.last() === a);\n                    assert(post.top_sort.contains(a));\n                } else {\n                    assert(pre.visited.contains(a));\n                    assert(pre.top_sort.contains(a));\n                    let i = choose |i| 0 <= i < pre.top_sort.len() && pre.top_sort.index(i) === a;\n                    assert(post.top_sort.index(i) === a);\n                    assert(post.top_sort.contains(a));\n                }\n            }\n\n            assert forall |v| #[trigger] post.top_sort.contains(v) implies\n                post.visited.contains(v)\n            by {\n            }\n        }\n\n    }\n}\n\nstruct ConcreteDirectedGraph {\n    edges: Vec<Vec<usize>>,\n}\n\nimpl ConcreteDirectedGraph {\n    spec fn well_formed(&self) -> bool {\n        forall|i, j|\n            0 <= i < self.edges@.len() && 0 <= j < self.edges@.index(i)@.len() ==> 0 <= (\n            #[trigger] self.edges@.index(i)@.index(j)) < self.edges@.len()\n    }\n\n    spec fn view(&self) -> DirectedGraph<usize> {\n        DirectedGraph {\n            edges: Set::<(usize, usize)>::new(\n                |p: (usize, usize)|\n                    0 <= (p.0 as int) < (self.edges@.len() as int) && self.edges@.index(\n                        p.0 as int,\n                    )@.contains(p.1),\n            ),\n        }\n    }\n}\n\nenum NodeToken {\n    Unvisited(TopSort::unvisited<usize>),\n    InProgress,\n    Visited(TopSort::visited<usize>),\n}\n\nstruct NodeState {\n    visited: bool,\n    in_stack: bool,\n    token: Tracked<NodeToken>,\n}\n\nimpl NodeState {\n    spec fn well_formed(&self, i: int, inst: TopSort::Instance<usize>) -> bool {\n        match self.token@ {\n            NodeToken::Unvisited(token) => {\n                &&& !self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n            NodeToken::InProgress => {\n                &&& self.visited\n                &&& self.in_stack\n            },\n            NodeToken::Visited(token) => {\n                &&& self.visited\n                &&& !self.in_stack\n                &&& token.instance_id() == inst.id()\n                &&& token.element() == i\n            },\n        }\n    }\n}\n\nstruct DfsState {\n    top_sort: Vec<usize>,\n    cur_stack: Vec<usize>,\n    cycle: Vec<usize>,\n    node_states: Vec<NodeState>,\n    top_sort_token: Tracked<TopSort::top_sort<usize>>,\n    instance: Tracked<TopSort::Instance<usize>>,\n}\n\nspec fn valid_stack_i(cur_stack: Seq<usize>, graph: DirectedGraph<usize>, i: int) -> bool {\n    graph.edges.contains((cur_stack[i], cur_stack[i + 1]))\n}\n\nspec fn valid_stack(cur_stack: Seq<usize>, graph: DirectedGraph<usize>) -> bool {\n    forall|i: int| 0 <= i < cur_stack.len() as int - 1 ==> valid_stack_i(cur_stack, graph, i)\n}\n\nimpl DfsState {\n    spec fn well_formed(&self, graph: &ConcreteDirectedGraph) -> bool {\n        &&& graph.well_formed()\n        &&& self.node_states@.len() == graph.edges@.len()\n        &&& forall|i|\n            0 <= i < self.node_states@.len() ==> self.node_states@[i].well_formed(i, self.instance@)\n        &&& self.top_sort_token@.instance_id() === self.instance@.id()\n        &&& self.top_sort_token@.value() === self.top_sort@\n        &&& self.instance@.graph() === graph@\n        &&& valid_stack(self.cur_stack@, graph@)\n        &&& forall|i: usize|\n            0 <= i < self.node_states@.len() ==> (self.node_states@[i as int].in_stack\n                <==> self.cur_stack@.contains(i))\n    }\n}\n\nspec fn is_complete_top_sort(top_sort: &Vec<usize>, graph: &ConcreteDirectedGraph) -> bool {\n    graph@.is_sorted(top_sort@) && forall|i: usize|\n        0 <= i < graph.edges@.len() ==> top_sort@.contains(i)\n}\n\nfn vec_find(v: &Vec<usize>, needle: usize) -> (idx: usize)\n    requires\n        v@.contains(needle),\n    ensures\n        0 <= idx < v@.len() && v@[idx as int] == needle,\n{\n    let mut idx = 0;\n    loop\n        invariant\n            v@.contains(needle),\n            0 <= idx < v@.len(),\n            forall|j| 0 <= j < idx ==> v@[j] != needle,\n    {\n        if v[idx] == needle {\n            return idx;\n        }\n        assert(idx + 1 < v.len());\n        idx = idx + 1;\n    }\n}\n\nfn find_cycle(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize)\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n        old(dfs_state).node_states@.index(v as int).in_stack,\n    ensures\n        graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let j = vec_find(&dfs_state.cur_stack, v);\n    let len = dfs_state.cur_stack.len();\n    let tmp1 = dfs_state.cur_stack.as_slice();\n    let tmp2 = slice_subrange(tmp1, j, len);\n    let cycle = slice_to_vec(tmp2);\n    dfs_state.cycle = cycle;\n    assert(tmp1@.len() == dfs_state.cur_stack.len());\n    assert(tmp2@.len() + j == len);\n    assert(tmp2@ == cycle@);\n    assert(cycle.len() + j == len);\n    assert(j + dfs_state.cycle@.len() == len);\n    assert(graph@.is_cycle(dfs_state.cycle@)) by {\n        assert forall|i: int| 0 <= i < dfs_state.cycle@.len() - 1 implies graph@.is_cycle_i(\n            dfs_state.cycle@,\n            i,\n        ) by {\n            assert(valid_stack_i(dfs_state.cur_stack@, graph@, i + j));  // trigger\n        }\n    };\n}\n\nfn visit(graph: &ConcreteDirectedGraph, dfs_state: &mut DfsState, v: usize) -> (res: (\n    bool,\n    Tracked<Option<TopSort::visited<usize>>>,\n))\n    requires\n        0 <= v && v < graph.edges@.len(),\n        old(dfs_state).well_formed(graph),\n        old(dfs_state).cur_stack@.len() >= 1 ==> graph@.edges.contains(\n            (old(dfs_state).cur_stack@.last(), v),\n        ),\n    ensures\n        res.0 ==> dfs_state.well_formed(graph),\n        res.0 ==> equal(dfs_state.cur_stack@, old(dfs_state).cur_stack@),\n        res.0 ==> res.1@ is Some && res.1@->0.instance_id() == dfs_state.instance@.id()\n            && res.1@->0.element() == v,\n        !res.0 ==> graph@.is_cycle(dfs_state.cycle@),\n        equal(dfs_state.instance, old(dfs_state).instance),\n{\n    let node_state = &dfs_state.node_states[v as usize];\n    if node_state.in_stack {\n        find_cycle(graph, dfs_state, v);\n        return (false, Tracked(None));\n    }\n    if node_state.visited {\n        let tracked tok = match node_state.token.borrow() {\n            NodeToken::Visited(tok) => tok.clone(),\n            _ => proof_from_false(),\n        };\n        return (true, Tracked(Some(tok)));\n    }\n    let mut node_state_tmp = NodeState {\n        in_stack: true,\n        visited: true,\n        token: Tracked(NodeToken::InProgress),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    let tracked unvisited = match node_state_tmp.token.get() {\n        NodeToken::Unvisited(unvisited) => unvisited,\n        _ => proof_from_false(),\n    };\n    dfs_state.cur_stack.push(v);\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: int|\n            0 <= i && i < dfs_state.cur_stack@.len() as int - 2 ==> valid_stack_i(\n                old(dfs_state).cur_stack@,\n                graph@,\n                i,\n            ) ==> #[trigger] valid_stack_i(dfs_state.cur_stack@, graph@, i));\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assert forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() implies dfs_state.node_states@.index(\n            i as int,\n        ).in_stack == dfs_state.cur_stack@.contains(i) by {\n            if i == v {\n                assert(dfs_state.cur_stack@.last() == i);\n                assert(dfs_state.cur_stack@.contains(i));\n            } else {\n                if old(dfs_state).cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(dfs_state.cur_stack@.index(j) == i);\n                }\n                if dfs_state.cur_stack@.contains(i) {\n                    let j = old(dfs_state).cur_stack@.index_of(i);\n                    assert(old(dfs_state).cur_stack@.index(j) == i);\n                }\n                assert(dfs_state.cur_stack@.contains(i) == old(dfs_state).cur_stack@.contains(i));\n            }\n        }\n    }\n    let ghost extended_cur_stack = dfs_state.cur_stack;\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> =\n        TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    let mut idx: usize = 0;\n    while idx < graph.edges[v as usize].len()\n        invariant\n            equal(dfs_state.instance, old(dfs_state).instance),\n            dfs_state.cur_stack@.len() > 0,\n            dfs_state.cur_stack@.last() == v,\n            0 <= v && v < graph.edges@.len(),\n            0 <= idx && idx <= graph.edges@.index(v as int)@.len(),\n            dfs_state.well_formed(graph),\n            equal(dfs_state.cur_stack@, extended_cur_stack@),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|idx0: int|\n                0 <= idx0 && idx0 < idx ==> {\n                    let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n                    map_visited_deps.contains(w)\n                },\n    {\n        let w = graph.edges[v as usize][idx];\n        assert((v as usize) as int == v as int);\n        assert(graph.edges@.index(v as int)@.index(idx as int) == w);\n        assert(graph.edges@.index(v as int)@.contains(w));\n        assert(graph@.edges.contains((v, w)));\n        let (b, Tracked(opt_visited)) = visit(graph, dfs_state, w);\n        if !b {\n            return (false, Tracked(None));\n        }\n        let ghost old_map_visited_deps = map_visited_deps;\n        let ghost old_idx = idx;\n        proof {\n            let tracked visited = opt_visited.tracked_unwrap();\n            map_visited_deps.insert(visited);\n        }\n        idx = idx + 1;\n        assert forall|idx0: int| 0 <= idx0 && idx0 < idx implies ({\n            let w = #[trigger] graph.edges@.index(v as int)@.index(idx0);\n            map_visited_deps.contains(w)\n        }) by {\n            assume(false);\n        }\n    }\n    dfs_state.cur_stack.pop();\n    assert(equal(unvisited.instance_id(), dfs_state.instance@.id()));\n    let tracked visited = dfs_state.instance.borrow().push_into_top_sort(\n        v,\n        unvisited,\n        &map_visited_deps,\n        dfs_state.top_sort_token.borrow_mut(),\n    );\n    dfs_state.top_sort.push(v);\n    let mut node_state_tmp = NodeState {\n        in_stack: false,  // TODO don't need to write this field again\n        visited: true,\n        token: Tracked(NodeToken::Visited(visited.clone())),\n    };\n    dfs_state.node_states.set_and_swap(v as usize, &mut node_state_tmp);\n    proof {\n        assert_seqs_equal!(\n            dfs_state.cur_stack@,\n            old(dfs_state).cur_stack@);\n    }\n    assert(dfs_state.well_formed(graph)) by {\n        assert(valid_stack(dfs_state.cur_stack@, graph@));\n        assume(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==> (dfs_state.node_states@.index(\n                i as int,\n            ).in_stack == dfs_state.cur_stack@.contains(i)));\n    };\n    (true, Tracked(Some(visited)))\n}\n\nfn init_node_states(\n    n: usize,\n    Tracked(instance): Tracked<TopSort::Instance<usize>>,\n    Tracked(unv): Tracked<TopSort::unvisited_set<usize>>,\n) -> (node_states: Vec<NodeState>)\n    requires\n        forall|j: usize| 0 <= j && j < n ==> unv.contains(j),\n        unv.instance_id() == instance.id(),\n    ensures\n        node_states@.len() == n as int,\n        forall|j: int|\n            0 <= j && j < node_states@.len() ==> node_states@.index(j).well_formed(j, instance),\n        forall|j: int| 0 <= j && j < node_states@.len() ==> !node_states@.index(j).in_stack,\n{\n    let mut node_states = Vec::<NodeState>::new();\n    let mut i: usize = 0;\n    let tracked mut unv = unv;\n    while i < n\n        invariant\n            0 <= i && i <= n,\n            node_states@.len() == i as int,\n            forall|j: int| 0 <= j && j < i ==> node_states@.index(j).well_formed(j, instance),\n            forall|j: int| 0 <= j && j < i ==> !node_states@.index(j).in_stack,\n            forall|j: usize| i <= j && j < n ==> #[trigger] unv.contains(j),\n            unv.instance_id() == instance.id(),\n    {\n        assert(unv.contains(i));\n        let tracked unv1 = unv.remove(i);\n        node_states.push(\n            NodeState {\n                visited: false,\n                in_stack: false,\n                token: Tracked(NodeToken::Unvisited(unv1)),\n            },\n        );\n        i = i + 1;\n        /*let ghost i_spec = i;\n        assert_forall_by(|j: int| {\n            requires(0 <= j && j < i);\n            ensures(node_states@.index(j).well_formed(j, instance));\n\n            if j + 1 < i_spec {\n                assert(old_node_states@.index(j).well_formed(j, instance));\n            } else {\n                assert(node_states@.index(j).well_formed(j, instance));\n            }\n        });*/\n    }\n    node_states\n}\n\nenum TopSortResult {\n    TopSort(Vec<usize>),\n    Cycle(Vec<usize>),\n}\n\nfn compute_top_sort(graph: &ConcreteDirectedGraph) -> (tsr: TopSortResult)\n    requires\n        graph.well_formed(),\n    ensures\n        (match tsr {\n            TopSortResult::TopSort(top_sort) => is_complete_top_sort(&top_sort, graph),\n            TopSortResult::Cycle(cycle) => graph@.is_cycle(cycle@),\n        }),\n{\n    let tracked (Tracked(instance), Tracked(unv), _, Tracked(top_sort_token)) =\n        TopSort::Instance::<usize>::initialize(graph@);\n    let mut dfs_state = DfsState {\n        top_sort: Vec::new(),\n        cur_stack: Vec::new(),\n        cycle: Vec::new(),\n        node_states: init_node_states(\n            graph.edges.len() as usize,\n            Tracked(instance.clone()),\n            Tracked(unv),\n        ),\n        top_sort_token: Tracked(top_sort_token),\n        instance: Tracked(instance),\n    };\n    let tracked mut map_visited_deps: TopSort::visited_set<usize> = TopSort::visited_set::<usize>::empty(dfs_state.instance@.id());\n    assert(dfs_state.well_formed(graph)) by {\n        assert(forall|i: usize|\n            0 <= i && i < dfs_state.node_states@.len() ==>\n                (dfs_state.node_states@.index(i as int).in_stack == dfs_state.cur_stack@.contains(i)));\n    }\n    let mut v: usize = 0;\n    while v < graph.edges.len() as usize\n        invariant\n            graph.well_formed(),\n            dfs_state.well_formed(graph),\n            map_visited_deps.instance_id() == dfs_state.instance@.id(),\n            forall|w| 0 <= w && (w as int) < (v as int) ==> map_visited_deps.contains(w),\n            dfs_state.cur_stack@.len() == 0,\n    {\n        let (b, Tracked(opt_visited)) = visit(graph, &mut dfs_state, v);\n        if !b {\n            return TopSortResult::Cycle(dfs_state.cycle);\n        }\n        proof {\n            map_visited_deps.insert(opt_visited.tracked_unwrap());\n        }\n        v = v + 1;\n    }\n    let DfsState { top_sort, top_sort_token: Tracked(top_sort_token), .. } = dfs_state;\n    proof {\n        let ghost s = Set::new(|i: usize| 0 <= i && i < graph.edges@.len());\n        dfs_state.instance.borrow().done(s, &map_visited_deps, &top_sort_token);\n        assert forall|i: usize| 0 <= i && i < graph.edges@.len() implies top_sort@.contains(i) by {\n            assert(s.contains(i));\n        }\n        assert(is_complete_top_sort(&top_sort, graph));\n    }\n    TopSortResult::TopSort(top_sort)\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/top_sort_dfs.rs", "verified": true, "metadata": {"original_id": "verus_top_sort_dfs_ea18631d9b04", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d84fbbd78108", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "d84fbbd78108", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_10aa01824fda", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >)  { let n = a . len () ; let mut i = 0 ; while i < n  { let mut min_idx = i ; let mut j = i + 1 ; while j < n  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \ndecreases n - i, n - j\ninvariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let n = a . len () ; let mut i = 0 ; while i < n invariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - i { let mut min_idx = i ; let mut j = i + 1 ; while j < n invariant a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_selectionsort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "10aa01824fda", "function_name": "selection_sort", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8daca2889972", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code.rs", "verified": true, "metadata": {"original_id": "8daca2889972", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_06d9796e8a51", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2u32 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i, n + 1 - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "06d9796e8a51", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a5e65eff668f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "a5e65eff668f", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8ba2722e9141", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 0 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { sum [0] = 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/res1_impl.rs", "verified": true, "metadata": {"original_id": "8ba2722e9141", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_df16c7a2cedb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "df16c7a2cedb", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f18dbd825d99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len ()  { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - j\ninvariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] , decreases nums . len () - j { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "f18dbd825d99", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2182d5a3a9ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/condg_impl.rs", "verified": true, "metadata": {"original_id": "2182d5a3a9ad", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_552ff365c53b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 'Z' || text [j] == 'z')) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 'Z' || text [j] == 'z')) , { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "552ff365c53b", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_05d0b38c00a3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { return 0 ; }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_24/verina_advanced_24.rs", "verified": true, "metadata": {"original_id": "05d0b38c00a3", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c3cc4658647f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {    return false ; } i = i + 1 ; }   return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> (result : bool) { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "c3cc4658647f", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_698ec277f9f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "698ec277f9f0", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1aee52178d30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires increasing_triplet_precond (nums @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_15/verina_advanced_15.rs", "verified": true, "metadata": {"original_id": "1aee52178d30", "function_name": "increasing_triplet", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e411cbb3539f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { if n <= a [i] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> n > a [j] decreases a . len () - i { if n <= a [i] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_10/verina_basic_10_impl.rs", "verified": true, "metadata": {"original_id": "e411cbb3539f", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b6b4b6f0a43e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - idx \ninvariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b6b4b6f0a43e", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2f8692a729d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == N \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2f8692a729d3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e5c473732173", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_307_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e5c473732173", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7d57dec697c6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_95/verina_basic_95_impl.rs", "verified": true, "metadata": {"original_id": "7d57dec697c6", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3cecf9ec9a1d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "3cecf9ec9a1d", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a88d0a2ed15b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "a88d0a2ed15b", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_77a7241cc52c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j = j + 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "77a7241cc52c", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e09614caceae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/arithmetic_weird.rs", "verified": true, "metadata": {"original_id": "e09614caceae", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_27efb7251eee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "27efb7251eee", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_88bffd3a8741", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88bffd3a8741", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_680933740be3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , (3 * N) as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , (3 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s22if_impl.rs", "verified": true, "metadata": {"original_id": "680933740be3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8d4192fb2564", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; }   result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "8d4192fb2564", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_826b70672971", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "826b70672971", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ba00bb584db0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)   { let mut i = 0 ; while i < numbers . len ()  { let mut j = 0 ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires i != MIN , threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures i < 0 ==> res == - i , i >= 0 ==> res == i, flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold\ndecreases numbers . len () - i, numbers . len () - j\ninvariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold, 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && i != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && i != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ba00bb584db0", "function_name": "has_close_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5f2ed7f9208b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "5f2ed7f9208b", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0437d714c0c6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ndecreases arr . len () - i, arr1 . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "0437d714c0c6", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3f064b15d620", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3f064b15d620", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b48402502142", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s4if_impl.rs", "verified": true, "metadata": {"original_id": "b48402502142", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c18e772b405a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/abs_impl.rs", "verified": true, "metadata": {"original_id": "c18e772b405a", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9f6bfb281468", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } return false ; }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "9f6bfb281468", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_530a59003962", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)   { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n  { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n  { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len ()\nensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i]\ndecreases n - i, n - j\ninvariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k], 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/WIP/WIP__transpose_matrix_iter_3_current.rs", "verified": true, "metadata": {"original_id": "530a59003962", "function_name": "transpose", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_43c70428af29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)   { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "requires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_95/verina_basic_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "43c70428af29", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_23c0a61ba5df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "23c0a61ba5df", "function_name": "count_digits_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_043f04c7ca52", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "043f04c7ca52", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_9863f659a4f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "9863f659a4f0", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ed45023dc6e4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ed45023dc6e4", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_504950a7e62a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires find_even_numbers_precond (arr @)\nensures result == is_even (n as int), find_even_numbers_postcond (arr @ , result @)\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "504950a7e62a", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_76f6e7217b9f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "76f6e7217b9f", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_90cc8f8ea843", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nfn encode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 \nensures r == encode_char_spec (c as int) , 65 <= r <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "90cc8f8ea843", "function_name": "encode_char", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_be5b60c99ead", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)   { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "target_text": "requires i + 1 < old (a) . len () , j <= i , i + 1 < old (a) . len () , i < old (a) . len () , j < old (a) . len () , bubble_sort_precond (a @) \nensures a . len () == old (a) . len () , a . len () == old (a) . len () , a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , result . len () == a . len () , a . len () == old (a) . len () , decreases i , a . len () == old (a) . len () , decreases i - j \ndecreases i , i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "be5b60c99ead", "function_name": "bubble_sort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_40acf87cc45e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)   { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_of_list_precond (lst @) \nensures max_of_list_postcond (lst @ , result) \ndecreases lst . len () - i \ninvariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_39/verina_advanced_39_iter_2_current.rs", "verified": true, "metadata": {"original_id": "40acf87cc45e", "function_name": "max_of_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ac7d8f2e369b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize)   { return 0 ; }\n\n} // verus!", "target_text": "requires b . len () <= a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ac7d8f2e369b", "function_name": "containsSubString", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_760e39901bff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "760e39901bff", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_23c01853704b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases j\ninvariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "23c01853704b", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1f053d22680c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "1f053d22680c", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d39393f10bf5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "d39393f10bf5", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_80e5ef23e3da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "80e5ef23e3da", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b21e836cb3fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b21e836cb3fe", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d4dbcfd2b9f0", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >)  { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len ()  { out . push (v [i]) ; i = i + 1 ; }  out }\npub fn clone_arg (arg : & Arg) -> (out : Arg)  { clone_vec_u8 (arg) }\n\n} // verus!", "target_text": "ensures out @ == v @, out @ == arg @\ndecreases v . len () - i \ninvariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_arg (arg : & Arg) -> (out : Arg) ensures out @ == arg @ { clone_vec_u8 (arg) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "d4dbcfd2b9f0", "function_name": "clone_arg", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_998dbba568b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/choose_odd_iter_3_current.rs", "verified": true, "metadata": {"original_id": "998dbba568b9", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_quants_2c1605b7ea09", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    {\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n\n{\n\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n\n{\n     // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n\n{\n      // triggers is_even(s[3])\n      // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n\n{\n      // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n\n{\n     // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n\n{\n      // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n\n{\n     // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n\n{\n     // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n\n{\n      // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n\n{\n\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n\n      // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n     // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n\n{\n    let i_witness = choose|i: int| f(i);\n\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n     // i_witness is some integer\n     // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n      // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n\n{\n    // using the exists just works; the trigger is irrelevant\n\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n\n{\n\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n\n{\n    }\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n      // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "target_text": "requires s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]), s.len() == 5,\n        all_evens(s), 5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]), 5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]), 5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]), 5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]), 5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note, 5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger, 5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]), 5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]), 5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]), 5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j], 5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j], 5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i, 5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j], 5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j], 5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j], 5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j], 5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1], exists|i: int| f(i), exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5), x == i + 1 && is_distinct(i, 5), is_even(i), g(i, j), exists|j: int| g(i, j), exists|j: int| g(i, j), forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i]\nensures forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i), is_distinct(i, j) ==> is_distinct(j, i), f(i), forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma, forall|i: int| is_even(i) ==> f(i), forall|i: int| is_even(i) ==> f(i), f(i), f(i), f(i), r < v.len(),\n        k == v[r as int]\ndecreases s.len(), i2 - i1\ninvariant i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j]", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/quants.rs", "verified": true, "metadata": {"original_id": "verus_quants_2c1605b7ea09", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_34ee70fc7788", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_subrange_at (main : Seq < i32 > , sub : Seq < i32 > , i : int) -> bool { sub =~= main . subrange (i , i + sub . len ()) }\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool)   { let mut i = 0 ; while i < sub . len ()  { if main [idx + i] != sub [i] {   return false ; } i += 1 ; }   true }\nfn is_sub_array (main : & Vec < i32 > , sub : & Vec < i32 >) -> (result : bool)  { if sub . len () > main . len () {  return false ; } let mut idx = 0 ; while idx <= main . len () - sub . len ()  {  if sub_array_at_index (main , sub , idx) {  return true ; } idx += 1 ; }  false }\n\n} // verus!", "target_text": "requires 0 <= idx <= (main . len () - sub . len ()) \nensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , result == (exists | k : int | 0 <= k <= (main . len () - sub . len ()) && is_subrange_at (main @ , sub @ , k)) \ndecreases sub . len () - i , main . len () - sub . len () + 1 - idx \ninvariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , 0 <= idx <= main . len () - sub . len () + 1 , sub . len () <= main . len () , forall | k : int | 0 <= k < idx ==> ! is_subrange_at (main @ , sub @ , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_subrange_at (main : Seq < i32 > , sub : Seq < i32 > , i : int) -> bool { sub =~= main . subrange (i , i + sub . len ()) }\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , decreases sub . len () - i , { if main [idx + i] != sub [i] { assert (main @ [idx + i as int] != sub @ [i as int]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @ == false) ; return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx + j] == sub @ [j]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) ; true }\nfn is_sub_array (main : & Vec < i32 > , sub : & Vec < i32 >) -> (result : bool) ensures result == (exists | k : int | 0 <= k <= (main . len () - sub . len ()) && is_subrange_at (main @ , sub @ , k)) , { if sub . len () > main . len () { assert (forall | k : int | 0 <= k <= (main . len () - sub . len ()) ==> ! is_subrange_at (main @ , sub @ , k)) ; return false ; } let mut idx = 0 ; while idx <= main . len () - sub . len () invariant 0 <= idx <= main . len () - sub . len () + 1 , sub . len () <= main . len () , forall | k : int | 0 <= k < idx ==> ! is_subrange_at (main @ , sub @ , k) , decreases main . len () - sub . len () + 1 - idx , { assert (idx <= main . len () - sub . len ()) ; if sub_array_at_index (main , sub , idx) { assert (is_subrange_at (main @ , sub @ , idx as int)) ; return true ; } idx += 1 ; } assert (forall | k : int | 0 <= k <= (main . len () - sub . len ()) ==> ! is_subrange_at (main @ , sub @ , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_576_v2_impl.rs", "verified": true, "metadata": {"original_id": "34ee70fc7788", "function_name": "is_sub_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6b2e222911ac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nspec fn compare_precond (a : int , b : int) -> bool { true }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_55/verina_basic_55_impl.rs", "verified": true, "metadata": {"original_id": "6b2e222911ac", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3b58820cc7d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_43/verina_basic_43_impl.rs", "verified": true, "metadata": {"original_id": "3b58820cc7d3", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4586f8902d83", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "4586f8902d83", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2ca2835ce03b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2ca2835ce03b", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f0ac8f0eb2b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f0ac8f0eb2b3", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3ec4aa8d4a38", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/abs_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3ec4aa8d4a38", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e5495ef6372", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn is_lower_case_exec (c : char) -> (result : bool)  { c >= 'a' && c <= 'z' }\n\n} // verus!", "target_text": "ensures result == is_lower_case (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "0e5495ef6372", "function_name": "is_lower_case_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0ebe982968e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "0ebe982968e8", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6b9009807334", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires set_to_seq_precond (s @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >) requires set_to_seq_precond (s @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_89/verina_basic_89_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6b9009807334", "function_name": "set_to_seq", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_90d3d3af14ce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool)  { let mut idx = 0 ; while idx < str . len ()  { if str [idx] == key { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) \ndecreases str . len () - idx \ninvariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , decreases str . len () - idx , { if str [idx] == key { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_161_impl.rs", "verified": true, "metadata": {"original_id": "90d3d3af14ce", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_26cc4adf82f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize)   { return 0 ; }\n\n} // verus!", "target_text": "requires b . len () <= a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "26cc4adf82f1", "function_name": "containsSubString", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e65c2dc56da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0e65c2dc56da", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_086bd322fe63", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high  { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () \ndecreases high - low \ninvariant 0 <= low <= high <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "086bd322fe63", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_recursion_3249f30c7209", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: spec\nspec fn triangle(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\n// ANCHOR_END: spec\n/*\n// ANCHOR: bogus\nspec fn bogus(i: int) -> int {\n    bogus(i) + 1 // FAILS, error due to nontermination\n}\n// ANCHOR_END: bogus\n\n// ANCHOR: exploit_bogus\nproof fn exploit_bogus()\n\n{\n\n}\n// ANCHOR_END: exploit_bogus\n*/\n\n/*\n// ANCHOR: lacks_fuel\nfn test_triangle_fail() {\n     // succeeds\n     // FAILS\n}\n// ANCHOR_END: lacks_fuel\n*/\n\n// ANCHOR: step_by_step\nfn test_triangle_step_by_step() {\n\n      // succeeds\n}\n// ANCHOR_END: step_by_step\n\n// ANCHOR: fuel\nfn test_triangle_reveal() {\n\n}\n// ANCHOR_END: fuel\n\n// ANCHOR: fuel_by\nfn test_triangle_assert_by() {\n\n    }\n}\n// ANCHOR_END: fuel_by\n\n// ANCHOR: min\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n// ANCHOR_END: min\n\n/*\n// ANCHOR: rec_fail\nfn rec_triangle(n: u32) -> (sum: u32)\n\n{\n    if n == 0 {\n        0\n    } else {\n        n + rec_triangle(n - 1) // FAILS: possible overflow\n    }\n}\n// ANCHOR_END: rec_fail\n*/\n\n// ANCHOR: rec\nfn rec_triangle(n: u32) -> (sum: u32)\n\n    {\n    if n == 0 {\n        0\n    } else {\n        n + rec_triangle(n - 1)\n    }\n}\n// ANCHOR_END: rec\n\n// ANCHOR: mut\nfn mut_triangle(n: u32, sum: &mut u32)\n\n    {\n    if n == 0 {\n        *sum = 0;\n    } else {\n        mut_triangle(n - 1, sum);\n        *sum = *sum + n;\n    }\n}\n// ANCHOR_END: mut\n\n/*\n// ANCHOR: tail_fail\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n\n{\n    if idx < n {\n        let idx = idx + 1;\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n// ANCHOR_END: tail_fail\n*/\n\n// ANCHOR: mono\nproof fn triangle_is_monotonic(i: nat, j: nat)\n\n    {\n    // We prove the statement `i <= j ==> triangle(i) <= triangle(j)`\n    // by induction on `j`.\n\n    if j == 0 {\n        // The base case (`j == 0`) is trivial since it's only\n        // necessary to reason about when `i` and `j` are both 0.\n        // So no proof lines are needed for this case.\n    }\n    else {\n        // In the induction step, we can assume the statement is true\n        // for `j - 1`. In Verus, we can get that fact into scope with\n        // a recursive call substituting `j - 1` for `j`.\n\n        triangle_is_monotonic(i, (j - 1) as nat);\n\n        // Once we know it's true for `j - 1`, the rest of the proof\n        // is trivial.\n    }\n}\n\n// ANCHOR_END: mono\n/*\n// ANCHOR: circular\nproof fn circular_reasoning()\n\n{\n    circular_reasoning(); // FAILS, does not terminate\n}\n// ANCHOR_END: circular\n*/\n\n// ANCHOR: tail\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n\n    {\n    if idx < n {\n        let idx = idx + 1;\n\n        }\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n// ANCHOR_END: tail\n\n// ANCHOR: loop\nfn loop_triangle(n: u32) -> (sum: u32)\n\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n\n    {\n        idx = idx + 1;\n\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop\n\n// ANCHOR: loop_return\nfn loop_triangle_return(n: u32) -> (sum: u32)\n\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n\n    {\n        idx = idx + 1;\n        if sum as u64 + idx as u64 >= 0x1_0000_0000 {\n\n            return 0xffff_ffff;\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop_return\n\n#[verusfmt::skip]\n// ANCHOR: loop_break\nfn loop_triangle_break(n: u32) -> (sum: u32)\n\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n        invariant_except_break\n            idx <= n,\n            sum == triangle(idx as nat),\n\n        {\n        idx = idx + 1;\n        if sum as u64 + idx as u64 >= 0x1_0000_0000 {\n\n            sum = 0xffff_ffff;\n            break;\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop_break\n\n// ANCHOR: for_loop\nfn for_loop_triangle(n: u32) -> (sum: u32)\n\n{\n    let mut sum: u32 = 0;\n\n    for idx in iter: 0..n\n\n    {\n\n        }\n        sum = sum + idx + 1;\n    }\n    sum\n}\n// ANCHOR_END: for_loop\n\n// ANCHOR: ackermann\nspec fn ackermann(m: nat, n: nat) -> nat\n    {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ackermann((m - 1) as nat, 1)\n    } else {\n        ackermann((m - 1) as nat, ackermann(m, (n - 1) as nat))\n    }\n}\n\nproof fn test_ackermann() {\n    reveal_with_fuel(ackermann, 9);\n\n}\n// ANCHOR_END: ackermann\n\n// ANCHOR: even\nspec fn abs(i: int) -> int {\n    if i < 0 {\n        -i\n    } else {\n        i\n    }\n}\n\nspec fn is_even(i: int) -> bool\n    {\n    if i == 0 {\n        true\n    } else if i > 0 {\n        is_odd(i - 1)\n    } else {\n        is_odd(i + 1)\n    }\n}\n\nspec fn is_odd(i: int) -> bool\n    {\n    if i == 0 {\n        false\n    } else if i > 0 {\n        is_even(i - 1)\n    } else {\n        is_even(i + 1)\n    }\n}\n\nproof fn even_odd_mod2(i: int)\n\n    {\n    if i < 0 {\n        even_odd_mod2(i + 1);\n    }\n    if i > 0 {\n        even_odd_mod2(i - 1);\n    }\n}\n\nfn test_even() {\n\n}\n\nfn test_odd() {\n\n}\n// ANCHOR_END: even\n\n#[verusfmt::skip]\nmod M {\nuse verus_builtin::*;\n\nspec fn abs(i: int) -> int {\n    if i < 0 {\n        -i\n    } else {\n        i\n    }\n}\n\n// ANCHOR: even2\nspec fn is_even(i: int) -> bool\n    {\n    if i == 0 {\n        true\n    } else if i > 0 {\n        is_odd(i - 1)\n    } else {\n        is_odd(i + 1)\n    }\n}\n\nspec fn is_odd(i: int) -> bool\n    {\n    !is_even(i)\n}\n\nproof fn even_odd_mod2(i: int)\n\n    {\n    reveal_with_fuel(is_odd, 2);\n    if i < 0 {\n        even_odd_mod2(i + 1);\n    }\n    if i > 0 {\n        even_odd_mod2(i - 1);\n    }\n}\n\nfn test_even() {\n\n}\n\nfn test_odd() {\n\n}\n// ANCHOR_END: even2\n}\n\n// ANCHOR: example_decreases_to\nproof fn example_decreases_to(s: Seq<int>)\n\n{\n\n    // fails: can't decrease to negative number\n    //\n\n    // Comma-separated elements are treated lexicographically:\n\n    // Datatypes decrease-to their fields:\n    let x = Some(8int);\n\n    let y = (true, false);\n\n    // fails: tuples are not treated lexicographically\n    //\n\n    // sequence decreases-to an element of the sequence\n\n    // sequence decreases-to a subrange of the sequence\n\n}\n// ANCHOR_END: example_decreases_to\n\n// ANCHOR: example_proof_in_spec\nspec fn floor_log2(n: u64) -> int\n    {\n    if n <= 1 {\n        0\n    } else {\n\n        floor_log2(n >> 1) + 1\n    }\n}\n// ANCHOR_END: example_proof_in_spec\n\n// ANCHOR: example_proof_using_via\nspec fn floor_log2_via(n: u64) -> int\n    {\n    if n <= 1 {\n        0\n    } else {\n        floor_log2_via(n >> 1) + 1\n    }\n}\n\n#[via_fn]\nproof fn floor_log2_decreases_proof(n: u64) {\n\n}\n// ANCHOR_END: example_proof_using_via\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires triangle(n as nat) < 0x1_0000_0000, triangle(n as nat) < 0x1_0000_0000, idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000, idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000, triangle(n as nat) < 0x1_0000_0000, triangle(n as nat) < 0x1_0000_0000, s.len() == 5\nensures false, sum == triangle(n as nat), sum == triangle(n as nat), *sum == triangle(n as nat), *sum == triangle(n as nat), i <= j ==> triangle(i) <= triangle(j), false, *sum == triangle(n as nat), sum == triangle(n as nat), sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000), sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000), sum == triangle(n as nat), is_even(i) <==> i % 2 == 0,\n        is_odd(i) <==> i % 2 == 1, is_even(i) <==> i % 2 == 0,\n        is_odd(i) <==> i % 2 == 1, sum == triangle(n as nat),\n    decreases n, *sum == triangle(n as nat),\n    decreases n, i <= j ==> triangle(i) <= triangle(j),\n    decreases j, *sum == triangle(n as nat),\n    decreases n - idx, sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000),\n        decreases n - idx, is_even(i) <==> i % 2 == 0,\n        is_odd(i) <==> i % 2 == 1,\n    decreases abs(i)\ndecreases n, n, n, j, n - idx, n - idx, n - idx, n - idx, m, n, abs(i), abs(i), abs(i), abs(i), 0int, abs(i), 1int, abs(i), n, n\n    via floor_log2_decreases_proof\ninvariant idx <= n,\n            sum == triangle(idx as nat),\n            triangle(n as nat) < 0x1_0000_0000, idx <= n,\n            sum == triangle(idx as nat), sum == triangle(idx as nat),\n            triangle(n as nat) < 0x1_0000_0000", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: spec\nspec fn triangle(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else {\n        n + triangle((n - 1) as nat)\n    }\n}\n\n// ANCHOR_END: spec\n/*\n// ANCHOR: bogus\nspec fn bogus(i: int) -> int {\n    bogus(i) + 1 // FAILS, error due to nontermination\n}\n// ANCHOR_END: bogus\n\n// ANCHOR: exploit_bogus\nproof fn exploit_bogus()\n    ensures\n        false,\n{\n    assert(bogus(3) == bogus(3) + 1);\n}\n// ANCHOR_END: exploit_bogus\n*/\n\n/*\n// ANCHOR: lacks_fuel\nfn test_triangle_fail() {\n    assert(triangle(0) == 0); // succeeds\n    assert(triangle(10) == 55); // FAILS\n}\n// ANCHOR_END: lacks_fuel\n*/\n\n// ANCHOR: step_by_step\nfn test_triangle_step_by_step() {\n    assert(triangle(0) == 0);\n    assert(triangle(1) == 1);\n    assert(triangle(2) == 3);\n    assert(triangle(3) == 6);\n    assert(triangle(4) == 10);\n    assert(triangle(5) == 15);\n    assert(triangle(6) == 21);\n    assert(triangle(7) == 28);\n    assert(triangle(8) == 36);\n    assert(triangle(9) == 45);\n    assert(triangle(10) == 55);  // succeeds\n}\n// ANCHOR_END: step_by_step\n\n// ANCHOR: fuel\nfn test_triangle_reveal() {\n    proof {\n        reveal_with_fuel(triangle, 11);\n    }\n    assert(triangle(10) == 55);\n}\n// ANCHOR_END: fuel\n\n// ANCHOR: fuel_by\nfn test_triangle_assert_by() {\n    assert(triangle(10) == 55) by {\n        reveal_with_fuel(triangle, 11);\n    }\n}\n// ANCHOR_END: fuel_by\n\n// ANCHOR: min\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n// ANCHOR_END: min\n\n/*\n// ANCHOR: rec_fail\nfn rec_triangle(n: u32) -> (sum: u32)\n    ensures\n        sum == triangle(n as nat),\n{\n    if n == 0 {\n        0\n    } else {\n        n + rec_triangle(n - 1) // FAILS: possible overflow\n    }\n}\n// ANCHOR_END: rec_fail\n*/\n\n// ANCHOR: rec\nfn rec_triangle(n: u32) -> (sum: u32)\n    requires\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        sum == triangle(n as nat),\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else {\n        n + rec_triangle(n - 1)\n    }\n}\n// ANCHOR_END: rec\n\n// ANCHOR: mut\nfn mut_triangle(n: u32, sum: &mut u32)\n    requires\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        *sum == triangle(n as nat),\n    decreases n,\n{\n    if n == 0 {\n        *sum = 0;\n    } else {\n        mut_triangle(n - 1, sum);\n        *sum = *sum + n;\n    }\n}\n// ANCHOR_END: mut\n\n/*\n// ANCHOR: tail_fail\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n    requires\n        idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        *sum == triangle(n as nat),\n{\n    if idx < n {\n        let idx = idx + 1;\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n// ANCHOR_END: tail_fail\n*/\n\n// ANCHOR: mono\nproof fn triangle_is_monotonic(i: nat, j: nat)\n    ensures\n        i <= j ==> triangle(i) <= triangle(j),\n    decreases j,\n{\n    // We prove the statement `i <= j ==> triangle(i) <= triangle(j)`\n    // by induction on `j`.\n\n    if j == 0 {\n        // The base case (`j == 0`) is trivial since it's only\n        // necessary to reason about when `i` and `j` are both 0.\n        // So no proof lines are needed for this case.\n    }\n    else {\n        // In the induction step, we can assume the statement is true\n        // for `j - 1`. In Verus, we can get that fact into scope with\n        // a recursive call substituting `j - 1` for `j`.\n\n        triangle_is_monotonic(i, (j - 1) as nat);\n\n        // Once we know it's true for `j - 1`, the rest of the proof\n        // is trivial.\n    }\n}\n\n// ANCHOR_END: mono\n/*\n// ANCHOR: circular\nproof fn circular_reasoning()\n    ensures\n        false,\n{\n    circular_reasoning(); // FAILS, does not terminate\n}\n// ANCHOR_END: circular\n*/\n\n// ANCHOR: tail\nfn tail_triangle(n: u32, idx: u32, sum: &mut u32)\n    requires\n        idx <= n,\n        *old(sum) == triangle(idx as nat),\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        *sum == triangle(n as nat),\n    decreases n - idx,\n{\n    if idx < n {\n        let idx = idx + 1;\n        assert(*sum + idx < 0x1_0000_0000) by {\n            triangle_is_monotonic(idx as nat, n as nat);\n        }\n        *sum = *sum + idx;\n        tail_triangle(n, idx, sum);\n    }\n}\n// ANCHOR_END: tail\n\n// ANCHOR: loop\nfn loop_triangle(n: u32) -> (sum: u32)\n    requires\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        sum == triangle(n as nat),\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n        invariant\n            idx <= n,\n            sum == triangle(idx as nat),\n            triangle(n as nat) < 0x1_0000_0000,\n        decreases n - idx,\n    {\n        idx = idx + 1;\n        assert(sum + idx < 0x1_0000_0000) by {\n            triangle_is_monotonic(idx as nat, n as nat);\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop\n\n// ANCHOR: loop_return\nfn loop_triangle_return(n: u32) -> (sum: u32)\n    ensures\n        sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000),\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n        invariant\n            idx <= n,\n            sum == triangle(idx as nat),\n        decreases n - idx,\n    {\n        idx = idx + 1;\n        if sum as u64 + idx as u64 >= 0x1_0000_0000 {\n            proof {\n                triangle_is_monotonic(idx as nat, n as nat);\n            }\n            return 0xffff_ffff;\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop_return\n\n#[verusfmt::skip]\n// ANCHOR: loop_break\nfn loop_triangle_break(n: u32) -> (sum: u32)\n    ensures\n        sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000),\n{\n    let mut sum: u32 = 0;\n    let mut idx: u32 = 0;\n    while idx < n\n        invariant_except_break\n            idx <= n,\n            sum == triangle(idx as nat),\n        ensures\n            sum == triangle(n as nat) || (sum == 0xffff_ffff && triangle(n as nat) >= 0x1_0000_0000),\n        decreases n - idx,\n    {\n        idx = idx + 1;\n        if sum as u64 + idx as u64 >= 0x1_0000_0000 {\n            proof {\n                triangle_is_monotonic(idx as nat, n as nat);\n            }\n            sum = 0xffff_ffff;\n            break;\n        }\n        sum = sum + idx;\n    }\n    sum\n}\n// ANCHOR_END: loop_break\n\n// ANCHOR: for_loop\nfn for_loop_triangle(n: u32) -> (sum: u32)\n    requires\n        triangle(n as nat) < 0x1_0000_0000,\n    ensures\n        sum == triangle(n as nat),\n{\n    let mut sum: u32 = 0;\n\n    for idx in iter: 0..n\n        invariant\n            sum == triangle(idx as nat),\n            triangle(n as nat) < 0x1_0000_0000,\n    {\n        assert(sum + idx + 1 < 0x1_0000_0000) by {\n            triangle_is_monotonic((idx + 1) as nat, n as nat);\n        }\n        sum = sum + idx + 1;\n    }\n    sum\n}\n// ANCHOR_END: for_loop\n\n// ANCHOR: ackermann\nspec fn ackermann(m: nat, n: nat) -> nat\n    decreases m, n,\n{\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ackermann((m - 1) as nat, 1)\n    } else {\n        ackermann((m - 1) as nat, ackermann(m, (n - 1) as nat))\n    }\n}\n\nproof fn test_ackermann() {\n    reveal_with_fuel(ackermann, 9);\n    assert(ackermann(2, 3) == 9);\n}\n// ANCHOR_END: ackermann\n\n// ANCHOR: even\nspec fn abs(i: int) -> int {\n    if i < 0 {\n        -i\n    } else {\n        i\n    }\n}\n\nspec fn is_even(i: int) -> bool\n    decreases abs(i),\n{\n    if i == 0 {\n        true\n    } else if i > 0 {\n        is_odd(i - 1)\n    } else {\n        is_odd(i + 1)\n    }\n}\n\nspec fn is_odd(i: int) -> bool\n    decreases abs(i),\n{\n    if i == 0 {\n        false\n    } else if i > 0 {\n        is_even(i - 1)\n    } else {\n        is_even(i + 1)\n    }\n}\n\nproof fn even_odd_mod2(i: int)\n    ensures\n        is_even(i) <==> i % 2 == 0,\n        is_odd(i) <==> i % 2 == 1,\n    decreases abs(i),\n{\n    if i < 0 {\n        even_odd_mod2(i + 1);\n    }\n    if i > 0 {\n        even_odd_mod2(i - 1);\n    }\n}\n\nfn test_even() {\n    proof {\n        reveal_with_fuel(is_even, 11);\n    }\n    assert(is_even(10));\n}\n\nfn test_odd() {\n    proof {\n        reveal_with_fuel(is_odd, 11);\n    }\n    assert(!is_odd(10));\n}\n// ANCHOR_END: even\n\n#[verusfmt::skip]\nmod M {\nuse verus_builtin::*;\n\nspec fn abs(i: int) -> int {\n    if i < 0 {\n        -i\n    } else {\n        i\n    }\n}\n\n// ANCHOR: even2\nspec fn is_even(i: int) -> bool\n    decreases abs(i), 0int,\n{\n    if i == 0 {\n        true\n    } else if i > 0 {\n        is_odd(i - 1)\n    } else {\n        is_odd(i + 1)\n    }\n}\n\nspec fn is_odd(i: int) -> bool\n    decreases abs(i), 1int,\n{\n    !is_even(i)\n}\n\nproof fn even_odd_mod2(i: int)\n    ensures\n        is_even(i) <==> i % 2 == 0,\n        is_odd(i) <==> i % 2 == 1,\n    decreases abs(i),\n{\n    reveal_with_fuel(is_odd, 2);\n    if i < 0 {\n        even_odd_mod2(i + 1);\n    }\n    if i > 0 {\n        even_odd_mod2(i - 1);\n    }\n}\n\nfn test_even() {\n    proof {\n        reveal_with_fuel(is_even, 21);\n    }\n    assert(is_even(10));\n}\n\nfn test_odd() {\n    proof {\n        reveal_with_fuel(is_odd, 22);\n    }\n    assert(!is_odd(10));\n}\n// ANCHOR_END: even2\n}\n\n// ANCHOR: example_decreases_to\nproof fn example_decreases_to(s: Seq<int>)\n    requires s.len() == 5\n{\n    assert(decreases_to!(8int => 4int));\n\n    // fails: can't decrease to negative number\n    // assert(decreases_to!(8 => -2));\n\n    // Comma-separated elements are treated lexicographically:\n    assert(decreases_to!(12int, 8int, 1int => 12int, 4int, 50000int));\n\n    // Datatypes decrease-to their fields:\n    let x = Some(8int);\n    assert(decreases_to!(x => x->0));\n\n    let y = (true, false);\n    assert(decreases_to!(y => y.0));\n\n    // fails: tuples are not treated lexicographically\n    // assert(decreases_to!((20, 9) => (11, 15)));\n\n    // sequence decreases-to an element of the sequence\n    assert(decreases_to!(s => s[2]));\n\n    // sequence decreases-to a subrange of the sequence\n    assert(decreases_to!(s => s.subrange(1, 3)));\n}\n// ANCHOR_END: example_decreases_to\n\n\n// ANCHOR: example_proof_in_spec\nspec fn floor_log2(n: u64) -> int \n    decreases n\n{\n    if n <= 1 { \n        0   \n    } else {\n        proof {\n          assert(n > 1 ==> (n >> 1) < n) by(bit_vector);\n        }\n        floor_log2(n >> 1) + 1 \n    }   \n}\n// ANCHOR_END: example_proof_in_spec\n\n// ANCHOR: example_proof_using_via\nspec fn floor_log2_via(n: u64) -> int \n    decreases n\n    via floor_log2_decreases_proof\n{\n    if n <= 1 { \n        0   \n    } else {\n        floor_log2_via(n >> 1) + 1 \n    }   \n}\n\n#[via_fn]\nproof fn floor_log2_decreases_proof(n: u64) {\n    assert(n > 1 ==> (n >> 1) < n) by(bit_vector);\n}\n// ANCHOR_END: example_proof_using_via\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/recursion.rs", "verified": true, "metadata": {"original_id": "verus_recursion_3249f30c7209", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_79cc494d4616", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_55/verina_basic_55_iter_1_current.rs", "verified": true, "metadata": {"original_id": "79cc494d4616", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6ea439f50aee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6ea439f50aee", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_38203a5d7122", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)  { if n <= 1 { return false ; } let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { if n <= 1 { return false ; } let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "38203a5d7122", "function_name": "is_non_prime", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3a261bf6d204", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; }  result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "3a261bf6d204", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_integers_db93b3447f4e", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n     // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n      // x + y has type int, so the assertion succeeds\n      // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n     // FAILS: add(x, y) has type u8, so addition might overflow\n     // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: test_u8\nfn test_u8(u: u8) {\n    assert(0 <= u < 256);\n}\n// ANCHOR_END: test_u8\n\n// ANCHOR: test_consts\nfn test_consts() {\n    let u: u8 = 1u8;\n    assert({\n        let i: int = 2int;\n        let n: nat = 3nat;\n        0int <= u < i < n < 4int\n    });\n}\n// ANCHOR_END: test_consts\n\n// ANCHOR: test_consts_infer\nfn test_consts_infer() {\n    let u: u8 = 1;\n    assert({\n        let i: int = 2;\n        let n: nat = 3;\n        0 <= u < i < n < 4\n    });\n}\n// ANCHOR_END: test_consts_infer\n\n// ANCHOR: test_consts_large\nfn test_consts_large() {\n    assert({\n        let i: int = 0x10000000000000000000000000000000000000000000000000000000000000000int;\n        let j: int = i + i;\n        j == 2 * i\n    });\n}\n// ANCHOR_END: test_consts_large\n\n// ANCHOR: test_coerce\nfn test_coerce() {\n    let u: u8 = 1;\n    assert({\n        let i: int = u as int;\n        let n: nat = u as nat;\n        u == i && u == n\n    });\n}\n// ANCHOR_END: test_coerce\n\n/*\n// ANCHOR: test_coerce_fail\nfn test_coerce_fail() {\n    let v: u16 = 257;\n    let u: u8 = v as u8;\n    assert(u == v); // FAILS, because u has type u8 and therefore cannot be equal to 257\n}\n// ANCHOR_END: test_coerce_fail\n*/\n\n/*\n// ANCHOR: test_sum\nfn test_sum(x: u8, y: u8) {\n    let sum1: u8 = x + y; // FAILS: possible overflow\n}\n// ANCHOR_END: test_sum\n*/\n\n// ANCHOR: test_sum2\nfn test_sum2(x: u8, y: u8) {\n    assert({\n        let sum2: int = x + y;  // in ghost code, + returns int and does not overflow\n        0 <= sum2 < 511\n    });\n}\n// ANCHOR_END: test_sum2\n\n// ANCHOR: test_sum3\nfn test_sum3(x: u8, y: u8)\n    requires\n        x + y < 256,  // make sure \"let sum1: u8 = x + y\" can't overflow\n{\n    let sum1: u8 = x + y;  // succeeds\n}\n// ANCHOR_END: test_sum3\n\n// ANCHOR: test_sum_mixed\nfn test_sum_mixed(x: u8, y: u16) {\n    assert(x + y >= y);  // x + y has type int, so the assertion succeeds\n    assert(x - y <= x);  // x - y has type int, so the assertion succeeds\n}\n// ANCHOR_END: test_sum_mixed\n\n/*\n// ANCHOR: test_sum_add_sub\nfn test_sum_add_sub(x: u8, y: u8) {\n    assert(add(x, y) >= y); // FAILS: add(x, y) has type u8, so addition might overflow\n    assert(sub(x, y) <= x); // FAILS: sub(x, y) has type u8, so subtraction might underflow\n}\n// ANCHOR_END: test_sum_add_sub\n*/\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/integers.rs", "verified": true, "metadata": {"original_id": "verus_integers_db93b3447f4e", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4e3126effe84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n\n} // verus!", "target_text": "requires p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "4e3126effe84", "function_name": "modmul", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4f29741cb0fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let result = 3 * N ; sum . set (0 , result) ;   }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 , ensures sum [0] == 3 * N , { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "4f29741cb0fd", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e8b5c057c88f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ninvariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_251_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e8b5c057c88f", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d93bb6a5c9b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "d93bb6a5c9b8", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4f53cba43f6d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "4f53cba43f6d", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_379762ca5f16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] % arr2 [k]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "379762ca5f16", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_377c0479642d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)   { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len ()  { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))\ndecreases vals_1 . len () - i\ninvariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "377c0479642d", "function_name": "conditional_average", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_07a415573335", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 \nensures result >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "07a415573335", "function_name": "abs_diff", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a3d479510faf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a3d479510faf", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a35b4681ae80", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32)  { if x >= y { x } else { y } }\n\n} // verus!", "target_text": "ensures r >= x && r >= y , r == x || r == y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a35b4681ae80", "function_name": "Max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_79c8fe2c4736", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_impl.rs", "verified": true, "metadata": {"original_id": "79c8fe2c4736", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_47ed6365d3bd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "47ed6365d3bd", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_ba3b88d6691c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ba3b88d6691c", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_50db734c64eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "target_text": "ensures result @ == digit_to_letters (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "50db734c64eb", "function_name": "digit_to_letters_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_90920f49e7c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int)  {  lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int)   { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires n % 3 == 0, triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, n / 3 * 3 == n, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_impl.rs", "verified": true, "metadata": {"original_id": "90920f49e7c7", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_56ca9be41886", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "56ca9be41886", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c55b8b249333", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "c55b8b249333", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b762cfe467b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b762cfe467b6", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f30ee42b689d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires unique_product_precond (arr)\nensures true", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_product_precond (arr : & Vec < i32 >) -> bool { true }\nfn unique_product (arr : & Vec < i32 >) -> (result : i32) requires unique_product_precond (arr) ensures true { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_20/verina_basic_20.rs", "verified": true, "metadata": {"original_id": "f30ee42b689d", "function_name": "unique_product", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_583c089d4d04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "583c089d4d04", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_41e970df2ec5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "41e970df2ec5", "function_name": "three_distinct", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_18b96f320034", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_canyon_search/verus_code.rs", "verified": true, "metadata": {"original_id": "18b96f320034", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bf5a9b8a0047", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/verified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "bf5a9b8a0047", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0ae5535bf9b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "0ae5535bf9b7", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c7e6da5e5ec9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1 ; let mut i = 2 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i, n + 1 - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "c7e6da5e5ec9", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c5e0e1ff8db1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool)   { let first_len = seq [0] . len () ; for k in 1 .. seq . len ()  { if seq [k] . len () != first_len {  return false ; } }  true }\n\n} // verus!", "target_text": "requires seq . len () > 0 \nensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) \ninvariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "c5e0e1ff8db1", "function_name": "all_sequence_equal_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f0ef3d33a02f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let result = 6 * N ; sum . set (0 , result) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 6 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 6 , ensures sum [0] == 6 * N , { let result = 6 * N ; sum . set (0 , result) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "f0ef3d33a02f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7b04b45e7b4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_array_postcond (xs : Seq < int > , result : Seq < int >) -> bool { result . len () == xs . len () && (forall | i : int | 0 <= i < xs . len () ==> result [i] == xs [i]) }\nspec fn to_array_precond (xs : Seq < int >) -> bool { true }\nfn to_array (xs : Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < xs . len ()  { result . push (xs [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires to_array_precond (xs @) \nensures to_array_postcond (xs @ , result @) \ndecreases xs . len () - i \ninvariant 0 <= i <= xs . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result @ [j] == xs @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_array_postcond (xs : Seq < int > , result : Seq < int >) -> bool { result . len () == xs . len () && (forall | i : int | 0 <= i < xs . len () ==> result [i] == xs [i]) }\nspec fn to_array_precond (xs : Seq < int >) -> bool { true }\nfn to_array (xs : Vec < int >) -> (result : Vec < int >) requires to_array_precond (xs @) , ensures to_array_postcond (xs @ , result @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < xs . len () invariant 0 <= i <= xs . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result @ [j] == xs @ [j] , decreases xs . len () - i , { result . push (xs [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_88/verina_basic_88_impl.rs", "verified": true, "metadata": {"original_id": "7b04b45e7b4b", "function_name": "to_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c5be681dd3cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c5be681dd3cc", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_818220f07c68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/023-strlen_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "818220f07c68", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fd10a5ca04a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s42if_impl.rs", "verified": true, "metadata": {"original_id": "fd10a5ca04a2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d9ae801d5e6c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] != element { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] == element", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "d9ae801d5e6c", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8392135093bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires length_of_lis_precond (nums) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize) requires length_of_lis_precond (nums) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_25/verina_advanced_25_iter_0_original.rs", "verified": true, "metadata": {"original_id": "8392135093bc", "function_name": "length_of_lis", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c6f8ad5e9d11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/havoc_inline_post.rs", "verified": true, "metadata": {"original_id": "c6f8ad5e9d11", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c73ee527dbc3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { for i in 0 .. l . len ()  { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t \ninvariant forall | j : int | 0 <= j < i ==> l [j] < t ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/052-below-threshold_impl.rs", "verified": true, "metadata": {"original_id": "c73ee527dbc3", "function_name": "below_threshold", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3c12a69d39ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3c12a69d39ba", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_47e7ebd516ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len ()  { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; }  max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - k\ninvariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_145_iter_2_current.rs", "verified": true, "metadata": {"original_id": "47e7ebd516ec", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b26a9355f09c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "target_text": "requires start <= chars . len ()\nensures result @ == digit_to_letters (c)\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "b26a9355f09c", "function_name": "go", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2bf9cdde1219", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { let mut result : u32 = 0 ; let mut i : u32 = 0 ; while i < n  { if let Some (new_result) = result . checked_add (i + 1) { result = new_result ; i = i + 1 ; } else { return None ; } } Some (result) }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n , n - i \ninvariant i <= n , result == spec_sum_to_n (i as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { let mut result : u32 = 0 ; let mut i : u32 = 0 ; while i < n invariant i <= n , result == spec_sum_to_n (i as nat) , decreases n - i , { if let Some (new_result) = result . checked_add (i + 1) { result = new_result ; i = i + 1 ; } else { return None ; } } Some (result) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/060-sum_to_n_impl.rs", "verified": true, "metadata": {"original_id": "2bf9cdde1219", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5aff9921717a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i]  { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires longest_common_prefix_precond (str1 @ , str2 @)\nensures longest_common_prefix_postcond (str1 @ , str2 @ , result @)\ndecreases str1 @ . len () - i\ninvariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >) requires longest_common_prefix_precond (str1 @ , str2 @) ensures longest_common_prefix_postcond (str1 @ , str2 @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i] invariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j] decreases str1 @ . len () - i { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_71/verina_basic_71_impl.rs", "verified": true, "metadata": {"original_id": "5aff9921717a", "function_name": "longest_common_prefix", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f0e073f9612b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires length_of_lis_precond (nums) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize) requires length_of_lis_precond (nums) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_25/verina_advanced_25.rs", "verified": true, "metadata": {"original_id": "f0e073f9612b", "function_name": "length_of_lis", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9b30b92ae6cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_update_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9b30b92ae6cc", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_42262fbd4b9c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,)   { }\n\n} // verus!", "target_text": "requires nums . len () == old (used) . len () \nensures used . len () == old (used) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/permutations_iter_0_original.rs", "verified": true, "metadata": {"original_id": "42262fbd4b9c", "function_name": "backtrack", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_oneshot_3f95b9acbbd0", "task": "task_a", "input_text": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//!\n//!\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//!\n//!\n//!\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//!\n//!\n//!\n//!\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an  {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n\n        {\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n\n    let tracked knowledge = half1.duplicate();\n\n}\n\n} // verus!\n", "target_text": "requires self@ is FullRightToComplete, old(self)@ is FullRightToComplete, old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty), self@ is Complete, other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty)\nensures resource@ is FullRightToComplete, (, self@ is Complete, old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(), other.id() == self.id(),\n            other@ is Complete, self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete\ninvariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus!", "full_verified_code": "//! This file implements one-shot permissions using a custom resource\n//! algebra.\n//!\n//! A one-shot allows an operation to be performed exactly once. If\n//! you have two resources each granting half authority to perform it,\n//! you can combine them and perform the one-shot. Performing it\n//! grants duplicable knowledge that it has been performed.\n//!\n//! To create a one-shot, call `OneShotResource::alloc()`. This will\n//! return a resource granting full authority to perform the created\n//! one-shot. You can then call `perform` to perform that one-shot.\n//! Here's an example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! proof { full.perform(); }\n//! assert(full@ is Complete);\n//! ```\n//!\n//! Often, you will first split the full authority into two halves,\n//! each granting half the authority to perform the created one-shot.\n//! This way, you can stash one in an invariant. Both halves will have\n//! the same `id()`, meaning they belong to the same one-shot\n//! instance. For example:\n//!\n//! ```\n//! let tracked full = OneShotResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@ is HalfRightToComplete);\n//! assert(half2@ is HalfRightToComplete);\n//! ```\n//!\n//! To perform a one-shot using two halves, use\n//! `perform_using_two_halves`. This function takes two resources, the\n//! first of which must provide half authority to perform the\n//! one-shot. On return, the passed-in resources will have both been\n//! changed to `Complete`, i.e., knowledge that the one-shot has\n//! complete.\n//!\n//! ```\n//! let ghost id = half1.id();\n//! proof { half1.perform_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id() == id);\n//! assert(half1@ is Complete);\n//! assert(half2@ is Complete);\n//! ```\n//!\n//! Note that only *one* of the two parameters to `perform` has to be\n//! `HalfRightToComplete`. This is useful so you can stash half the\n//! authority in an invariant and call `perform` even if the invariant\n//! predicate allows the stashed permission to change later.\n//!\n//! Knowledge that the one-shot has completed is freely duplicable\n//! because that's the nature of one-shots. If you want to duplicate\n//! it, you can call `duplicate`, but you can only call this if you\n//! know the permission passed in is `Complete`. Here's an example of\n//! its usage:\n//!\n//! ```\n//! let tracked knowledge = half1.duplicate();\n//! assert(knowledge.id() == half1.id());\n//! assert(knowledge@ is Complete);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A one-shot resource represents one of the following four resources:\n//\n// `FullRightToComplete` -- the authority to complete the one-shot;\n//\n// `HalfRightToComplete` -- half of the authority to complete the\n// one-shot, which can be combined with another half to make a full\n// authority; or\n//\n// `Complete` -- knowledge that the one-shot has completed.\n//\n// `Empty` - no permission at all.\npub enum OneShotResourceValue {\n    FullRightToComplete,\n    HalfRightToComplete,\n    Complete,\n    Empty,\n    Invalid,\n}\n\n// To use `OneShotResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for OneShotResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (OneShotResourceValue::Empty, _) => other,\n            (_, OneShotResourceValue::Empty) => self,\n            (\n                OneShotResourceValue::HalfRightToComplete,\n                OneShotResourceValue::HalfRightToComplete,\n            ) => OneShotResourceValue::FullRightToComplete {  },\n            (\n                OneShotResourceValue::Complete,\n                OneShotResourceValue::Complete,\n            ) => OneShotResourceValue::Complete {  },\n            (_, _) => OneShotResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        OneShotResourceValue::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct OneShotResource {\n    r: Resource<OneShotResourceValue>,\n}\n\nimpl OneShotResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> OneShotResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a one-shot and returns a resource\n    // granting the full authority to perform the created\n    // one-shot.\n    pub proof fn alloc() -> (tracked resource: Self)\n        ensures\n            resource@ is FullRightToComplete,\n    {\n        let v = OneShotResourceValue::FullRightToComplete {  };\n        let tracked mut r = Resource::<OneShotResourceValue>::alloc(v);\n        OneShotResource { r }\n    }\n\n    // This function splits full authority to perform a one-shot\n    // into two half authorities to perform it.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToComplete,\n        ensures\n            ({\n                let (half1, half2) = return_value;\n                &&& half1@ is HalfRightToComplete\n                &&& half2@ is HalfRightToComplete\n                &&& half2.id() == half1.id() == self.id()\n            }),\n    {\n        let half = OneShotResourceValue::HalfRightToComplete {  };\n        let tracked (r1, r2) = self.r.split(half, half);\n        (OneShotResource { r: r1 }, OneShotResource { r: r2 })\n    }\n\n    // This function performs a one-shot given a resource representing\n    // full authority to complete the one-shot.\n    //\n    // Upon return, the passed-in resource will have been transformed\n    // into knowledge that the one-shot has been performed.\n    pub proof fn perform(tracked &mut self)\n        requires\n            old(self)@ is FullRightToComplete,\n        ensures\n            self@ is Complete,\n    {\n        let v = OneShotResourceValue::Complete {  };\n        update_mut(&mut self.r, v);\n    }\n\n    // This function performs a one-shot given two resources, the\n    // first of which represents an incomplete one-shot (and half the\n    // authority needed to perform it). The resources must have the\n    // same `id()`, meaning they're talking about the same one-shot.\n    //\n    // Upon return, the passed-in resources will have both been\n    // transformed into knowledge that the one-shot has been\n    // performed.\n    //\n    // The caller of this function only needs to know that `self`\n    // provides half authority and that `other` isn't `Empty`. Upon\n    // return the caller will learn that *both* the resources had\n    // provided half authority at call time. However, those resources\n    // were transformed so they don't provide that authority anymore.\n    pub proof fn perform_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(other).id() == old(self).id(),\n            old(self)@ is HalfRightToComplete,\n            !(old(other)@ is Empty),\n        ensures\n            old(other)@ is HalfRightToComplete,\n            self@ is Complete,\n            other@ is Complete,\n            other.id() == self.id() == old(self).id(),\n    {\n        self.r.validate();\n        other.r.validate();\n        // A `HalfRightToComplete` doesn't combine validly with a\n        // `Complete`, so validating them together proves that\n        // `other.r.value()` is `HalfRightToComplete`.\n        self.r.validate_2(&other.r);\n        assert(other@ is HalfRightToComplete);\n        // Knowing they're both `HalfRightToComplete` allows them to\n        // be combined and transformed into `Complete` resources.\n        let v = OneShotResourceValue::Complete {  };\n        update_and_redistribute(&mut self.r, &mut other.r, v, v);\n    }\n\n    // This function duplicates a one-shot resource representing\n    // knowledge of completion.\n    pub proof fn duplicate(tracked &self) -> (tracked other: Self)\n        requires\n            self@ is Complete,\n        ensures\n            other.id() == self.id(),\n            other@ is Complete,\n    {\n        let tracked r = duplicate(&self.r);\n        Self { r }\n    }\n\n    pub proof fn lemma_is_complete_if_other_is(tracked &mut self, tracked other: &Self)\n        requires\n            other.id() == old(self).id(),\n            other@ is Complete,\n            !(old(self)@ is Empty),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ is Complete,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\n// This example illustrates some uses of the one-shot functions.\nfn main() {\n    let tracked full = OneShotResource::alloc();\n    proof {\n        full.perform();\n    }\n    assert(full@ is Complete);\n    let tracked different_oneshot = OneShotResource::alloc();\n    let tracked (mut half1, mut half2) = different_oneshot.split();\n    let ghost id = half1.id();\n    assert(half1.id() == half2.id());\n    assert(half1@ is HalfRightToComplete);\n    assert(half2@ is HalfRightToComplete);\n    proof {\n        half1.perform_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@ is Complete);\n    assert(half2@ is Complete);\n    let tracked knowledge = half1.duplicate();\n    assert(knowledge.id() == half1.id() == id);\n    assert(knowledge@ is Complete);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/oneshot.rs", "verified": true, "metadata": {"original_id": "verus_oneshot_3f95b9acbbd0", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_afa8ad47d9ce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "afa8ad47d9ce", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a034c452334d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1)  { result . push (first [i]) ; } for i in 0 .. second . len ()  { result . push (second [i]) ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , i <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , i as int)) , { result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "a034c452334d", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_aa6e977e59b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "aa6e977e59b2", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_17a45c21ce64", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "17a45c21ce64", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d25a6e7acc46", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "d25a6e7acc46", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2c18f8f4e000", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)   { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_of_list_precond (lst @) \nensures max_of_list_postcond (lst @ , result) \ndecreases lst . len () - i \ninvariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "2c18f8f4e000", "function_name": "max_of_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c20b16b4f66b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c20b16b4f66b", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4eca4073d78f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_414_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4eca4073d78f", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_861f8b0e0841", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem  { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len ()  { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i , a . len () - i \ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_idx : usize = 0 ; let mut i : usize = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i , { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= last_idx < a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i , { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/last_position_impl.rs", "verified": true, "metadata": {"original_id": "861f8b0e0841", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f216662e71d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1)  {   result . push (first [i]) ; } for i in 0 .. second . len ()  {  result . push (second [i]) ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , i <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { assert (i < first . len () - 1) ; assert (i < first . len ()) ; result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , i as int)) , { assert (i < second . len ()) ; result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "f216662e71d8", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a7c0f30a11be", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a7c0f30a11be", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_632bcb3a872c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "632bcb3a872c", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cbd30f294a58", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_even_list/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cbd30f294a58", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4f2d31fc8adb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "4f2d31fc8adb", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5876a4969db2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5876a4969db2", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d7c20a3f1d1e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_97/verina_basic_97_impl.rs", "verified": true, "metadata": {"original_id": "d7c20a3f1d1e", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fa340bf79212", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "fa340bf79212", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_57e27db4e05a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ninvariant forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "57e27db4e05a", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4da0545c264f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { x * 3 }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4da0545c264f", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c35438a2b9a6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/abs_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c35438a2b9a6", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e83d10ce5078", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/code_from_spec_on_17-07_17h24/task_id_2_impl_impl.rs", "verified": true, "metadata": {"original_id": "e83d10ce5078", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4cfbdb158521", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_even_list/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4cfbdb158521", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
