{"id": "task_a_813646cb02a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if (n % i) == 0 {    return false ; } i = i + 1 ; }   return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if (n % i) == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/code_from_spec_on_17-07_17h24/task_id_605_impl_impl.rs", "verified": true, "metadata": {"original_id": "813646cb02a1", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1e6373b9e813", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s52if_impl.rs", "verified": true, "metadata": {"original_id": "1e6373b9e813", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b58efa7bfbce", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) && ! contains (& result , arr1 [i]) { result . push (arr1 [i]) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if contains (arr2 , arr1 [i]) && ! contains (& result , arr1 [i]) { result . push (arr1 [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "b58efa7bfbce", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_4749b06bd7ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >)   { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "requires a . len () <= 100 \nensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] \ndecreases a . len () - i\ninvariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "4749b06bd7ea", "function_name": "copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_de870870e279", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> text [j] != 90 && text [j] != 122 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> text [j] != 90 && text [j] != 122 , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "de870870e279", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_40f496cd3ee4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_subrange_at (main : Seq < i32 > , sub : Seq < i32 > , i : int) -> (result : bool) { sub =~= main . subrange (i , i + sub . len ()) }\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool)   { let mut i = 0 ; while i < sub . len ()  {  if main [idx + i] != sub [i] { return false ; } i += 1 ; }  true }\nfn is_sub_array (main : & Vec < i32 > , sub : & Vec < i32 >) -> (result : bool)  { if sub . len () == 0 {   return true ; } if sub . len () > main . len () { return false ; } let mut idx = 0 ; while idx <= main . len () - sub . len ()  {  if sub_array_at_index (main , sub , idx) {  return true ; } idx += 1 ; }  false }\n\n} // verus!", "target_text": "requires 0 <= idx <= (main . len () - sub . len ()) \nensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , result == (exists | k : int | 0 <= k <= (main . len () - sub . len ()) && is_subrange_at (main @ , sub @ , k)) \ndecreases sub . len () - i , main . len () - sub . len () + 1 - idx \ninvariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx as int + j] == sub @ [j] , 0 <= idx <= main . len () - sub . len () + 1 , sub . len () <= main . len () , sub . len () > 0 , forall | k : int | 0 <= k < idx ==> ! is_subrange_at (main @ , sub @ , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_subrange_at (main : Seq < i32 > , sub : Seq < i32 > , i : int) -> (result : bool) { sub =~= main . subrange (i , i + sub . len ()) }\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx as int + j] == sub @ [j] , decreases sub . len () - i , { assert (idx + i < main . len ()) ; if main [idx + i] != sub [i] { return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx as int + j] == sub @ [j]) ; true }\nfn is_sub_array (main : & Vec < i32 > , sub : & Vec < i32 >) -> (result : bool) ensures result == (exists | k : int | 0 <= k <= (main . len () - sub . len ()) && is_subrange_at (main @ , sub @ , k)) , { if sub . len () == 0 { assert (is_subrange_at (main @ , sub @ , 0)) ; assert (0 <= 0 <= main . len () - sub . len ()) ; return true ; } if sub . len () > main . len () { return false ; } let mut idx = 0 ; while idx <= main . len () - sub . len () invariant 0 <= idx <= main . len () - sub . len () + 1 , sub . len () <= main . len () , sub . len () > 0 , forall | k : int | 0 <= k < idx ==> ! is_subrange_at (main @ , sub @ , k) , decreases main . len () - sub . len () + 1 - idx , { assert (idx <= main . len () - sub . len ()) ; if sub_array_at_index (main , sub , idx) { assert (is_subrange_at (main @ , sub @ , idx as int)) ; return true ; } idx += 1 ; } assert (forall | k : int | 0 <= k <= main . len () - sub . len () ==> ! is_subrange_at (main @ , sub @ , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_576_v2_impl.rs", "verified": true, "metadata": {"original_id": "40f496cd3ee4", "function_name": "is_sub_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_eae110158f55", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/preconditions_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "eae110158f55", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f13e69fe3cf1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "f13e69fe3cf1", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_66b00e25a27b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "66b00e25a27b", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e5011044af14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "ensures check_find_first_odd (arr , index) \ndecreases arr . len () - i \ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& idx < arr . len () &&& arr [idx as int] % 2 != 0 &&& forall | k : int | 0 <= k < idx ==> arr [k] % 2 == 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < i ==> arr [k] % 2 == 0 , decreases arr . len () - i , { if arr [i] % 2 != 0 { return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "e5011044af14", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verified-node-replication_utils_b235fd8d2aa0", "task": "task_a", "input_text": "// Verified Node Replication Library\n// SPDX-License-Identifier: Apache-2.0 OR MIT\n//\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nuse vstd::prelude::*;\nuse vstd::set::Set;\n\nverus! {\n\npub open spec fn seq_unique<A>(\n    seq: Seq<A>,\n) -> bool\n// where A: PartialEq + Structural\n {\n    forall|i: int, j: int|\n        (0 <= i < seq.len() && 0 <= j < seq.len() && i != j) ==> seq.index(i as int) !== seq.index(\n            j as int,\n        )\n}\n\n/// whether two sequences are disjoint, i.e., they don't have common elements\npub open spec fn seq_disjoint<A>(s: Seq<A>, t: Seq<A>) -> bool {\n    forall|i, j| 0 <= i < s.len() && 0 <= j < t.len() ==> s.index(i) !== t.index(j)\n}\n\n/// recursive definition of seq to set conversion\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    {\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n#[via_fn]\nproof fn seq_to_set_rec_decreases<A>(seq: Seq<A>) {\n    if seq.len() == 0 {\n    } else {\n          // INCOMPLETENESS weird incompleteness again\n    }\n}\n\n/// shows that the recursive definition of set_to_seq produces a finite set\nproof fn seq_to_set_rec_is_finite<A>(seq: Seq<A>)\n\n    {\n    if seq.len() > 0 {\n        let sub_seq = seq.drop_last();\n\n        }\n    }\n}\n\n/// shows that the resulting set contains all elements of the sequence\nproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n\n    {\n    if seq.len() > 0 {\n\n        }\n\n        else {\n\n                }\n            }\n        }\n    }\n}\n\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n\n{\n\n    }\n\n}\n\npub open spec fn seq_to_set<A>(seq: Seq<A>) -> Set<A> {\n    Set::new(|a: A| seq.contains(a))\n}\n\npub proof fn seq_to_set_is_finite<A>(seq: Seq<A>)\n\n{\n\n        seq_to_set_rec_is_finite(seq);\n    }\n}\n\npub open spec fn map_new_rec<V>(dom: nat, val: V) -> Map<nat, V>\n    {\n    if dom == 0 {\n        map![ dom => val]\n    } else {\n        map_new_rec((dom - 1) as nat, val).insert(dom, val)\n    }\n}\n\npub proof fn map_new_rec_dom_finite<V>(dom: nat, val: V)\n\n    {\n    if dom == 0 {\n    } else {\n        let sub_dom = (dom - 1) as nat;\n        let sub_map = map_new_rec(sub_dom as nat, val);\n\n        }\n\n        }\n\n        }\n    }\n}\n\npub open spec fn map_contains_value<K, V>(\n    map: Map<K, V>,\n    val: V,\n) -> bool\n// where K: PartialEq + Structural\n {\n    exists|i: K| #[trigger] map.contains_key(i) && map.index(i) == val\n}\n\npub open spec fn range(low: nat, mid: nat, high: nat) -> bool {\n    low <= mid && mid < high\n}\n\npub open spec fn rangeincl(low: nat, mid: nat, high: nat) -> bool {\n    low <= mid && mid <= high\n}\n\n#[verifier(nonlinear)]\npub proof fn int_mod_less_than_same(i: int, len: int)\n\n{\n}\n\n} // verus!\n", "target_text": "requires 0 <= i < len,\n        len > 0\nensures seq_to_set_rec(seq).finite(), forall|a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a), seq_to_set(seq) == seq_to_set_rec(seq), seq_to_set(seq).finite(), map_new_rec(dom, val).dom().finite(),\n        forall|n: nat| 0 <= n <= dom <==> map_new_rec(dom, val).contains_key(n),\n        forall|n|\n            (#[trigger] map_new_rec(dom, val).contains_key(n)) ==> map_new_rec(dom, val)[n] == val, (i % len) == i, seq_to_set_rec(seq).finite(),\n    decreases seq.len(), forall|a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a),\n    decreases seq.len(), map_new_rec(dom, val).dom().finite(),\n        forall|n: nat| 0 <= n <= dom <==> map_new_rec(dom, val).contains_key(n),\n        forall|n|\n            (#[trigger] map_new_rec(dom, val).contains_key(n)) ==> map_new_rec(dom, val)[n] == val,\n    decreases dom\ndecreases seq.len(),\n    when seq.len() >= 0\n    via seq_to_set_rec_decreases::<A>, seq.len(), seq.len(), dom,\n    when dom >= 0, dom", "full_verified_code": "// Verified Node Replication Library\n// SPDX-License-Identifier: Apache-2.0 OR MIT\n//\n#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\nuse vstd::prelude::*;\nuse vstd::set::Set;\n\nverus! {\n\npub open spec fn seq_unique<A>(\n    seq: Seq<A>,\n) -> bool\n// where A: PartialEq + Structural\n {\n    forall|i: int, j: int|\n        (0 <= i < seq.len() && 0 <= j < seq.len() && i != j) ==> seq.index(i as int) !== seq.index(\n            j as int,\n        )\n}\n\n/// whether two sequences are disjoint, i.e., they don't have common elements\npub open spec fn seq_disjoint<A>(s: Seq<A>, t: Seq<A>) -> bool {\n    forall|i, j| 0 <= i < s.len() && 0 <= j < t.len() ==> s.index(i) !== t.index(j)\n}\n\n/// recursive definition of seq to set conversion\nspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>\n    decreases seq.len(),\n    when seq.len() >= 0\n    via seq_to_set_rec_decreases::<A>\n{\n    if seq.len() == 0 {\n        Set::empty()\n    } else {\n        seq_to_set_rec(seq.drop_last()).insert(seq.last())\n    }\n}\n\n#[via_fn]\nproof fn seq_to_set_rec_decreases<A>(seq: Seq<A>) {\n    if seq.len() == 0 {\n    } else {\n        assert(seq.drop_last().len() < seq.len());  // INCOMPLETENESS weird incompleteness again\n    }\n}\n\n/// shows that the recursive definition of set_to_seq produces a finite set\nproof fn seq_to_set_rec_is_finite<A>(seq: Seq<A>)\n    ensures\n        seq_to_set_rec(seq).finite(),\n    decreases seq.len(),\n{\n    if seq.len() > 0 {\n        let sub_seq = seq.drop_last();\n        assert(seq_to_set_rec(sub_seq).finite()) by {\n            seq_to_set_rec_is_finite(sub_seq);\n        }\n    }\n}\n\n/// shows that the resulting set contains all elements of the sequence\nproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)\n    ensures\n        forall|a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a),\n    decreases seq.len(),\n{\n    if seq.len() > 0 {\n        assert(forall|a| #[trigger]\n            seq.drop_last().contains(a) <==> seq_to_set_rec(seq.drop_last()).contains(a)) by {\n            seq_to_set_rec_contains(seq.drop_last());\n        }\n        assert(seq =~= seq.drop_last().push(seq.last()));\n        assert forall|a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a) by {\n            if !seq.drop_last().contains(a) {\n                if a == seq.last() {\n                    assert(seq.contains(a));\n                    assert(seq_to_set_rec(seq).contains(a));\n                } else {\n                    assert(!seq_to_set_rec(seq).contains(a));\n                }\n            }\n        }\n    }\n}\n\nproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)\n    ensures\n        seq_to_set(seq) == seq_to_set_rec(seq),\n{\n    assert(forall|n| #[trigger] seq.contains(n) <==> seq_to_set_rec(seq).contains(n)) by {\n        seq_to_set_rec_contains(seq);\n    }\n    assert(forall|n| #[trigger] seq.contains(n) <==> seq_to_set(seq).contains(n));\n    assert(seq_to_set(seq) =~= seq_to_set_rec(seq));\n}\n\npub open spec fn seq_to_set<A>(seq: Seq<A>) -> Set<A> {\n    Set::new(|a: A| seq.contains(a))\n}\n\npub proof fn seq_to_set_is_finite<A>(seq: Seq<A>)\n    ensures\n        seq_to_set(seq).finite(),\n{\n    assert(seq_to_set(seq).finite()) by {\n        seq_to_set_equal_rec(seq);\n        seq_to_set_rec_is_finite(seq);\n    }\n}\n\npub open spec fn map_new_rec<V>(dom: nat, val: V) -> Map<nat, V>\n    decreases dom,\n    when dom >= 0\n{\n    if dom == 0 {\n        map![ dom => val]\n    } else {\n        map_new_rec((dom - 1) as nat, val).insert(dom, val)\n    }\n}\n\npub proof fn map_new_rec_dom_finite<V>(dom: nat, val: V)\n    ensures\n        map_new_rec(dom, val).dom().finite(),\n        forall|n: nat| 0 <= n <= dom <==> map_new_rec(dom, val).contains_key(n),\n        forall|n|\n            (#[trigger] map_new_rec(dom, val).contains_key(n)) ==> map_new_rec(dom, val)[n] == val,\n    decreases dom,\n{\n    if dom == 0 {\n    } else {\n        let sub_dom = (dom - 1) as nat;\n        let sub_map = map_new_rec(sub_dom as nat, val);\n        assert(sub_map.dom().finite()) by {\n            map_new_rec_dom_finite(sub_dom, val);\n        }\n        assert(forall|n: nat| (#[trigger] sub_map.contains_key(n)) <==> 0 <= n <= sub_dom) by {\n            map_new_rec_dom_finite(sub_dom, val);\n        }\n        assert(forall|n: nat| (#[trigger] sub_map.contains_key(n)) ==> sub_map[n] == val) by {\n            map_new_rec_dom_finite(sub_dom, val);\n        }\n    }\n}\n\npub open spec fn map_contains_value<K, V>(\n    map: Map<K, V>,\n    val: V,\n) -> bool\n// where K: PartialEq + Structural\n {\n    exists|i: K| #[trigger] map.contains_key(i) && map.index(i) == val\n}\n\npub open spec fn range(low: nat, mid: nat, high: nat) -> bool {\n    low <= mid && mid < high\n}\n\npub open spec fn rangeincl(low: nat, mid: nat, high: nat) -> bool {\n    low <= mid && mid <= high\n}\n\n#[verifier(nonlinear)]\npub proof fn int_mod_less_than_same(i: int, len: int)\n    requires\n        0 <= i < len,\n        len > 0,\n    ensures\n        (i % len) == i,\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-node-replication/verified-node-replication/src/spec/utils.rs", "verified": true, "metadata": {"original_id": "verified-node-replication_utils_b235fd8d2aa0", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_90329c5173ed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_273_impl.rs", "verified": true, "metadata": {"original_id": "90329c5173ed", "function_name": "element_wise_subtract", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_505d8929e73f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 0 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum [0] = 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "505d8929e73f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1c9aefc878f6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "ensures intervals @ . len () == old (intervals) @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1c9aefc878f6", "function_name": "sort_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b7c7995e7ed1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "b7c7995e7ed1", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_478115b3906a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "478115b3906a", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_347dbf3d5269", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_increasing_streak_precond (nums @)\nensures longest_increasing_streak_postcond (nums @ , result as nat)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_streak_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_streak_postcond (nums : Seq < i32 > , result : nat) -> bool { result <= nums . len () && (nums . len () == 0 ==> result == 0) }\nfn longest_increasing_streak (nums : Vec < i32 >) -> (result : usize) requires longest_increasing_streak_precond (nums @) ensures longest_increasing_streak_postcond (nums @ , result as nat) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "347dbf3d5269", "function_name": "longest_increasing_streak", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_292f839cb54c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int)   { 1int } else { 0int } , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ;    let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ;   let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ;   }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)   { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  {  if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; }  count }\n\n} // verus!", "target_text": "requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () \nensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i], 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count \ndecreases s1 . len () , s2 . len () , s3 . len () , s1 . len () - i , arr1 . len () - i\ninvariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "292f839cb54c", "function_name": "count_identical_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b749d780e75e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "b749d780e75e", "function_name": "element_wise_subtract", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9a7b68788753", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { if arr [i] % 2 == 0 { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { if arr [i] % 2 == 0 { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9a7b68788753", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7a9ffd58a947", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { let mut i = 0 ; while i < x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , decreases x . len () - i { if x [i] % 3 == 0 { y . push (x [i]) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "7a9ffd58a947", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1e6ddf5088b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i : usize = 0 ; while i < a . len ()  { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == N \ndecreases a . len () - i\ninvariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/sina1_impl.rs", "verified": true, "metadata": {"original_id": "1e6ddf5088b6", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d9c3a6fa55a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "d9c3a6fa55a0", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8b2f6f0f024a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >)   { let mut result = dest ; let mut i = 0 ; while i < len  { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires src . len () >= s_start + len , dest . len () >= d_start + len \nensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) \ndecreases len - i\ninvariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_impl (src : Vec < i32 > , s_start : usize , dest : Vec < i32 > , d_start : usize , len : usize) -> (r : Vec < i32 >) requires src . len () >= s_start + len , dest . len () >= d_start + len , ensures r . len () == dest . len () , r @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , d_start + len <= dest . len () ==> r @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , r @ . subrange (d_start as int , (d_start + len) as int) == src @ . subrange (s_start as int , (s_start + len) as int) , { let mut result = dest ; let mut i = 0 ; while i < len invariant result . len () == dest . len () , i <= len , s_start + len <= src . len () , d_start + len <= dest . len () , result @ . subrange (0 , d_start as int) == dest @ . subrange (0 , d_start as int) , result @ . subrange ((d_start + len) as int , dest . len () as int) == dest @ . subrange ((d_start + len) as int , dest . len () as int) , result @ . subrange (d_start as int , (d_start + i) as int) == src @ . subrange (s_start as int , (s_start + i) as int) , decreases len - i { result . set (d_start + i , src [s_start + i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_copy_part/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "8b2f6f0f024a", "function_name": "copy_impl", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_844e2378bd71", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_prime_precond (n as nat) , n <= 0xFFFF ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_precond (n : nat) -> bool { n >= 2 }\nfn is_prime (n : u32) -> (result : bool) requires is_prime_precond (n as nat) , n <= 0xFFFF , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_28/verina_basic_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "844e2378bd71", "function_name": "is_prime", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_191bf0a53059", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) \ndecreases text . len () - i\ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "191bf0a53059", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ad62c8ff5efd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)   { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires has_common_element_precond (a @ , b @) \nensures has_common_element_postcond (a @ , b @ , result) \ndecreases a . len () - i, b . len () - j\ninvariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "ad62c8ff5efd", "function_name": "has_common_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cde96910488e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (arr : & Vec < i32 >) -> (ret : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures ret . len () == arr . len () , forall | i : int | 0 <= i < arr . len () ==> ret [i] == arr [i] \ndecreases arr . len () - i\ninvariant i <= arr . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (arr : & Vec < i32 >) -> (ret : Vec < i32 >) ensures ret . len () == arr . len () , forall | i : int | 0 <= i < arr . len () ==> ret [i] == arr [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr [j] , decreases arr . len () - i { result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_copy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cde96910488e", "function_name": "copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_edaffa22605f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32)   { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1\nensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat), result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n\ndecreases n, n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_43/verina_basic_43_iter_1_current.rs", "verified": true, "metadata": {"original_id": "edaffa22605f", "function_name": "sum_of_fourth_power_of_odd_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_a7fd77c8cb35", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a7fd77c8cb35", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c20619b9e882", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)   { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 , max_array_precond (a) \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c20619b9e882", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8cbc230833eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32)   { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8cbc230833eb", "function_name": "triple_if", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_565b6f8306ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)   { let mut i = 0 ; while i < nums . len () - 1  { let mut j = i + 1 ; while j < nums . len ()  { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN \nensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target \ndecreases nums . len () - 1 - i, nums . len () - j\ninvariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_iter_4_current.rs", "verified": true, "metadata": {"original_id": "565b6f8306ad", "function_name": "pairs_sum_to_zero", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4af4d15af143", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code.rs", "verified": true, "metadata": {"original_id": "4af4d15af143", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0e759adffffd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >)  { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len ()  { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "target_text": "ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] \ninvariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >) ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] , { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len () invariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0 { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_cum_sum_iter_4_current.rs", "verified": true, "metadata": {"original_id": "0e759adffffd", "function_name": "cum_sum", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_50a22596a4e9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32)   { let mut i = 0 ; while i != N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "50a22596a4e9", "function_name": "up_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7173535ee445", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 {  return true ; } }  false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } proof { assert (forall | k : int | 0 <= k < arr . len () ==> ! is_even (arr [k])) ; assert (! (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k]))) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "7173535ee445", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_33fe3b1c79f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "33fe3b1c79f2", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_331f92ec0dfb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "331f92ec0dfb", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_7513c9d2b94d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i\ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "7513c9d2b94d", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c5de529f9395", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "ensures result == sum_of_digits (x as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "c5de529f9395", "function_name": "sum_of_digits_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_dec266c13e53", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_iter_3_current.rs", "verified": true, "metadata": {"original_id": "dec266c13e53", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4e3a229ecf7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "4e3a229ecf7b", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_fb494ff22b85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "fb494ff22b85", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_36d83e911467", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_8/verina_basic_8_iter_1_current.rs", "verified": true, "metadata": {"original_id": "36d83e911467", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cc9e6d363369", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)   { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len ()  { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] \ndecreases nums . len () - j\ninvariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] , decreases nums . len () - j { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_array_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cc9e6d363369", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f4d1b5cf461c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool)  { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } idx = idx + 1 ; } result }\n\n} // verus!", "target_text": "ensures result == is_lower_case (c), str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) \ndecreases str1 . len () - idx\ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } idx = idx + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "f4d1b5cf461c", "function_name": "to_uppercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f0d81eee94af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882\nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f0d81eee94af", "function_name": "Triple1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7dc4f9d33fc8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7dc4f9d33fc8", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verified-ironkv_seq_lib_v_d34419b2766e", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::seq_lib::*;\n\nverus! {\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n\n{\n\n}\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}\n\npub proof fn lemma_seq_fold_left_merge_right_assoc<A, B>(s: Seq<A>, init: B, f: spec_fn(A) -> B, g: spec_fn(B, B) -> B)\n\n  {\n  let emp = Seq::<B>::empty();\n  let len: int = s.len() as int;\n  let i = len - 1;\n  let s1 = s.subrange(0, len - 1);\n  let last = s[len - 1];\n  let accf = |b: B, a: A| g(b, f(a));\n\n  let start = s1.fold_left(init, accf);\n  let all = s.fold_left(init, accf);\n\n  if s1.len() == 0 {\n\n    reveal_with_fuel(Seq::fold_left, 2);\n    reveal_with_fuel(Seq::fold_left, 2);\n  } else {\n    reveal_with_fuel(Seq::fold_left, 2);\n    let head = s[0];\n    let tail = s.subrange(1, len);\n    let p = accf(init, s[0]);\n    //\n    //\n    //\n    //\n    //\n    //\n    assert_seqs_equal!(tail.subrange(0, len - 2) == s1.subrange(1, len - 1));\n    //\n    //\n    lemma_seq_fold_left_merge_right_assoc::<A, B>(tail, p, f, g);\n    //\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_right<A>(s: Seq<A>, low: int, f: spec_fn(A) -> int)\n\n{\n  let g = |x: int, y: int| x + y;\n\n  lemma_seq_fold_left_merge_right_assoc::<A, int>(s, low, f, g);\n}\n\npub proof fn lemma_seq_fold_left_append_right<A, B>(s: Seq<A>, prefix: Seq<B>, f: spec_fn(A) -> Seq<B>)\n\n{\n  let g = |x: Seq<B>, y: Seq<B>| x + y;\n\n  lemma_seq_fold_left_merge_right_assoc::<A, Seq<B>>(s, prefix, f, g);\n}\n\npub proof fn lemma_seq_fold_left_append_len_int<A, B>(s: Seq<A>, prefix: Seq<B>, f: spec_fn(A) -> Seq<B>)\n\n  {\n  s.lemma_fold_left_alt(prefix, |sb: Seq<B>, a: A| sb + f(a));\n  s.lemma_fold_left_alt(prefix.len() as int, |i: int, a: A| i + f(a).len() as int);\n  if s.len() != 0 {\n    lemma_seq_fold_left_append_len_int::<A, B>(s.subrange(1, s.len() as int), prefix + f(s[0]), f);\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(prefix + f(s[0]), |sb: Seq<B>, a: A| sb + f(a));\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(prefix.len() as int + f(s[0]).len() as int, |i: int, a: A| i + f(a).len() as int);\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_len_int_positive<A, B>(s: Seq<A>, low: nat, f: spec_fn(A) -> Seq<B>)\n\n  {\n  s.lemma_fold_left_alt(low as int, |acc: int, x: A| acc + f(x).len());\n  if s.len() != 0 {\n    lemma_seq_fold_left_sum_len_int_positive::<A, B>(s.subrange(1, s.len() as int), low + f(s[0]).len(), f);\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(low + f(s[0]).len() as int, |acc: int, x: A| acc + f(x).len());\n  }\n}\n\npub proof fn lemma_seq_fold_left_append_len_int_le<A, B>(s: Seq<A>, i: int, low: int, f: spec_fn(A) -> Seq<B>)\n\n  {\n  lemma_seq_fold_left_sum_len_int_positive::<A, B>(s, low as nat, f);\n  let accfl = |acc: int, x: A| acc + f(x).len();\n  if s.len() == 0 {\n    // done\n  } else if i == s.len() {\n    assert_seqs_equal!(s.subrange(0, i) == s);\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s.subrange(1, s.len() as int), i - 1, low + f(s[0]).len() as int, f);\n  } else if i == s.len() - 1 {\n    let fl = |x| f(x).len() as int;\n\n    lemma_seq_fold_left_sum_right::<A>(s, low, fl);\n  } else {\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s.subrange(0, s.len() - 1), i, low, f);\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s, s.len() - 1, low, f);\n    assert_seqs_equal!(s.subrange(0, s.len() - 1).subrange(0, i) == s.subrange(0, i));\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_le<A>(s: Seq<A>, init: int, high: int, f: spec_fn(A) -> int)\n\n  {\n  if s.len() != 0 {\n    lemma_seq_fold_left_sum_le(s.drop_last(), init, high, f);\n\n  }\n}\n\npub proof fn lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity<A>(s: Seq<A>, pred: spec_fn(A) -> bool)\n\n    {\n    reveal(Seq::filter);\n    if s.len() != 0 {\n        let subseq = s.drop_last();\n        lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(subseq, pred);\n        assert_seqs_equal!(s, subseq.push(s.last()));\n    }\n}\n\npub proof fn lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty<A>(s: Seq<A>, pred: spec_fn(A) -> bool)\n\n    {\n    reveal(Seq::filter);\n    if s.len() != 0 {\n        let subseq = s.drop_last();\n        lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(subseq, pred);\n        assert_seqs_equal!(s, subseq.push(s.last()));\n    }\n}\n\npub proof fn lemma_filter_skip_rejected<A>(s: Seq<A>, pred: spec_fn(A) -> bool, i: int)\n\n    {\n    reveal(Seq::filter);\n    if s.len() == 0 {\n\n    }\n    else if i < s.len() {\n\n        lemma_filter_skip_rejected(s.drop_last(), pred, i);\n    }\n    else {\n\n        lemma_filter_skip_rejected(s.drop_last(), pred, i - 1);\n    }\n}\n\npub proof fn lemma_fold_left_on_equiv_seqs<A, B>(s1: Seq<A>, s2: Seq<A>, eq: spec_fn(A, A) -> bool, init: B, f: spec_fn(B, A) -> B)\n\n    {\n  reveal(Seq::fold_left);\n  if s1.len() != 0 {\n    lemma_fold_left_on_equiv_seqs(s1.drop_last(), s2.drop_last(), eq, init, f);\n  }\n}\n\npub proof fn lemma_fold_left_append_merge<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> Seq<B>)\n\n  {\n  let e = Seq::<B>::empty();\n  let af = |acc: Seq<B>, a: A| acc + f(a);\n  let fl = |s: Seq<A>| s.fold_left(e, af);\n  if s2.len() == 0 {\n\n  } else {\n    lemma_fold_left_append_merge(s1, s2.drop_last(), f);\n\n  }\n}\n\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}\n\n} // verus!\n", "target_text": "requires 0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start, 0 <= i <= j <= k <= s.len(), s.len() > 0,\n    forall |x, y, z|\n      #[trigger] g(g(x, y), z) == g(x, g(y, z)), s.len() > 0, s.len() > 0, 0 <= i <= s.len() as int,\n    0 <= low, forall |i:int| 0 <= i < s.len() ==> f(s[i]) <= high, forall |i: int| 0 <= i && i < s.len() ==> pred(s[i]), forall |i: int| 0 <= i && i < s.len() ==> !pred(s[i]), 0 <= i <= s.len(),\n        forall |j| 0 <= j < i ==> !pred(s[j]), s1.len() == s2.len(),\n      (forall |i: int| 0 <= i < s1.len() ==> eq(s1[i], s2[i])),\n      (forall |b: B, a1: A, a2: A| #[trigger] eq(a1, a2) ==> #[trigger] f(b, a1) == f(b, a2)), s1 != s2,\n    s1.len() == s2.len()\nensures s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize), s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k), g(s.subrange(0, s.len() - 1).fold_left(init, |b: B, a: A| g(b, f(a))), f(s[s.len() - 1]))\n    ==\n    s.fold_left(init, |b: B, a: A| g(b, f(a))), s.subrange(0, s.len() - 1).fold_left(low, |b: int, a: A| b + f(a)) + f(s[s.len() - 1])\n    ==\n    s.fold_left(low, |b: int, a: A| b + f(a)), s.subrange(0, s.len() - 1).fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)) + f(s[s.len() - 1])\n    ==\n    s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)), s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)).len() as int\n    ==\n    s.fold_left(prefix.len() as int, |i: int, a: A| i + f(a).len() as int), s.fold_left(low as int, |acc: int, x: A| acc + f(x).len()) >= 0, s.fold_left(low, |acc: int, x: A| acc + f(x).len()) >= 0,\n    s.subrange(0, i).fold_left(low, |acc: int, x: A| acc + f(x).len()) <=\n    s.fold_left(low, |acc: int, x: A| acc + f(x).len()), s.fold_left(init, |acc: int, x: A| acc + f(x)) <= init + s.len() * high, s.filter(pred) == s, s.filter(pred) =~= Seq::<A>::empty(), s.filter(pred) == s.skip(i).filter(pred), s1.fold_left(init, f) == s2.fold_left(init, f), (s1 + s2).fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      ==\n    s1.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      +\n    s2.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a)), 0 <= i < s1.len(),\n    s1[i] != s2[i], g(s.subrange(0, s.len() - 1).fold_left(init, |b: B, a: A| g(b, f(a))), f(s[s.len() - 1]))\n    ==\n    s.fold_left(init, |b: B, a: A| g(b, f(a)))\n  decreases s.len(), s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)).len() as int\n    ==\n    s.fold_left(prefix.len() as int, |i: int, a: A| i + f(a).len() as int),\n  decreases s.len(), s.fold_left(low as int, |acc: int, x: A| acc + f(x).len()) >= 0,\n  decreases s.len(), s.fold_left(low, |acc: int, x: A| acc + f(x).len()) >= 0,\n    s.subrange(0, i).fold_left(low, |acc: int, x: A| acc + f(x).len()) <=\n    s.fold_left(low, |acc: int, x: A| acc + f(x).len()),\n  decreases (2 * s.len() - i), s.fold_left(init, |acc: int, x: A| acc + f(x)) <= init + s.len() * high,\n  decreases s.len(), s.filter(pred) == s\n    decreases s.len(), s.filter(pred) =~= Seq::<A>::empty()\n    decreases s.len(), s.filter(pred) == s.skip(i).filter(pred)\n    decreases\n        s.len(), s1.fold_left(init, f) == s2.fold_left(init, f)\n    decreases s1.len(), (s1 + s2).fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      ==\n    s1.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      +\n    s2.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n  decreases\n    s1.len() + s2.len()\ndecreases s.len(), s.len(), s.len(), (2 * s.len() - i), s.len(), s.len(), s.len(), s.len(), s1.len(), s1.len() + s2.len()", "full_verified_code": "use vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::seq_lib::*;\n\nverus! {\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n\n\npub proof fn lemma_seq_add_subrange<A>(s: Seq<A>, i: int, j: int, k: int)\n  requires 0 <= i <= j <= k <= s.len(),\n  ensures s.subrange(i, j) + s.subrange(j, k) == s.subrange(i, k),\n{\n    assert_seqs_equal!{s.subrange(i, j) + s.subrange(j, k), s.subrange(i, k)}\n}\n\npub proof fn lemma_seq_fold_left_merge_right_assoc<A, B>(s: Seq<A>, init: B, f: spec_fn(A) -> B, g: spec_fn(B, B) -> B)\n  requires\n    s.len() > 0,\n    forall |x, y, z|\n      #[trigger] g(g(x, y), z) == g(x, g(y, z)),\n  ensures\n    g(s.subrange(0, s.len() - 1).fold_left(init, |b: B, a: A| g(b, f(a))), f(s[s.len() - 1]))\n    ==\n    s.fold_left(init, |b: B, a: A| g(b, f(a)))\n  decreases s.len(),\n{\n  let emp = Seq::<B>::empty();\n  let len: int = s.len() as int;\n  let i = len - 1;\n  let s1 = s.subrange(0, len - 1);\n  let last = s[len - 1];\n  let accf = |b: B, a: A| g(b, f(a));\n\n  let start = s1.fold_left(init, accf);\n  let all = s.fold_left(init, accf);\n\n  if s1.len() == 0 {\n    assert(s.len() == 1);\n    reveal_with_fuel(Seq::fold_left, 2);\n    reveal_with_fuel(Seq::fold_left, 2);\n  } else {\n    reveal_with_fuel(Seq::fold_left, 2);\n    let head = s[0];\n    let tail = s.subrange(1, len);\n    let p = accf(init, s[0]);\n    // assert(tail.len() > 0);\n    // assert(all == tail.fold_left(p, accf));\n    // assert(start == s1.fold_left(init, accf));\n    // assert(s1.len() > 0);\n    // assert(start == s1.subrange(1, s1.len() as int).fold_left(p, accf));\n    // assert(start == s1.subrange(1, len - 1).fold_left(p, accf));\n    assert_seqs_equal!(tail.subrange(0, len - 2) == s1.subrange(1, len - 1));\n    // assert(start == tail.subrange(0, tail.len() - 1).fold_left(p, accf));\n    // assert(all == tail.fold_left(p, accf));\n    lemma_seq_fold_left_merge_right_assoc::<A, B>(tail, p, f, g);\n    // assert(all == g(start, f(last)));\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_right<A>(s: Seq<A>, low: int, f: spec_fn(A) -> int)\n  requires\n    s.len() > 0,\n  ensures\n    s.subrange(0, s.len() - 1).fold_left(low, |b: int, a: A| b + f(a)) + f(s[s.len() - 1])\n    ==\n    s.fold_left(low, |b: int, a: A| b + f(a))\n{\n  let g = |x: int, y: int| x + y;\n  assert((|b: int, a: A| b + f(a)) =~= (|b: int, a: A| g(b, f(a))));\n  lemma_seq_fold_left_merge_right_assoc::<A, int>(s, low, f, g);\n}\n\npub proof fn lemma_seq_fold_left_append_right<A, B>(s: Seq<A>, prefix: Seq<B>, f: spec_fn(A) -> Seq<B>)\n  requires s.len() > 0,\n  ensures\n    s.subrange(0, s.len() - 1).fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)) + f(s[s.len() - 1])\n    ==\n    s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a))\n{\n  let g = |x: Seq<B>, y: Seq<B>| x + y;\n  assert forall |x, y, z| #[trigger] g(g(x, y), z) == g(x, g(y, z)) by {\n    assert_seqs_equal!(g(g(x, y), z) == g(x, g(y, z)));\n  };\n  assert((|b: Seq<B>, a: A| b + f(a)) =~= (|b: Seq<B>, a: A| g(b, f(a))));\n  lemma_seq_fold_left_merge_right_assoc::<A, Seq<B>>(s, prefix, f, g);\n}\n\npub proof fn lemma_seq_fold_left_append_len_int<A, B>(s: Seq<A>, prefix: Seq<B>, f: spec_fn(A) -> Seq<B>)\n  ensures\n    s.fold_left(prefix, |sb: Seq<B>, a: A| sb + f(a)).len() as int\n    ==\n    s.fold_left(prefix.len() as int, |i: int, a: A| i + f(a).len() as int),\n  decreases s.len(),\n{\n  s.lemma_fold_left_alt(prefix, |sb: Seq<B>, a: A| sb + f(a));\n  s.lemma_fold_left_alt(prefix.len() as int, |i: int, a: A| i + f(a).len() as int);\n  if s.len() != 0 {\n    lemma_seq_fold_left_append_len_int::<A, B>(s.subrange(1, s.len() as int), prefix + f(s[0]), f);\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(prefix + f(s[0]), |sb: Seq<B>, a: A| sb + f(a));\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(prefix.len() as int + f(s[0]).len() as int, |i: int, a: A| i + f(a).len() as int);\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_len_int_positive<A, B>(s: Seq<A>, low: nat, f: spec_fn(A) -> Seq<B>)\n  ensures\n    s.fold_left(low as int, |acc: int, x: A| acc + f(x).len()) >= 0,\n  decreases s.len(),\n{\n  s.lemma_fold_left_alt(low as int, |acc: int, x: A| acc + f(x).len());\n  if s.len() != 0 {\n    lemma_seq_fold_left_sum_len_int_positive::<A, B>(s.subrange(1, s.len() as int), low + f(s[0]).len(), f);\n    s.subrange(1, s.len() as int).lemma_fold_left_alt(low + f(s[0]).len() as int, |acc: int, x: A| acc + f(x).len());\n  }\n}\n\npub proof fn lemma_seq_fold_left_append_len_int_le<A, B>(s: Seq<A>, i: int, low: int, f: spec_fn(A) -> Seq<B>)\n  requires\n    0 <= i <= s.len() as int,\n    0 <= low,\n  ensures\n    s.fold_left(low, |acc: int, x: A| acc + f(x).len()) >= 0,\n    s.subrange(0, i).fold_left(low, |acc: int, x: A| acc + f(x).len()) <=\n    s.fold_left(low, |acc: int, x: A| acc + f(x).len()),\n  decreases (2 * s.len() - i),\n{\n  lemma_seq_fold_left_sum_len_int_positive::<A, B>(s, low as nat, f);\n  let accfl = |acc: int, x: A| acc + f(x).len();\n  if s.len() == 0 {\n    // done\n  } else if i == s.len() {\n    assert_seqs_equal!(s.subrange(0, i) == s);\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s.subrange(1, s.len() as int), i - 1, low + f(s[0]).len() as int, f);\n  } else if i == s.len() - 1 {\n    let fl = |x| f(x).len() as int;\n    assert(accfl =~= (|acc: int, x: A| acc + fl(x)));\n    lemma_seq_fold_left_sum_right::<A>(s, low, fl);\n  } else {\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s.subrange(0, s.len() - 1), i, low, f);\n    lemma_seq_fold_left_append_len_int_le::<A, B>(s, s.len() - 1, low, f);\n    assert_seqs_equal!(s.subrange(0, s.len() - 1).subrange(0, i) == s.subrange(0, i));\n  }\n}\n\npub proof fn lemma_seq_fold_left_sum_le<A>(s: Seq<A>, init: int, high: int, f: spec_fn(A) -> int)\n  requires\n    forall |i:int| 0 <= i < s.len() ==> f(s[i]) <= high,\n  ensures\n    s.fold_left(init, |acc: int, x: A| acc + f(x)) <= init + s.len() * high,\n  decreases s.len(),\n{\n  if s.len() != 0 {\n    lemma_seq_fold_left_sum_le(s.drop_last(), init, high, f);\n    assert(init + (s.len() - 1) * high + high <= init + s.len() * high) by (nonlinear_arith);\n  }\n}\n\npub proof fn lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity<A>(s: Seq<A>, pred: spec_fn(A) -> bool)\n    requires forall |i: int| 0 <= i && i < s.len() ==> pred(s[i])\n    ensures  s.filter(pred) == s\n    decreases s.len()\n{\n    reveal(Seq::filter);\n    if s.len() != 0 {\n        let subseq = s.drop_last();\n        lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(subseq, pred);\n        assert_seqs_equal!(s, subseq.push(s.last()));\n    }\n}\n\npub proof fn lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty<A>(s: Seq<A>, pred: spec_fn(A) -> bool)\n    requires forall |i: int| 0 <= i && i < s.len() ==> !pred(s[i])\n    ensures  s.filter(pred) =~= Seq::<A>::empty()\n    decreases s.len()\n{\n    reveal(Seq::filter);\n    if s.len() != 0 {\n        let subseq = s.drop_last();\n        lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(subseq, pred);\n        assert_seqs_equal!(s, subseq.push(s.last()));\n    }\n}\n\npub proof fn lemma_filter_skip_rejected<A>(s: Seq<A>, pred: spec_fn(A) -> bool, i: int)\n    requires\n        0 <= i <= s.len(),\n        forall |j| 0 <= j < i ==> !pred(s[j]),\n    ensures\n        s.filter(pred) == s.skip(i).filter(pred)\n    decreases\n        s.len()\n{\n    reveal(Seq::filter);\n    if s.len() == 0 {\n        assert(s.skip(i) =~= s);\n    }\n    else if i < s.len() {\n        assert(s.skip(i).drop_last() =~= s.drop_last().skip(i));\n        lemma_filter_skip_rejected(s.drop_last(), pred, i);\n    }\n    else {\n        assert(s.skip(i) =~= s.drop_last().skip(i - 1));\n        lemma_filter_skip_rejected(s.drop_last(), pred, i - 1);\n    }\n}\n\npub proof fn lemma_fold_left_on_equiv_seqs<A, B>(s1: Seq<A>, s2: Seq<A>, eq: spec_fn(A, A) -> bool, init: B, f: spec_fn(B, A) -> B)\n    requires\n      s1.len() == s2.len(),\n      (forall |i: int| 0 <= i < s1.len() ==> eq(s1[i], s2[i])),\n      (forall |b: B, a1: A, a2: A| #[trigger] eq(a1, a2) ==> #[trigger] f(b, a1) == f(b, a2)),\n    ensures\n      s1.fold_left(init, f) == s2.fold_left(init, f)\n    decreases s1.len(),\n{\n  reveal(Seq::fold_left);\n  if s1.len() != 0 {\n    lemma_fold_left_on_equiv_seqs(s1.drop_last(), s2.drop_last(), eq, init, f);\n  }\n}\n\npub proof fn lemma_fold_left_append_merge<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> Seq<B>)\n  ensures\n    (s1 + s2).fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      ==\n    s1.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n      +\n    s2.fold_left(Seq::empty(), |acc: Seq<B>, a: A| acc + f(a))\n  decreases\n    s1.len() + s2.len()\n{\n  let e = Seq::<B>::empty();\n  let af = |acc: Seq<B>, a: A| acc + f(a);\n  let fl = |s: Seq<A>| s.fold_left(e, af);\n  if s2.len() == 0 {\n    assert(s1 + s2 =~= s1);\n    assert(fl(s1) =~= fl(s1) + e);\n  } else {\n    lemma_fold_left_append_merge(s1, s2.drop_last(), f);\n    assert((s1 + s2).drop_last() =~= s1 + s2.drop_last());\n    assert((fl(s1) + fl(s2.drop_last())) + f(s2.last()) =~= fl(s1) + (fl(s2.drop_last()) + f(s2.last())));\n  }\n}\n\npub proof fn some_differing_index_for_unequal_seqs<A>(s1: Seq<A>, s2: Seq<A>) -> (i: int)\n  requires\n    s1 != s2,\n    s1.len() == s2.len(),\n  ensures\n    0 <= i < s1.len(),\n    s1[i] != s2[i],\n{\n  if forall |i| 0 <= i < s1.len() ==> s1[i] == s2[i] {\n    assert(s1 =~= s2);\n  }\n  choose |i:int| 0 <= i < s1.len() && s1[i] != s2[i]\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-ironkv/ironsht/src/verus_extra/seq_lib_v.rs", "verified": true, "metadata": {"original_id": "verified-ironkv_seq_lib_v_d34419b2766e", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0343db65884e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "0343db65884e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cc6cbb1c578e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "cc6cbb1c578e", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_20232715b1c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "20232715b1c3", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e826955ded98", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool)   { let mut i = 0 ; while i < sub . len ()  { if main [idx + i] != sub [i] {   return false ; } i += 1 ; }   true }\n\n} // verus!", "target_text": "requires 0 <= idx <= (main . len () - sub . len ()) \nensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) \ndecreases sub . len () - i \ninvariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main () { }\nfn sub_array_at_index (main : & Vec < i32 > , sub : & Vec < i32 > , idx : usize) -> (result : bool) requires 0 <= idx <= (main . len () - sub . len ()) , ensures result == (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) , { let mut i = 0 ; while i < sub . len () invariant 0 <= i <= sub . len () , idx + sub . len () <= main . len () , forall | j : int | 0 <= j < i ==> main @ [idx + j] == sub @ [j] , decreases sub . len () - i , { if main [idx + i] != sub [i] { assert (main @ [idx + i as int] != sub @ [i as int]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @ == false) ; return false ; } i += 1 ; } assert (forall | j : int | 0 <= j < sub . len () ==> main @ [idx + j] == sub @ [j]) ; assert (main @ . subrange (idx as int , (idx + sub @ . len ())) =~= sub @) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_576_v2_impl.rs", "verified": true, "metadata": {"original_id": "e826955ded98", "function_name": "sub_array_at_index", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f0c7978ce6d2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , N <= MAX / 2 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 2 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/conda_impl.rs", "verified": true, "metadata": {"original_id": "f0c7978ce6d2", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f79524a8b984", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "f79524a8b984", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7b5a4ce6916f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires smallest_missing_precond (l @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize) requires smallest_missing_precond (l @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_73/verina_advanced_73.rs", "verified": true, "metadata": {"original_id": "7b5a4ce6916f", "function_name": "smallest_missing", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7a07e78bbb25", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)   {       }\nfn decode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let decoded = decode_char (s [i]) ; result . push (decoded) ;  i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 , 65 <= c <= 90 , forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 \nensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , r == decode_char_spec (c as int) , 65 <= r <= 90 , s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] \ndecreases s . len () - i \ninvariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "7a07e78bbb25", "function_name": "decode_shift", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cf16f3478de7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {      let product = arr1 [i] * arr2 [i] ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) \ndecreases arr1 . len () - i \ninvariant 0 <= i <= arr1 . len () , result . len () == i , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < i ==> result [j as int] == arr1 [j] * arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_multiplication (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] * arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] * arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , result . len () == i , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < i ==> result [j as int] == arr1 [j] * arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] * arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert ((i as int) < arr1 . len ()) ; assert ((i as int) < arr2 . len ()) ; assert (MIN <= arr1 [i as int] * arr2 [i as int] <= MAX) ; let product = arr1 [i] * arr2 [i] ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_445_impl.rs", "verified": true, "metadata": {"original_id": "cf16f3478de7", "function_name": "element_wise_multiplication", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a9338b565e15", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32)   { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len ()  { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "target_text": "requires v . len () > 0 \nensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] \ndecreases v . len () - idx\ninvariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset/verus_code_iter_4_current.rs", "verified": true, "metadata": {"original_id": "a9338b565e15", "function_name": "min_of_vec", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_132c2652b22c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; }  index += 1 ; }  lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nfn to_lowercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < char > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 'A' && str1 [index] <= 'Z') { lower_case . push (((str1 [index] as u8) + 32) as char) ; } else { lower_case . push (str1 [index]) ; } assert (lower_case [index as int] == (if is_upper_case (str1 [index as int]) { shift32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] })) ; lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_477_iter_2_current.rs", "verified": true, "metadata": {"original_id": "132c2652b22c", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7551c5191921", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7551c5191921", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ffe96f793371", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s4lif_impl.rs", "verified": true, "metadata": {"original_id": "ffe96f793371", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4eb753211bbd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "ensures intervals @ . len () == old (intervals) @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4eb753211bbd", "function_name": "sort_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5114314b0258", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | p : int , q : int | 0 <= p < q < c . len () ==> c [p] != c [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | p : int , q : int | 0 <= p < q < c . len () ==> c [p] != c [q] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "5114314b0258", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0ee14ac92912", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "target_text": "requires p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0ee14ac92912", "function_name": "modmul", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_rfmig_script_5cc96d9896a6", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n\n    {\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n\n}\n\n//- fn cmain(account: Account)\n//-      {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n\n{\n\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n\n        //+ ;\n        increment(counter, Tracked(&mut perm));\n\n    }\n\n}\n\n// F1\n\n} // verus!\n", "target_text": "requires i <= j, fibo_fits_u64(n as nat), old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX, old(v1)@.len() == 2,\n        old(v2)@.len() == 3, y != 0, counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100, counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit\nensures ret == a || ret == b,\n        ret >= a && ret >= b, fibo(i) <= fibo(j), result == fibo(n as nat), dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount, v1@.len() == v2@.len(), divide(x, y) <= x, ret == x % 8, s1.s == s2.s, perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64), fibo(i) <= fibo(j),\n    decreases j - i\ndecreases n, j - i\ninvariant 0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat)", "full_verified_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n// #![allow(unused_imports, unused_macros, non_camel_case_types)] #![feature(fmt_internals)]\nuse vstd::prelude::verus;\n\nfn main() {}\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    //-   if a >= b { b } else { a }\n    /*+*/\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\n// ## B -- B-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## C -- C-linearity.rs\npub struct Account {\n    pub balance: u64,\n}\n\npub fn transfer(orig: &mut Account, dest: &mut Account, amount: u64)\n    requires\n        old(orig).balance >= amount,\n        old(dest).balance + amount < u64::MAX,\n    ensures\n        dest.balance == old(dest).balance + amount,\n        orig.balance == old(orig).balance - amount,\n{\n    /*+*/\n    let accounts_pre: Ghost<(Account, Account)> = Ghost((*orig, *dest));\n    orig.balance = orig.balance - amount;\n    dest.balance = dest.balance + amount;\n    /*+*/\n    assert(orig.balance + dest.balance == accounts_pre@.0.balance + accounts_pre@.1.balance);\n}\n\n//- fn cmain(account: Account)\n//-     requires account.balance >= 100\n//- {\n//-     let mut account = account;\n//-     transfer(&mut account, &mut account, 100);\n//- }\n// ## C2(e) -- C2-linearity.rs\nuse vstd::prelude::*;\n\n//-  exec fn f(v: Vec<u64>) -> (Vec<u64>, Vec<u64>) {\n//-      let v1 = v;\n//-      let v2 = v;\n//-      (v1, v2)\n//-  }\n/*+*/\n\nexec fn f(v: Vec<u64>) {\n    /*+*/\n    let v1: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    let v2: Ghost<Vec<u64>> = Ghost(v);\n    /*+*/\n    assert(v1@.len() == v2@.len());\n    /*+*/\n}\n\nexec fn g(v1: &mut Vec<u64>, v2: &mut Vec<u64>)\n    requires\n        old(v1)@.len() == 2,\n        old(v2)@.len() == 3,\n    ensures\n        v1@.len() == v2@.len(),\n{\n    v1.push(42);\n    v1.push(43);\n    v2.push(52);\n}\n\n// ## D -- D-recommends.rs\nspec fn divide(x: nat, y: nat) -> nat\n    recommends\n        y != 0,\n{\n    x / y\n}\n\n// E -- E-solvers.rs\nproof fn div_is_smaller(x: nat, y: nat)/*+*/\n\n    by (nonlinear_arith)\n    requires\n        y != 0,\n    ensures\n        divide(x, y) <= x,\n{\n}\n\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n// F0 -- F-linear-ghost\nstruct State1 {\n    s: nat,\n}\n\nstruct State2 {\n    s: nat,\n}\n\n#[verifier::external_body]\nproof fn exchange(tracked s1: State1) -> (tracked s2: State2)\n    ensures\n        s1.s == s2.s,\n{\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise1(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\n#[verifier::external_body]\nproof fn exercise2(tracked s1: &State1) -> (result: bool) {\n    todo!()\n}\n\nproof fn p(tracked s1: State1) {\n    //+ let tracked s2 = exchange(s1);\n    exercise1(&s1);\n    //+ exercise(&s2);\n}\n\n// F1 -- F-linear-proof\nmod F1 {\n    use vstd::{prelude::*, simple_pptr::*};\n\n    #[verifier::external_body]\n    fn send_pointer(ptr: PPtr<u64>) {\n        todo!()\n    }\n\n    #[verifier::external_body]\n    proof fn transfer_permission(tracked perm: PointsTo<u64>) {\n        todo!()\n    }\n\n    fn increment(counter: PPtr<u64>, Tracked(perm): Tracked<&mut PointsTo<u64>>)\n        requires\n            counter == old(perm).pptr(),\n            old(perm).is_init() && old(perm).value() < 100,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.opt_value() == MemContents::Init((old(perm).value() + 1) as u64),\n    {\n        // pub fn borrow<'a>(&self, perm: &'a Tracked<PointsTo<V>>) -> (v: &'a V)\n        let cur_i: u64 = *counter.borrow(Tracked(&*perm));\n        // pub fn replace(&self, perm: &mut Tracked<PointsTo<V>>, in_v: V) -> (out_v: V)\n        counter.replace(Tracked(perm), cur_i + 1);\n    }\n\n    fn start_thread(counter: PPtr<u64>, Tracked(perm): Tracked<PointsTo<u64>>)\n        requires\n            counter == perm.pptr(),\n            perm.opt_value() === MemContents::Uninit,\n    {\n        send_pointer(counter);\n        let tracked mut perm: PointsTo<u64> = perm;\n        // pub fn put(&self, perm: &mut Tracked<PointsTo<V>>, v: V)\n        counter.put(Tracked(&mut perm), 5);\n        assert(perm.opt_value() === MemContents::Init(5));\n        //+ proof { transfer_permission(perm) };\n        increment(counter, Tracked(&mut perm));\n        assert(perm.opt_value() === MemContents::Init(6));\n    }\n\n}\n\n// F1\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/rfmig_script.rs", "verified": true, "metadata": {"original_id": "verus_rfmig_script_5cc96d9896a6", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e22bfd31b40d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)   { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "e22bfd31b40d", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bd6ced50adfe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "bd6ced50adfe", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ec9643a6ca26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >)  { let n = a . len () ; let mut i = 0 ; while i < n  { let mut min_idx = i ; let mut j = i + 1 ; while j < n  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \ndecreases n - i, n - j\ninvariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let n = a . len () ; let mut i = 0 ; while i < n invariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - i { let mut min_idx = i ; let mut j = i + 1 ; while j < n invariant a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_selectionsort/verus_code_iter_5_current.rs", "verified": true, "metadata": {"original_id": "ec9643a6ca26", "function_name": "selection_sort", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c2f5cc349692", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "requires x > MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x > MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/abs_impl.rs", "verified": true, "metadata": {"original_id": "c2f5cc349692", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_80e3bb58f1bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires run_length_encoder_precond (input @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn run_length_encoder_precond (input : Seq < char >) -> bool { true }\nfn run_length_encoder (input : Vec < char >) -> (result : Vec < char >) requires run_length_encoder_precond (input @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_68/verina_advanced_68.rs", "verified": true, "metadata": {"original_id": "80e3bb58f1bc", "function_name": "run_length_encoder", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_df05bebd4caf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)   { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index\ndecreases arr . len () - index\ninvariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_iter_2_current.rs", "verified": true, "metadata": {"original_id": "df05bebd4caf", "function_name": "find_first_occurrence", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9bdb4f793182", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_odd_at_index_odd_precond (a @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool) requires is_odd_at_index_odd_precond (a @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_44/verina_basic_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9bdb4f793182", "function_name": "is_odd_at_index_odd", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eb76f12c022c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "eb76f12c022c", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9c0664056fa4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1)  { result . push (first [i]) ; } for i in 0 .. second . len ()  { result . push (second [i]) ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "9c0664056fa4", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_61ea2b2cc328", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/mods_impl.rs", "verified": true, "metadata": {"original_id": "61ea2b2cc328", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1faaccb99904", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1faaccb99904", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0e172342657b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0e172342657b", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_86054ae2b654", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "86054ae2b654", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fe61d0d48284", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add_list (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    result . push (arr1 [i] + arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] + arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] + arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] + arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] + arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add_list (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] + arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] + arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] + arr2 [j] , forall | j : int | 0 <= j < arr1 . len () ==> (MIN <= # [trigger] (arr1 [j] + arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] + arr2 [i as int] <= MAX) ; result . push (arr1 [i] + arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_728_impl.rs", "verified": true, "metadata": {"original_id": "fe61d0d48284", "function_name": "add_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_20bf1f4c1fc3", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64)   { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n\n} // verus!", "target_text": "requires 0 < alignment \nensures result == space_needed_for_alignment (addr as int , alignment as int)\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "20bf1f4c1fc3", "function_name": "get_space_needed_for_alignment", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6c69f2a0ee72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6c69f2a0ee72", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_42032eb12d0e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >)  { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len ()\ndecreases a . len () - i\ninvariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_append_iter_2_current.rs", "verified": true, "metadata": {"original_id": "42032eb12d0e", "function_name": "append_with_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_abe392580485", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >)   { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { '0' } else { '1' }) { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1')\nensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i]\ndecreases a . len () - i\ninvariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/string_xor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "abe392580485", "function_name": "xor_strings", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2033daf455eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >)  { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { ch } else { str1 [k] }) , { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32 { ch } else { str1 [k] }) , decreases str1 . len () - index { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "2033daf455eb", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7b894c483b19", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos  { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len ()  { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases pos - i , a . len () - j \ninvariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7b894c483b19", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4d082ffd5263", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4d082ffd5263", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_assert_by_compute_ef8e5465ddbe", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    {\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n      // Assertion 1\n      // Assertion 2\n      // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\n\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n\n{\n\n    let prop = |x| p(x as usize);\n\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "target_text": "requires 25 <= u < 100\nensures p(u)\ndecreases exp, n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/assert_by_compute.rs", "verified": true, "metadata": {"original_id": "verus_assert_by_compute_ef8e5465ddbe", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_9f6e0444618e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let result = (2i64 * N as i64) as i32 ; sum . set (0 , result) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 2 * N , { let result = (2i64 * N as i64) as i32 ; sum . set (0 , result) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res1_impl.rs", "verified": true, "metadata": {"original_id": "9f6e0444618e", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_42571a0eac5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = (3 * N) as i32 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum [0] = (3 * N) as i32 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s22if_impl.rs", "verified": true, "metadata": {"original_id": "42571a0eac5f", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_67e361506093", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "67e361506093", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_af931a99b1cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start_idx <= lst . len () \ndecreases lst . len () - start_idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_73/verina_advanced_73.rs", "verified": true, "metadata": {"original_id": "af931a99b1cc", "function_name": "search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2a8db183c2ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires find_even_numbers_precond (arr @)\nensures result == is_even (n as int), find_even_numbers_postcond (arr @ , result @)\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2a8db183c2ea", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_75c8f0f25afe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code.rs", "verified": true, "metadata": {"original_id": "75c8f0f25afe", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_beb6de963fa7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "beb6de963fa7", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1608f835c367", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1608f835c367", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cc4448042c54", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "cc4448042c54", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_cc57c1da04eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)   { arr [k - 1] }\n\n} // verus!", "target_text": "requires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { arr [k - 1] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_4/verina_basic_4_impl.rs", "verified": true, "metadata": {"original_id": "cc57c1da04eb", "function_name": "kth_element", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3f1bc0b73066", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires isSublist_precond (sub @ , main @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_21/verina_basic_21_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3f1bc0b73066", "function_name": "isSublist", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5d51a32c80a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_binary_digit (c : char) -> (ret : bool) { c == '0' || c == '1' }\nspec fn xor_char (a : char , b : char) -> (result : char) recommends is_binary_digit (a) , is_binary_digit (b) , { if a == b { '0' } else { '1' } }\nfn string_xor (a : & [char] , b : & [char]) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { let xor_result = if a [i] == b [i] { '0' } else { '1' } ; result . push (xor_result) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires a @ . len () == b @ . len () , forall | i : int | 0 <= i < a @ . len () as int ==> is_binary_digit (# [trigger] a [i]) , forall | i : int | 0 <= i < b @ . len () as int ==> is_binary_digit (# [trigger] b [i]) \nensures result . len () == a @ . len () , forall | i : int | 0 <= i < result . len () as int ==> # [trigger] result [i] == xor_char (a [i] , b [i]) \ndecreases a @ . len () - i\ninvariant 0 <= i <= a @ . len () , a @ . len () == b @ . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == xor_char (a [j] , b [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_binary_digit (c : char) -> (ret : bool) { c == '0' || c == '1' }\nspec fn xor_char (a : char , b : char) -> (result : char) recommends is_binary_digit (a) , is_binary_digit (b) , { if a == b { '0' } else { '1' } }\nfn string_xor (a : & [char] , b : & [char]) -> (result : Vec < char >) requires a @ . len () == b @ . len () , forall | i : int | 0 <= i < a @ . len () as int ==> is_binary_digit (# [trigger] a [i]) , forall | i : int | 0 <= i < b @ . len () as int ==> is_binary_digit (# [trigger] b [i]) , ensures result . len () == a @ . len () , forall | i : int | 0 <= i < result . len () as int ==> # [trigger] result [i] == xor_char (a [i] , b [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a @ . len () , a @ . len () == b @ . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == xor_char (a [j] , b [j]) , decreases a @ . len () - i { let xor_result = if a [i] == b [i] { '0' } else { '1' } ; result . push (xor_result) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/011-string_xor_impl.rs", "verified": true, "metadata": {"original_id": "5d51a32c80a1", "function_name": "string_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6a79ac2a5c8a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)   { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 , max_array_precond (a) \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_impl.rs", "verified": true, "metadata": {"original_id": "6a79ac2a5c8a", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_55215c015b40", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == is_even (n), result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "55215c015b40", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ae90a95f7cfc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ae90a95f7cfc", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9f1e1e37d5ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/preconditions_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9f1e1e37d5ee", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fffd0321c22e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "fffd0321c22e", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_de45d8bf2819", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32)   { x + 15 }\n\n} // verus!", "target_text": "requires 10 <= x <= 1000\nensures 25 <= y", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MyMethod (x : i32) -> (y : i32) requires 10 <= x <= 1000 ensures 25 <= y { x + 15 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "de45d8bf2819", "function_name": "MyMethod", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5aa8ca8567d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "5aa8ca8567d8", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_9b562aba017e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires nums . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_single_number (nums : & Vec < i32 >) -> (result : i32) requires nums . len () > 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_1/verina_advanced_1_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9b562aba017e", "function_name": "find_single_number", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_68a400c8bb6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - i\ninvariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "68a400c8bb6f", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_769b50debd28", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs3_impl.rs", "verified": true, "metadata": {"original_id": "769b50debd28", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8c528113aee7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/code_from_spec_on_17-07_17h24/task_id_2_impl_impl.rs", "verified": true, "metadata": {"original_id": "8c528113aee7", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ec15545c7b54", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32)   { 0 }\n\n} // verus!", "target_text": "requires 0 < x < y \nensures z >= 0 && z <= y && z != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ec15545c7b54", "function_name": "m1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_34d5b3a0ba0d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "34d5b3a0ba0d", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_dbfd245c5fae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dbfd245c5fae", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6de671c213a4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_8/verina_basic_8_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6de671c213a4", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_68ef5666482a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {   let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i \ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "68ef5666482a", "function_name": "element_wise_division", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0ff7ec34d139", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant 0 <= i <= v . len () , forall | j : int | 0 <= j < i ==> v [j] % 2 == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , forall | j : int | 0 <= j < i ==> v [j] % 2 == 0 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (forall | j : int | 0 <= j < i ==> v [j] % 2 == 0) ; assert (forall | j : int | 0 <= j < v . len () ==> v [j] % 2 == 0) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "0ff7ec34d139", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_chapter-1-22_fa6ac1200b1d", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n\n    {\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n     {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    {\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    //\n                    //\n                    return TreeSortedness::Unsorted;\n                } else {\n                    //\n                    //\n                    //\n                    left_bound = ll;\n                },\n            }\n            //\n            //\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    //\n                    //\n                    return TreeSortedness::Unsorted;\n                } else {\n                    //\n                    //\n                    //\n                    //\n                    //\n                    right_bound = rr;\n                },\n            }\n\n            //\n            //\n            //\n            //\n            //\n            //\n            //\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //\n            //\n            //\n            //\n            //     } else {\n            //\n            //     }\n            // });\n\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n\n    {\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n\n                } else {\n\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //\n                    //                        } else if idx==left@.len() {\n                    //\n                    //                        } else {\n                    //                              // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //\n                    //  // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //\n                    //\n                    //                          if 0 < right_idx {\n                    //\n                    //                          }\n                    //\n                    //\n                    //                        }\n                    //                    });\n                }\n                //\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n\n                //                    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires tree.is_sorted(), tree.is_sorted()\nensures sequence_is_sorted(tree@), tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret, ret == tree@.contains(needle as int), sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny , ret == tree@.contains(needle as int),\n    decreases tree\ndecreases self, self, tree  // guessed by Dafny , tree, tree", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-1-22.rs", "verified": true, "metadata": {"original_id": "verus_chapter-1-22_fa6ac1200b1d", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_591d328922b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "591d328922b8", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7e4f191e6a5d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize)  { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i]  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int]\ndecreases a . len () - i\ninvariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7e4f191e6a5d", "function_name": "longest_prefix", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4fcf7012d1ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires find_even_numbers_precond (arr @)\nensures result == is_even (n as int), find_even_numbers_postcond (arr @ , result @)\ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4fcf7012d1ec", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_078fe62f544e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (arr : & Vec < i32 >) -> (ret : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures ret . len () == arr . len () , forall | i : int | 0 <= i < arr . len () ==> ret [i] == arr [i] \ndecreases arr . len () - i\ninvariant i <= arr . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (arr : & Vec < i32 >) -> (ret : Vec < i32 >) ensures ret . len () == arr . len () , forall | i : int | 0 <= i < arr . len () ==> ret [i] == arr [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr [j] , decreases arr . len () - i { result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_copy_impl.rs", "verified": true, "metadata": {"original_id": "078fe62f544e", "function_name": "copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b2a90168af14", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 2 * N ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum [0] = 2 * N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s1lif_impl.rs", "verified": true, "metadata": {"original_id": "b2a90168af14", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3f0a9a03306c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if arr [index] != element { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) \ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> arr [i] == element ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> arr [i] == element , decreases arr . len () - index { if arr [index] != element { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_284_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3f0a9a03306c", "function_name": "all_elements_equals", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6ef2c7616a96", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  {   result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant result . len () == idx , idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant result . len () == idx , idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "6ef2c7616a96", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ac6ee2e63302", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32)   { let mut i = N ; while i != 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ac6ee2e63302", "function_name": "down_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cc269de4e045", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_even_list/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "cc269de4e045", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f0354149d7eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { let mut i = 0 ; while i < lst . len () - 1  { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ndecreases lst . len () - 1 - i\ninvariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "f0354149d7eb", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1fad4a296380", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { x . checked_add (y) }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1fad4a296380", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7c0414c57813", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i\ninvariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "7c0414c57813", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_5dacaca36979", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)   {       }\nfn encode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let encoded = encode_char (s [i]) ; result . push (encoded) ;  i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 , 65 <= c <= 90 , forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 \nensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , r == encode_char_spec (c as int) , 65 <= r <= 90 , s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] \ndecreases s . len () - i \ninvariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5dacaca36979", "function_name": "encode_shift", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_be7063317a85", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "be7063317a85", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_verus_agreement_d4fe5ceec4fe", "task": "task_a", "input_text": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//!\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//!\n//!\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//!\n//!\n//!\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n\n    let tracked r2 = r1.duplicate();\n\n}\n\n} // verus!\n", "target_text": "requires old(self).inv(), old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id()\nensures result.inv(),\n            result@ == c, self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@, self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@", "full_verified_code": "//! This file implements agreement on a constant value using a custom\n//! resource algebra.\n//!\n//! An agreement resource constitutes knowledge of a constant value.\n//! To create an instance of a constant value of type `T`, use\n//! `AgreementResource::<T>::alloc()` as in the following example:\n//!\n//! ```\n//! let tracked r1 = AgreementResource::<int>::alloc(72);\n//! assert(r1@ == 72);\n//! ```\n//!\n//! Knowledge of a constant value can be duplicated with `duplicate`,\n//! which creates another agreement resource with the same constant\n//! value and the same ID. Here's an example:\n//!\n//! ```\n//! let tracked r2 = r1.duplicate();\n//! assert(r2.id() == r1.id());\n//! assert(r2@ == r1@);\n//! ```\n//!\n//! Any two agreement resources with the same `id()` are guaranteed to\n//! have equal values. You can establish this by calling\n//! `lemma_agreement`, as in the following example:\n//!\n//! ```\n//! assert(r2.id() == r1.id());\n//! proof { r1.lemma_agreement(&mut r2); }\n//! assert(r2@ == r1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum AgreementResourceValue<T> {\n    Empty,\n    Chosen { c: T },\n    Invalid,\n}\n\nimpl<T> AgreementResourceValue<T> {\n    pub open spec fn new(c: T) -> Self {\n        AgreementResourceValue::<T>::Chosen { c }\n    }\n}\n\nimpl<T> PCM for AgreementResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (AgreementResourceValue::<T>::Empty, _) => other,\n            (_, AgreementResourceValue::<T>::Empty) => self,\n            (AgreementResourceValue::<T>::Invalid, _) => AgreementResourceValue::<T>::Invalid {  },\n            (_, AgreementResourceValue::<T>::Invalid) => AgreementResourceValue::<T>::Invalid {  },\n            (\n                AgreementResourceValue::<T>::Chosen { c: c1 },\n                AgreementResourceValue::<T>::Chosen { c: c2 },\n            ) => if c1 == c2 {\n                self\n            } else {\n                AgreementResourceValue::<T>::Invalid {  }\n            },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        AgreementResourceValue::<T>::Empty {  }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct AgreementResource<T> {\n    r: Resource<AgreementResourceValue<T>>,\n}\n\nimpl<T> AgreementResource<T> {\n    pub closed spec fn inv(self) -> bool {\n        self.r.value() is Chosen\n    }\n\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> T\n        recommends\n            self.inv(),\n    {\n        self.r.value()->c\n    }\n\n    pub proof fn alloc(c: T) -> (tracked result: AgreementResource<T>)\n        ensures\n            result.inv(),\n            result@ == c,\n    {\n        let r_value = AgreementResourceValue::<T>::new(c);\n        let tracked r = Resource::<AgreementResourceValue::<T>>::alloc(r_value);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn duplicate(tracked self: &mut AgreementResource<T>) -> (tracked result:\n        AgreementResource<T>)\n        requires\n            old(self).inv(),\n        ensures\n            self.inv(),\n            result.inv(),\n            self.id() == result.id() == old(self).id(),\n            self@ == result@,\n            self@ == old(self)@,\n    {\n        let tracked r = duplicate(&self.r);\n        AgreementResource::<T> { r }\n    }\n\n    pub proof fn lemma_agreement(\n        tracked self: &mut AgreementResource<T>,\n        tracked other: &AgreementResource<T>,\n    )\n        requires\n            old(self).inv(),\n            other.inv(),\n            old(self).id() == other.id(),\n        ensures\n            self.id() == old(self).id(),\n            self@ == old(self)@,\n            self@ == other@,\n    {\n        self.r.validate_2(&other.r);\n    }\n}\n\npub fn main() {\n    let tracked r1 = AgreementResource::<int>::alloc(72);\n    assert(r1@ == 72);\n    let tracked r2 = r1.duplicate();\n    assert(r2@ == r1@);\n    proof {\n        r1.lemma_agreement(&mut r2);\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/agreement.rs", "verified": true, "metadata": {"original_id": "verus_agreement_d4fe5ceec4fe", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c5f835af6a72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c5f835af6a72", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b11a90b961d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires length_of_lis_precond (nums) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn length_of_lis_precond (nums : Vec < i32 >) -> bool { true }\nfn length_of_lis (nums : Vec < i32 >) -> (result : usize) requires length_of_lis_precond (nums) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_25/verina_advanced_25_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b11a90b961d4", "function_name": "length_of_lis", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6c91566c3811", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = 0 ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum [0] = 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6c91566c3811", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_660f31076864", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)\ndecreases nums . len () - i\ninvariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 && exists | i : int | 0 <= i < nums . len () && nums [i] == result && forall | j : int | 0 <= j < nums . len () ==> nums [j] <= result }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , exists | k : int | 0 <= k < i && nums @ [k] == max_val , forall | j : int | 0 <= j < i ==> nums @ [j] <= max_val decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_43/verina_advanced_43_iter_3_current.rs", "verified": true, "metadata": {"original_id": "660f31076864", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0d2b509c988a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "0d2b509c988a", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_71f559984c48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_0_original.rs", "verified": true, "metadata": {"original_id": "71f559984c48", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_bst_map_generic_a07b70c89126", "task": "task_a", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: trait\npub enum Cmp { Less, Equal, Greater }\n\npub trait TotalOrdered : Sized {\n    spec fn le(self, other: Self) -> bool;\n\n    proof fn reflexive(x: Self)\n         {\n            Cmp::Less => self.le(*other) && self != other,\n            Cmp::Equal => self == other,\n            Cmp::Greater => other.le(*self) && self != other,\n        });\n}\n// ANCHOR_END: trait\n\n// ANCHOR: structs\nstruct Node<K: TotalOrdered, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\npub struct TreeMap<K: TotalOrdered, V> {\n    root: Option<Box<Node<K, V>>>,\n}\n// ANCHOR_END: structs\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<K, V>>>) -> Map<K, V>\n        {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    pub closed spec fn as_map(self) -> Map<K, V>\n        {\n        Node::<K, V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<K, V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub closed spec fn as_map(self) -> Map<K, V> {\n        Node::<K, V>::optional_as_map(self.root)\n    }\n}\n\nimpl<K: TotalOrdered, V> View for TreeMap<K, V> {\n    type V = Map<K, V>;\n\n    open spec fn view(&self) -> Map<K, V> {\n        self.as_map()\n    }\n}\n\n// ANCHOR: well_formed\nimpl<K: TotalOrdered, V> Node<K, V> {\n    pub closed spec fn well_formed(self) -> bool\n        {\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.left).dom().contains(elem) ==> elem.le(self.key) && elem != self.key)\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.right).dom().contains(elem) ==> self.key.le(elem) && elem != self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn new() -> (s: Self)\n\n    {\n        TreeMap::<K, V> { root: None }\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<K, V>>>, key: K, value: V)\n\n        {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<K, V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V)\n\n        {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                self.value = value;\n\n            }\n            Cmp::Less => {\n                Self::insert_into_optional(&mut self.left, key, value);\n\n            }\n            Cmp::Greater => {\n                Self::insert_into_optional(&mut self.right, key, value);\n\n            }\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn insert(&mut self, key: K, value: V)\n\n    {\n\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<K, V>>>, key: K)\n\n        {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            match key.compare(&boxed_node.key) {\n                Cmp::Equal => {\n\n                    if boxed_node.left.is_none() {\n                        *node = boxed_node.right;\n                    } else {\n                        if boxed_node.right.is_none() {\n                            *node = boxed_node.left;\n                        } else {\n                            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.left);\n                            boxed_node.key = popped_key;\n                            boxed_node.value = popped_value;\n                            *node = Some(boxed_node);\n\n                            proof {\n                                }\n                            }\n                        }\n                    }\n                }\n                Cmp::Less => {\n\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.left, key);\n                    *node = Some(boxed_node);\n                }\n                Cmp::Greater => {\n\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.right, key);\n                    *node = Some(boxed_node);\n                }\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<K, V>>>) -> (popped: (K, V))\n\n        {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.right);\n            proof {\n                if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(popped_key) {\n                    TotalOrdered::antisymmetric(boxed_node.key, popped_key);\n\n                }\n                }\n            }\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn delete(&mut self, key: K)\n\n    {\n\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n\n// ANCHOR: node_get\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn get_from_optional(node: &Option<Box<Node<K, V>>>, key: K) -> Option<&V>\n         {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: K) -> Option<&V>\n         { Some(&self.as_map()[key]) } else { None }),\n        {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                Some(&self.value)\n            }\n            Cmp::Less => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.right).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n\n                    }\n\n                }\n                Self::get_from_optional(&self.left, key)\n            }\n            Cmp::Greater => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.left).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n\n                    }\n\n                }\n                Self::get_from_optional(&self.right, key)\n            }\n        }\n    }\n}\n// ANCHOR_END: node_get\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn get(&self, key: K) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n    {\n\n        Node::<K, V>::get_from_optional(&self.root, key)\n    }\n}\n\n// ANCHOR: clone_full_impl\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for Node<K, V> {\n    fn clone(&self) -> (res: Self)\n\n        {\n        let res = Node {\n            key: self.key,\n            value: self.value.clone(),\n            // Ordinarily, we would use Option<Node>::clone rather than inlining\n            // the case statement here; we write it this way to work around\n            // this issue: https://github.com/verus-lang/verus/issues/1346\n            left: (match &self.left {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n            right: (match &self.right {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n        };\n\n        return res;\n    }\n}\n\n// ANCHOR: clone_signature\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for TreeMap<K, V> {\n    fn clone(&self) -> (res: Self)\n\n    {\n\n        TreeMap {\n            // This calls Option<Node<K, V>>::Clone\n            root: self.root.clone(),\n        }\n    }\n}\n// ANCHOR_END: clone_full_impl\n\nimpl TotalOrdered for u64 {\n    open spec fn le(self, other: Self) -> bool { self <= other }\n\n    proof fn reflexive(x: Self) { }\n    proof fn transitive(x: Self, y: Self, z: Self) { }\n    proof fn antisymmetric(x: Self, y: Self) { }\n    proof fn total(x: Self, y: Self) { }\n\n    fn compare(&self, other: &Self) -> (c: Cmp) {\n        if *self == *other {\n            Cmp::Equal\n        } else if *self < *other {\n            Cmp::Less\n        } else {\n            Cmp::Greater\n        }\n    }\n}\n\nfn test() {\n    let mut tree_map = TreeMap::<u64, bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    tree_map.delete(17);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<u64, bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n\n// ANCHOR: clone_u32\nfn test_clone_u32(tree_map: TreeMap<u64, u32>) {\n    let tree_map2 = tree_map.clone();\n\n}\n// ANCHOR_END: clone_u32\n\n// ANCHOR: clone_int_wrapper\nstruct IntWrapper {\n    pub int_value: u32,\n}\n\nimpl Clone for IntWrapper {\n    fn clone(&self) -> (s: Self)\n\n    {\n        IntWrapper { int_value: self.int_value }\n    }\n}\n\nfn test_clone_int_wrapper(tree_map: TreeMap<u64, IntWrapper>) {\n    let tree_map2 = tree_map.clone();\n\n}\n// ANCHOR_END: clone_int_wrapper\n\n// ANCHOR: clone_weird_int\npub struct WeirdInt {\n    pub int_value: u32,\n    pub other: u32,\n}\n\nimpl Clone for WeirdInt {\n    fn clone(&self) -> (s: Self)\n\n    {\n        WeirdInt { int_value: self.int_value, other: 0 }\n    }\n}\n\nfn test_clone_weird_int(tree_map: TreeMap<u64, WeirdInt>) {\n    let tree_map2 = tree_map.clone();\n\n    //  // this would fail\n\n}\n// ANCHOR_END: clone_weird_int\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "requires Self::le(x, y), Self::le(y, z), Self::le(x, y), Self::le(y, x), old(node).is_some() ==> old(node).unwrap().well_formed(), old(self).well_formed(), old(node).is_some() ==> old(node).unwrap().well_formed(), old(node).is_some(),\n            old(node).unwrap().well_formed(), node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node, self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key)\nensures Self::le(x, x);\n\n    proof fn transitive(x: Self, y: Self, z: Self)\n        requires Self::le(x, y), Self::le(y, z),\n        ensures Self::le(x, z);\n\n    proof fn antisymmetric(x: Self, y: Self)\n        requires Self::le(x, y), Self::le(y, x),\n        ensures x == y;\n\n    proof fn total(x: Self, y: Self)\n        ensures Self::le(x, y) || Self::le(y, x);\n\n    fn compare(&self, other: &Self) -> (c: Cmp)\n        ensures (match c, s@ == Map::<K, V>::empty(), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value), self@ == old(self)@.insert(key, value), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0), self@ == old(self)@.remove(key), self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]), self@.dom() =~= res@.dom(),\n            forall |key| #[trigger] res@.dom().contains(key) ==>\n                cloned::<V>(self@[key], res@[key]),\n// ANCHOR_END: clone_signature, s == *self, s.int_value == self.int_value, node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node), self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node), node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0),\n        decreases *old(node), self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]),\n        decreases self\ndecreases node_opt, self, self, *old(node), *old(self), *old(node), *old(node), node, self, self", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: trait\npub enum Cmp { Less, Equal, Greater }\n\npub trait TotalOrdered : Sized {\n    spec fn le(self, other: Self) -> bool;\n\n    proof fn reflexive(x: Self)\n        ensures Self::le(x, x);\n\n    proof fn transitive(x: Self, y: Self, z: Self)\n        requires Self::le(x, y), Self::le(y, z),\n        ensures Self::le(x, z);\n\n    proof fn antisymmetric(x: Self, y: Self)\n        requires Self::le(x, y), Self::le(y, x),\n        ensures x == y;\n\n    proof fn total(x: Self, y: Self)\n        ensures Self::le(x, y) || Self::le(y, x);\n\n    fn compare(&self, other: &Self) -> (c: Cmp)\n        ensures (match c {\n            Cmp::Less => self.le(*other) && self != other,\n            Cmp::Equal => self == other,\n            Cmp::Greater => other.le(*self) && self != other,\n        });\n}\n// ANCHOR_END: trait\n\n// ANCHOR: structs\nstruct Node<K: TotalOrdered, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\npub struct TreeMap<K: TotalOrdered, V> {\n    root: Option<Box<Node<K, V>>>,\n}\n// ANCHOR_END: structs\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<K, V>>>) -> Map<K, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    pub closed spec fn as_map(self) -> Map<K, V>\n        decreases self,\n    {\n        Node::<K, V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<K, V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub closed spec fn as_map(self) -> Map<K, V> {\n        Node::<K, V>::optional_as_map(self.root)\n    }\n}\n\nimpl<K: TotalOrdered, V> View for TreeMap<K, V> {\n    type V = Map<K, V>;\n\n    open spec fn view(&self) -> Map<K, V> {\n        self.as_map()\n    }\n}\n\n// ANCHOR: well_formed\nimpl<K: TotalOrdered, V> Node<K, V> {\n    pub closed spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.left).dom().contains(elem) ==> elem.le(self.key) && elem != self.key)\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.right).dom().contains(elem) ==> self.key.le(elem) && elem != self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<K, V>::empty(),\n    {\n        TreeMap::<K, V> { root: None }\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<K, V>>>, key: K, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<K, V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                self.value = value;\n\n                assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n            }\n            Cmp::Less => {\n                Self::insert_into_optional(&mut self.left, key, value);\n\n                proof {\n                    if self.key.le(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n                }\n            }\n            Cmp::Greater => {\n                Self::insert_into_optional(&mut self.right, key, value);\n\n                proof {\n                    if key.le(self.key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                }\n            }\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn insert(&mut self, key: K, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value)\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<K, V>>>, key: K)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            match key.compare(&boxed_node.key) {\n                Cmp::Equal => {\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key));\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key));\n                    assert(boxed_node.right.is_some() ==> boxed_node.right.unwrap().well_formed());\n                    assert(boxed_node.left.is_some() ==> boxed_node.left.unwrap().well_formed());\n\n                    if boxed_node.left.is_none() {\n                        *node = boxed_node.right;\n                    } else {\n                        if boxed_node.right.is_none() {\n                            *node = boxed_node.left;\n                        } else {\n                            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.left);\n                            boxed_node.key = popped_key;\n                            boxed_node.value = popped_value;\n                            *node = Some(boxed_node);\n\n                            proof {\n                                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(node.unwrap().right).dom().contains(elem) implies node.unwrap().key.le(elem) && elem != node.unwrap().key\n                                by {\n                                    TotalOrdered::transitive(node.unwrap().key, key, elem);\n                                    if elem == node.unwrap().key {\n                                        TotalOrdered::antisymmetric(elem, key);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Cmp::Less => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.left, key);\n                    *node = Some(boxed_node);\n                }\n                Cmp::Greater => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.right, key);\n                    *node = Some(boxed_node);\n                }\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<K, V>>>) -> (popped: (K, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0),\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            proof {\n                assert(Node::<K, V>::optional_as_map(boxed_node.right) =~= Map::empty());\n                assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n                TotalOrdered::reflexive(boxed_node.key);\n            }\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.right);\n            proof {\n                if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(popped_key) {\n                    TotalOrdered::antisymmetric(boxed_node.key, popped_key);\n                    assert(false);\n                }\n                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) implies elem.le(popped_key)\n                by {\n                    if elem.le(boxed_node.key) {\n                        TotalOrdered::transitive(elem, boxed_node.key, popped_key);\n                    }\n                }\n            }\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn delete(&mut self, key: K)\n        ensures\n            self@ == old(self)@.remove(key),\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n\n// ANCHOR: node_get\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn get_from_optional(node: &Option<Box<Node<K, V>>>, key: K) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: K) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                Some(&self.value)\n            }\n            Cmp::Less => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.right).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.left {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.left, key)\n            }\n            Cmp::Greater => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.left).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.right {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.right, key)\n            }\n        }\n    }\n}\n// ANCHOR_END: node_get\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn get(&self, key: K) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<K, V>::get_from_optional(&self.root, key)\n    }\n}\n\n// ANCHOR: clone_full_impl\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for Node<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]),\n        decreases self,\n    {\n        let res = Node {\n            key: self.key,\n            value: self.value.clone(),\n            // Ordinarily, we would use Option<Node>::clone rather than inlining\n            // the case statement here; we write it this way to work around\n            // this issue: https://github.com/verus-lang/verus/issues/1346\n            left: (match &self.left {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n            right: (match &self.right {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n        };\n\n        proof {\n            assert(Node::optional_as_map(res.left).dom() =~= \n                Node::optional_as_map(self.left).dom());\n            assert(Node::optional_as_map(res.right).dom() =~= \n                Node::optional_as_map(self.right).dom());\n        }\n\n        return res;\n    }\n}\n\n// ANCHOR: clone_signature\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for TreeMap<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures self@.dom() =~= res@.dom(),\n            forall |key| #[trigger] res@.dom().contains(key) ==>\n                cloned::<V>(self@[key], res@[key]),\n// ANCHOR_END: clone_signature\n    {\n        proof {\n            use_type_invariant(self);\n        }\n\n        TreeMap {\n            // This calls Option<Node<K, V>>::Clone\n            root: self.root.clone(),\n        }\n    }\n}\n// ANCHOR_END: clone_full_impl\n\nimpl TotalOrdered for u64 {\n    open spec fn le(self, other: Self) -> bool { self <= other }\n\n    proof fn reflexive(x: Self) { }\n    proof fn transitive(x: Self, y: Self, z: Self) { }\n    proof fn antisymmetric(x: Self, y: Self) { }\n    proof fn total(x: Self, y: Self) { }\n\n    fn compare(&self, other: &Self) -> (c: Cmp) {\n        if *self == *other {\n            Cmp::Equal\n        } else if *self < *other {\n            Cmp::Less\n        } else {\n            Cmp::Greater\n        }\n    }\n}\n\nfn test() {\n    let mut tree_map = TreeMap::<u64, bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<u64, bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n\n// ANCHOR: clone_u32\nfn test_clone_u32(tree_map: TreeMap<u64, u32>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_u32\n\n// ANCHOR: clone_int_wrapper\nstruct IntWrapper {\n    pub int_value: u32,\n}\n\nimpl Clone for IntWrapper {\n    fn clone(&self) -> (s: Self)\n        ensures s == *self\n    {\n        IntWrapper { int_value: self.int_value }\n    }\n}\n\nfn test_clone_int_wrapper(tree_map: TreeMap<u64, IntWrapper>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_int_wrapper\n\n// ANCHOR: clone_weird_int\npub struct WeirdInt {\n    pub int_value: u32,\n    pub other: u32,\n}\n\nimpl Clone for WeirdInt {\n    fn clone(&self) -> (s: Self)\n        ensures\n            s.int_value == self.int_value,\n    {\n        WeirdInt { int_value: self.int_value, other: 0 }\n    }\n}\n\nfn test_clone_weird_int(tree_map: TreeMap<u64, WeirdInt>) {\n    let tree_map2 = tree_map.clone();\n\n    // assert(tree_map2@ =~= tree_map@); // this would fail\n\n    assert(tree_map2@.dom() == tree_map@.dom());\n    assert(forall |k| tree_map@.dom().contains(k) ==>\n        tree_map2@[k].int_value == tree_map@[k].int_value);\n}\n// ANCHOR_END: clone_weird_int\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map_generic.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_generic_a07b70c89126", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f3d7341b238d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires concat_precond (a , b) , a . len () + b . len () <= MAX \nensures concat_postcond (a , b , & result) \ndecreases a . len () - i, b . len () - j\ninvariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_83/verina_basic_83_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f3d7341b238d", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2cc966840512", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires replace_with_colon_precond (s @)\nensures result == is_space_comma_dot_spec (c), replace_with_colon_postcond (s @ , result @)\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn replace_with_colon_precond (s : Seq < char >) -> bool { true }\nspec fn replace_with_colon_postcond (s : Seq < char > , result : Seq < char >) -> bool { result . len () == s . len () && forall | i : int | # ! [trigger s . index (i)] # ! [trigger result . index (i)] 0 <= i < s . len () ==> { let old_char = s . index (i) ; let new_char = result . index (i) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } }\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\nfn replace_with_colon (s : & Vec < char >) -> (result : Vec < char >) requires replace_with_colon_precond (s @) ensures replace_with_colon_postcond (s @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | # ! [trigger s @. index (j)] # ! [trigger result @. index (j)] 0 <= j < i ==> { let old_char = s @ . index (j) ; let new_char = result @ . index (j) ; if is_space_comma_dot_spec (old_char) { new_char == ':' } else { new_char == old_char } } decreases s . len () - i { let c = s [i] ; if is_space_comma_dot (c) { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "2cc966840512", "function_name": "replace_with_colon", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f8e712e6172", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { let mut k = 0 ; while k < arr . len () - 1  { if arr [k] > arr [k + 1] { return false ; } k += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ndecreases arr . len () - 1 - k\ninvariant 0 <= k <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j < k + 1 ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut k = 0 ; while k < arr . len () - 1 invariant 0 <= k <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j < k + 1 ==> arr [i] <= arr [j] , decreases arr . len () - 1 - k { if arr [k] > arr [k + 1] { return false ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "0f8e712e6172", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fe04a85d49ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fe04a85d49ae", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f9a82987d703", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_canyon_search/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f9a82987d703", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0a7649c8135d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)   { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 , max_array_precond (a) \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0a7649c8135d", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8640e6ee29f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "8640e6ee29f2", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_c194c63c8d21", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires if_power_of_four_precond (n as nat)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c194c63c8d21", "function_name": "if_power_of_four", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3bbf27449524", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {   return true ; } i = i + 1 ; }   false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "3bbf27449524", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8471bd3498e6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "8471bd3498e6", "function_name": "helper", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_42497c9b60db", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "42497c9b60db", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_1e6a2c5ea120", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1e6a2c5ea120", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2799ef46af24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "2799ef46af24", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8e38951fbc78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)   { let mut last_idx = 0 ; let mut i = 0 ; while i < a . len () && a [i] != elem  { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len ()  { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "target_text": "requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem \nensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem \ndecreases a . len () - i, a . len () - i\ninvariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , 0 <= last_idx < a . len () , last_idx < i <= a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_idx = 0 ; let mut i = 0 ; while i < a . len () && a [i] != elem invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { i += 1 ; } last_idx = i ; i += 1 ; while i < a . len () invariant 0 <= last_idx < a . len () , last_idx < i <= a . len () , a [last_idx as int] == elem , forall | j : int | last_idx < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { last_idx = i ; } i += 1 ; } last_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/last_position_impl.rs", "verified": true, "metadata": {"original_id": "8e38951fbc78", "function_name": "last_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_743b0b5f06d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > { return None ; }\n\n} // verus!", "target_text": "decreases nums . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn two_sum_outer (nums : & Vec < i32 > , target : i32 , i : usize) -> Option < (usize , usize) > decreases nums . len () - i { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "743b0b5f06d5", "function_name": "two_sum_outer", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_d5b84d7ee178", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "d5b84d7ee178", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_734530d2ece4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires increasing_triplet_precond (nums @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "734530d2ece4", "function_name": "increasing_triplet", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9e7741be6e29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for idx in 0 .. arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ninvariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for idx in 0 .. arr . len () invariant forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) { if (idx % 2) != (arr [idx] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "9e7741be6e29", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e9d9e1bb47f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 \nensures result >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_63/verina_basic_63.rs", "verified": true, "metadata": {"original_id": "e9d9e1bb47f8", "function_name": "abs_diff", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_76a4a45ed837", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant c @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_array_append/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "76a4a45ed837", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b986bdb21d26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool)   { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len ()  { if chars [i] != first_char { return false ; } i += 1 ; }  true }\n\n} // verus!", "target_text": "requires all_characters_same_precond (chars)\nensures all_characters_same_postcond (chars , result)\ndecreases chars . len () - i\ninvariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_38/verina_basic_38_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b986bdb21d26", "function_name": "all_characters_same", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bda45de2df39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , arr1 . len () == arr2 . len () , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "bda45de2df39", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_exec_termination_example_3677eba6fccb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n    // basic recursive expression\n    fn exec_basic_recursive_expr(i: u64) -> (r: u64)\n\n        {\n        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }\n    }\n\n    // basic recursive statement\n    fn exec_basic_recursive_stmt(i: u64)\n        {\n        if i != 0 {\n            exec_basic_recursive_stmt(i - 1);\n        }\n    }\n\n    // basic while loop\n    fn exec_basic_while_loop() {\n        let mut i = 0;\n        while i < 10\n\n        {\n            i = i + 1;\n        }\n\n    }\n\n    // nested while\n    fn exec_nested_while_loop() {\n        let mut i = 0;\n        let mut j = 0;\n        while i < 10\n\n            {\n                i = i + 1;\n                while j < 5\n\n                    {\n                        j = j + 1;\n                    }\n            }\n    }\n\n    // infinite loop with break\n    fn exec_basic_loop_break() {\n        let mut i: i8 = 0;\n        loop\n            invariant_except_break i <= 9\n\n        {\n            i = i + 1;\n            if i == 10 {\n                break;\n            }\n        }\n    }\n\n    // for loop\n    fn exec_for_loop() {\n        let mut n: u64 = 0;\n        for x in iter: 0..10\n\n        {\n            n += 3;\n        }\n    }\n\n    fn exec_for_loop_2() {\n        let mut n: u64 = 0;\n        let mut end = 10;\n        for x in iter: 0..end\n\n        {\n            n += 3;\n        }\n    }\n\n    // basic recursive expression + basic while loop\n    #[verifier::loop_isolation(false)]\n    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)\n\n        {\n        let ghost initial_i = i;\n        while 0 < i && i <= 10\n\n        {\n            exec_basic_recursive_stmt_basic_while_loop(i - 1);\n            i -= 1;\n        }\n    }\n}", "target_text": "requires i <= 10\nensures r == i, r == i\n        decreases i, 1 <= i\n            decreases 10 - i\ndecreases i, i, 10 - i, 10 - i, 5 - j, 10 - i, automatically for `for` loops:\n            //   decreases 10 - iter.cur, automatically for `for` loops:\n            //   decreases end - iter.cur, i, i\ninvariant i <= 10, i <= 10,\n                j <= 5, j <= 5, 0 <= i <= 10\n            ensures 1 <= i, n == iter.cur * 3,\n            // You can write a `, n == iter.cur * 3,\n                end == 10,\n            // You can write a `, 0 <= i <= 10,\n                i <= initial_i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n    // basic recursive expression\n    fn exec_basic_recursive_expr(i: u64) -> (r: u64)\n        ensures r == i\n        decreases i\n    {\n        if i == 0 { 0 } else { 1 + exec_basic_recursive_expr(i - 1) }\n    }\n\n    // basic recursive statement\n    fn exec_basic_recursive_stmt(i: u64)\n        decreases i \n    {\n        if i != 0 {\n            exec_basic_recursive_stmt(i - 1);\n        }\n    }\n\n    // basic while loop\n    fn exec_basic_while_loop() {\n        let mut i = 0;\n        while i < 10\n            invariant i <= 10\n            decreases 10 - i\n        {\n            i = i + 1;\n        }\n        assert(i == 10);\n    }\n\n    // nested while \n    fn exec_nested_while_loop() {\n        let mut i = 0;\n        let mut j = 0;\n        while i < 10 \n            invariant \n                i <= 10,\n                j <= 5\n            decreases 10 - i\n            {\n                i = i + 1;\n                while j < 5\n                    invariant j <= 5\n                    decreases 5 - j\n                    {\n                        j = j + 1;\n                    }\n            }\n    }\n\n    // infinite loop with break\n    fn exec_basic_loop_break() {\n        let mut i: i8 = 0;\n        loop\n            invariant_except_break i <= 9\n            invariant 0 <= i <= 10\n            ensures 1 <= i\n            decreases 10 - i\n        {\n            i = i + 1;\n            if i == 10 {\n                break;\n            }\n        }\n    }\n\n    // for loop \n    fn exec_for_loop() {\n        let mut n: u64 = 0;\n        for x in iter: 0..10\n            invariant n == iter.cur * 3,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases 10 - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    fn exec_for_loop_2() {\n        let mut n: u64 = 0;\n        let mut end = 10;\n        for x in iter: 0..end \n            invariant \n                n == iter.cur * 3,\n                end == 10,\n            // You can write a `decreases` if you want, but it's not needed\n            // because Verus inserts a decreases automatically for `for` loops:\n            //   decreases end - iter.cur,\n        {\n            n += 3;\n        }\n    }\n\n    // basic recursive expression + basic while loop\n    #[verifier::loop_isolation(false)]\n    fn exec_basic_recursive_stmt_basic_while_loop(mut i: u64)\n        requires i <= 10,\n        decreases i,\n    {\n        let ghost initial_i = i;\n        while 0 < i && i <= 10\n            invariant\n                0 <= i <= 10,\n                i <= initial_i,\n            decreases i,\n        {\n            exec_basic_recursive_stmt_basic_while_loop(i - 1);\n            i -= 1;\n        }\n    }\n}", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/exec_termination_example.rs", "verified": true, "metadata": {"original_id": "verus_exec_termination_example_3677eba6fccb", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_eb5a74776909", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] % 2 != 0 {  return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "target_text": "requires find_first_odd_precond (a)\nensures find_first_odd_postcond (a , result)\ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_first_odd_postcond (a : & Vec < i32 > , result : Option < usize >) -> bool { match result { Some (idx) => { &&& idx < a . len () &&& is_odd (a [idx as int] as int) &&& forall | j : int | 0 <= j < idx ==> ! is_odd (a [j] as int) } None => forall | i : int | 0 <= i < a . len () ==> ! is_odd (a [i] as int) } }\nspec fn is_odd (x : int) -> bool { x % 2 != 0 }\nspec fn find_first_odd_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_first_odd (a : & Vec < i32 >) -> (result : Option < usize >) requires find_first_odd_precond (a) ensures find_first_odd_postcond (a , result) { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> ! is_odd (a [j] as int) decreases a . len () - i { if a [i] % 2 != 0 { proof { assert (is_odd (a [i as int] as int)) ; } return Some (i) ; } i += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_49/verina_basic_49_impl.rs", "verified": true, "metadata": {"original_id": "eb5a74776909", "function_name": "find_first_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_51ebab2ed7f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires smallest_missing_precond (l @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn smallest_missing_precond (l : Seq < usize >) -> bool { is_sorted (l) }\nspec fn is_sorted (l : Seq < usize >) -> bool { forall | i : int , j : int | 0 <= i < j < l . len () ==> l [i] < l [j] }\nfn smallest_missing (l : & Vec < usize >) -> (result : usize) requires smallest_missing_precond (l @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_73/verina_advanced_73_iter_0_original.rs", "verified": true, "metadata": {"original_id": "51ebab2ed7f1", "function_name": "smallest_missing", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_69c92090d0b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "69c92090d0b3", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_02bd388ca617", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "02bd388ca617", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_cb3b4c22af88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb3b4c22af88", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4510ba4388fc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2_impl.rs", "verified": true, "metadata": {"original_id": "4510ba4388fc", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_overflow_dfccd418b493", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n/*\n// ANCHOR: compute_sum_fails\nfn compute_sum_fails(x: u64, y: u64) -> (result: u64)\n\n{\n    x + y  // error: possible arithmetic underflow/overflow\n}\n// ANCHOR_END: compute_sum_fails\n*/\n\n// ANCHOR: compute_sum_limited\nfn compute_sum_limited(x: u64, y: u64) -> (result: u64)\n\n{\n    x + y\n}\n// ANCHOR_END: compute_sum_limited\n\n// ANCHOR: compute_sum_runtime_check\nfn compute_sum_runtime_check(x: u64, y: u64) -> (result: Option<u64>)\n     {\n            Some(z) => z == x + y,\n            None => x + y > u64::MAX,\n        },\n{\n    x.checked_add(y)\n}\n// ANCHOR: compute_sum_runtime_check\n\nfn main() {\n}\n\n} // verus!\n\n", "target_text": "requires x < 1000000,\n        y < 1000000\nensures result == x + y, result == x + y, match result", "full_verified_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::prelude::*;\n\nverus! {\n\n/*\n// ANCHOR: compute_sum_fails\nfn compute_sum_fails(x: u64, y: u64) -> (result: u64)\n    ensures\n        result == x + y,\n{\n    x + y  // error: possible arithmetic underflow/overflow\n}\n// ANCHOR_END: compute_sum_fails\n*/\n\n// ANCHOR: compute_sum_limited\nfn compute_sum_limited(x: u64, y: u64) -> (result: u64)\n    requires\n        x < 1000000,\n        y < 1000000,\n    ensures\n        result == x + y,\n{\n    x + y\n}\n// ANCHOR_END: compute_sum_limited\n\n// ANCHOR: compute_sum_runtime_check\nfn compute_sum_runtime_check(x: u64, y: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(z) => z == x + y,\n            None => x + y > u64::MAX,\n        },\n{\n    x.checked_add(y)\n}\n// ANCHOR: compute_sum_runtime_check\n\nfn main() {\n}\n\n} // verus!\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/overflow.rs", "verified": true, "metadata": {"original_id": "verus_overflow_dfccd418b493", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f9dae54162f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "ensures result == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "f9dae54162f8", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c893d9589bae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool)   { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1  { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires is_sorted_precond (a @) \nensures is_sorted_postcond (a @ , result) \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_19/verina_basic_19_impl.rs", "verified": true, "metadata": {"original_id": "c893d9589bae", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3d716dc15b3b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3d716dc15b3b", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_0b3b8005ec1b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | idx1 : int , idx2 : int | 0 <= idx1 < idx2 < c . len () ==> c [idx1] != c [idx2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | idx1 : int , idx2 : int | 0 <= idx1 < idx2 < c . len () ==> c [idx1] != c [idx2] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "0b3b8005ec1b", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8f912cd18533", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "8f912cd18533", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4abc3024a852", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4abc3024a852", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_48a62884a497", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for idx in 0 .. arr . len ()  { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for idx in 0 .. arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , { if arr [idx] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "48a62884a497", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_139126d5f7b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "139126d5f7b6", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_442259409fce", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ndecreases nums . len () - idx\ninvariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "442259409fce", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f95c1362d71d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "f95c1362d71d", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6447b6bf41d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ndecreases arr . len () - i, arr1 . len () - i\ninvariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (result [k]) && arr2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6447b6bf41d3", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_91f1ac21a368", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "91f1ac21a368", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ca844d5abd72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 . len () - i\ninvariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "ca844d5abd72", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dc955fe25f39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn pow (base : int , exp : nat) -> int { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool)   {  if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "target_text": "requires is_power_of_two_precond (n as int) \nensures is_power_of_two_postcond (n as int , result) \ndecreases exp", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_power_of_two_postcond (n : int , result : bool) -> bool { if result { exists | x : nat | pow (2 , x) == n && n > 0 } else { ! exists | x : nat | pow (2 , x) == n && n > 0 } }\nspec fn is_power_of_two_precond (n : int) -> bool { true }\nspec fn pow (base : int , exp : nat) -> int decreases exp { if exp == 0 { 1 } else { base * pow (base , (exp - 1) as nat) } }\nfn is_power_of_two (n : i32) -> (result : bool) requires is_power_of_two_precond (n as int) , ensures is_power_of_two_postcond (n as int , result) , { proof { admit () ; } if n <= 0 { false } else { n & (n - 1) == 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_23/verina_advanced_23_iter_3_current.rs", "verified": true, "metadata": {"original_id": "dc955fe25f39", "function_name": "is_power_of_two", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_9c4186b33523", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "9c4186b33523", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_41fdc36900c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >)   { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len ()  { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "target_text": "requires find_smallest_precond (s @) \nensures find_smallest_postcond (s @ , result) \ndecreases s . len () - i\ninvariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_2/verina_basic_2_impl.rs", "verified": true, "metadata": {"original_id": "41fdc36900c2", "function_name": "find_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_log_43fc5e898ac9", "task": "task_a", "input_text": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//!\n//!\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//!\n//!\n//!\n//!\n//!\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//!\n//!\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//!\n//!\n//!\n//!\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n\n    }\n\n    proof fn op_unit(a: Self) {\n\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n\n        {\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n\n}\n\n} // verus!\n", "target_text": "requires self@ is FullAuthority, old(self)@ is FullAuthority, old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(), old(self).id() == other.id()\nensures result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(), (, self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v], self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@, out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(), self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log())", "full_verified_code": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/log.rs", "verified": true, "metadata": {"original_id": "verus_log_43fc5e898ac9", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2fbde1781d56", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] pub fn copy_from_slice (bytes : & [u8]) -> (out : Vec < u8 >)  { let mut buffer = vec ! [0 ; bytes . len ()] ; let buffer_slice = buffer . as_mut_slice () ; buffer_slice . copy_from_slice (bytes) ; buffer }\n\n} // verus!", "target_text": "ensures out @ == bytes @\ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] pub fn copy_from_slice (bytes : & [u8]) -> (out : Vec < u8 >) ensures out @ == bytes @ { let mut buffer = vec ! [0 ; bytes . len ()] ; let buffer_slice = buffer . as_mut_slice () ; buffer_slice . copy_from_slice (bytes) ; buffer }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "2fbde1781d56", "function_name": "copy_from_slice", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_dceab52d1719", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)   { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "requires start < l . len (), is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "dceab52d1719", "function_name": "is_peak_valley", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8f3c315d2596", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,)   { }\n\n} // verus!", "target_text": "requires nums . len () == old (used) . len () \nensures used . len () == old (used) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/permutations_iter_0_original.rs", "verified": true, "metadata": {"original_id": "8f3c315d2596", "function_name": "backtrack", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b82e307bc662", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires prev_nums . len () == lengths . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize) requires prev_nums . len () == lengths . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_32/verina_advanced_32_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b82e307bc662", "function_name": "find_length_ending_at_curr", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_63f93a3ee908", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "63f93a3ee908", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_70b51eb12558", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { if N == 0 { 0 } else { 2 * N } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/cell_2_sum_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "70b51eb12558", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e3c963be11d9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool)   { let mut i = 0 ; while i < s . len ()  { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires match_precond (s @ , p @)\nensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?')\ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?')", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_73/verina_basic_73_impl.rs", "verified": true, "metadata": {"original_id": "e3c963be11d9", "function_name": "match_fn", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bf6679700b1e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)  { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. a . len ()  { let mut should_add = true ; for j in 0 .. result . len ()  { if result [j] == a [i] { should_add = false ; break ; } } if should_add { let mut insert_pos = result . len () ; for k in 0 .. result . len ()  { if result [k] > a [i] { insert_pos = k ; break ; } } result . insert (insert_pos , a [i]) ; } } result }\n\n} // verus!", "target_text": "ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] \ninvariant forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , should_add ==> forall | k : int | 0 <= k < j ==> result [k] != a [i as int] , ! should_add ==> exists | k : int | 0 <= k < result . len () && result [k] == a [i as int] , forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , insert_pos <= result . len () , forall | m : int | 0 <= m < k ==> result [m] < a [i as int] , insert_pos == result . len () || result [insert_pos as int] > a [i as int] , k <= insert_pos ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result : Vec < i32 > = Vec :: new () ; for i in 0 .. a . len () invariant forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , { let mut should_add = true ; for j in 0 .. result . len () invariant forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , should_add ==> forall | k : int | 0 <= k < j ==> result [k] != a [i as int] , ! should_add ==> exists | k : int | 0 <= k < result . len () && result [k] == a [i as int] , { if result [j] == a [i] { should_add = false ; break ; } } if should_add { let mut insert_pos = result . len () ; for k in 0 .. result . len () invariant forall | x : int , y : int | # ! [trigger result [x] , result [y]] 0 <= x && x < y && y < result . len () ==> result [x] < result [y] , insert_pos <= result . len () , forall | m : int | 0 <= m < k ==> result [m] < a [i as int] , insert_pos == result . len () || result [insert_pos as int] > a [i as int] , k <= insert_pos , { if result [k] > a [i] { insert_pos = k ; break ; } } result . insert (insert_pos , a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/unique_better_impl.rs", "verified": true, "metadata": {"original_id": "bf6679700b1e", "function_name": "unique", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_59006ed52bd0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "59006ed52bd0", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1047714361fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , N : i32 , m : i32)   { let mut i = 0 ; while i < a . len ()  { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] <= N \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/condn_impl.rs", "verified": true, "metadata": {"original_id": "1047714361fe", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_059445716718", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool)  { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "target_text": "requires m > 0 \ndecreases fuel", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool) requires m > 0 , decreases fuel { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_23/verina_advanced_23_iter_3_current.rs", "verified": true, "metadata": {"original_id": "059445716718", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_5ef4fb1fdca0", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ninvariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut max_idx = 0 ; for idx in 1 .. nums . len () invariant 0 <= max_idx < nums @ . len () , max_val == nums @ [max_idx as int] , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , { if nums [idx] > max_val { max_val = nums [idx] ; max_idx = idx ; } } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "5ef4fb1fdca0", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_81a63418f7a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i = i + 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "81a63418f7a2", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_bd3511fcfec6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start <= end , end < nums . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: exec_allows_no_decreases_clause] fn count_distinct_elements (nums : & Vec < u32 > , start : usize , end : usize) -> (count : usize) requires start <= end , end < nums . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_74/verina_advanced_74_iter_0_original.rs", "verified": true, "metadata": {"original_id": "bd3511fcfec6", "function_name": "count_distinct_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8933e0081cf9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires solution_precond (nums @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_74/verina_advanced_74_iter_0_original.rs", "verified": true, "metadata": {"original_id": "8933e0081cf9", "function_name": "solution", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4470d68dccef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nspec fn isEven_precond (n : int) -> bool { true }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_26/verina_basic_26_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4470d68dccef", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_aab4fcf08ecc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len () invariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "aab4fcf08ecc", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
