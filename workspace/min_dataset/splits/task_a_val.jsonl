{"id": "task_a_ca844d5abd72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 . len () - i\ninvariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "ca844d5abd72", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a238802c8e44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_and_intro(a: bool, b: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires a,\n        b,\n    ensures a && b\nensures a && b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_and_intro(a: bool, b: bool)\n    requires a,\n        b,\n    ensures a && b\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "proofobjects_verus.rs", "verified": true, "metadata": {"original_id": "a238802c8e44", "function_name": "lemma_and_intro", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ea4aa97c6d20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ea4aa97c6d20", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c5f835af6a72", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c5f835af6a72", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ba3b88d6691c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ba3b88d6691c", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9ffef5e1c6ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9ffef5e1c6ff", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ba32384a2ed3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_103/verina_basic_103_impl.rs", "verified": true, "metadata": {"original_id": "ba32384a2ed3", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bbd92c4c0b50", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn gen_sample(size: nat, count: nat) -> Seq<nat>\n    {\n    if count == 0 {\n        Seq::empty()\n    } else {\n        let seed = count;  // Use count as seed for variety\n        seq![gen_nat(seed, size)].add(gen_sample(size, (count - 1) as nat))\n    }\n}\n\n} // verus!", "target_text": "decreases count", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn gen_sample(size: nat, count: nat) -> Seq<nat>\n    decreases count\n{\n    if count == 0 {\n        Seq::empty()\n    } else {\n        let seed = count;  // Use count as seed for variety\n        seq![gen_nat(seed, size)].add(gen_sample(size, (count - 1) as nat))\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_gen.rs", "verified": true, "metadata": {"original_id": "bbd92c4c0b50", "function_name": "gen_sample", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_d9c3a6fa55a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "d9c3a6fa55a0", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_04911af74c2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool)   { n % 2 == 0 }\n\n} // verus!", "target_text": "requires isEven_precond (n as int)\nensures isEven_postcond (n as int , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isEven_precond (n : int) -> bool { true }\nspec fn isEven_postcond (n : int , result : bool) -> bool { (result ==> n % 2 == 0) && (! result ==> n % 2 != 0) }\nfn isEven (n : i64) -> (result : bool) requires isEven_precond (n as int) ensures isEven_postcond (n as int , result) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_26/verina_basic_26_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "04911af74c2c", "function_name": "isEven", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a20861a306ed", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "a20861a306ed", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0314439c145f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "0314439c145f", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_83a442acf0ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_size_positive(t: Ty)\n    \n    {\n    match t {\n        Ty::TBool => {}\n        Ty::TNat => {}\n        Ty::TUnit => {}\n        Ty::TProd { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n        Ty::TSum { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n        Ty::TArrow { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n    }\n}\n\n} // verus!", "target_text": "ensures ty_size(t) >= 1\n    decreases t\ndecreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ty_size_positive(t: Ty)\n    ensures ty_size(t) >= 1\n    decreases t\n{\n    match t {\n        Ty::TBool => {}\n        Ty::TNat => {}\n        Ty::TUnit => {}\n        Ty::TProd { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n        Ty::TSum { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n        Ty::TArrow { t1, t2 } => {\n            ty_size_positive(*t1);\n            ty_size_positive(*t2);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_gen_type.rs", "verified": true, "metadata": {"original_id": "83a442acf0ea", "function_name": "ty_size_positive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_verus_proposal-rw2022_7d76b33c938f", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n\n    {\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n\n    {\n        i = i + 1;\n\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires i <= j, fibo_fits_u64(n as nat)\nensures fibo(i) <= fibo(j), result == fibo(n as nat), fibo(i) <= fibo(j),\n    decreases j - i\ndecreases n, j - i\ninvariant 0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat)", "full_verified_code": "// rust_verify/tests/example.rs\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::*;\n\nverus! {\n\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/proposal-rw2022.rs", "verified": true, "metadata": {"original_id": "verus_proposal-rw2022_7d76b33c938f", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_162ceab2570d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn rhs(self) -> nat\n        {\n        match self {\n            LeEv::Refl(n) => n,\n            LeEv::Step(p) => (*p).rhs() + 1,\n        }\n    }\n\n} // verus!", "target_text": "decreases self", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn rhs(self) -> nat\n        decreases self\n    {\n        match self {\n            LeEv::Refl(n) => n,\n            LeEv::Step(p) => (*p).rhs() + 1,\n        }\n    }\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "162ceab2570d", "function_name": "rhs", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_4f53cba43f6d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "4f53cba43f6d", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_67d8fb759c01", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn atoms_dont_shrink()\n    \n{\n\n}\n\n} // verus!", "target_text": "ensures shrink_expr(Expr::Zero).len() == 0,\n        shrink_expr(Expr::Tru).len() == 0,\n        shrink_expr(Expr::Fls).len() == 0,", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn atoms_dont_shrink()\n    ensures\n        shrink_expr(Expr::Zero).len() == 0,\n        shrink_expr(Expr::Tru).len() == 0,\n        shrink_expr(Expr::Fls).len() == 0,\n{\n    assert(shrink_expr(Expr::Zero) =~= seq![]);\n    assert(shrink_expr(Expr::Tru) =~= seq![]);\n    assert(shrink_expr(Expr::Fls) =~= seq![]);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_shrink.rs", "verified": true, "metadata": {"original_id": "67d8fb759c01", "function_name": "atoms_dont_shrink", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_bcd1a0f2c0c0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_triple3/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "bcd1a0f2c0c0", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4a4dc9705230", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool)  { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len ()  { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) \ndecreases arr . len () - j\ninvariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len () invariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] , decreases arr . len () - j { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_760_impl.rs", "verified": true, "metadata": {"original_id": "4a4dc9705230", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_62a8cc71df06", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "62a8cc71df06", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_6c56620d6a39", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int)   { let remainder = addr % alignment ; if remainder != 0 {  }   } } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize)   { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64_to_usize (v : & CheckedU64 , alignment : usize) -> (result : CheckedU64)   {  if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment_usize (v . unwrap () , alignment) as u64) } }\n\n} // verus!", "target_text": "requires 0 < alignment , 0 < alignment , 0 < alignment \nensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment), result == space_needed_for_alignment (addr as int , alignment as int), v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) \ninvariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment_usize (addr : u64 , alignment : usize) -> (result : usize) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder : usize = (addr % (alignment as u64)) as usize ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64_to_usize (v : & CheckedU64 , alignment : usize) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment_usize (v . unwrap () , alignment) as u64) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "6c56620d6a39", "function_name": "align_checked_u64_to_usize", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_896a3b8e6bc9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right  { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } }  0 }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases right - left \ninvariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "896a3b8e6bc9", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dc79c0fb0aec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)   { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len ()  { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_of_list_precond (lst @) \nensures max_of_list_postcond (lst @ , result) \ndecreases lst . len () - i \ninvariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "dc79c0fb0aec", "function_name": "max_of_list", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_278dffab5ea1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tm_lookup(label: Label, t: Tm) -> Option<Tm>\n    {\n    match t {\n        Tm::RNil => Option::None,\n        Tm::RCons { label: l, t: v, rest } =>\n            if l == label {\n                Option::Some(*v)\n            } else {\n                tm_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tm_lookup(label: Label, t: Tm) -> Option<Tm>\n    decreases t\n{\n    match t {\n        Tm::RNil => Option::None,\n        Tm::RCons { label: l, t: v, rest } =>\n            if l == label {\n                Option::Some(*v)\n            } else {\n                tm_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "records_verus.rs", "verified": true, "metadata": {"original_id": "278dffab5ea1", "function_name": "tm_lookup", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_7551c5191921", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , x <= MAX / 3\nensures triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7551c5191921", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a61d998dd5a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex_map_update_shadow_value(m: M, k: Key, v1: int, v2: int)\n    \n{\n    lemma_insert_same(m.insert(k, v1), k, v2);\n}\n\n} // verus!", "target_text": "ensures (m.insert(k, v1).insert(k, v2))[k] == v2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex_map_update_shadow_value(m: M, k: Key, v1: int, v2: int)\n    ensures (m.insert(k, v1).insert(k, v2))[k] == v2\n{\n    lemma_insert_same(m.insert(k, v1), k, v2);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "auto_verus.rs", "verified": true, "metadata": {"original_id": "a61d998dd5a2", "function_name": "ex_map_update_shadow_value", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c48a942dd7e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gcd_comm(a: nat, b: nat)  {\n    reveal_with_fuel(gcd, 3);\n    if b == 0 || a == 0 {} else if a >= b { gcd_comm((a - b) as nat, b); } else { gcd_comm(a, (b - a) as nat); }\n}\n\n} // verus!", "target_text": "ensures gcd(a, b) == gcd(b, a) decreases a + b\ndecreases a + b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gcd_comm(a: nat, b: nat) ensures gcd(a, b) == gcd(b, a) decreases a + b {\n    reveal_with_fuel(gcd, 3);\n    if b == 0 || a == 0 {} else if a >= b { gcd_comm((a - b) as nat, b); } else { gcd_comm(a, (b - a) as nat); }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_gcd.rs", "verified": true, "metadata": {"original_id": "c48a942dd7e8", "function_name": "gcd_comm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_1ae572968fec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_height<T>(t: Tree<T>) -> nat\n    {\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } => {\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            1 + if lh > rh { lh } else { rh }\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_height<T>(t: Tree<T>) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } => {\n            let lh = tree_height(*left);\n            let rh = tree_height(*right);\n            1 + if lh > rh { lh } else { rh }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_sized.rs", "verified": true, "metadata": {"original_id": "1ae572968fec", "function_name": "tree_height", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_d1dd43ef56dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d1dd43ef56dd", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_998dbba568b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/choose_odd_iter_3_current.rs", "verified": true, "metadata": {"original_id": "998dbba568b9", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_d245d4d43e16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_add_shifts(lo: int, hi: int, k: int)\n    \n{\n    if in_int_range(n, lo + k, hi + k) {\n            let m = n - k;\n            \n        }\n    }\n}\n\n} // verus!", "target_text": "ensures forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n            in_int_range(n, lo + k, hi + k)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_add_shifts(lo: int, hi: int, k: int)\n    ensures\n        forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n            in_int_range(n, lo + k, hi + k)\n{\n    assert forall|n: int| gen_int_add(choose_int_outputs(lo, hi), k).contains(n) <==>\n        in_int_range(n, lo + k, hi + k) by {\n        if gen_int_add(choose_int_outputs(lo, hi), k).contains(n) {\n            let m = choose|m: int| choose_int_outputs(lo, hi).contains(m) && m + k == n;\n            assert(in_int_range(m, lo, hi));\n            assert(n == m + k);\n        }\n        if in_int_range(n, lo + k, hi + k) {\n            let m = n - k;\n            assert(choose_int_outputs(lo, hi).contains(m));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "d245d4d43e16", "function_name": "gen_int_add_shifts", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_4194da580db7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_iff_bool_sound(a: bool, b: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_iff_bool(a, b)) == (a == b)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_iff_bool_sound(a: bool, b: bool)\n    ensures dec_to_bool(dec_iff_bool(a, b)) == (a == b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_bool.rs", "verified": true, "metadata": {"original_id": "4194da580db7", "function_name": "dec_iff_bool_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_bfcf722e4b05", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn list_append<T>(l1: List<T>, l2: List<T>) -> List<T>\n    {\n    match l1 {\n        List::Nil => l2,\n        List::Cons { head, tail } => List::Cons { head, tail: Box::new(list_append(*tail, l2)) },\n    }\n}\n\n} // verus!", "target_text": "decreases l1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn list_append<T>(l1: List<T>, l2: List<T>) -> List<T>\n    decreases l1\n{\n    match l1 {\n        List::Nil => l2,\n        List::Cons { head, tail } => List::Cons { head, tail: Box::new(list_append(*tail, l2)) },\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_list_def.rs", "verified": true, "metadata": {"original_id": "bfcf722e4b05", "function_name": "list_append", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_d2bf7eb3aa63", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_passing_helper(props: Seq<LabeledProp>, idx: int) -> nat\n    {\n    if idx >= props.len() {\n        0\n    } else {\n        let count = if props[idx].holds { 1 as nat } else { 0 as nat };\n        count + count_passing_helper(props, idx + 1)\n    }\n}\n\n} // verus!", "target_text": "decreases props.len() - idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_passing_helper(props: Seq<LabeledProp>, idx: int) -> nat\n    decreases props.len() - idx\n{\n    if idx >= props.len() {\n        0\n    } else {\n        let count = if props[idx].holds { 1 as nat } else { 0 as nat };\n        count + count_passing_helper(props, idx + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_label.rs", "verified": true, "metadata": {"original_id": "d2bf7eb3aa63", "function_name": "count_passing_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_7459e298200f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_chord_intersection (n : usize , chords : Vec < Vec < usize > >) -> (result : bool) requires n >= 2 , forall | i : int | 0 <= i < chords . len () ==> (# [trigger] chords [i] . len () == 2 && chords [i] [0] >= 1 && chords [i] [0] <= 2 * n && chords [i] [1] >= 1 && chords [i] [1] <= 2 * n) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_13/verina_advanced_13_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7459e298200f", "function_name": "has_chord_intersection", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8f26ff6b2328", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f26ff6b2328", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_24679d6e00de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_97/verina_basic_97_iter_1_current.rs", "verified": true, "metadata": {"original_id": "24679d6e00de", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_beb6de963fa7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "beb6de963fa7", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4d13c74ee1ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)   { x + x + x }\n\n} // verus!", "target_text": "requires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4d13c74ee1ab", "function_name": "triple_over", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_43ab2c0e8435", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_not(b: bool, p: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires reflect(b, p)\n    ensures reflect(!b, !p)\nensures reflect(!b, !p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_not(b: bool, p: bool)\n    requires reflect(b, p)\n    ensures reflect(!b, !p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_bool.rs", "verified": true, "metadata": {"original_id": "43ab2c0e8435", "function_name": "reflect_not", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_a8b602cf3ad1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn nth(l: List, n: nat) -> Option<nat> n {\n    match l {\n        List::Nil => None,\n        List::Cons { head, tail } => if n == 0 { Some(head) } else { nth(*tail, (n-1) as nat) }\n    }\n}\n\n} // verus!", "target_text": "decreases l", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn nth(l: List, n: nat) -> Option<nat> decreases l, n {\n    match l {\n        List::Nil => None,\n        List::Cons { head, tail } => if n == 0 { Some(head) } else { nth(*tail, (n-1) as nat) }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_list_ops.rs", "verified": true, "metadata": {"original_id": "a8b602cf3ad1", "function_name": "nth", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_c194c63c8d21", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires if_power_of_four_precond (n as nat)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn if_power_of_four_precond (n : nat) -> bool { true }\npub fn if_power_of_four (n : u32) -> (result : bool) requires if_power_of_four_precond (n as nat) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c194c63c8d21", "function_name": "if_power_of_four", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_06e9ab3799fd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_add_succ_r(n: nat, m: nat)\n    \n    {\n    if n == 0 {\n    } else {\n        lemma_add_succ_r((n - 1) as nat, m);\n    }\n}\n\n} // verus!", "target_text": "ensures add(n, m + 1) == add(n, m) + 1\n    decreases n\ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_add_succ_r(n: nat, m: nat)\n    ensures add(n, m + 1) == add(n, m) + 1\n    decreases n\n{\n    if n == 0 {\n    } else {\n        lemma_add_succ_r((n - 1) as nat, m);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprinciples_verus.rs", "verified": true, "metadata": {"original_id": "06e9ab3799fd", "function_name": "lemma_add_succ_r", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_3ad9f9478ab9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_law_pair_u8()\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures pair_nat_le(min_bound_pair_u8(), max_bound_pair_u8())", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_law_pair_u8()\n    ensures pair_nat_le(min_bound_pair_u8(), max_bound_pair_u8())\n{\n    assert(0 <= 255);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_bounded.rs", "verified": true, "metadata": {"original_id": "3ad9f9478ab9", "function_name": "bounded_law_pair_u8", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_4992a05a5b8b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "4992a05a5b8b", "function_name": "is_integer", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_68652cb1403d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8)   { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "requires 65 <= c <= 90 \nensures r == decode_char_spec (c as int) , 65 <= r <= 90 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "68652cb1403d", "function_name": "decode_char", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_93ad0d5e060c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires iter_copy_precond (s @) \nensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93ad0d5e060c", "function_name": "iter_copy", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0ae5535bf9b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "0ae5535bf9b7", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f2d5cfd37d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "0f2d5cfd37d4", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_dc92e425a7a9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ap_seq_zip_identity<A>(xs: Seq<A>)\n    \n{\n    let fs = pure_seq(|a: A| a, xs.len());\n    let result = ap_seq_zip(fs, xs);\n\n}\n\n} // verus!", "target_text": "ensures ap_seq_zip(pure_seq(|a: A| a, xs.len()), xs) =~= xs", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ap_seq_zip_identity<A>(xs: Seq<A>)\n    ensures ap_seq_zip(pure_seq(|a: A| a, xs.len()), xs) =~= xs\n{\n    let fs = pure_seq(|a: A| a, xs.len());\n    let result = ap_seq_zip(fs, xs);\n    assert(result.len() == xs.len());\n    assert forall|i: int| 0 <= i < xs.len() as int implies result[i] == xs[i] by {\n        assert(fs[i] == (|a: A| a));\n        assert(result[i] == fs[i](xs[i]));\n        assert(result[i] == xs[i]);\n    };\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_applicative.rs", "verified": true, "metadata": {"original_id": "dc92e425a7a9", "function_name": "ap_seq_zip_identity", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_429699ddefc5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_disj_comm(p: bool, q: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures disj_comm(p, q)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_disj_comm(p: bool, q: bool)\n    ensures disj_comm(p, q)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_disjunction.rs", "verified": true, "metadata": {"original_id": "429699ddefc5", "function_name": "verify_disj_comm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_1be5df6de237", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { 0 }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "1be5df6de237", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ac09e9633e26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ac09e9633e26", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_266020011d8c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires move_zeros_to_end_precond (arr @) \nensures move_zeros_to_end_postcond (arr @ , result @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_35/verina_basic_35.rs", "verified": true, "metadata": {"original_id": "266020011d8c", "function_name": "move_zeros_to_end", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_chapter-2-2_fd1678b12990", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n\n    {\n        if candidate % factor == 0 {\n\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires 1 < candidate\nensures result == is_prime(candidate as nat)\ninvariant 1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat)", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\nspec fn divides(factor: nat, candidate: nat) -> bool\n    recommends\n        1 <= factor,\n{\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-2-2.rs", "verified": true, "metadata": {"original_id": "verus_chapter-2-2_fd1678b12990", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fe69ac43052f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/023-strlen_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fe69ac43052f", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_91373d0f3de9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn clamp_preserves_valid(n: nat)\n\n{\n    \n}\n\n} // verus!", "target_text": "requires in_bounds_u8(n)\n    ensures clamp_u8(n as int) == n\nensures clamp_u8(n as int) == n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn clamp_preserves_valid(n: nat)\n    requires in_bounds_u8(n)\n    ensures clamp_u8(n as int) == n\n{\n    assert(0 <= n as int <= 255);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_bounded.rs", "verified": true, "metadata": {"original_id": "91373d0f3de9", "function_name": "clamp_preserves_valid", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_d683b18e2b05", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn iff_comm(a: bool, b: bool)  {}\n\n} // verus!", "target_text": "ensures bool_iff(a, b) == bool_iff(b, a)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn iff_comm(a: bool, b: bool) ensures bool_iff(a, b) == bool_iff(b, a) {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_bool.rs", "verified": true, "metadata": {"original_id": "d683b18e2b05", "function_name": "iff_comm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_af24ef4d27ab", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i, list @ . len () - j\ninvariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "af24ef4d27ab", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_123dc7135748", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_commutative(d1: Dec, d2: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_or(d1, d2) == dec_or(d2, d1)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_commutative(d1: Dec, d2: Dec)\n    ensures dec_or(d1, d2) == dec_or(d2, d1)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "123dc7135748", "function_name": "dec_or_commutative", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_b41dac90da0f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn id_eq_decidable(x: Id, y: Id)\n    \n{\n    // Trivially true by classical logic\n}\n\n} // verus!", "target_text": "ensures id_eq(x, y) || !id_eq(x, y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn id_eq_decidable(x: Id, y: Id)\n    ensures id_eq(x, y) || !id_eq(x, y)\n{\n    // Trivially true by classical logic\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_ident.rs", "verified": true, "metadata": {"original_id": "b41dac90da0f", "function_name": "id_eq_decidable", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c6d460687d5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/060-sum_to_n.rs", "verified": true, "metadata": {"original_id": "c6d460687d5f", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_79cc494d4616", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool)   { a == b }\n\n} // verus!", "target_text": "requires compare_precond (a , b)\nensures compare_postcond (a , b , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn compare_precond (a : int , b : int) -> bool { true }\nspec fn compare_postcond (a : int , b : int , result : bool) -> bool { (a == b ==> result == true) && (a != b ==> result == false) }\nfn compare (a : int , b : int) -> (result : bool) requires compare_precond (a , b) ensures compare_postcond (a , b , result) { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_55/verina_basic_55_iter_1_current.rs", "verified": true, "metadata": {"original_id": "79cc494d4616", "function_name": "compare", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a30a136e4ced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "a30a136e4ced", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_bb5357ceeafb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_snd_contains<A, B>(outputs: Set<(A, B)>, a: A, b: B)\n\n{\n}\n\n} // verus!", "target_text": "requires outputs.contains((a, b))\n    ensures gen_pair_snd(outputs).contains(b)\nensures gen_pair_snd(outputs).contains(b)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_pair_snd_contains<A, B>(outputs: Set<(A, B)>, a: A, b: B)\n    requires outputs.contains((a, b))\n    ensures gen_pair_snd(outputs).contains(b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_pair.rs", "verified": true, "metadata": {"original_id": "bb5357ceeafb", "function_name": "gen_pair_snd_contains", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_7dfba95d31d0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn div_self(a: nat)\n\n{\n}\n\n} // verus!", "target_text": "requires a > 0\n    ensures a / a == 1\nensures a / a == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn div_self(a: nat)\n    requires a > 0\n    ensures a / a == 1\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "7dfba95d31d0", "function_name": "div_self", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_304d7e656951", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn one_pass_len(s: Seq<nat>)\n    \n{\n    if s.len() > 1 {\n        bubble_pass_len(s, 0);\n    }\n}\n\n} // verus!", "target_text": "ensures one_pass(s).len() == s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn one_pass_len(s: Seq<nat>)\n    ensures one_pass(s).len() == s.len()\n{\n    if s.len() > 1 {\n        bubble_pass_len(s, 0);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_bubble.rs", "verified": true, "metadata": {"original_id": "304d7e656951", "function_name": "one_pass_len", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_28f246cc2622", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let double_n = 2 * N ; sum . set (0 , double_n) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 , ensures sum [0] == 2 * N , { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "28f246cc2622", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_476e4fc506c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "476e4fc506c2", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_33b2294d8aac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "33b2294d8aac", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_98ed39156ac1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "98ed39156ac1", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_cf00da7bcd48", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn add_zero_left(a: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures 0 + a == a", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn add_zero_left(a: nat)\n    ensures 0 + a == a\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "cf00da7bcd48", "function_name": "add_zero_left", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_698ec277f9f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)   { 3 * x }\n\n} // verus!", "target_text": "requires x % 2 == 0 && x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "698ec277f9f0", "function_name": "triple_conditions", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d33cd27e6ce2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_not_both_less(x: nat, y: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures not_both_less(x, y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_not_both_less(x: nat, y: nat)\n    ensures not_both_less(x, y)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_negation.rs", "verified": true, "metadata": {"original_id": "d33cd27e6ce2", "function_name": "verify_not_both_less", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c19ba825f92e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) \ndecreases str1 . len () - idx \ninvariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c19ba825f92e", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_f1e911514a59", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_intro(p: bool, q: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p, q\n    ensures p && q\nensures p && q", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_intro(p: bool, q: bool)\n    requires p, q\n    ensures p && q\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "f1e911514a59", "function_name": "and_intro", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c9dce987a094", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c9dce987a094", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3a3e49e2a791", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn compute_failure(pattern: Seq<nat>, i: nat, j: nat) -> Seq<nat>\n    {\n    if i >= pattern.len() { Seq::empty() }\n    else {\n        let new_j = if j > 0 && pattern[i as int] == pattern[j as int] { j + 1 } else { 0 };\n        seq![new_j] + compute_failure(pattern, i + 1, new_j)\n    }\n}\n\n} // verus!", "target_text": "decreases pattern.len() - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn compute_failure(pattern: Seq<nat>, i: nat, j: nat) -> Seq<nat>\n    decreases pattern.len() - i\n{\n    if i >= pattern.len() { Seq::empty() }\n    else {\n        let new_j = if j > 0 && pattern[i as int] == pattern[j as int] { j + 1 } else { 0 };\n        seq![new_j] + compute_failure(pattern, i + 1, new_j)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_kmp.rs", "verified": true, "metadata": {"original_id": "3a3e49e2a791", "function_name": "compute_failure", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_d2a64f515fe1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    {\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Eq { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Lt { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "target_text": "decreases e", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Eq { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Lt { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_mutation.rs", "verified": true, "metadata": {"original_id": "d2a64f515fe1", "function_name": "expr_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_3f0c969f3f71", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_existence_from_witness(n: nat, bound: nat, pred: spec_fn(nat) -> bool)\n\n{\n}\n\n} // verus!", "target_text": "requires n < bound, pred(n)\n    ensures exists_bounded(bound, pred)\nensures exists_bounded(bound, pred)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bounded_existence_from_witness(n: nat, bound: nat, pred: spec_fn(nat) -> bool)\n    requires n < bound, pred(n)\n    ensures exists_bounded(bound, pred)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "3f0c969f3f71", "function_name": "bounded_existence_from_witness", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_4632f8d7e462", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ceval(fuel: nat, c: Com, st: Store) -> Option<Store>\n    c\n{\n    if fuel == 0 {\n        Option::<Store>::None\n    } else {\n        let fuel1 = (fuel - 1) as nat;\n        match c {\n            Com::CSkip => Option::Some(st),\n            Com::CAsgn { x, a } => Option::Some(store_update(st, x, aeval(*a, st))),\n            Com::CSeq { c1, c2 } => {\n                match ceval(fuel1, *c1, st) {\n                    Option::None => Option::<Store>::None,\n                    Option::Some(st1) => ceval(fuel1, *c2, st1),\n                }\n            }\n            Com::CIf { b, ct, cf } => {\n                if beval(*b, st) {\n                    ceval(fuel1, *ct, st)\n                } else {\n                    ceval(fuel1, *cf, st)\n                }\n            }\n            Com::CWhile { b, body } => {\n                if beval(*b, st) {\n                    match ceval(fuel1, *body, st) {\n                        Option::None => Option::<Store>::None,\n                        Option::Some(st1) => ceval(fuel1, Com::CWhile { b: Box::new(*b), body: Box::new(*body) }, st1),\n                    }\n                } else {\n                    Option::Some(st)\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases fuel", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ceval(fuel: nat, c: Com, st: Store) -> Option<Store>\n    decreases fuel, c\n{\n    if fuel == 0 {\n        Option::<Store>::None\n    } else {\n        let fuel1 = (fuel - 1) as nat;\n        match c {\n            Com::CSkip => Option::Some(st),\n            Com::CAsgn { x, a } => Option::Some(store_update(st, x, aeval(*a, st))),\n            Com::CSeq { c1, c2 } => {\n                match ceval(fuel1, *c1, st) {\n                    Option::None => Option::<Store>::None,\n                    Option::Some(st1) => ceval(fuel1, *c2, st1),\n                }\n            }\n            Com::CIf { b, ct, cf } => {\n                if beval(*b, st) {\n                    ceval(fuel1, *ct, st)\n                } else {\n                    ceval(fuel1, *cf, st)\n                }\n            }\n            Com::CWhile { b, body } => {\n                if beval(*b, st) {\n                    match ceval(fuel1, *body, st) {\n                        Option::None => Option::<Store>::None,\n                        Option::Some(st1) => ceval(fuel1, Com::CWhile { b: Box::new(*b), body: Box::new(*body) }, st1),\n                    }\n                } else {\n                    Option::Some(st)\n                }\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "hoare_verus.rs", "verified": true, "metadata": {"original_id": "4632f8d7e462", "function_name": "ceval", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_e4f1bab20d97", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "e4f1bab20d97", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_445e1ae99e9c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len ()  { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - idx\ninvariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx += 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "445e1ae99e9c", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2b70411ce9b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_parity(x: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures parity(x)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_parity(x: nat)\n    ensures parity(x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_disjunction.rs", "verified": true, "metadata": {"original_id": "2b70411ce9b1", "function_name": "verify_parity", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_f0601ff35320", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len ()  { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - idx\ninvariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut idx = 0 ; while idx < arr . len () invariant idx <= arr . len () , copied @ . len () == idx , forall | j : int | (0 <= j < idx) ==> arr [j] == copied [j] , decreases arr . len () - idx { copied . push (arr [idx]) ; idx += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "f0601ff35320", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_809b4a9c397e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_empty()\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures shrink_seq_nat(Seq::empty()).len() == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_seq_empty()\n    ensures shrink_seq_nat(Seq::empty()).len() == 0\n{\n    assert(shrink_seq_nat(Seq::empty()) =~= Seq::empty());\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "809b4a9c397e", "function_name": "shrink_seq_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_fce2ce40aa0d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_log_size_offset : u64 = 24 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_head_offset : u64 = 8 ;\npub const header_size : u64 = 32 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn crc_and_metadata_bytes_to_header (crc_bytes : & [u8] , header_bytes : & [u8]) -> (out : PersistentHeader)   { let head_bytes = slice_subrange (header_bytes , (header_head_offset - 8) as usize , (header_head_offset + 8 - 8) as usize) ; let tail_bytes = slice_subrange (header_bytes , (header_tail_offset - 8) as usize , (header_tail_offset + 8 - 8) as usize) ; let log_size_bytes = slice_subrange (header_bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset + 8 - 8) as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) } } }\n\n} // verus!", "target_text": "requires crc_bytes @ . len () == 8 , header_bytes @ . len () == header_size - 8\nensures out . crc == spec_u64_from_le_bytes (crc_bytes @) , out . metadata == spec_bytes_to_metadata (header_bytes @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: set :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: bytes :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: arithmetic :: mul :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub const header_log_size_offset : u64 = 24 ;\npub const header_tail_offset : u64 = 16 ;\npub const header_head_offset : u64 = 8 ;\npub const header_size : u64 = 32 ;\n# [verifier :: ext_equal] pub struct PersistentHeader { pub crc : u64 , pub metadata : PersistentHeaderMetadata , }\n# [verifier :: ext_equal] pub struct PersistentHeaderMetadata { pub head : u64 , pub tail : u64 , pub log_size : u64 , }\npub open spec (checked) fn spec_bytes_to_metadata (header_seq : Seq < u8 >) -> PersistentHeaderMetadata recommends header_seq . len () == 3 * 8 { let head = spec_u64_from_le_bytes (header_seq . subrange (header_head_offset - 8 , header_head_offset - 8 + 8)) ; let tail = spec_u64_from_le_bytes (header_seq . subrange (header_tail_offset - 8 , header_tail_offset - 8 + 8)) ; let log_size = spec_u64_from_le_bytes (header_seq . subrange (header_log_size_offset - 8 , header_log_size_offset - 8 + 8)) ; PersistentHeaderMetadata { head , tail , log_size } }\nexec fn crc_and_metadata_bytes_to_header (crc_bytes : & [u8] , header_bytes : & [u8]) -> (out : PersistentHeader) requires crc_bytes @ . len () == 8 , header_bytes @ . len () == header_size - 8 ensures out . crc == spec_u64_from_le_bytes (crc_bytes @) , out . metadata == spec_bytes_to_metadata (header_bytes @) { let head_bytes = slice_subrange (header_bytes , (header_head_offset - 8) as usize , (header_head_offset + 8 - 8) as usize) ; let tail_bytes = slice_subrange (header_bytes , (header_tail_offset - 8) as usize , (header_tail_offset + 8 - 8) as usize) ; let log_size_bytes = slice_subrange (header_bytes , (header_log_size_offset - 8) as usize , (header_log_size_offset + 8 - 8) as usize) ; PersistentHeader { crc : u64_from_le_bytes (crc_bytes) , metadata : PersistentHeaderMetadata { head : u64_from_le_bytes (head_bytes) , tail : u64_from_le_bytes (tail_bytes) , log_size : u64_from_le_bytes (log_size_bytes) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "pmemlog_inlined.rs", "verified": true, "metadata": {"original_id": "fce2ce40aa0d", "function_name": "crc_and_metadata_bytes_to_header", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c8cc7b15e076", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn skip_terminates(fuel: nat, st: Store)\n\n{\n    reveal_with_fuel(ceval, 1);\n}\n\n} // verus!", "target_text": "requires fuel >= 1\n    ensures ceval(fuel, Com::CSkip, st) == Option::Some(st)\nensures ceval(fuel, Com::CSkip, st) == Option::Some(st)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn skip_terminates(fuel: nat, st: Store)\n    requires fuel >= 1\n    ensures ceval(fuel, Com::CSkip, st) == Option::Some(st)\n{\n    reveal_with_fuel(ceval, 1);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "equiv_verus.rs", "verified": true, "metadata": {"original_id": "c8cc7b15e076", "function_name": "skip_terminates", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_662a64951fe7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn excluded_middle(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures p || !p", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn excluded_middle(p: bool)\n    ensures p || !p\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "662a64951fe7", "function_name": "excluded_middle", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_5f13844c7197", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_half_smaller<T>(s: Seq<T>)\n\n{\n}\n\n} // verus!", "target_text": "requires s.len() > 1\n    ensures shrink_seq_half(s).len() < s.len()\nensures shrink_seq_half(s).len() < s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_half_smaller<T>(s: Seq<T>)\n    requires s.len() > 1\n    ensures shrink_seq_half(s).len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_shrinking.rs", "verified": true, "metadata": {"original_id": "5f13844c7197", "function_name": "verify_shrink_seq_half_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_f4cde1453d44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f4cde1453d44", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_0175a4390701", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_graph_1_colorable(n: nat)\n    \n{\n    let g = empty_graph(n);\n    let c = empty_coloring();\n\n    // Show valid_coloring - no edges in empty graph\n    // Show uses_k_colors - all colors are 0 < 1\n    assume(k_colorable(empty_graph(n), 1));\n}\n\n} // verus!", "target_text": "ensures k_colorable(empty_graph(n), 1)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_graph_1_colorable(n: nat)\n    ensures k_colorable(empty_graph(n), 1)\n{\n    let g = empty_graph(n);\n    let c = empty_coloring();\n\n    // Show valid_coloring - no edges in empty graph\n    // Show uses_k_colors - all colors are 0 < 1\n    assume(k_colorable(empty_graph(n), 1));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_color_def.rs", "verified": true, "metadata": {"original_id": "0175a4390701", "function_name": "empty_graph_1_colorable", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e978678edf95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires merge_intervals_precond (intervals @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_47/verina_advanced_47_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e978678edf95", "function_name": "merge_intervals", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ab94299eda92", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ab94299eda92", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_b0cca78820da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_complement(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures conj_complement(p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_complement(p: bool)\n    ensures conj_complement(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "b0cca78820da", "function_name": "verify_conj_complement", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_39a2785ef55b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_le_mono_left(a: nat, b: nat, c: nat)\n\n{\n    assert(a * b <= a * c) by (nonlinear_arith)\n        requires b <= c;\n}\n\n} // verus!", "target_text": "requires b <= c\n    ensures a * b <= a * c\nrequires b <= c;\n}\nensures a * b <= a * c", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_le_mono_left(a: nat, b: nat, c: nat)\n    requires b <= c\n    ensures a * b <= a * c\n{\n    assert(a * b <= a * c) by (nonlinear_arith)\n        requires b <= c;\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "39a2785ef55b", "function_name": "mul_le_mono_left", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c8c74e93671f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_xor_sound(d1: Dec, d2: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_xor(d1, d2)) == (dec_to_bool(d1) != dec_to_bool(d2))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_xor_sound(d1: Dec, d2: Dec)\n    ensures dec_to_bool(dec_xor(d1, d2)) == (dec_to_bool(d1) != dec_to_bool(d2))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "c8c74e93671f", "function_name": "dec_xor_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_771269f016fc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn quicksort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    {\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let rest = s.subrange(1, s.len() as int);\n        let lo = filter_le(rest, pivot);\n        let hi = filter_gt(rest, pivot);\n        quicksort_fuel(lo, (fuel - 1) as nat) + seq![pivot] + quicksort_fuel(hi, (fuel - 1) as nat)\n    }\n}\n\n} // verus!", "target_text": "decreases fuel", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn quicksort_fuel(s: Seq<nat>, fuel: nat) -> Seq<nat>\n    decreases fuel\n{\n    if fuel == 0 || s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let rest = s.subrange(1, s.len() as int);\n        let lo = filter_le(rest, pivot);\n        let hi = filter_gt(rest, pivot);\n        quicksort_fuel(lo, (fuel - 1) as nat) + seq![pivot] + quicksort_fuel(hi, (fuel - 1) as nat)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_quick.rs", "verified": true, "metadata": {"original_id": "771269f016fc", "function_name": "quicksort_fuel", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_805978747e5c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn contains(k: nat, t: Tree) -> bool\n    {\n    match t {\n        Tree::E => false,\n        Tree::T { left, key, value: _, right } =>\n            if k < key {\n                contains(k, *left)\n            } else if k > key {\n                contains(k, *right)\n            } else {\n                true\n            }\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn contains(k: nat, t: Tree) -> bool\n    decreases t\n{\n    match t {\n        Tree::E => false,\n        Tree::T { left, key, value: _, right } =>\n            if k < key {\n                contains(k, *left)\n            } else if k > key {\n                contains(k, *right)\n            } else {\n                true\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_delete.rs", "verified": true, "metadata": {"original_id": "805978747e5c", "function_name": "contains", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_df8542f593af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)   { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i\ndecreases a . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_82/verina_basic_82_impl.rs", "verified": true, "metadata": {"original_id": "df8542f593af", "function_name": "copy_from", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_cc4d8d29f131", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cc4d8d29f131", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_442259409fce", "task": "task_a", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32)   { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret \ndecreases nums . len () - idx\ninvariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val ", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "442259409fce", "function_name": "find_max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ad36b550c9c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bind_left_identity<A, B>(a: A, f: spec_fn(A) -> Set<B>, b: B)\n\n{\n    // Witness that a is in gen_return(a) and f(a) contains b\n\n}\n\n} // verus!", "target_text": "requires f(a).contains(b)\n    ensures gen_bind(gen_return(a), f).contains(b)\nensures gen_bind(gen_return(a), f).contains(b)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bind_left_identity<A, B>(a: A, f: spec_fn(A) -> Set<B>, b: B)\n    requires f(a).contains(b)\n    ensures gen_bind(gen_return(a), f).contains(b)\n{\n    // Witness that a is in gen_return(a) and f(a) contains b\n    assert(gen_return(a).contains(a));\n    assert(f(a).contains(b));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_combinator_bind.rs", "verified": true, "metadata": {"original_id": "ad36b550c9c2", "function_name": "bind_left_identity", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_934b8a5b050b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires bound <= 100 , r <= 10 , n <= 100 \ndecreases bound", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32) requires bound <= 100 , r <= 10 , n <= 100 , decreases bound { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_65/verina_basic_65.rs", "verified": true, "metadata": {"original_id": "934b8a5b050b", "function_name": "bounded_loop", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f9304443414a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f9304443414a", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_24d9011b1778", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn list_any_helper<T>(s: Seq<T>, p: spec_fn(T) -> bool, i: int) -> bool\n    {\n    if i >= s.len() {\n        false\n    } else if p(s[i]) {\n        true\n    } else {\n        list_any_helper(s, p, i + 1)\n    }\n}\n\n} // verus!", "target_text": "decreases s.len() - i when i >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn list_any_helper<T>(s: Seq<T>, p: spec_fn(T) -> bool, i: int) -> bool\n    decreases s.len() - i when i >= 0\n{\n    if i >= s.len() {\n        false\n    } else if p(s[i]) {\n        true\n    } else {\n        list_any_helper(s, p, i + 1)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_list.rs", "verified": true, "metadata": {"original_id": "24d9011b1778", "function_name": "list_any_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_9a3960fc31ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_tree_respects_size<T>(inner_outputs: Set<T>, max_size: nat, t: Tree<T>)\n\n{\n}\n\n} // verus!", "target_text": "requires gen_tree_outputs(inner_outputs, max_size).contains(t)\n    ensures tree_size(t) <= max_size\nensures tree_size(t) <= max_size", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_tree_respects_size<T>(inner_outputs: Set<T>, max_size: nat, t: Tree<T>)\n    requires gen_tree_outputs(inner_outputs, max_size).contains(t)\n    ensures tree_size(t) <= max_size\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_tree.rs", "verified": true, "metadata": {"original_id": "9a3960fc31ea", "function_name": "gen_tree_respects_size", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_f0757364b3b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ndecreases text . len () - i \ninvariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_454_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f0757364b3b9", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e8a6af2d3ba1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn success_or_failure<A>(r: Result<A>)\n    \n{\n    match r {\n        Result::Success { .. } => {}\n        Result::Failure { .. } => {}\n    }\n}\n\n} // verus!", "target_text": "ensures is_success(r) || is_failure(r)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn success_or_failure<A>(r: Result<A>)\n    ensures is_success(r) || is_failure(r)\n{\n    match r {\n        Result::Success { .. } => {}\n        Result::Failure { .. } => {}\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_result_success.rs", "verified": true, "metadata": {"original_id": "e8a6af2d3ba1", "function_name": "success_or_failure", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_5b43f6a64d64", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_absorb(a: bool, b: bool)\n    \n{}\n\n} // verus!", "target_text": "ensures bool_and(a, bool_or(a, b)) == a", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn and_absorb(a: bool, b: bool)\n    ensures bool_and(a, bool_or(a, b)) == a\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_bool.rs", "verified": true, "metadata": {"original_id": "5b43f6a64d64", "function_name": "and_absorb", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ad5e2b7671b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contraposition(p: bool, q: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures prop_contraposition(p, q)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contraposition(p: bool, q: bool)\n    ensures prop_contraposition(p, q)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_implies.rs", "verified": true, "metadata": {"original_id": "ad5e2b7671b6", "function_name": "verify_contraposition", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_000123eb08c1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , linear_search_precond (a , e) \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "000123eb08c1", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e049439dc7b7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >)  { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { 58 } else { str1 [k] }) , { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : u8) -> bool { (c == 32) || (c == 44) || (c == 46) }\nfn replace_with_colon (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , { let mut result : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result . len () == index , forall | k : int | 0 <= k < index ==> # [trigger] result [k] == (if is_space_comma_dot_spec (str1 [k]) { 58 } else { str1 [k] }) , decreases str1 . len () - index { if ((str1 [index] == 32) || (str1 [index] == 44) || (str1 [index] == 46)) { result . push (58) ; } else { result . push (str1 [index]) ; } index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e049439dc7b7", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1320de41d5b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant result @ == a @ . subrange (0 , i as int) { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1320de41d5b9", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fd348cb7ac80", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_idempotent(d: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_and(d, d) == d", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_idempotent(d: Dec)\n    ensures dec_and(d, d) == d\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_and.rs", "verified": true, "metadata": {"original_id": "fd348cb7ac80", "function_name": "dec_and_idempotent", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_1724c5b4309e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_is_even/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1724c5b4309e", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_67a052cba483", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_true(p: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p\n    ensures reflect(true, p)\nensures reflect(true, p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reflect_true(p: bool)\n    requires p\n    ensures reflect(true, p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_dec.rs", "verified": true, "metadata": {"original_id": "67a052cba483", "function_name": "reflect_true", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_8c1f49608d2b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_28/verina_advanced_28.rs", "verified": true, "metadata": {"original_id": "8c1f49608d2b", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_82327a98dd41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j\ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "82327a98dd41", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2689d2a36fa2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires has_close_elements_precond (numbers @ , threshold) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_close_elements_precond (numbers : Seq < i32 > , threshold : i32) -> bool { threshold >= 0 && forall | i : int | 0 <= i < numbers . len () ==> numbers [i] >= - 1000000 && numbers [i] <= 1000000 }\nfn has_close_elements (numbers : Vec < i32 > , threshold : i32) -> (result : bool) requires has_close_elements_precond (numbers @ , threshold) , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_63/verina_basic_63.rs", "verified": true, "metadata": {"original_id": "2689d2a36fa2", "function_name": "has_close_elements", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_581ea793a1b2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn remove_min(t: Tree) -> Tree\n    recommends !matches!(t, Tree::E)\n    {\n    match t {\n        Tree::E => Tree::E,\n        Tree::T { left, key, value, right } =>\n            match *left {\n                Tree::E => *right,\n                _ => Tree::T {\n                    left: Box::new(remove_min(*left)),\n                    key,\n                    value,\n                    right,\n                },\n            }\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn remove_min(t: Tree) -> Tree\n    recommends !matches!(t, Tree::E)\n    decreases t\n{\n    match t {\n        Tree::E => Tree::E,\n        Tree::T { left, key, value, right } =>\n            match *left {\n                Tree::E => *right,\n                _ => Tree::T {\n                    left: Box::new(remove_min(*left)),\n                    key,\n                    value,\n                    right,\n                },\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_delete.rs", "verified": true, "metadata": {"original_id": "581ea793a1b2", "function_name": "remove_min", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_a17cd7dcaa30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a17cd7dcaa30", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b4293197674c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_add_n_0(n: nat)\n    \n    {\n    if n == 0 {\n        \n    } else {\n        let n1 = (n - 1) as nat;\n        ex7_add_n_0(n1);\n\n    }\n}\n\n} // verus!", "target_text": "ensures add(n, 0) == n\n    decreases n\ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_add_n_0(n: nat)\n    ensures add(n, 0) == n\n    decreases n\n{\n    if n == 0 {\n        assert(add(0, 0) == 0);\n    } else {\n        let n1 = (n - 1) as nat;\n        ex7_add_n_0(n1);\n        assert(add(n, 0) == add(n1, 0) + 1);\n        assert(n == n1 + 1);\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "b4293197674c", "function_name": "ex7_add_n_0", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_21723d6ef86c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >)   { let mut i = 0 ; while i < s . len ()  { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 \nensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () \ndecreases s . len () - i\ninvariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_double_array_elements/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "21723d6ef86c", "function_name": "double_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4d9a661a21c8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn cmp_nat_reflexive(x: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures cmp_nat(x, x) == Ordering::Eq", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn cmp_nat_reflexive(x: nat)\n    ensures cmp_nat(x, x) == Ordering::Eq\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_ord.rs", "verified": true, "metadata": {"original_id": "4d9a661a21c8", "function_name": "cmp_nat_reflexive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_2270ec249b07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32)   { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len ()  { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "target_text": "requires v . len () > 0 \nensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] \ndecreases v . len () - idx\ninvariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "2270ec249b07", "function_name": "min_of_vec", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2e26fee4cbba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn push_back_len(d: Deque, x: nat)  {}\n\n} // verus!", "target_text": "ensures deque_len(push_back(d, x)) == deque_len(d) + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn push_back_len(d: Deque, x: nat) ensures deque_len(push_back(d, x)) == deque_len(d) + 1 {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_deque_def.rs", "verified": true, "metadata": {"original_id": "2e26fee4cbba", "function_name": "push_back_len", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_16834247ba4d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_1_current.rs", "verified": true, "metadata": {"original_id": "16834247ba4d", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9310b7192322", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn const_eval_ok(env: Env, fuel: nat)\n\n{\n}\n\n} // verus!", "target_text": "requires fuel >= 1\n    ensures\n        is_ok(eval(env, bool_expr(true), fuel)),\n        is_ok(eval(env, bool_expr(false), fuel)),\n        is_ok(eval(env, nat_expr(42), fuel)),\nensures is_ok(eval(env, bool_expr(true), fuel)),\n        is_ok(eval(env, bool_expr(false), fuel)),\n        is_ok(eval(env, nat_expr(42), fuel)),", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn const_eval_ok(env: Env, fuel: nat)\n    requires fuel >= 1\n    ensures\n        is_ok(eval(env, bool_expr(true), fuel)),\n        is_ok(eval(env, bool_expr(false), fuel)),\n        is_ok(eval(env, nat_expr(42), fuel)),\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_eval.rs", "verified": true, "metadata": {"original_id": "9310b7192322", "function_name": "const_eval_ok", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_849aa2fc577e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "849aa2fc577e", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_5345fcf0599b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_implies_refl(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures prop_implies_refl(p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_implies_refl(p: bool)\n    ensures prop_implies_refl(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_implies.rs", "verified": true, "metadata": {"original_id": "5345fcf0599b", "function_name": "verify_implies_refl", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_9c0a3280d2c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> (ret : bool) { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "9c0a3280d2c3", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_82ccc346b8b1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_impl.rs", "verified": true, "metadata": {"original_id": "82ccc346b8b1", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9bdb4f793182", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires is_odd_at_index_odd_precond (a @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_odd_at_index_odd_precond (a : Seq < i32 >) -> bool { true }\nfn is_odd_at_index_odd (a : & Vec < i32 >) -> (result : bool) requires is_odd_at_index_odd_precond (a @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_44/verina_basic_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9bdb4f793182", "function_name": "is_odd_at_index_odd", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_12e79e5822de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i, arr . len () - j\ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "12e79e5822de", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c44443f16137", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_neg_false()\n    \n{\n}\n\n} // verus!", "target_text": "ensures neg_false()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_neg_false()\n    ensures neg_false()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_negation.rs", "verified": true, "metadata": {"original_id": "c44443f16137", "function_name": "verify_neg_false", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_d9e8c9a06f89", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_pair_nonzero_has_candidates(a: nat, b: nat)\n\n{\n    let shrink_a = shrink_nat(a);\n    let shrink_b = shrink_nat(b);\n\n    if a > 0 {\n        // shrink_nat(a) has at least 1 element when a > 0\n        if a == 1 {\n\n        } else {\n            \n        }\n    }\n    if b > 0 {\n        if b == 1 {\n\n        } else {\n            \n        }\n    }\n}\n\n} // verus!", "target_text": "requires a > 0 || b > 0\n    ensures shrink_pair_nat((a, b)).len() > 0\nensures shrink_pair_nat((a, b)).len() > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_pair_nonzero_has_candidates(a: nat, b: nat)\n    requires a > 0 || b > 0\n    ensures shrink_pair_nat((a, b)).len() > 0\n{\n    let shrink_a = shrink_nat(a);\n    let shrink_b = shrink_nat(b);\n\n    if a > 0 {\n        // shrink_nat(a) has at least 1 element when a > 0\n        if a == 1 {\n            assert(shrink_nat(1) =~= seq![0nat]);\n            assert(shrink_a.len() == 1);\n        } else {\n            assert(shrink_a.len() >= 1);\n        }\n    }\n    if b > 0 {\n        if b == 1 {\n            assert(shrink_nat(1) =~= seq![0nat]);\n            assert(shrink_b.len() == 1);\n        } else {\n            assert(shrink_b.len() >= 1);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "d9e8c9a06f89", "function_name": "shrink_pair_nonzero_has_candidates", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_db4a01d941e4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_record_ty(ty: Ty) -> bool\n    {\n    match ty {\n        Ty::TRNil => true,\n        Ty::TRCons { label: _, ty: _, rest } => is_record_ty(*rest),\n        _ => false,\n    }\n}\n\n} // verus!", "target_text": "decreases ty", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_record_ty(ty: Ty) -> bool\n    decreases ty\n{\n    match ty {\n        Ty::TRNil => true,\n        Ty::TRCons { label: _, ty: _, rest } => is_record_ty(*rest),\n        _ => false,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "records_verus.rs", "verified": true, "metadata": {"original_id": "db4a01d941e4", "function_name": "is_record_ty", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_539c069a85bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mconcat_singleton(x: nat)\n    \n{\n    reveal_with_fuel(mconcat_nat_add, 2);\n}\n\n} // verus!", "target_text": "ensures mconcat_nat_add(seq![x]) == x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mconcat_singleton(x: nat)\n    ensures mconcat_nat_add(seq![x]) == x\n{\n    reveal_with_fuel(mconcat_nat_add, 2);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_monoid.rs", "verified": true, "metadata": {"original_id": "539c069a85bb", "function_name": "mconcat_singleton", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_7bd7f4c207a8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_preserves_shrink_count<A, B>(data: TestData<A>, f: spec_fn(A) -> B)\n    where A: std::marker::Copy\n    \n{\n}\n\n} // verus!", "target_text": "ensures map_test_data(data, f).shrinks.len() == data.shrinks.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_preserves_shrink_count<A, B>(data: TestData<A>, f: spec_fn(A) -> B)\n    where A: std::marker::Copy\n    ensures map_test_data(data, f).shrinks.len() == data.shrinks.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_test_data.rs", "verified": true, "metadata": {"original_id": "7bd7f4c207a8", "function_name": "map_preserves_shrink_count", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_0ef69038b253", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_filter_false<A>(xs: List<A>)\n    \n    {\n    if xs.len() == 0 {\n        \n    } else {\n        let tail = xs.skip(1);\n        ex6_filter_false(tail);\n        \n    }\n}\n\n} // verus!", "target_text": "ensures filter(xs, |a: A| false) =~= Seq::empty()\n    decreases xs.len()\ndecreases xs.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex6_filter_false<A>(xs: List<A>)\n    ensures filter(xs, |a: A| false) =~= Seq::empty()\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        assert(filter(xs, |a: A| false) =~= Seq::empty());\n    } else {\n        let tail = xs.skip(1);\n        ex6_filter_false(tail);\n        assert(filter(xs, |a: A| false) == filter(tail, |a: A| false));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "poly_verus.rs", "verified": true, "metadata": {"original_id": "0ef69038b253", "function_name": "ex6_filter_false", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_eb8f584e0505", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_even(n: nat) -> bool\n    {\n    if n == 0 {\n        true\n    } else if n == 1 {\n        false\n    } else {\n        is_even((n - 2) as nat)\n    }\n}\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_even(n: nat) -> bool\n    decreases n\n{\n    if n == 0 {\n        true\n    } else if n == 1 {\n        false\n    } else {\n        is_even((n - 2) as nat)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "eb8f584e0505", "function_name": "is_even", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_aab4fcf08ecc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_idx = 0 ; let mut i = 1 ; while i < x . len () invariant max_idx < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_idx as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "aab4fcf08ecc", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0a7649c8135d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)   { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 , max_array_precond (a) \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0a7649c8135d", "function_name": "max_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_4c8eec1b5676", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn foldl_empty<A, B>(init: B, f: spec_fn(B, A) -> B)\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures foldl(Seq::<A>::empty(), init, f) == init", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn foldl_empty<A, B>(init: B, f: spec_fn(B, A) -> B)\n    ensures foldl(Seq::<A>::empty(), init, f) == init\n{\n    assert(Seq::<A>::empty().len() == 0);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_foldable.rs", "verified": true, "metadata": {"original_id": "4c8eec1b5676", "function_name": "foldl_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_5fc68d9033cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { let idx = n as int - 1 - j ; 0 <= idx < list @ . len () } , { i = i - 1 ;   result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { let idx = n as int - 1 - k ; 0 <= idx < list @ . len () } , forall | k : int | n as int <= k < result @ . len () ==> # [trigger] result @ [k] == list @ [k] , {  result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i , list . len () - j \ninvariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , forall | j : int | 0 <= j < result @ . len () ==> # [trigger] result @ [j] == list @ [n as int - 1 - j] &&, n <= j <= list . len () , n < list @ . len () , result @ . len () == (n + (j - n)) as int , forall | k : int | 0 <= k < n as int ==> # [trigger] result @ [k] == list @ [n as int - 1 - k] &&", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , forall | j : int | 0 <= j < result @ . len () ==> # [trigger] result @ [j] == list @ [n as int - 1 - j] && { let idx = n as int - 1 - j ; 0 <= idx < list @ . len () } , decreases i , { i = i - 1 ; assert (i < n) ; assert (i < list . len ()) ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list . len () , n < list @ . len () , result @ . len () == (n + (j - n)) as int , forall | k : int | 0 <= k < n as int ==> # [trigger] result @ [k] == list @ [n as int - 1 - k] && { let idx = n as int - 1 - k ; 0 <= idx < list @ . len () } , forall | k : int | n as int <= k < result @ . len () ==> # [trigger] result @ [k] == list @ [k] , decreases list . len () - j , { assert (j < list . len ()) ; result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "5fc68d9033cc", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2c35719f4dbe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "2c35719f4dbe", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_01647fd9aa11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_iter_2_current.rs", "verified": true, "metadata": {"original_id": "01647fd9aa11", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_de8d779929f2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_absorbing_yes_left(d: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_or(Dec::Yes, d) == Dec::Yes", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_or_absorbing_yes_left(d: Dec)\n    ensures dec_or(Dec::Yes, d) == Dec::Yes\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "de8d779929f2", "function_name": "dec_or_absorbing_yes_left", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_2d5c23d76df7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_fibfib (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else if (n == 1) { 0 } else if (n == 2) { 1 } else { spec_fibfib ((n - 1) as nat) + spec_fibfib ((n - 2) as nat) + spec_fibfib ((n - 3) as nat) } }\nfn fibfib (x : u32) -> (ret : Option < u32 >) ensures ret . is_some () ==> spec_fibfib (x as nat) == ret . unwrap () , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/063-fibfib_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2d5c23d76df7", "function_name": "fibfib", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_481feda38498", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "481feda38498", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ed3d551422ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn fold_constants_aexp(a: AExp) -> AExp\n    {\n    match a {\n        AExp::ANum { n } => AExp::ANum { n },\n        AExp::AId { x } => AExp::AId { x },\n        AExp::APlus { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 + n2 },\n                (a1f, a2f) => AExp::APlus { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n        AExp::AMinus { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 - n2 },\n                (a1f, a2f) => AExp::AMinus { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n        AExp::AMult { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 * n2 },\n                (a1f, a2f) => AExp::AMult { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases a", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn fold_constants_aexp(a: AExp) -> AExp\n    decreases a\n{\n    match a {\n        AExp::ANum { n } => AExp::ANum { n },\n        AExp::AId { x } => AExp::AId { x },\n        AExp::APlus { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 + n2 },\n                (a1f, a2f) => AExp::APlus { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n        AExp::AMinus { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 - n2 },\n                (a1f, a2f) => AExp::AMinus { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n        AExp::AMult { a1, a2 } => {\n            let a1_folded = fold_constants_aexp(*a1);\n            let a2_folded = fold_constants_aexp(*a2);\n            match (a1_folded, a2_folded) {\n                (AExp::ANum { n: n1 }, AExp::ANum { n: n2 }) => AExp::ANum { n: n1 * n2 },\n                (a1f, a2f) => AExp::AMult { a1: Box::new(a1f), a2: Box::new(a2f) },\n            }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "equiv_verus.rs", "verified": true, "metadata": {"original_id": "ed3d551422ae", "function_name": "fold_constants_aexp", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_1e144a06fd44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_some_no_none<T>(inner_outputs: Set<T>)\n    \n{\n}\n\n} // verus!", "target_text": "ensures !gen_some_outputs(inner_outputs).contains(Option::None)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_some_no_none<T>(inner_outputs: Set<T>)\n    ensures !gen_some_outputs(inner_outputs).contains(Option::None)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_option.rs", "verified": true, "metadata": {"original_id": "1e144a06fd44", "function_name": "gen_some_no_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_374cf55dc764", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)   { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "target_text": "requires index <= a . len () , a . len () > 0 \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index \ndecreases a . len () - index , a . len () - index ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "374cf55dc764", "function_name": "max_array_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e1a807ad74df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn drop(l: List, n: nat) -> List n {\n    if n == 0 { l }\n    else { match l {\n        List::Nil => List::Nil,\n        List::Cons { tail, .. } => drop(*tail, (n-1) as nat)\n    }}\n}\n\n} // verus!", "target_text": "decreases l", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn drop(l: List, n: nat) -> List decreases l, n {\n    if n == 0 { l }\n    else { match l {\n        List::Nil => List::Nil,\n        List::Cons { tail, .. } => drop(*tail, (n-1) as nat)\n    }}\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_list_ops.rs", "verified": true, "metadata": {"original_id": "e1a807ad74df", "function_name": "drop", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_c08d9d515981", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ring_eval_poly_int(coeffs: Seq<int>, x: int) -> int\n    {\n    if coeffs.len() == 0 {\n        ring_zero_int()\n    } else {\n        ring_add_int(\n            coeffs[0],\n            ring_mul_int(x, ring_eval_poly_int(coeffs.skip(1), x))\n        )\n    }\n}\n\n} // verus!", "target_text": "decreases coeffs.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ring_eval_poly_int(coeffs: Seq<int>, x: int) -> int\n    decreases coeffs.len()\n{\n    if coeffs.len() == 0 {\n        ring_zero_int()\n    } else {\n        ring_add_int(\n            coeffs[0],\n            ring_mul_int(x, ring_eval_poly_int(coeffs.skip(1), x))\n        )\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_ring.rs", "verified": true, "metadata": {"original_id": "c08d9d515981", "function_name": "ring_eval_poly_int", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_530a59003962", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)   { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n  { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n  { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len ()\nensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i]\ndecreases n - i, n - j\ninvariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k], 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/WIP/WIP__transpose_matrix_iter_3_current.rs", "verified": true, "metadata": {"original_id": "530a59003962", "function_name": "transpose", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fcc40bdcef11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >)   { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len ()  { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "target_text": "requires start <= chars . len (), letter_combinations_precond (digits @)\nensures result == is_valid_digit (c), result @ == digit_to_letters (c), letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @))\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1, 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >) requires letter_combinations_precond (digits @) ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "fcc40bdcef11", "function_name": "letter_combinations", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1f4ecf5f95a2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn positive_negative_disjoint(bound: nat)\n    \n{\n    if gen_negative_outputs(bound).contains(n) {\n            gen_negative_correct(bound, n);\n            \n        }\n    }\n}\n\n} // verus!", "target_text": "ensures gen_int_intersect(gen_positive_outputs(bound), gen_negative_outputs(bound)) =~= Set::empty()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn positive_negative_disjoint(bound: nat)\n    ensures gen_int_intersect(gen_positive_outputs(bound), gen_negative_outputs(bound)) =~= Set::empty()\n{\n    assert forall|n: int| !gen_int_intersect(gen_positive_outputs(bound), gen_negative_outputs(bound)).contains(n) by {\n        if gen_positive_outputs(bound).contains(n) {\n            gen_positive_correct(bound, n);\n            assert(n > 0);\n        }\n        if gen_negative_outputs(bound).contains(n) {\n            gen_negative_correct(bound, n);\n            assert(n < 0);\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "1f4ecf5f95a2", "function_name": "positive_negative_disjoint", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ab4797b84e5b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_test_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ab4797b84e5b", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8c31501366df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx\ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "8c31501366df", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1751f905c120", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn parent_child_relation(i: nat)\n\n{}\n\n} // verus!", "target_text": "requires i > 0\n    ensures parent(left_child(parent(i))) == parent(i) || parent(right_child(parent(i))) == parent(i)\nensures parent(left_child(parent(i))) == parent(i) || parent(right_child(parent(i))) == parent(i)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn parent_child_relation(i: nat)\n    requires i > 0\n    ensures parent(left_child(parent(i))) == parent(i) || parent(right_child(parent(i))) == parent(i)\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_heap_def.rs", "verified": true, "metadata": {"original_id": "1751f905c120", "function_name": "parent_child_relation", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_7d8a2ff74a16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_lt_nat_sound(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_lt_nat(a, b)) <==> (a < b)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_lt_nat_sound(a: nat, b: nat)\n    ensures dec_to_bool(dec_lt_nat(a, b)) <==> (a < b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_ord.rs", "verified": true, "metadata": {"original_id": "7d8a2ff74a16", "function_name": "dec_lt_nat_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_086588b7d2c2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn count_empty(v: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures count(Seq::<nat>::empty(), v) == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn count_empty(v: nat)\n    ensures count(Seq::<nat>::empty(), v) == 0\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_perm_count.rs", "verified": true, "metadata": {"original_id": "086588b7d2c2", "function_name": "count_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_71383fe86069", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "71383fe86069", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_8b030ce1d5f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn seq_exists_dec(s: Seq<nat>, p: spec_fn(nat) -> bool) -> bool\n    {\n    if s.len() == 0 {\n        false\n    } else {\n        p(s[0]) || seq_exists_dec(s.skip(1), p)\n    }\n}\n\n} // verus!", "target_text": "decreases s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn seq_exists_dec(s: Seq<nat>, p: spec_fn(nat) -> bool) -> bool\n    decreases s.len()\n{\n    if s.len() == 0 {\n        false\n    } else {\n        p(s[0]) || seq_exists_dec(s.skip(1), p)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_decide_def.rs", "verified": true, "metadata": {"original_id": "8b030ce1d5f1", "function_name": "seq_exists_dec", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_6d6abc8ecfff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j \ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j , { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "6d6abc8ecfff", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1a323275286e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1a323275286e", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_42e2e4a3e5e9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_cache_empty(cap: nat)  { reveal_with_fuel(lru_get, 2); }\n\n} // verus!", "target_text": "ensures !lru_contains(lru_empty(cap), 42)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_cache_empty(cap: nat) ensures !lru_contains(lru_empty(cap), 42) { reveal_with_fuel(lru_get, 2); }\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_lru_cache.rs", "verified": true, "metadata": {"original_id": "42e2e4a3e5e9", "function_name": "empty_cache_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e4fbf149649e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn binary_shrink_decreasing(n: nat)\n\n{\n    assume(forall|i: int| 0 <= i < binary_shrink(n).len() ==> binary_shrink(n)[i] < n);\n}\n\n} // verus!", "target_text": "requires n > 0\n    ensures forall|i: int| 0 <= i < binary_shrink(n).len() ==> binary_shrink(n)[i] < n\nensures forall|i: int| 0 <= i < binary_shrink(n).len() ==> binary_shrink(n)[i] < n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn binary_shrink_decreasing(n: nat)\n    requires n > 0\n    ensures forall|i: int| 0 <= i < binary_shrink(n).len() ==> binary_shrink(n)[i] < n\n{\n    assume(forall|i: int| 0 <= i < binary_shrink(n).len() ==> binary_shrink(n)[i] < n);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_runner_shrink.rs", "verified": true, "metadata": {"original_id": "e4fbf149649e", "function_name": "binary_shrink_decreasing", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_0f778607c179", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires prev_nums . len () == lengths . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_length_ending_at_curr (prev_nums : & Vec < i32 > , lengths : & Vec < usize > , curr_num : i32) -> (result : usize) requires prev_nums . len () == lengths . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_32/verina_advanced_32.rs", "verified": true, "metadata": {"original_id": "0f778607c179", "function_name": "find_length_ending_at_curr", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a99a3561c276", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn aequiv_trans(a1: AExp, a2: AExp, a3: AExp)\n\n{\n    // Follows from transitivity of equality\n}\n\n} // verus!", "target_text": "requires aequiv(a1, a2),\n        aequiv(a2, a3),\n    ensures aequiv(a1, a3)\nensures aequiv(a1, a3)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn aequiv_trans(a1: AExp, a2: AExp, a3: AExp)\n    requires\n        aequiv(a1, a2),\n        aequiv(a2, a3),\n    ensures aequiv(a1, a3)\n{\n    // Follows from transitivity of equality\n}\n\n} // verus!", "source": "coq_translation", "source_file": "equiv_verus.rs", "verified": true, "metadata": {"original_id": "a99a3561c276", "function_name": "aequiv_trans", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_b577db116855", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_state_is_empty()\n    \n{\n    }\n\n} // verus!", "target_text": "ensures forall|x: Id| !state_contains(empty_state(), x)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_state_is_empty()\n    ensures forall|x: Id| !state_contains(empty_state(), x)\n{\n    assert forall|x: Id| !state_contains(empty_state(), x) by {\n        assert(!Map::<Id, Value>::empty().dom().contains(x));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_state.rs", "verified": true, "metadata": {"original_id": "b577db116855", "function_name": "empty_state_is_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_d0c86e33c6fb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d0c86e33c6fb", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_1de965d92f4c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { let mut max_sum : i32 = 0 ; let n = arr . len () ; let mut start = 0 ; while start < n { let mut len = k as usize ; while start + len <= n { let mut current_sum : i32 = 0 ; let mut i = start ; while i < start + len { current_sum = current_sum + arr [i] ; i += 1 ; } if current_sum > max_sum { max_sum = current_sum ; } len += k as usize ; } start += 1 ; } max_sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_44/verina_advanced_44_impl.rs", "verified": true, "metadata": {"original_id": "1de965d92f4c", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_03bd53cb96eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn filter_gt_bounded(s: Seq<nat>, pivot: nat)\n    \n    {\n    reveal_with_fuel(filter_gt, 2);\n    if s.len() > 0 {\n        filter_gt_bounded(s.skip(1), pivot);\n    }\n    assume(forall|i: int| 0 <= i < filter_gt(s, pivot).len() as int ==>\n        #[trigger] filter_gt(s, pivot)[i] > pivot);\n}\n\n} // verus!", "target_text": "ensures forall|i: int| 0 <= i < filter_gt(s, pivot).len() as int ==>\n        #[trigger] filter_gt(s, pivot)[i] > pivot\n    decreases s.len()\ndecreases s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn filter_gt_bounded(s: Seq<nat>, pivot: nat)\n    ensures forall|i: int| 0 <= i < filter_gt(s, pivot).len() as int ==>\n        #[trigger] filter_gt(s, pivot)[i] > pivot\n    decreases s.len()\n{\n    reveal_with_fuel(filter_gt, 2);\n    if s.len() > 0 {\n        filter_gt_bounded(s.skip(1), pivot);\n    }\n    assume(forall|i: int| 0 <= i < filter_gt(s, pivot).len() as int ==>\n        #[trigger] filter_gt(s, pivot)[i] > pivot);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_quick.rs", "verified": true, "metadata": {"original_id": "03bd53cb96eb", "function_name": "filter_gt_bounded", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_0451d58550f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32)   { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "target_text": "requires d > 0, count_sum_divisible_by_precond (n as nat , d as nat)\nensures result == is_sum_divisible_by (x as nat , d as nat), result == sum_of_digits (x as nat), result == count_sum_divisible_by_spec (n as nat , d as nat)\ndecreases n, x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_sum_divisible_by_spec (n : nat , d : nat) -> nat recommends d > 0 decreases n { if n == 0 { 0nat } else { let prev = (n - 1) as nat ; count_sum_divisible_by_spec (prev , d) + (if is_sum_divisible_by (prev , d) { 1nat } else { 0nat }) } }\nspec fn count_sum_divisible_by_precond (n : nat , d : nat) -> bool { d > 0 }\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n# [verifier :: external_body] fn count_sum_divisible_by (n : u32 , d : u32) -> (result : u32) requires count_sum_divisible_by_precond (n as nat , d as nat) ensures result == count_sum_divisible_by_spec (n as nat , d as nat) { let mut count = 0u32 ; let mut i = 0u32 ; while i < n { if is_sum_divisible_by_exec (i , d) { count = count + 1 ; } i = i + 1 ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "0451d58550f1", "function_name": "count_sum_divisible_by", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b197612d2de2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) \ninvariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_454_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b197612d2de2", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_751387d56f1f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique.rs", "verified": true, "metadata": {"original_id": "751387d56f1f", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_1abcb777eff1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "1abcb777eff1", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_ad5e04a97e75", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn disj_syllogism_right(p: bool, q: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p || q, !q\n    ensures p\nensures p", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn disj_syllogism_right(p: bool, q: bool)\n    requires p || q, !q\n    ensures p\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_disjunction.rs", "verified": true, "metadata": {"original_id": "ad5e04a97e75", "function_name": "disj_syllogism_right", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_fea20d875003", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i \ninvariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "fea20d875003", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1b7c625ce440", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)   { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len ()  { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "target_text": "requires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>\ninvariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==>", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1b7c625ce440", "function_name": "pluck_smallest_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_e7d4b3a9c731", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max \ndecreases a . len () - idx\ninvariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/035-max-element_iter_3_current.rs", "verified": true, "metadata": {"original_id": "e7d4b3a9c731", "function_name": "max_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4238801bac99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)   { return false ; }\n\n} // verus!", "target_text": "requires true \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4238801bac99", "function_name": "tangent", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_c665d8bd494e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c665d8bd494e", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_8c81c80d49c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool)   { let result = n % 11 == 0 ; if result {  } else { proof {  } } } result }\n\n} // verus!", "target_text": "requires is_divisible_by_11_precond (n as int)\nensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible_by_11_precond (n : int) -> bool { true }\nfn is_divisible_by_11 (n : i64) -> (result : bool) requires is_divisible_by_11_precond (n as int) ensures (result ==> exists | k : int | # [trigger] (11 * k) == n as int) && (! result ==> forall | k : int | # [trigger] (11 * k) != n as int) { let result = n % 11 == 0 ; if result { proof { let k = n as int / 11 ; assert (11 * k == n as int) ; } } else { proof { assert (n as int % 11 != 0) ; assert (forall | k : int | # [trigger] (11 * k) != n as int) by { if exists | k : int | # [trigger] (11 * k) == n as int { let k = choose | k : int | # [trigger] (11 * k) == n as int ; assert (n as int % 11 == 0) ; assert (false) ; } } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_3/verina_basic_3_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8c81c80d49c3", "function_name": "is_divisible_by_11", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a899b374f623", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a899b374f623", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_c8304568ff0a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)   { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "requires 0 < i && i + 1 < s . len () \nensures is <==> three_distinct_spec (s @ , i as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c8304568ff0a", "function_name": "three_distinct", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f4bac1a13b76", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >)  { return None ; }\n\n} // verus!", "target_text": "requires two_sum_precond (nums @ , target)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn two_sum_precond (nums : Seq < i32 > , target : i32) -> bool { true }\nfn two_sum (nums : Vec < i32 > , target : i32) -> (result : Option < (usize , usize) >) requires two_sum_precond (nums @ , target) { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_79/verina_advanced_79_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f4bac1a13b76", "function_name": "two_sum", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f59b35d8bc93", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_consecutive_numbers (arr : & Vec < i32 >) -> (is_consecutive : bool)   { for idx in 0 .. arr . len () - 1  {    if arr [idx] + 1 != arr [idx + 1] { return false ; } } return true ; }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) \nensures is_consecutive == (forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 ==> (arr [i] + 1 == arr [j])) \ninvariant arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 && j <= idx ==> (arr [i] + 1 == arr [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_consecutive_numbers (arr : & Vec < i32 >) -> (is_consecutive : bool) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , ensures is_consecutive == (forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 ==> (arr [i] + 1 == arr [j])) , { for idx in 0 .. arr . len () - 1 invariant arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> (0 <= # [trigger] arr [i] + 1 < MAX) , forall | i : int , j : int | 0 <= i < j < arr . len () && j == i + 1 && j <= idx ==> (arr [i] + 1 == arr [j]) , { assert (idx < arr . len () - 1) ; assert (idx + 1 < arr . len ()) ; assert (0 <= arr [idx as int] + 1 < MAX) ; if arr [idx] + 1 != arr [idx + 1] { return false ; } } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_472_impl.rs", "verified": true, "metadata": {"original_id": "f59b35d8bc93", "function_name": "contains_consecutive_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_eaf2a2271d61", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { return 0 ; }\n\n} // verus!", "target_text": "ensures pos <= dp . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_24/verina_advanced_24_iter_0_original.rs", "verified": true, "metadata": {"original_id": "eaf2a2271d61", "function_name": "binary_search_position", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b75a5b215173", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool)  { x % 2 == 0 }\n\n} // verus!", "target_text": "ensures (x % 2 == 0) == is_even", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_is_even (x : u32) -> (is_even : bool) ensures (x % 2 == 0) == is_even { x % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_is_even/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b75a5b215173", "function_name": "compute_is_even", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0bd2de8dca8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_size(t: Tree) -> nat\n    {\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } =>\n            1 + tree_size(*left) + tree_size(*right),\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn tree_size(t: Tree) -> nat\n    decreases t\n{\n    match t {\n        Tree::Leaf => 0,\n        Tree::Node { left, value: _, right } =>\n            1 + tree_size(*left) + tree_size(*right),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_traverse.rs", "verified": true, "metadata": {"original_id": "0bd2de8dca8e", "function_name": "tree_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_bb646573475a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "bb646573475a", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7cdebe7cc5c4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_eq(s: Seq<nat>, v: nat) -> nat\n    {\n    if s.len() == 0 {\n        0\n    } else if s[0] == v {\n        1 + count_eq(s.skip(1), v)\n    } else {\n        count_eq(s.skip(1), v)\n    }\n}\n\n} // verus!", "target_text": "decreases s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_eq(s: Seq<nat>, v: nat) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == v {\n        1 + count_eq(s.skip(1), v)\n    } else {\n        count_eq(s.skip(1), v)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_perm_swap.rs", "verified": true, "metadata": {"original_id": "7cdebe7cc5c4", "function_name": "count_eq", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_cb6172ad4867", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb6172ad4867", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_916dc54cfc27", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_bool_law()\n    \n{\n\n}\n\n} // verus!", "target_text": "ensures shrink_bool(false).len() == 0,\n            shrink_bool(true).len() == 1,\n            shrink_bool(true)[0] == false", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_bool_law()\n    ensures shrink_bool(false).len() == 0,\n            shrink_bool(true).len() == 1,\n            shrink_bool(true)[0] == false\n{\n    assert(shrink_bool(false) =~= Seq::empty());\n    assert(shrink_bool(true) =~= seq![false]);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "916dc54cfc27", "function_name": "shrink_bool_law", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_9fa61fc375fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_comm_int(a: int, b: int)  {}\n\n} // verus!", "target_text": "ensures a * b == b * a", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_comm_int(a: int, b: int) ensures a * b == b * a {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_int_arith.rs", "verified": true, "metadata": {"original_id": "9fa61fc375fe", "function_name": "mul_comm_int", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_4a8c135ac4f9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires first_duplicate_precond (lst @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_12/verina_advanced_12.rs", "verified": true, "metadata": {"original_id": "4a8c135ac4f9", "function_name": "first_duplicate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_a2c6d590c065", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a2c6d590c065", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3af88082379a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_all_different(n: nat, x: nat, y: nat)\n\n{\n    reveal_with_fuel(find_root_fuel, 2);\n    assume(!same_set(uf_init(n), x, y));\n}\n\n} // verus!", "target_text": "requires x < n, y < n, x != y\n    ensures !same_set(uf_init(n), x, y)\nensures !same_set(uf_init(n), x, y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn init_all_different(n: nat, x: nat, y: nat)\n    requires x < n, y < n, x != y\n    ensures !same_set(uf_init(n), x, y)\n{\n    reveal_with_fuel(find_root_fuel, 2);\n    assume(!same_set(uf_init(n), x, y));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_union_find.rs", "verified": true, "metadata": {"original_id": "3af88082379a", "function_name": "init_all_different", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_0f2f1427ef78", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize))   { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len ()  { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len ()  { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "target_text": "requires numbers . len () >= 2 \nensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) \ndecreases seq . len () , numbers . len () - i , numbers . len () - i \ninvariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_755_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0f2f1427ef78", "function_name": "second_smallest", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1f681c77b4c7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  {    let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 \nensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] \ndecreases s . len () - i \ninvariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "1f681c77b4c7", "function_name": "extract_rear_chars", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_29d9c6a0ca2c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires start <= nums . len ()\ndecreases nums . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_15/verina_advanced_15.rs", "verified": true, "metadata": {"original_id": "29d9c6a0ca2c", "function_name": "loop_search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_2033daf455eb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >)  { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { ch } else { str1 [k] }) , { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_blanks_with_chars (str1 : & [u8] , ch : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if str1 [i] == 32 { ch } else { str1 [i] }) , { let mut out_str : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , out_str @ . len () == index , forall | k : int | 0 <= k < index ==> out_str [k] == (if str1 [k] == 32 { ch } else { str1 [k] }) , decreases str1 . len () - index { if (str1 [index] == 32) { out_str . push (ch) ; } else { out_str . push (str1 [index]) ; } index += 1 ; } out_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "2033daf455eb", "function_name": "replace_blanks_with_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e2deed44497c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e2deed44497c", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_960dc809f6e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "960dc809f6e3", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d2b21a9d851b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d2b21a9d851b", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b64b42983e26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn progress_true()\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures progress_holds(Tm::Tru)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn progress_true()\n    ensures progress_holds(Tm::Tru)\n{\n    assert(value(Tm::Tru));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "stlc_prop_verus.rs", "verified": true, "metadata": {"original_id": "b64b42983e26", "function_name": "progress_true", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_af4639a7be50", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ctx_extend_other(ctx: Context, x: Id, y: Id, ty: Ty)\n\n{\n    if ctx.dom().contains(y) {\n\n    } else {\n        \n    }\n}\n\n} // verus!", "target_text": "requires x != y\n    ensures ctx_lookup(ctx_extend(ctx, x, ty), y) == ctx_lookup(ctx, y)\nensures ctx_lookup(ctx_extend(ctx, x, ty), y) == ctx_lookup(ctx, y)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ctx_extend_other(ctx: Context, x: Id, y: Id, ty: Ty)\n    requires x != y\n    ensures ctx_lookup(ctx_extend(ctx, x, ty), y) == ctx_lookup(ctx, y)\n{\n    if ctx.dom().contains(y) {\n        assert(ctx.insert(x, ty).dom().contains(y));\n        assert(ctx.insert(x, ty)[y] == ctx[y]);\n    } else {\n        assert(!ctx.insert(x, ty).dom().contains(y));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_context.rs", "verified": true, "metadata": {"original_id": "af4639a7be50", "function_name": "ctx_extend_other", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_647733a81b77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn modus_ponens(p: bool, q: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p, p ==> q\n    ensures q\nensures q", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn modus_ponens(p: bool, q: bool)\n    requires p, p ==> q\n    ensures q\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "647733a81b77", "function_name": "modus_ponens", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_a86b79beb50f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_and(a: bool, b: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_not_bool(dec_to_bool(dec_and_bool(a, b)))) ==\n            dec_to_bool(dec_or_bool(!a, !b))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_and(a: bool, b: bool)\n    ensures dec_to_bool(dec_not_bool(dec_to_bool(dec_and_bool(a, b)))) ==\n            dec_to_bool(dec_or_bool(!a, !b))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_bool.rs", "verified": true, "metadata": {"original_id": "a86b79beb50f", "function_name": "dec_demorgan_and", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_3d27422846e8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32)   { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "requires my_min_precond (a as int , b as int) \nensures my_min_postcond (a as int , b as int , result as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_8/verina_basic_8_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3d27422846e8", "function_name": "my_min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_61406431865f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { for i in 0 .. arr . len ()  { if arr [i] % 2 != 0 {   return Some (i) ; } } None }\n\n} // verus!", "target_text": "ensures check_find_first_odd (arr , index) \ninvariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0) { if arr [i] % 2 != 0 { assert (forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)) ; assert (arr [i as int] % 2 != 0) ; return Some (i) ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "61406431865f", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6efd117c7b65", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn hypothetical_syllogism(p: bool, q: bool, r: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p ==> q, q ==> r\n    ensures p ==> r\nensures p ==> r", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn hypothetical_syllogism(p: bool, q: bool, r: bool)\n    requires p ==> q, q ==> r\n    ensures p ==> r\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_implies.rs", "verified": true, "metadata": {"original_id": "6efd117c7b65", "function_name": "hypothetical_syllogism", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_9d1ba670100f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size\ndecreases a . len (), size - i\ninvariant i <= size , result . len () == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dec4df5a603e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_produces_shorter<A>(s: Seq<A>)\n\n{\n}\n\n} // verus!", "target_text": "requires s.len() > 0\n    ensures forall|i: int| 0 <= i < shrink_list_by_removal(s).len() ==>\n        shrink_list_by_removal(s)[i].len() < s.len()\nensures forall|i: int| 0 <= i < shrink_list_by_removal(s).len() ==>\n        shrink_list_by_removal(s)[i].len() < s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn shrink_produces_shorter<A>(s: Seq<A>)\n    requires s.len() > 0\n    ensures forall|i: int| 0 <= i < shrink_list_by_removal(s).len() ==>\n        shrink_list_by_removal(s)[i].len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_shrink_list.rs", "verified": true, "metadata": {"original_id": "dec4df5a603e", "function_name": "shrink_produces_shorter", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_0b80a21ebf16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)   { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1\ndecreases f - c + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "0b80a21ebf16", "function_name": "binary_search_recursive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_5d77e5301987", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "5d77e5301987", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bae2c7702c04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "bae2c7702c04", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_befeb2ba707c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "befeb2ba707c", "function_name": "count_digits_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7ae15ff834b5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64)   { 3 * x }\n\n} // verus!", "target_text": "requires - 1000000 <= x <= 1000000 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7ae15ff834b5", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b22aeab90b3a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "b22aeab90b3a", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_2d94ab73a521", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant result @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant result @ == a @ . subrange (0 , i as int) { result . push (a [i]) ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2d94ab73a521", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_3b317f7559d1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b317f7559d1", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_e2ed5df5f5bf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)   { let mut i = 0 ; while i < x . len ()  { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB \nensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 \ndecreases x . len () - i\ninvariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | 0 <= k < x . len () ==> old (x) @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { x [i] = x [i] + 4 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "e2ed5df5f5bf", "function_name": "myfun2", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_be78b18779d9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_all_sound(ds: Seq<Dec>)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_and_all(ds)) == dec_to_bool(dec_and_all_helper(ds, 0))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_all_sound(ds: Seq<Dec>)\n    ensures dec_to_bool(dec_and_all(ds)) == dec_to_bool(dec_and_all_helper(ds, 0))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_and.rs", "verified": true, "metadata": {"original_id": "be78b18779d9", "function_name": "dec_and_all_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e18fae1acc6e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_ge_antisymmetric(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_le_nat(a, b)) == dec_to_bool(dec_ge_nat(b, a))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_ge_antisymmetric(a: nat, b: nat)\n    ensures dec_to_bool(dec_le_nat(a, b)) == dec_to_bool(dec_ge_nat(b, a))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_ord.rs", "verified": true, "metadata": {"original_id": "e18fae1acc6e", "function_name": "dec_le_ge_antisymmetric", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_9313283c3d39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_99/verina_basic_99_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9313283c3d39", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bad90820d702", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32)   {     let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut min_index = 0 ; for i in 1 .. arr . len ()  {    if arr [i] [1] < min_second { min_second = arr [i] [1] ; result_first = arr [i] [0] ; min_index = i ; } }     result_first }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 \nensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) \ninvariant arr . len () > 0 , forall | k : int | 0 <= k < arr . len () ==> arr [k] . len () >= 2 , 0 <= min_index < arr . len () , min_index < i , min_second == arr [min_index as int] [1] , result_first == arr [min_index as int] [0] , forall | j : int | 0 <= j < i ==> min_second <= arr [j] [1] , i <= arr . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_second_value_first (arr : & Vec < Vec < i32 > >) -> (first_of_min_second : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> # [trigger] arr [i] . len () >= 2 , ensures exists | i : int | 0 <= i < arr . len () && first_of_min_second == # [trigger] arr [i] [0] && (forall | j : int | 0 <= j < arr . len () ==> (arr [i] [1] <= # [trigger] arr [j] [1])) , { assert (arr . len () > 0) ; assert (0 < arr . len ()) ; assert (arr [0] . len () >= 2) ; assert (0 < arr [0] . len () && 1 < arr [0] . len ()) ; let mut min_second = arr [0] [1] ; let mut result_first = arr [0] [0] ; let mut min_index = 0 ; for i in 1 .. arr . len () invariant arr . len () > 0 , forall | k : int | 0 <= k < arr . len () ==> arr [k] . len () >= 2 , 0 <= min_index < arr . len () , min_index < i , min_second == arr [min_index as int] [1] , result_first == arr [min_index as int] [0] , forall | j : int | 0 <= j < i ==> min_second <= arr [j] [1] , i <= arr . len () , { assert (i < arr . len ()) ; assert (arr [i as int] . len () >= 2) ; assert (1 < arr [i as int] . len ()) ; if arr [i] [1] < min_second { min_second = arr [i] [1] ; result_first = arr [i] [0] ; min_index = i ; } } assert (forall | j : int | 0 <= j < arr . len () ==> min_second <= arr [j] [1]) ; assert (0 <= min_index < arr . len ()) ; assert (result_first == arr [min_index as int] [0]) ; assert (min_second == arr [min_index as int] [1]) ; result_first }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_94_impl.rs", "verified": true, "metadata": {"original_id": "bad90820d702", "function_name": "min_second_value_first", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_d3ea3c5f63ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_false_evals_false()\n    \n{\n}\n\n} // verus!", "target_text": "ensures eval_property(prop_false()) == false", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn prop_false_evals_false()\n    ensures eval_property(prop_false()) == false\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_checker_property.rs", "verified": true, "metadata": {"original_id": "d3ea3c5f63ec", "function_name": "prop_false_evals_false", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_3069463d1a00", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i += 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/max_index_iter_2_current.rs", "verified": true, "metadata": {"original_id": "3069463d1a00", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_381bdab64a2a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn arbitrary_int_in_range(seed: nat, size: nat)\n\n{\n    let raw = (seed % (2 * size + 1)) as int;\n    \n    let result = raw - size as int;\n    \n}\n\n} // verus!", "target_text": "requires size > 0\n    ensures -(size as int) <= arbitrary_int(seed, size) <= size as int\nensures -(size as int) <= arbitrary_int(seed, size) <= size as int", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn arbitrary_int_in_range(seed: nat, size: nat)\n    requires size > 0\n    ensures -(size as int) <= arbitrary_int(seed, size) <= size as int\n{\n    let raw = (seed % (2 * size + 1)) as int;\n    assert(0 <= raw < (2 * size + 1) as int);\n    let result = raw - size as int;\n    assert(-(size as int) <= result <= size as int);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_arbitrary.rs", "verified": true, "metadata": {"original_id": "381bdab64a2a", "function_name": "arbitrary_int_in_range", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_f74c1826b71d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn iff_elim_left(p: bool, q: bool)\n\n{\n}\n\n} // verus!", "target_text": "requires p <==> q, p\n    ensures q\nensures q", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn iff_elim_left(p: bool, q: bool)\n    requires p <==> q, p\n    ensures q\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_prop.rs", "verified": true, "metadata": {"original_id": "f74c1826b71d", "function_name": "iff_elim_left", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_cc3380315826", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_none<T, U>(f: spec_fn(T) -> U)\n    \n{\n}\n\n} // verus!", "target_text": "ensures is_none(map_option::<T, U>(None, f))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_none<T, U>(f: spec_fn(T) -> U)\n    ensures is_none(map_option::<T, U>(None, f))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_option_def.rs", "verified": true, "metadata": {"original_id": "cc3380315826", "function_name": "map_none", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_8f912cd18533", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "8f912cd18533", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_17b7d9170e2d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_bool_sound(a: bool, b: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_eq_bool(a, b)) <==> (a == b)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_eq_bool_sound(a: bool, b: bool)\n    ensures dec_to_bool(dec_eq_bool(a, b)) <==> (a == b)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_eq.rs", "verified": true, "metadata": {"original_id": "17b7d9170e2d", "function_name": "dec_eq_bool_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_a239dbf1c5f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32) requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_7/verina_advanced_7_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a239dbf1c5f7", "function_name": "binary_to_decimal", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_8dc92c9af408", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_count_pair_bool_is_product()\n    \n{\n\n}\n\n} // verus!", "target_text": "ensures enum_count_pair_bool() == enum_count_bool() * enum_count_bool()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_count_pair_bool_is_product()\n    ensures enum_count_pair_bool() == enum_count_bool() * enum_count_bool()\n{\n    assert(enum_count_pair_bool() == 4);\n    assert(enum_count_bool() == 2);\n    assert(2 * 2 == 4);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_enum.rs", "verified": true, "metadata": {"original_id": "8dc92c9af408", "function_name": "enum_count_pair_bool_is_product", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_55fd6833f96e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn dec_and_all_helper(ds: Seq<Dec>, i: int) -> Dec\n    {\n    if i >= ds.len() {\n        Dec::Yes\n    } else {\n        match ds[i] {\n            Dec::No => Dec::No,\n            Dec::Yes => dec_and_all_helper(ds, i + 1),\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases ds.len() - i when i >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn dec_and_all_helper(ds: Seq<Dec>, i: int) -> Dec\n    decreases ds.len() - i when i >= 0\n{\n    if i >= ds.len() {\n        Dec::Yes\n    } else {\n        match ds[i] {\n            Dec::No => Dec::No,\n            Dec::Yes => dec_and_all_helper(ds, i + 1),\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_and.rs", "verified": true, "metadata": {"original_id": "55fd6833f96e", "function_name": "dec_and_all_helper", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_8b9a3246ecde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8b9a3246ecde", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_cacff53fe20f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn sequence_nested<A>(xss: Seq<Seq<Option<A>>>) -> Option<Seq<Seq<A>>>\n    {\n    if xss.len() == 0 {\n        Option::Some(Seq::empty())\n    } else {\n        match (sequence_seq_option(xss[0]), sequence_nested(xss.skip(1))) {\n            (Option::Some(xs), Option::Some(rest)) => Option::Some(seq![xs].add(rest)),\n            _ => Option::None,\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases xss.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn sequence_nested<A>(xss: Seq<Seq<Option<A>>>) -> Option<Seq<Seq<A>>>\n    decreases xss.len()\n{\n    if xss.len() == 0 {\n        Option::Some(Seq::empty())\n    } else {\n        match (sequence_seq_option(xss[0]), sequence_nested(xss.skip(1))) {\n            (Option::Some(xs), Option::Some(rest)) => Option::Some(seq![xs].add(rest)),\n            _ => Option::None,\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_traversable.rs", "verified": true, "metadata": {"original_id": "cacff53fe20f", "function_name": "sequence_nested", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_332009c5997f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn swap_swap<A, B>(p: (A, B))  {}\n\n} // verus!", "target_text": "ensures swap(swap(p)) == p", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn swap_swap<A, B>(p: (A, B)) ensures swap(swap(p)) == p {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_pair_def.rs", "verified": true, "metadata": {"original_id": "332009c5997f", "function_name": "swap_swap", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_419b0e2e73f0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - idx \ninvariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "419b0e2e73f0", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7ac87adca802", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn expr_size_positive(e: Expr)\n    \n    {\n    match e {\n        Expr::Var { .. } => {}\n        Expr::Lam { body, .. } => expr_size_positive(*body),\n        Expr::App { e1, e2 } => {\n            expr_size_positive(*e1);\n            expr_size_positive(*e2);\n        }\n        Expr::Tru => {}\n        Expr::Fls => {}\n        Expr::If { cond, then_br, else_br } => {\n            expr_size_positive(*cond);\n            expr_size_positive(*then_br);\n            expr_size_positive(*else_br);\n        }\n        Expr::Zero => {}\n        Expr::Succ { e } => expr_size_positive(*e),\n        Expr::Pred { e } => expr_size_positive(*e),\n        Expr::IsZero { e } => expr_size_positive(*e),\n        Expr::Add { e1, e2 } => {\n            expr_size_positive(*e1);\n            expr_size_positive(*e2);\n        }\n        Expr::Not { e } => expr_size_positive(*e),\n    }\n}\n\n} // verus!", "target_text": "ensures expr_size(e) >= 1\n    decreases e\ndecreases e", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn expr_size_positive(e: Expr)\n    ensures expr_size(e) >= 1\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => {}\n        Expr::Lam { body, .. } => expr_size_positive(*body),\n        Expr::App { e1, e2 } => {\n            expr_size_positive(*e1);\n            expr_size_positive(*e2);\n        }\n        Expr::Tru => {}\n        Expr::Fls => {}\n        Expr::If { cond, then_br, else_br } => {\n            expr_size_positive(*cond);\n            expr_size_positive(*then_br);\n            expr_size_positive(*else_br);\n        }\n        Expr::Zero => {}\n        Expr::Succ { e } => expr_size_positive(*e),\n        Expr::Pred { e } => expr_size_positive(*e),\n        Expr::IsZero { e } => expr_size_positive(*e),\n        Expr::Add { e1, e2 } => {\n            expr_size_positive(*e1);\n            expr_size_positive(*e2);\n        }\n        Expr::Not { e } => expr_size_positive(*e),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_shrink.rs", "verified": true, "metadata": {"original_id": "7ac87adca802", "function_name": "expr_size_positive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_9dc8ed2f674a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool)   { return false ; }\n\n} // verus!", "target_text": "requires c <= n , n == a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn fillK (a : & [int] , n : usize , k : int , c : usize) -> (b : bool) requires c <= n , n == a . len () , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9dc8ed2f674a", "function_name": "fillK", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4ad4ac703343", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lookup(d: nat, k: nat, t: Tree) -> nat\n    {\n    match t {\n        Tree::E => d,\n        Tree::T { left, key, value, right } =>\n            if k < key {\n                lookup(d, k, *left)\n            } else if k > key {\n                lookup(d, k, *right)\n            } else {\n                value\n            }\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn lookup(d: nat, k: nat, t: Tree) -> nat\n    decreases t\n{\n    match t {\n        Tree::E => d,\n        Tree::T { left, key, value, right } =>\n            if k < key {\n                lookup(d, k, *left)\n            } else if k > key {\n                lookup(d, k, *right)\n            } else {\n                value\n            }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_bst_delete.rs", "verified": true, "metadata": {"original_id": "4ad4ac703343", "function_name": "lookup", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_b11d94c23d98", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) \ndecreases str1 . len () - i\ninvariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b11d94c23d98", "function_name": "to_toggle_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0ff7ec34d139", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()\ndecreases v . len () - i\ninvariant 0 <= i <= v . len () , forall | j : int | 0 <= j < i ==> v [j] % 2 == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , forall | j : int | 0 <= j < i ==> v [j] % 2 == 0 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (forall | j : int | 0 <= j < i ==> v [j] % 2 == 0) ; assert (forall | j : int | 0 <= j < v . len () ==> v [j] % 2 == 0) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "0ff7ec34d139", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c7975defa497", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  {  new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases (k - 1) - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "c7975defa497", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4b532462b50b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4b532462b50b", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f1f5898c3bdf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn reverse_acc(s: Seq<nat>, acc: Seq<nat>) -> Seq<nat>\n    {\n    if s.len() == 0 {\n        acc\n    } else {\n        reverse_acc(s.skip(1), seq![s[0]] + acc)\n    }\n}\n\n} // verus!", "target_text": "decreases s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn reverse_acc(s: Seq<nat>, acc: Seq<nat>) -> Seq<nat>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        acc\n    } else {\n        reverse_acc(s.skip(1), seq![s[0]] + acc)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_seq_reverse.rs", "verified": true, "metadata": {"original_id": "f1f5898c3bdf", "function_name": "reverse_acc", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_65351c08791b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    {\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Mul { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "target_text": "decreases e", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn expr_size(e: Expr) -> nat\n    decreases e\n{\n    match e {\n        Expr::Var { .. } => 1,\n        Expr::Tru => 1,\n        Expr::Fls => 1,\n        Expr::If { cond, then_br, else_br } =>\n            1 + expr_size(*cond) + expr_size(*then_br) + expr_size(*else_br),\n        Expr::Zero => 1,\n        Expr::Succ { e } => 1 + expr_size(*e),\n        Expr::Pred { e } => 1 + expr_size(*e),\n        Expr::IsZero { e } => 1 + expr_size(*e),\n        Expr::And { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Or { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Not { e } => 1 + expr_size(*e),\n        Expr::Add { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n        Expr::Mul { e1, e2 } => 1 + expr_size(*e1) + expr_size(*e2),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_normalize.rs", "verified": true, "metadata": {"original_id": "65351c08791b", "function_name": "expr_size", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_f08edbdadb07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms2_impl.rs", "verified": true, "metadata": {"original_id": "f08edbdadb07", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_42fd355a8ad8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "42fd355a8ad8", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6feb82691110", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i : usize = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len () , v [odd_index as int] % 2 == 1\ndecreases v . len () - i\ninvariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () , v [odd_index as int] % 2 == 1 { let mut i : usize = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "6feb82691110", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e89a8ee9d629", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_compose<T, U, V>(o: Option<T>, f: spec_fn(T) -> U, g: spec_fn(U) -> V)\n    \n{\n}\n\n} // verus!", "target_text": "ensures map_option(map_option(o, f), g) == map_option(o, |x: T| g(f(x)))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn map_compose<T, U, V>(o: Option<T>, f: spec_fn(T) -> U, g: spec_fn(U) -> V)\n    ensures map_option(map_option(o, f), g) == map_option(o, |x: T| g(f(x)))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_option_def.rs", "verified": true, "metadata": {"original_id": "e89a8ee9d629", "function_name": "map_compose", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_c74fe1b57d6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(n: nat, m: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else {\n        add(mul((n - 1) as nat, m), m)\n    }\n}\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(n: nat, m: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else {\n        add(mul((n - 1) as nat, m), m)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "c74fe1b57d6b", "function_name": "mul", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_34b41bac24b8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) {  return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "34b41bac24b8", "function_name": "any_value_exists", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8c8aa235938a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn zero_score_when_none_killed(total: nat)\n\n{\n    \n}\n\n} // verus!", "target_text": "requires total > 0\n    ensures mutation_score(0, total) == 0\nensures mutation_score(0, total) == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn zero_score_when_none_killed(total: nat)\n    requires total > 0\n    ensures mutation_score(0, total) == 0\n{\n    assert((0 * 100) / total == 0);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_mutation.rs", "verified": true, "metadata": {"original_id": "8c8aa235938a", "function_name": "zero_score_when_none_killed", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_25070bd26824", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ap_option_homomorphism<A, B>(f: spec_fn(A) -> B, x: A)\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures ap_option(pure_option(f), pure_option(x)) == pure_option(f(x))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ap_option_homomorphism<A, B>(f: spec_fn(A) -> B, x: A)\n    ensures ap_option(pure_option(f), pure_option(x)) == pure_option(f(x))\n{\n    assert(ap_option(Option::Some(f), Option::Some(x)) == Option::Some(f(x)));\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_applicative.rs", "verified": true, "metadata": {"original_id": "25070bd26824", "function_name": "ap_option_homomorphism", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_67e361506093", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "67e361506093", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_fdff90987a6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len ()  { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fdff90987a6f", "function_name": "unique", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ab64226ea226", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bool_and_left_identity(x: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures bool_and(bool_and_identity(), x) == x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn bool_and_left_identity(x: bool)\n    ensures bool_and(bool_and_identity(), x) == x\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_monoid.rs", "verified": true, "metadata": {"original_id": "ab64226ea226", "function_name": "bool_and_left_identity", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_733f0ff599ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos  { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len ()  { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires 0 <= pos < a . len () \nensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] \ndecreases pos - i , a . len () - j \ninvariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "733f0ff599ae", "function_name": "remove_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_32d92380bdf5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof_flatten_contains<T>(nested: Seq<Seq<Set<T>>>, i: int, j: int, x: T)\n\n{\n}\n\n} // verus!", "target_text": "requires 0 <= i < nested.len(),\n        0 <= j < nested[i].len(),\n        nested[i][j].contains(x),\n    ensures oneof_flatten(nested).contains(x)\nensures oneof_flatten(nested).contains(x)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn oneof_flatten_contains<T>(nested: Seq<Seq<Set<T>>>, i: int, j: int, x: T)\n    requires\n        0 <= i < nested.len(),\n        0 <= j < nested[i].len(),\n        nested[i][j].contains(x),\n    ensures oneof_flatten(nested).contains(x)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_oneof.rs", "verified": true, "metadata": {"original_id": "32d92380bdf5", "function_name": "oneof_flatten_contains", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_350655feed65", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool)   { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len ()  { if chars [i] != first_char { return false ; } i += 1 ; }  true }\n\n} // verus!", "target_text": "requires all_characters_same_precond (chars)\nensures all_characters_same_postcond (chars , result)\ndecreases chars . len () - i\ninvariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_38/verina_basic_38_impl.rs", "verified": true, "metadata": {"original_id": "350655feed65", "function_name": "all_characters_same", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b8409b9c1086", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "b8409b9c1086", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_938c5d5eff50", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mirror_height(t: Tree)  {\n    reveal_with_fuel(mirror, 2); reveal_with_fuel(tree_height, 2);\n    match t { Tree::E => {} Tree::T { left, right, .. } => { mirror_height(*left); mirror_height(*right); } }\n}\n\n} // verus!", "target_text": "ensures tree_height(mirror(t)) == tree_height(t) decreases t\ndecreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mirror_height(t: Tree) ensures tree_height(mirror(t)) == tree_height(t) decreases t {\n    reveal_with_fuel(mirror, 2); reveal_with_fuel(tree_height, 2);\n    match t { Tree::E => {} Tree::T { left, right, .. } => { mirror_height(*left); mirror_height(*right); } }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_mirror.rs", "verified": true, "metadata": {"original_id": "938c5d5eff50", "function_name": "mirror_height", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_422fb6277af5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn pq_delete_min_valid(pq: PriQueue)\n\n{\n    reveal_with_fuel(sorted, 2);\n}\n\n} // verus!", "target_text": "requires pq_valid(pq)\n    ensures pq_valid(pq_delete_min(pq))\nensures pq_valid(pq_delete_min(pq))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn pq_delete_min_valid(pq: PriQueue)\n    requires pq_valid(pq)\n    ensures pq_valid(pq_delete_min(pq))\n{\n    reveal_with_fuel(sorted, 2);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_priqueue_def.rs", "verified": true, "metadata": {"original_id": "422fb6277af5", "function_name": "pq_delete_min_valid", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_5a742015d7ee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_lookup(label: Label, ty: Ty) -> Option<Ty>\n    {\n    match ty {\n        Ty::TRNil => Option::None,\n        Ty::TRCons { label: l, ty: t, rest } =>\n            if l == label {\n                Option::Some(*t)\n            } else {\n                ty_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "target_text": "decreases ty", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_lookup(label: Label, ty: Ty) -> Option<Ty>\n    decreases ty\n{\n    match ty {\n        Ty::TRNil => Option::None,\n        Ty::TRCons { label: l, ty: t, rest } =>\n            if l == label {\n                Option::Some(*t)\n            } else {\n                ty_lookup(label, *rest)\n            },\n        _ => Option::None,\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "records_verus.rs", "verified": true, "metadata": {"original_id": "5a742015d7ee", "function_name": "ty_lookup", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_55215c015b40", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len ()  { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == is_even (n), result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) \ninvariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "55215c015b40", "function_name": "is_product_even", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_717d1b5b1bc2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32)   { 3 * x }\n\n} // verus!", "target_text": "requires - 715827882 <= x <= 715827882 \nensures r == 3 * x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple3/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "717d1b5b1bc2", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_08aae59234f8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_balanced(t: Tree) -> bool {\n    match t {\n        Tree::E => true,\n        Tree::T { left, right, .. } =>\n            abs_diff(height(*left), height(*right)) <= 1 && is_balanced(*left) && is_balanced(*right)\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_balanced(t: Tree) -> bool decreases t {\n    match t {\n        Tree::E => true,\n        Tree::T { left, right, .. } =>\n            abs_diff(height(*left), height(*right)) <= 1 && is_balanced(*left) && is_balanced(*right)\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_tree_balance.rs", "verified": true, "metadata": {"original_id": "08aae59234f8", "function_name": "is_balanced", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_ea5380f02e6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ea5380f02e6b", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d5c0fce34468", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { result . push (elem) ; result . push (arr [i]) ; i += 1 ; }   result }\n\n} // verus!", "target_text": "ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] \ndecreases arr . len () - i\ninvariant 0 <= i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } assert (i == arr . len ()) ; assert (result @ . len () == 2 * i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "d5c0fce34468", "function_name": "insert_before_each", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0d37c3770da8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_construct_double(n: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures construct_double(n) == n * 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_construct_double(n: nat)\n    ensures construct_double(n) == n * 2\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "0d37c3770da8", "function_name": "verify_construct_double", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_139126d5f7b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { k }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "139126d5f7b6", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_603011b658ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_all_empty()\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_and_all(Seq::<Dec>::empty()) == Dec::Yes", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_and_all_empty()\n    ensures dec_and_all(Seq::<Dec>::empty()) == Dec::Yes\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_and.rs", "verified": true, "metadata": {"original_id": "603011b658ea", "function_name": "dec_and_all_empty", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_2cb61b00933a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_label_eq_reflexive(l: Label)\n    \n{\n}\n\n} // verus!", "target_text": "ensures label_eq(l, l)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_label_eq_reflexive(l: Label)\n    ensures label_eq(l, l)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_label.rs", "verified": true, "metadata": {"original_id": "2cb61b00933a", "function_name": "verify_label_eq_reflexive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_173a2be6bfc3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : u32)   { let mut i = 0 ; while i < N  { let value = if N % 2 == 0 { 0i32 } else { 1i32 } ; a . set (i as usize , value) ;  i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] % 2 == N % 2 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] % 2 == N % 2 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : u32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] % 2 == N % 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] % 2 == N % 2 , decreases N - i , { let value = if N % 2 == 0 { 0i32 } else { 1i32 } ; a . set (i as usize , value) ; assert (a [i as int] % 2 == N % 2) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condm_impl.rs", "verified": true, "metadata": {"original_id": "173a2be6bfc3", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_ac554ba10315", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_rev_involutive(xs: NatList)\n    \n{\n    // Prove by extensional equality (same length, same indexing).\n\n}\n\n} // verus!", "target_text": "ensures xs.reverse().reverse() =~= xs", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex7_rev_involutive(xs: NatList)\n    ensures xs.reverse().reverse() =~= xs\n{\n    // Prove by extensional equality (same length, same indexing).\n    assert(xs.reverse().len() == xs.len());\n    assert(xs.reverse().reverse().len() == xs.len());\n\n    assert forall|i: int| 0 <= i < xs.len() implies xs.reverse().reverse()[i] == xs[i] by {\n        lemma_reverse_index(xs.reverse(), i);\n        lemma_reverse_index(xs, xs.len() - 1 - i);\n\n        // Expand the two reverses.\n        assert(xs.reverse().reverse()[i] == xs.reverse()[xs.len() - 1 - i]);\n        assert(xs.reverse()[xs.len() - 1 - i] == xs[xs.len() - 1 - (xs.len() - 1 - i)]);\n        assert(xs.len() - 1 - (xs.len() - 1 - i) == i);\n    };\n\n    assert(xs.reverse().reverse() =~= xs);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "lists_verus.rs", "verified": true, "metadata": {"original_id": "ac554ba10315", "function_name": "ex7_rev_involutive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_5f30927e27e9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_identity(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures conj_identity(p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_conj_identity(p: bool)\n    ensures conj_identity(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_conjunction.rs", "verified": true, "metadata": {"original_id": "5f30927e27e9", "function_name": "verify_conj_identity", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_02003148609e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_nat_sized_bounded(size: nat, n: nat)\n\n{\n}\n\n} // verus!", "target_text": "requires gen_nat_sized(size).contains(n)\n    ensures n <= size\nensures n <= size", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_nat_sized_bounded(size: nat, n: nat)\n    requires gen_nat_sized(size).contains(n)\n    ensures n <= size\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_sized.rs", "verified": true, "metadata": {"original_id": "02003148609e", "function_name": "gen_nat_sized_bounded", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_575b6114c039", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "575b6114c039", "function_name": "bubbleSorta", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2aa0ec32e41b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_count_eq_len_bool()\n    \n{\n\n}\n\n} // verus!", "target_text": "ensures enum_count_bool() == enum_all_bool().len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn enum_count_eq_len_bool()\n    ensures enum_count_bool() == enum_all_bool().len()\n{\n    assert(enum_all_bool().len() == 2);\n    assert(enum_count_bool() == 2);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_enum.rs", "verified": true, "metadata": {"original_id": "2aa0ec32e41b", "function_name": "enum_count_eq_len_bool", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_03dece2f4741", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_list_arbitrary<A>(elements: Set<A>, max_len: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures arbitrary_list(elements, max_len).contains(Seq::empty())", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_list_arbitrary<A>(elements: Set<A>, max_len: nat)\n    ensures arbitrary_list(elements, max_len).contains(Seq::empty())\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_arbitrary_list.rs", "verified": true, "metadata": {"original_id": "03dece2f4741", "function_name": "empty_list_arbitrary", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_7b52f71a7c21", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_zero_right(a: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures a * 0 == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul_zero_right(a: nat)\n    ensures a * 0 == 0\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_nat_arith.rs", "verified": true, "metadata": {"original_id": "7b52f71a7c21", "function_name": "mul_zero_right", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_cdcddf5c4b3d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "cdcddf5c4b3d", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_49dcd78eab5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l  { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i, p - j, l - k\ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_64/verina_basic_64_impl.rs", "verified": true, "metadata": {"original_id": "49dcd78eab5e", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0f689999fd88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int)  { }\nfn triple (x : i32) -> (result : i32)   {  3 * x }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 1000000 <= x <= 1000000\nensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_99/verina_basic_99_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0f689999fd88", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4abc3024a852", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4abc3024a852", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_4ff9e20b4700", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "4ff9e20b4700", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6ec50bf7bdb9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6ec50bf7bdb9", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f8c095391aa0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8c095391aa0", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_e709ccd63ece", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn contrapositive(a: bool, b: bool)\n    \n{}\n\n} // verus!", "target_text": "ensures bool_implies(a, b) == bool_implies(bool_not(b), bool_not(a))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn contrapositive(a: bool, b: bool)\n    ensures bool_implies(a, b) == bool_implies(bool_not(b), bool_not(a))\n{}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_logic_bool.rs", "verified": true, "metadata": {"original_id": "e709ccd63ece", "function_name": "contrapositive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_20e48fdb2a68", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_andb_comm(b1: bool, b2: bool)\n    \n{\n    match (b1, b2) {\n        (true, true) => {\n\n        }\n        (true, false) => {\n\n        }\n        (false, true) => {\n\n        }\n        (false, false) => {\n\n        }\n    }\n}\n\n} // verus!", "target_text": "ensures andb(b1, b2) == andb(b2, b1)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex2_andb_comm(b1: bool, b2: bool)\n    ensures andb(b1, b2) == andb(b2, b1)\n{\n    match (b1, b2) {\n        (true, true) => {\n            assert(andb(b1, b2));\n            assert(andb(b2, b1));\n        }\n        (true, false) => {\n            assert(!andb(b1, b2));\n            assert(!andb(b2, b1));\n        }\n        (false, true) => {\n            assert(!andb(b1, b2));\n            assert(!andb(b2, b1));\n        }\n        (false, false) => {\n            assert(!andb(b1, b2));\n            assert(!andb(b2, b1));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "20e48fdb2a68", "function_name": "ex2_andb_comm", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_26115561dc1d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2u32 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "26115561dc1d", "function_name": "is_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3a0e6319171c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex3_length_map<A, B>(xs: List<A>, f: spec_fn(A) -> B)\n    \n{\n    \n}\n\n} // verus!", "target_text": "ensures length(map(xs, f)) == length(xs)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex3_length_map<A, B>(xs: List<A>, f: spec_fn(A) -> B)\n    ensures length(map(xs, f)) == length(xs)\n{\n    assert(map(xs, f).len() == xs.len());\n}\n\n} // verus!", "source": "coq_translation", "source_file": "poly_verus.rs", "verified": true, "metadata": {"original_id": "3a0e6319171c", "function_name": "ex3_length_map", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_954cb6321571", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - i \ninvariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_product_impl.rs", "verified": true, "metadata": {"original_id": "954cb6321571", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_4ba28f7ce860", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int)   { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ;    }\nfn count_true (arr : & Vec < bool >) -> (count : u64)  { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len ()  { if arr [i] { count = count + 1 ; } i = i + 1 ;  }  count }\n\n} // verus!", "target_text": "requires 0 < i <= seq . len ()\nensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1], 0 <= count <= arr . len () , count_boolean (arr @) == count \ndecreases seq . len () , arr . len () - i \ninvariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) decreases seq . len () , { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int) requires 0 < i <= seq . len () ensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1] { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ; assert (prefix_i == prefix_i_minus_1 . push (seq [i - 1])) ; assert (prefix_i . drop_last () == prefix_i_minus_1) ; assert (prefix_i . last () == seq [i - 1]) ; }\nfn count_true (arr : & Vec < bool >) -> (count : u64) ensures 0 <= count <= arr . len () , count_boolean (arr @) == count , { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len () invariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count , decreases arr . len () - i , { if arr [i] { count = count + 1 ; } i = i + 1 ; proof { lemma_count_boolean_extend (arr @ , i as int) ; } } assert (arr @ . take (arr . len () as int) == arr @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_105_impl.rs", "verified": true, "metadata": {"original_id": "4ba28f7ce860", "function_name": "count_true", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_86b255551e8c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_neq_is_not_eq(a: nat, b: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_neq_nat(a, b)) == !dec_to_bool(dec_eq_nat(a, b))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_neq_is_not_eq(a: nat, b: nat)\n    ensures dec_to_bool(dec_neq_nat(a, b)) == !dec_to_bool(dec_eq_nat(a, b))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_eq.rs", "verified": true, "metadata": {"original_id": "86b255551e8c", "function_name": "dec_neq_is_not_eq", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ba95b2903940", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_ctx_included(ctx: Context)\n    \n{\n    }\n\n} // verus!", "target_text": "ensures ctx_included(empty_ctx(), ctx)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn empty_ctx_included(ctx: Context)\n    ensures ctx_included(empty_ctx(), ctx)\n{\n    assert forall|x: Id| ctx_contains(empty_ctx(), x) implies ctx_contains(ctx, x) && empty_ctx()[x] == ctx[x] by {\n        assert(!ctx_contains(empty_ctx(), x));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_context.rs", "verified": true, "metadata": {"original_id": "ba95b2903940", "function_name": "empty_ctx_included", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e18070090d7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)   { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos  { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p  { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos  { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) \ndecreases at_pos - i , p - j , (l - at_pos) - k \ninvariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i , { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j , { result . push (nl [j]) ; j += 1 ; } let mut k = 0 ; while k < l - at_pos invariant k <= l - at_pos , result . len () == at_pos + p + k , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases (l - at_pos) - k , { result . push (oline [at_pos + k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_64/verina_basic_64_impl.rs", "verified": true, "metadata": {"original_id": "e18070090d7b", "function_name": "insert", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7047bc6eecdd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s4if_impl.rs", "verified": true, "metadata": {"original_id": "7047bc6eecdd", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_5a13781737ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] \ndecreases a . len () - i\ninvariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "5a13781737ff", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_deb06059f272", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn has_type(ctx: Context, t: Tm, ty: Ty) -> bool\n    {\n    match t {\n        // T_Var\n        Tm::Var { x } => ctx.dom().contains(x) && ctx[x] == ty,\n\n        // T_Abs\n        Tm::Abs { x, ty: ty_param, body } => {\n            match ty {\n                Ty::TArrow { t1, t2 } =>\n                    *t1 == ty_param &&\n                    has_type(ctx_extend(ctx, x, ty_param), *body, *t2),\n                _ => false,\n            }\n        }\n\n        // T_App\n        Tm::App { t1, t2 } => {\n            exists|ty_arg: Ty|\n                has_type(ctx, *t1, Ty::TArrow { t1: Box::new(ty_arg), t2: Box::new(ty) }) &&\n                has_type(ctx, *t2, ty_arg)\n        }\n\n        // T_True\n        Tm::Tru => ty == Ty::TBool,\n\n        // T_False\n        Tm::Fls => ty == Ty::TBool,\n\n        // T_If\n        Tm::Ite { cond, then_br, else_br } =>\n            has_type(ctx, *cond, Ty::TBool) &&\n            has_type(ctx, *then_br, ty) &&\n            has_type(ctx, *else_br, ty),\n    }\n}\n\n} // verus!", "target_text": "decreases t", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn has_type(ctx: Context, t: Tm, ty: Ty) -> bool\n    decreases t\n{\n    match t {\n        // T_Var\n        Tm::Var { x } => ctx.dom().contains(x) && ctx[x] == ty,\n\n        // T_Abs\n        Tm::Abs { x, ty: ty_param, body } => {\n            match ty {\n                Ty::TArrow { t1, t2 } =>\n                    *t1 == ty_param &&\n                    has_type(ctx_extend(ctx, x, ty_param), *body, *t2),\n                _ => false,\n            }\n        }\n\n        // T_App\n        Tm::App { t1, t2 } => {\n            exists|ty_arg: Ty|\n                has_type(ctx, *t1, Ty::TArrow { t1: Box::new(ty_arg), t2: Box::new(ty) }) &&\n                has_type(ctx, *t2, ty_arg)\n        }\n\n        // T_True\n        Tm::Tru => ty == Ty::TBool,\n\n        // T_False\n        Tm::Fls => ty == Ty::TBool,\n\n        // T_If\n        Tm::Ite { cond, then_br, else_br } =>\n            has_type(ctx, *cond, Ty::TBool) &&\n            has_type(ctx, *then_br, ty) &&\n            has_type(ctx, *else_br, ty),\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "stlc_verus.rs", "verified": true, "metadata": {"original_id": "deb06059f272", "function_name": "has_type", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_9a568318d334", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn neg_neg(a: int)  {}\n\n} // verus!", "target_text": "ensures -(-a) == a", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn neg_neg(a: int) ensures -(-a) == a {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_int_arith.rs", "verified": true, "metadata": {"original_id": "9a568318d334", "function_name": "neg_neg", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_74c99236de02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "74c99236de02", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_cda0fddb188b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >)   { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "requires a . len () < MAX\nensures c @ == a @ + seq ! [b]\ninvariant c @ == a @ . subrange (0 , i as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cda0fddb188b", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6acf1140a197", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_depth(ty: Ty) -> nat\n    {\n    match ty {\n        Ty::TBool => 0,\n        Ty::TNat => 0,\n        Ty::TArrow { t1, t2 } => {\n            let d1 = ty_depth(*t1);\n            let d2 = ty_depth(*t2);\n            1 + if d1 > d2 { d1 } else { d2 }\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases ty", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn ty_depth(ty: Ty) -> nat\n    decreases ty\n{\n    match ty {\n        Ty::TBool => 0,\n        Ty::TNat => 0,\n        Ty::TArrow { t1, t2 } => {\n            let d1 = ty_depth(*t1);\n            let d2 = ty_depth(*t2);\n            1 + if d1 > d2 { d1 } else { d2 }\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_lang_type.rs", "verified": true, "metadata": {"original_id": "6acf1140a197", "function_name": "ty_depth", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_6a85dea21f16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn split_first_smaller(s: Seq<nat>)\n\n{\n}\n\n} // verus!", "target_text": "requires s.len() > 1\n    ensures split_first(s).len() < s.len()\nensures split_first(s).len() < s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn split_first_smaller(s: Seq<nat>)\n    requires s.len() > 1\n    ensures split_first(s).len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_sort_merge.rs", "verified": true, "metadata": {"original_id": "6a85dea21f16", "function_name": "split_first_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ac7d8f2e369b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize)   { return 0 ; }\n\n} // verus!", "target_text": "requires b . len () <= a . len () \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ac7d8f2e369b", "function_name": "containsSubString", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_9d367969c578", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , N <= 0x7FFF_FFFF \nensures sum <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "9d367969c578", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_eae110158f55", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/preconditions_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "eae110158f55", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_93b7609eb1e3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i\ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_732_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93b7609eb1e3", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_352fd7cf6f7e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)   { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop  { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] \ndecreases high - low\ninvariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "352fd7cf6f7e", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_3d1479bbbecd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn nat_add_left_identity(x: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures nat_add(nat_add_identity(), x) == x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn nat_add_left_identity(x: nat)\n    ensures nat_add(nat_add_identity(), x) == x\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_monoid.rs", "verified": true, "metadata": {"original_id": "3d1479bbbecd", "function_name": "nat_add_left_identity", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e6590f6bcd7d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contradiction(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures contradiction(p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_contradiction(p: bool)\n    ensures contradiction(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_negation.rs", "verified": true, "metadata": {"original_id": "e6590f6bcd7d", "function_name": "verify_contradiction", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_3a6b3f861a2e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 9 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 9 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3a6b3f861a2e", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6d87f75435ae", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len ()  { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - i\ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "6d87f75435ae", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9f8fba720391", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9f8fba720391", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_b05db7df5921", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    \n}\n\n} // verus!", "target_text": "requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\nensures s.reverse()[i] == s[s.len() - 1 - i]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_reverse_index<A>(s: Seq<A>, i: int)\n    requires 0 <= i < s.len(),\n    ensures s.reverse()[i] == s[s.len() - 1 - i]\n{\n    reveal_with_fuel(Seq::reverse, 1);\n    assert(s.reverse()[i] == s[s.len() - 1 - i]);\n}\n\n} // verus!", "source": "coq_translation", "source_file": "indprop_verus.rs", "verified": true, "metadata": {"original_id": "b05db7df5921", "function_name": "lemma_reverse_index", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_2f9728e3e9e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn exists_empty_seq<T>(p: spec_fn(T) -> bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures !dec_to_bool(dec_exists_seq(Seq::<T>::empty(), p))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn exists_empty_seq<T>(p: spec_fn(T) -> bool)\n    ensures !dec_to_bool(dec_exists_seq(Seq::<T>::empty(), p))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_exists.rs", "verified": true, "metadata": {"original_id": "2f9728e3e9e5", "function_name": "exists_empty_seq", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_adddd67fafb4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn rb_empty_valid(cap: nat)   {}\n\n} // verus!", "target_text": "requires cap > 0 ensures rb_valid(rb_empty(cap))\nensures rb_valid(rb_empty(cap))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn rb_empty_valid(cap: nat) requires cap > 0 ensures rb_valid(rb_empty(cap)) {}\n\n} // verus!", "source": "coq_translation", "source_file": "vfa_ring_buffer.rs", "verified": true, "metadata": {"original_id": "adddd67fafb4", "function_name": "rb_empty_valid", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ca08bb2a72f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_disj_complement(p: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures disj_complement(p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_disj_complement(p: bool)\n    ensures disj_complement(p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_disjunction.rs", "verified": true, "metadata": {"original_id": "ca08bb2a72f1", "function_name": "verify_disj_complement", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_b7c7995e7ed1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)   { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e \nensures linear_search_postcond (a , e , result) , linear_search_postcond (a , e , result) , decreases a . len () - n \ndecreases a . len () - n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "b7c7995e7ed1", "function_name": "linear_search_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_3374ebbe261b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "3374ebbe261b", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_db86df0fb3d6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_label(stats: LabelStats, label_id: nat) -> nat\n    {\n    if stats.labels.len() == 0 {\n        0\n    } else {\n        let last = stats.labels.last();\n        let rest = LabelStats { labels: stats.labels.drop_last(), total_tests: stats.total_tests };\n        if last.name == label_id {\n            last.count + count_label(rest, label_id)\n        } else {\n            count_label(rest, label_id)\n        }\n    }\n}\n\n} // verus!", "target_text": "decreases stats.labels.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_label(stats: LabelStats, label_id: nat) -> nat\n    decreases stats.labels.len()\n{\n    if stats.labels.len() == 0 {\n        0\n    } else {\n        let last = stats.labels.last();\n        let rest = LabelStats { labels: stats.labels.drop_last(), total_tests: stats.total_tests };\n        if last.name == label_id {\n            last.count + count_label(rest, label_id)\n        } else {\n            count_label(rest, label_id)\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_label_collect.rs", "verified": true, "metadata": {"original_id": "db86df0fb3d6", "function_name": "count_label", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_23bdb60d18e6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {   let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "23bdb60d18e6", "function_name": "element_wise_subtract", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_b420884e72ba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_map_membership(outputs: Set<int>, f: spec_fn(int) -> int, n: int)\n\n{\n}\n\n} // verus!", "target_text": "requires outputs.contains(n)\n    ensures gen_int_map(outputs, f).contains(f(n))\nensures gen_int_map(outputs, f).contains(f(n))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_map_membership(outputs: Set<int>, f: spec_fn(int) -> int, n: int)\n    requires outputs.contains(n)\n    ensures gen_int_map(outputs, f).contains(f(n))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "b420884e72ba", "function_name": "gen_int_map_membership", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_bb2c943e04b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_or(d1: Dec, d2: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_not(dec_or(d1, d2)) == dec_and(dec_not(d1), dec_not(d2))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_or(d1: Dec, d2: Dec)\n    ensures dec_not(dec_or(d1, d2)) == dec_and(dec_not(d1), dec_not(d2))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "bb2c943e04b9", "function_name": "dec_demorgan_or", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_1f3be13c8af3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32)   { 0 }\n\n} // verus!", "target_text": "requires 0 < x < y \nensures z >= 0 && z <= y && z != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1f3be13c8af3", "function_name": "m1", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_00b59b5a9b18", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_all_sound<T>(s: Seq<T>, p: spec_fn(T) -> bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_all(s, p)) == list_all(s, p)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_all_sound<T>(s: Seq<T>, p: spec_fn(T) -> bool)\n    ensures dec_to_bool(dec_all(s, p)) == list_all(s, p)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_list.rs", "verified": true, "metadata": {"original_id": "00b59b5a9b18", "function_name": "dec_all_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_b7fdb534c54b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32)  { if a < b { a } else { b } }\n\n} // verus!", "target_text": "ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b7fdb534c54b", "function_name": "minMethod", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_af931a99b1cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start_idx <= lst . len () \ndecreases lst . len () - start_idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_73/verina_advanced_73.rs", "verified": true, "metadata": {"original_id": "af931a99b1cc", "function_name": "search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_01364d90b6bb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for j in 0 .. text . len ()  { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "01364d90b6bb", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_78046adc9be3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_smaller<T>(s: Seq<T>)\n\n{\n}\n\n} // verus!", "target_text": "requires s.len() > 0\n    ensures shrink_seq_head(s).len() < s.len()\nensures shrink_seq_head(s).len() < s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_shrink_seq_smaller<T>(s: Seq<T>)\n    requires s.len() > 0\n    ensures shrink_seq_head(s).len() < s.len()\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_shrinking.rs", "verified": true, "metadata": {"original_id": "78046adc9be3", "function_name": "verify_shrink_seq_smaller", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_18be5efd162d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >)   { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 {   } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 {    } else {   } } }) ; }  }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64)  { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >)  { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len ()  { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; }  result }\n\n} // verus!", "target_text": "requires intersperse_quantified (numbers , delimiter , interspersed) \nensures interspersed == intersperse_spec (numbers , delimiter) , numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , result @ == intersperse_spec (numbers @ , delimiter) , interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () \ndecreases numbers . len () , numbers . len () , numbers . len () , numbers . len () - i \ninvariant 0 <= i <= numbers . len () , result . len () == if i == 0", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: assert_seqs_equal ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn intersperse_spec (numbers : Seq < u64 > , delimiter : u64) -> (result : Seq < u64 >) decreases numbers . len () , { if numbers . len () <= 1 { numbers } else { intersperse_spec (numbers . drop_last () , delimiter) + seq ! [delimiter , numbers . last ()] } }\nspec fn intersperse_quantified (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) -> (result : bool) { (if numbers . len () == 0 { interspersed . len () == 0 } else { interspersed . len () == 2 * numbers . len () - 1 }) && (forall | i : int | 0 <= i < numbers . len () ==> # [trigger] interspersed [even (i)] == numbers [i]) && (forall | i : int | 0 <= i < numbers . len () - 1 ==> # [trigger] interspersed [odd (i)] == delimiter) }\nspec fn even (i : int) -> (result : int) { 2 * i }\nspec fn odd (i : int) -> (result : int) { 2 * i + 1 }\nproof fn intersperse_quantified_is_spec (numbers : Seq < u64 > , delimiter : u64 , interspersed : Seq < u64 >) requires intersperse_quantified (numbers , delimiter , interspersed) , ensures interspersed == intersperse_spec (numbers , delimiter) , decreases numbers . len () , { let is = intersperse_spec (numbers , delimiter) ; if numbers . len () == 0 { } else if numbers . len () == 1 { assert (interspersed . len () == 1) ; assert (interspersed [even (0)] == numbers [0]) ; } else { intersperse_quantified_is_spec (numbers . drop_last () , delimiter , interspersed . take (interspersed . len () - 2) ,) ; intersperse_spec_len (numbers , delimiter) ; assert_seqs_equal ! (is == interspersed , i => { if i < is . len () - 2 { } else { if i % 2 == 0 { assert (is [i] == numbers . last ()) ; assert (interspersed [even (i / 2)] == numbers [i / 2]) ; assert (i / 2 == numbers . len () - 1) ; } else { assert (is [i] == delimiter) ; assert (interspersed [odd ((i - 1) / 2)] == delimiter) ; } } }) ; } assert (interspersed =~= intersperse_spec (numbers , delimiter)) ; }\nproof fn intersperse_spec_len (numbers : Seq < u64 > , delimiter : u64) ensures numbers . len () > 0 ==> intersperse_spec (numbers , delimiter) . len () == 2 * numbers . len () - 1 , decreases numbers . len () , { if numbers . len () > 0 { intersperse_spec_len (numbers . drop_last () , delimiter) ; } }\nfn intersperse (numbers : Vec < u64 > , delimiter : u64) -> (result : Vec < u64 >) ensures result @ == intersperse_spec (numbers @ , delimiter) , { if numbers . len () <= 1 { return numbers ; } let mut result = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , result . len () == if i == 0 { 0 } else { 2 * i - 1 } , forall | j : int | 0 <= j < i ==> # [trigger] result @ [2 * j] == numbers @ [j] , forall | j : int | 0 <= j < i - 1 ==> # [trigger] result @ [2 * j + 1] == delimiter , intersperse_quantified (numbers @ . take (i as int) , delimiter , result @) , decreases numbers . len () - i , { if i > 0 { result . push (delimiter) ; } result . push (numbers [i]) ; i += 1 ; } proof { assert (intersperse_quantified (numbers @ , delimiter , result @)) ; intersperse_quantified_is_spec (numbers @ , delimiter , result @) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/005-intersperse_impl.rs", "verified": true, "metadata": {"original_id": "18be5efd162d", "function_name": "intersperse", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_a0ae4bc19ca3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_negate_involutive(outputs: Set<int>)\n    \n{\n    if outputs.contains(n) {\n\n        }\n    }\n}\n\n} // verus!", "target_text": "ensures gen_int_negate(gen_int_negate(outputs)) =~= outputs", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn gen_int_negate_involutive(outputs: Set<int>)\n    ensures gen_int_negate(gen_int_negate(outputs)) =~= outputs\n{\n    assert forall|n: int| gen_int_negate(gen_int_negate(outputs)).contains(n) <==>\n        outputs.contains(n) by {\n        if gen_int_negate(gen_int_negate(outputs)).contains(n) {\n            let m = choose|m: int| gen_int_negate(outputs).contains(m) && -m == n;\n            let k = choose|k: int| outputs.contains(k) && -k == m;\n            assert(k == n);\n        }\n        if outputs.contains(n) {\n            assert(gen_int_negate(outputs).contains(-n));\n            assert(gen_int_negate(gen_int_negate(outputs)).contains(n));\n        }\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_gen_int.rs", "verified": true, "metadata": {"original_id": "a0ae4bc19ca3", "function_name": "gen_int_negate_involutive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_e930e6c3c5af", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len ()  { let c = str [i] ; let flipped = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - i\ninvariant i <= str . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len () invariant i <= str . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) , decreases str . len () - i { let c = str [i] ; let flipped = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/027-flip_case_impl.rs", "verified": true, "metadata": {"original_id": "e930e6c3c5af", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fe45d7bb9bcc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "fe45d7bb9bcc", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f4b0c9cb2904", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "f4b0c9cb2904", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_2792d8b04e5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_mul_n_0(n: nat)\n    \n    {\n    if n == 0 {\n        \n    } else {\n        let n1 = (n - 1) as nat;\n        ex10_mul_n_0(n1);\n        \n        // add(x, 0) == x (proved above)\n        ex7_add_n_0(mul(n1, 0));\n    }\n}\n\n} // verus!", "target_text": "ensures mul(n, 0) == 0\n    decreases n\ndecreases n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex10_mul_n_0(n: nat)\n    ensures mul(n, 0) == 0\n    decreases n\n{\n    if n == 0 {\n        assert(mul(0, 0) == 0);\n    } else {\n        let n1 = (n - 1) as nat;\n        ex10_mul_n_0(n1);\n        assert(mul(n, 0) == add(mul(n1, 0), 0));\n        // add(x, 0) == x (proved above)\n        ex7_add_n_0(mul(n1, 0));\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "basics_verus.rs", "verified": true, "metadata": {"original_id": "2792d8b04e5f", "function_name": "ex10_mul_n_0", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_0ccc6a238222", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "0ccc6a238222", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6fc6d123b071", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6fc6d123b071", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3c8f489ffced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex5_update_comm(m: TotalMap, default: int, k1: Key, v1: int, k2: Key, v2: int)\n\n{\n    else if x == k2 {\n            ex1_update_eq(t_update(m, k1, v1), default, k2, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, k2, v1);\n        } else {\n            ex2_update_neq(t_update(m, k1, v1), default, k2, x, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, x, v1);\n        }\n    };\n}\n\n} // verus!", "target_text": "requires k1 != k2,\n    ensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\nensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn ex5_update_comm(m: TotalMap, default: int, k1: Key, v1: int, k2: Key, v2: int)\n    requires k1 != k2,\n    ensures forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n{\n    assert forall|x: Key| t_apply(t_update(t_update(m, k1, v1), k2, v2), default, x)\n        == t_apply(t_update(t_update(m, k2, v2), k1, v1), default, x)\n    by {\n        if x == k1 {\n            // Left: update at k2 doesn't affect k1\n            ex2_update_neq(t_update(m, k1, v1), default, k2, k1, v2);\n            ex1_update_eq(t_update(m, k2, v2), default, k1, v1);\n        } else if x == k2 {\n            ex1_update_eq(t_update(m, k1, v1), default, k2, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, k2, v1);\n        } else {\n            ex2_update_neq(t_update(m, k1, v1), default, k2, x, v2);\n            ex2_update_neq(t_update(m, k2, v2), default, k1, x, v1);\n        }\n    };\n}\n\n} // verus!", "source": "coq_translation", "source_file": "maps_verus.rs", "verified": true, "metadata": {"original_id": "3c8f489ffced", "function_name": "ex5_update_comm", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_ec73e292afd0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_nat_add_zero_right(n: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures n + 0 == n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lemma_nat_add_zero_right(n: nat)\n    ensures n + 0 == n\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "auto_verus.rs", "verified": true, "metadata": {"original_id": "ec73e292afd0", "function_name": "lemma_nat_add_zero_right", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_verus_lib_c84f959a601d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the  {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n}\n\n} // verus!\n", "target_text": "ensures new_token@.instance_id() == instance.id() && new_token@.value() == true, new_token@.instance_id() == instance.id() && new_token@.value() == true\ninvariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter)", "full_verified_code": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n                    assert(pre.y <= pre.z);\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n                        assert(pre.y <= pre.z);\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n                        assert(pre.y <= pre.z);\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/state_machine_macro_usage/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_c84f959a601d", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_8746c00deeba", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_nat_reflexive(a: nat)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(dec_le_nat(a, a))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_le_nat_reflexive(a: nat)\n    ensures dec_to_bool(dec_le_nat(a, a))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_ord.rs", "verified": true, "metadata": {"original_id": "8746c00deeba", "function_name": "dec_le_nat_reflexive", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_1f06fb34afe9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "1f06fb34afe9", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3406b6f065de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "3406b6f065de", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_6a7db61f17ea", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6a7db61f17ea", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_a257b6e89d58", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reduce_pcc_decreases_size(t: Tm)\n\n{\n    reveal_with_fuel(tm_size, 3);\n    match t {\n        Tm::P { t1, t2 } => {\n            match (*t1, *t2) {\n                (Tm::C { n: _ }, Tm::C { n: _ }) => {\n                    // P(C n1, C n2) reduces to C(n1+n2)\n                    // Size goes from 1 + 1 + 1 = 3 to 1\n                }\n                _ => {}\n            }\n        }\n        _ => {}\n    }\n}\n\n} // verus!", "target_text": "requires can_reduce_pcc(t)\n    ensures tm_size(reduce_pcc(t)) < tm_size(t)\nensures tm_size(reduce_pcc(t)) < tm_size(t)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn reduce_pcc_decreases_size(t: Tm)\n    requires can_reduce_pcc(t)\n    ensures tm_size(reduce_pcc(t)) < tm_size(t)\n{\n    reveal_with_fuel(tm_size, 3);\n    match t {\n        Tm::P { t1, t2 } => {\n            match (*t1, *t2) {\n                (Tm::C { n: _ }, Tm::C { n: _ }) => {\n                    // P(C n1, C n2) reduces to C(n1+n2)\n                    // Size goes from 1 + 1 + 1 = 3 to 1\n                }\n                _ => {}\n            }\n        }\n        _ => {}\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "smallstep_verus.rs", "verified": true, "metadata": {"original_id": "a257b6e89d58", "function_name": "reduce_pcc_decreases_size", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_8533df8b482a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let elem = a [i] ; if ! in_array_exec (b , elem) && ! in_array_exec (& c , elem) { c . push (elem) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "8533df8b482a", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_6ae8c01737fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul4_ev_new(n: nat) -> (ev: Mul4Ev)\n\n{\n    Mul4Ev { n }\n}\n\n} // verus!", "target_text": "requires is_mul4(n)\n    ensures ev.n == n,\n        is_mul4(ev.n)\nensures ev.n == n,\n        is_mul4(ev.n)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn mul4_ev_new(n: nat) -> (ev: Mul4Ev)\n    requires is_mul4(n)\n    ensures ev.n == n,\n        is_mul4(ev.n)\n{\n    Mul4Ev { n }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "proofobjects_verus.rs", "verified": true, "metadata": {"original_id": "6ae8c01737fe", "function_name": "mul4_ev_new", "function_type": "proof", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_3420894e11ad", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn shrink_seq_nat(xs: Seq<nat>) -> Seq<Seq<nat>>\n    {\n    if xs.len() == 0 {\n        Seq::empty()\n    } else if xs.len() == 1 {\n        // Single element: try empty sequence\n        seq![Seq::empty()]\n    } else {\n        // Multiple elements: try removing each element\n        let removes = Seq::new(xs.len(), |i: int| xs.remove(i));\n        removes\n    }\n}\n\n} // verus!", "target_text": "decreases xs.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn shrink_seq_nat(xs: Seq<nat>) -> Seq<Seq<nat>>\n    decreases xs.len()\n{\n    if xs.len() == 0 {\n        Seq::empty()\n    } else if xs.len() == 1 {\n        // Single element: try empty sequence\n        seq![Seq::empty()]\n    } else {\n        // Multiple elements: try removing each element\n        let removes = Seq::new(xs.len(), |i: int| xs.remove(i));\n        removes\n    }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_shrink.rs", "verified": true, "metadata": {"original_id": "3420894e11ad", "function_name": "shrink_seq_nat", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_489f75f9f5da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_and(d1: Dec, d2: Dec)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_not(dec_and(d1, d2)) == dec_or(dec_not(d1), dec_not(d2))", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn dec_demorgan_and(d1: Dec, d2: Dec)\n    ensures dec_not(dec_and(d1, d2)) == dec_or(dec_not(d1), dec_not(d2))\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_or.rs", "verified": true, "metadata": {"original_id": "489f75f9f5da", "function_name": "dec_demorgan_and", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_a388c46c3217", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j = j + 1 ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - i , arr . len () - j \ninvariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i , { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j , { if arr [i] >= arr [j] { return false ; } j = j + 1 ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "a388c46c3217", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_9bcbb335e30e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >)  { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len ()\ndecreases a . len () - i\ninvariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_append_impl.rs", "verified": true, "metadata": {"original_id": "9bcbb335e30e", "function_name": "append_with_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c431a3841f95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize)   { a . set (j , 60) ; }\n\n} // verus!", "target_text": "requires 0 <= j < old (a) . len () \nensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c431a3841f95", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_43fe1daa1d32", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "43fe1daa1d32", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_441e1adae415", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "441e1adae415", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_modes_48bf1a515123", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n     // succeeds\n     // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n         // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n         // succeeds\n         // FAILS\n\n         // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n         // succeeds\n         // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n\n          // succeeds\n          // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n\n            lemma_min(100, 200);\n        }\n         // succeeds\n         // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n         // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n         // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n      // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n     // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n     // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "ensures m == min3(x as int, y as int, z as int), min(x,y) <= x && min(x,y) <= y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y, min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: fun_modes\nspec fn f1(x: int) -> int {\n    x / 2\n}\n\nproof fn f2(x: int) -> int {\n    x / 2\n}\n\n// \"exec\" is optional, and is usually omitted\nexec fn f3(x: u64) -> u64 {\n    x / 2\n}\n\n// ANCHOR_END: fun_modes\n/*\n// ANCHOR: fun_modes2\nfn f3(x: u64) -> u64 { x / 2 } // exec function\n// ANCHOR_END: fun_modes2\n*/\n\n/*\n// ANCHOR: spec_fun1\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn test() {\n    assert(min(10, 20) == 10); // succeeds\n    assert(min(100, 200) == 100); // succeeds\n}\n// ANCHOR_END: spec_fun1\n*/\n\n// ANCHOR: spec_fun3\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nspec fn min3(x: int, y: int, z: int) -> int {\n    min(x, min(y, z))\n}\n\nfn compute_min3(x: u64, y: u64, z: u64) -> (m: u64)\n    ensures\n        m == min3(x as int, y as int, z as int),\n{\n    let mut m = x;\n    if y < m {\n        m = y;\n    }\n    if z < m {\n        m = z;\n    }\n    m\n}\n\nfn test() {\n    let m = compute_min3(10, 20, 30);\n    assert(m == 10);\n}\n\n// ANCHOR_END: spec_fun3\n/*\n// ANCHOR: spec_fun_mod1\nmod M1 {\n    use verus_builtin::*;\n\n    pub open spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod1\n\n// ANCHOR: spec_fun_mod2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x,y) <= x && min(x,y) <= y,\n    {}\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == min(10, 20)); // succeeds\n        assert(min(10, 20) == 10); // FAILS\n        proof {\n            lemma_min(10,20);\n        }\n        assert(min(10, 20) <= 10); // succeeds\n    }\n}\n// ANCHOR_END: spec_fun_mod2\n*/\n\n/*\n// ANCHOR: spec_fun_proof\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test() {\n        lemma_min(10, 20);\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: spec_fun_proof\n*/\n\n// ANCHOR: spec_fun_proof_block1\nfn test_consts_infer() {\n    let u: u8 = 1;\n    proof {\n        let i: int = 2;\n        let n: nat = 3;\n        assert(0 <= u < i < n < 4);\n    }\n}\n\n// ANCHOR_END: spec_fun_proof_block1\n// ANCHOR: spec_fun_proof_block2\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        proof {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10);  // succeeds\n        assert(min(100, 200) == 100);  // succeeds\n    }\n\n}\n\n// ANCHOR_END: spec_fun_proof_block2\n/*\n// ANCHOR: assert_by\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn min(x: int, y: int) -> int {\n        if x <= y {\n            x\n        } else {\n            y\n        }\n    }\n\n    pub proof fn lemma_min(x: int, y: int)\n        ensures\n            min(x, y) <= x,\n            min(x, y) <= y,\n            min(x, y) == x || min(x, y) == y,\n    {\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    fn test() {\n        assert(min(10, 20) == 10) by {\n            lemma_min(10, 20);\n            lemma_min(100, 200);\n        }\n        assert(min(10, 20) == 10); // succeeds\n        assert(min(100, 200) == 100); // FAILS\n    }\n}\n// ANCHOR_END: assert_by\n*/\n\n/*\n// ANCHOR: determinism\nmod M1 {\n    use verus_builtin::*;\n\n    pub closed spec fn s(i: int) -> int {\n        i + 1\n    }\n\n    pub proof fn p(i: int) -> int {\n        i + 1\n    }\n}\n\nmod M2 {\n    use verus_builtin::*;\n    use crate::M1::*;\n\n    proof fn test_determinism() {\n        let s1 = s(10);\n        let s2 = s(10);\n        assert(s1 == s2); // succeeds\n\n        let p1 = p(10);\n        let p2 = p(10);\n        assert(p1 == p2); // FAILS\n    }\n}\n// ANCHOR_END: determinism\n*/\n\n// ANCHOR: recommends1\nspec fn f(i: nat) -> nat\n    recommends\n        i > 0,\n{\n    (i - 1) as nat\n}\n\nproof fn test1() {\n    assert(f(0) == f(0));  // succeeds\n}\n\n// ANCHOR_END: recommends1\n/*\n// ANCHOR: recommends2\nproof fn test2() {\n    assert(f(0) <= f(1)); // FAILS\n}\n// ANCHOR_END: recommends2\n*/\n\n// ANCHOR: recommends3\nspec fn caller1() -> nat {\n    f(0)  // no note, warning, or error generated\n\n}\n\n// ANCHOR_END: recommends3\n// ANCHOR: recommends4\nspec(checked) fn caller2() -> nat {\n    f(0)  // generates a warning because of \"(checked)\"\n\n}\n\n// ANCHOR_END: recommends4\n/*\n// ANCHOR: ghost_abilities0\nfn divide_by_zero() {\n    let x: u8 = 1;\n    assert(x / 0 == x / 0); // succeeds in ghost code\n    let y = x / 0; // FAILS in exec code\n}\n// ANCHOR_END: ghost_abilities0\n*/\n\n// ANCHOR: ghost_abilities1\nmod MA {\n    // does not implement Copy\n    // does not allow construction by other modules\n    pub struct S {\n        private_field: u8,\n    }\n\n}\n\nmod MB {\n    use verus_builtin::*;\n    use crate::MA::*;\n\n    // construct a ghost S\n    spec fn make_S() -> S;\n\n    // duplicate an S\n    spec fn duplicate_S(s: S) -> (S, S) {\n        (s, s)\n    }\n\n}\n\n// ANCHOR_END: ghost_abilities1\n/*\n// ANCHOR: ghost_abilities2\nfn test(s: S) {\n    let pair = duplicate_S(s); // FAILS\n}\n// ANCHOR_END: ghost_abilities2\n*/\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/modes.rs", "verified": true, "metadata": {"original_id": "verus_modes_48bf1a515123", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_034602eac6ff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mconcat_nat_mul(s: Seq<nat>) -> nat\n    {\n    if s.len() == 0 { nat_mul_identity() }\n    else { nat_mul(s[0], mconcat_nat_mul(s.skip(1))) }\n}\n\n} // verus!", "target_text": "decreases s.len()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn mconcat_nat_mul(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 { nat_mul_identity() }\n    else { nat_mul(s[0], mconcat_nat_mul(s.skip(1))) }\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_typeclass_monoid.rs", "verified": true, "metadata": {"original_id": "034602eac6ff", "function_name": "mconcat_nat_mul", "function_type": "spec", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true, "bug_type": null}}
{"id": "task_a_0e8fb8d80c13", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_even()\n    \n{\n}\n\n} // verus!", "target_text": "ensures witness_even() % 2 == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn verify_witness_even()\n    ensures witness_even() % 2 == 0\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_prop_exists.rs", "verified": true, "metadata": {"original_id": "0e8fb8d80c13", "function_name": "verify_witness_even", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
{"id": "task_a_2e466322187c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lift_and_sound(p1: bool, p2: bool)\n    \n{\n}\n\n} // verus!", "target_text": "ensures dec_to_bool(lift_and(p1, p2)) == (p1 && p2)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub proof fn lift_and_sound(p1: bool, p2: bool)\n    ensures dec_to_bool(lift_and(p1, p2)) == (p1 && p2)\n{\n}\n\n} // verus!", "source": "coq_translation", "source_file": "qc_dec_and.rs", "verified": true, "metadata": {"original_id": "2e466322187c", "function_name": "lift_and_sound", "function_type": "proof", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false, "bug_type": null}}
